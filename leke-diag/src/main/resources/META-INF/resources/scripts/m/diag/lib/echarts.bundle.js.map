{"version":3,"sources":["echarts.bundle.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","CoordinateSystemManager","this","_coordinateSystems","zrUtil","coordinateSystemCreators","prototype","constructor","create","ecModel","api","coordinateSystems","each","creater","type","list","concat","update","coordSys","getCoordinateSystems","slice","register","coordinateSystemCreator","get","zrender/lib/core/util","2","ExtensionAPI","chartInstance","echartsAPIList","name","bind","3","echarts","seriesType","actionInfos","actionInfo","registerAction","payload","selected","eachComponent","mainType","subType","query","seriesModel","method","data","getData","idx","getName","isSelected","../echarts","4","barLayoutGrid","registerLayout","curry","registerVisual","eachSeriesByType","setVisual","../component/grid","../coord/cartesian/Grid","../layout/barGrid","./bar/BarSeries","./bar/BarView","5","extend","dependencies","brushSelector","./BaseBarSeries","6","createRect","dataIndex","itemModel","layout","isHorizontal","animationModel","isUpdate","rect","graphic","Rect","shape","rectShape","animateProperty","animateTarget","removeRect","el","style","text","updateProps","width","parent","remove","getRectItemLayout","getItemLayout","fixedLineWidth","getLineWidth","signX","signY","height","x","y","updateStyle","color","getItemVisual","opacity","itemStyleModel","getModel","hoverStyle","getBarItemStyle","setShape","useStyle","defaults","fill","labelPositionOutside","helper","setLabel","setHoverStyle","rawLayout","lineWidth","BAR_BORDER_WIDTH_QUERY","Math","min","abs","BarView","extendChartView","render","_renderOnCartesian","group","dispose","noop","oldData","_data","cartesian","coordinateSystem","baseAxis","getBaseAxis","isAnimationEnabled","diff","add","hasValue","getItemModel","setItemGraphicEl","newIndex","oldIndex","getItemGraphicEl","execute","eachItemGraphicEl","removeAll","../../echarts","../../model/Model","../../util/graphic","./barItemStyle","./helper","7","SeriesModel","createListFromArray","getInitialData","option","__DEV__","getMarkerPosition","value","pt","dataToPoint","offset","getLayout","size","NaN","defaultOption","zlevel","z","legendHoverLink","barMinHeight","itemStyle","normal","emphasis","../../model/Series","../helper/createListFromArray","8","excludes","getBorderLineDash","lineDash","../../model/mixin/makeStyleMapper","9","model","labelText","setText","textPosition","normalStyle","labelModel","hoverLabelModel","retrieve","getFormattedLabel","getRawValue","10","./gauge/GaugeSeries","./gauge/GaugeView","11","List","GaugeSeries","dataOpt","isArray","initData","center","radius","startAngle","endAngle","clockwise","max","splitNumber","axisLine","show","lineStyle","splitLine","axisTick","axisLabel","distance","textStyle","pointer","title","offsetCenter","fontSize","detail","backgroundColor","borderWidth","borderColor","../../data/List","12","parsePosition","getWidth","getHeight","cx","parsePercent","cy","formatLabel","label","labelFormatter","replace","PointerPath","numberUtil","PI2","PI","GaugeView","colorList","posInfo","_renderMain","axisLineModel","lineStyleModel","angleRangeSpan","prevEndAngle","axisLineWidth","percent","sector","Sector","r0","silent","setStyle","getLineStyle","getColor","tmp","_renderTicks","_renderPointer","_renderTitle","_renderDetail","minVal","maxVal","splitLineModel","tickModel","subSplitNumber","splitLineLen","tickLen","angle","step","subStep","splitLineStyle","tickLineStyle","textStyleModel","unitX","cos","unitY","sin","Line","x1","y1","x2","y2","stroke","round","Text","getTextColor","textFont","getFont","textVerticalAlign","textAlign","j","tickLine","valueExtent","angleExtent","linearMap","newIdx","oldIdx","pointerModel","getItemStyle","titleModel","detailModel","textFill","../../util/number","../../view/Chart","./PointerPath","13","buildPath","ctx","mathCos","mathSin","moveTo","lineTo","zrender/lib/graphic/Path","14","makeSymbolTypeKey","symbolCategory","createSymbol","lineData","symbolType","symbolSize","symbolPath","symbolUtil","createLine","points","line","LinePath","setLinePoints","targetShape","p1","p2","cp1","cpx1","cpy1","updateSymbolAndLabelBeforeLineUpdate","lineGroup","symbolFrom","childOfName","symbolTo","ignore","invScale","parentNode","scale","__dirty","fromPos","pointAt","toPos","d","vector","sub","normalize","attr","tangent","tangentAt","atan2","__position","halfPercent","cp","rotation","__verticalAlign","__textAlign","position","seriesScope","Group","_createLine","SYMBOL_CATEGORIES","lineProto","beforeUpdate","hostModel","linePoints","initProps","symbol","_updateCommonStl","updateData","target","key","hoverLineStyle","hasItemOption","visualColor","visualOpacity","strokeNoScale","setColor","defaultLabelColor","defaultText","showLabel","getShallow","hoverShowLabel","rawVal","isFinite","dataType","textStyleHoverModel","updateLayout","linePath","dirty","inherits","../../util/symbol","./LinePath","zrender/lib/core/vector","15","isPointNaN","isNaN","lineNeedsDraw","pts","LineDraw","ctor","_ctor","LineGroup","lineDrawProto","oldLineData","_lineData","LineCtor","./Line","16","isLine","vec2","straightLineProto","bezierCurveProto","BezierCurve","extendShape","p","17","getSymbolSize","Array","getScale","Symbol","driftSymbol","dx","dy","drift","symbolProto","_createSymbol","z2","culling","_symbolType","stopSymbolAnimation","toLastFrame","childAt","stopAnimation","getSymbolPath","highlight","trigger","downplay","setZ","setDraggable","draggable","cursor","_updateCommon","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","hoverItemStyle","symbolRotate","symbolOffset","hoverAnimation","elStyle","valueDim","dimensions","pop","getDimensionInfo","off","onEmphasis","ratio","animateTo","onNormal","on","fadeOut","cb","18","SymbolDraw","symbolCtor","_symbolCtor","symbolNeedsDraw","isIgnore","point","symbolDrawProto","SymbolCtor","symbolEl","enableAnimation","./Symbol","19","firstDataNotNull","ifNeedCompleteOrdinalData","sampleItem","getDataItemValue","coordSysName","creator","creators","registeredCoordSys","CoordinateSystem","axesInfo","completeDimensions","categoryIndex","nameList","createNameList","categories","dimValueGetter","itemOpt","dimName","dimIndex","modelUtil","isDataItemOption","converDataValue","val","categoryAxesModels","getCategories","indexOf","isStackable","axisType","getDimTypeByAxis","result","categoryAxisModel","categoryDim","dataLen","cartesian2d","axesModels","map","queryComponents","index","id","xAxisModel","yAxisModel","xAxisType","yAxisType","stackable","isXAxisCateogry","isYAxisCategory","singleAxis","singleAxisModel","singleAxisType","isCategory","single","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","geo","../../CoordinateSystem","../../data/helper/completeDimensions","../../util/model","20","PRIORITY","registerProcessor","PROCESSOR","STATISTIC","../layout/points","../processor/dataSample","../visual/symbol","./line/LineSeries","./line/LineView","21","clipOverflow","smooth","smoothMonotone","showSymbol","showAllSymbol","connectNulls","sampling","animationEasing","progressive","hoverLayerThreshold","Infinity","22","isPointsSame","points1","points2","getSmooth","getAxisExtentWithGap","axis","extent","getGlobalExtent","onBand","halfBandWidth","getBandWidth","dir","sign","getStackedOnPoints","valueAxis","getOtherAxis","valueStart","onZero","getExtent","dim","baseDataOffset","mapArray","stackedOnSameSign","stackedOn","stackedData","createGridClipShape","hasAnimation","xExtent","getAxis","yExtent","expandSize","clipPath","createPolarClipShape","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","radiusExtent","RADIAN","inverse","createClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","nextPt","push","stepPt","middle","stepPt2","getVisualGradient","visualMetaList","getVisual","count","visualMeta","dimension","console","warn","colorStops","stops","stop","coord","toGlobalCoord","dataToCoord","stopLen","outerColors","reverse","minCoord","maxCoord","coordSpan","unshift","gradient","LinearGradient","lineAnimationDiff","polyHelper","ChartView","init","symbolDraw","_symbolDraw","_lineGroup","areaStyleModel","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","polygon","_polygon","isAreaChart","isEmpty","stackedOnPoints","isSymbolIgnore","_getSymbolIgnoreFunc","__temp","_step","_newPolygon","setClipPath","_stackedOnPoints","_points","_updateAnimation","_newPolyline","lineJoin","stackedOnSmooth","getAreaStyle","queryDataIndex","Polyline","Polygon","categoryAxis","getAxesByScale","isLabelIgnored","current","stackedOnCurrent","next","stackedOnNext","__points","updatedDataInfo","diffStatus","status","cmd","idx1","ptIdx","animators","during","../helper/Symbol","../helper/SymbolDraw","./lineAnimationDiff","./poly","23","getStackedOnPoint","diffData","newData","diffResult","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","dims","diffItem","pointAdded","currentPt","getRawIndex","rawIndex","sort","b","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","24","isPointNull","drawSegment","start","segLen","allLen","smoothMin","smoothMax","prevIdx","k","v2Copy","cp0","nextIdx","nextP","ratioNextSeg","prevP","v","lenPrevSeg","lenNextSeg","dist","scaleAndAdd","vec2Min","vec2Max","bezierCurveTo","getBoundingBox","smoothConstraint","ptMin","ptMax","Path","copy","len","bbox","stackedOnBBox","closePath","25","event","../action/createDataSelectAction","../processor/dataFilter","../visual/dataColor","./pie/PieSeries","./pie/PieView","./pie/pieLayout","26","dataSelectableMixin","PieSeries","extendSeriesModel","superApply","arguments","legendDataProvider","getRawData","updateSelectedMap","_defaultLabelLine","mergeOption","newOption","superCall","getDataParams","params","sum","getSum","toFixed","$vars","defaultEmphasis","labelLine","labelLineNormalOpt","labelLineEmphasisOpt","minAngle","selectedOffset","avoidLabelOverlap","stillShowZeroSum","rotate","length2","animationType","mixin","../../component/helper/selectableMixin","27","updateDataSelected","uid","dispatchAction","from","seriesId","toggleItemSelected","midAngle","animate","when","PiePiece","hoverIgnore","normalIgnore","getLabelStyle","state","labelPosition","isLabelInside","piePieceProto","firstCreate","sectorShape","_updateLabel","labelLayout","verticalAlign","font","origin","labelHoverModel","labelLineModel","labelLineHoverModel","Pie","sectorGroup","_sectorGroup","isFirstRender","onSectorClick","selectedMode","piePiece","eachChild","child","removeClipPath","_createClipPath","containPoint","itemLayout","sqrt","28","adjustSingleSide","viewWidth","viewHeight","shiftUp","end","delta","changeX","isDownList","lastDeltaX","Number","MAX_VALUE","deltaY","len2","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","textContain","hasLabelRotate","textX","textY","labelLineLen","labelLineLen2","x3","y3","labelRotate","textRect","getBoundingRect","zrender/lib/contain/text","29","unitRadian","roseType","getDataExtent","restAngle","valueSumLargerThanMinAngle","currentAngle","setItemLayout","./labelLayout","30","registerPreprocessor","../component/radar","./radar/RadarSeries","./radar/RadarView","./radar/backwardCompat","./radar/radarLayout","31","encodeHTML","RadarSeries","formatTooltip","indicatorAxes","getIndicatorAxes","join","radarIndex","../../util/format","32","normalizeSymbolSize","updateSymbols","oldPoints","newPoints","symbolGroup","isInit","__dimIdx","getInitialPoints","itemGroup","hoverPolygonIgnore","polygonIgnore","hoverAreaStyleModel","parentModel","itemHoverStyle","clone","33","polarOptArr","polarNotRadar","polarOpt","indicator","radar","series","seriesOpt","polarIndex","34","pointsConverter","35","../coord/cartesian/AxisModel","./axis/AxisView","36","makeAxisEventDataBase","axisModel","eventData","componentType","componentIndex","innerTextLayout","opt","textRotation","direction","rotationDiff","remRadian","isRadianAroundZero","endTextLayout","textRotate","onLeft","isSilent","tooltipOpt","formatUtil","Model","v2ApplyTransform","applyTransform","AxisBuilder","labelOffset","nameDirection","tickDirection","labelDirection","dumbGroup","updateTransform","_transform","transform","_dumbGroup","hasBuilder","builders","getGroup","matrix","pt1","pt2","subPixelOptimizeLine","anid","lineCap","strokeContainThreshold","isBlank","tickInterval","getInterval","labelInterval","ticksCoords","getTicksCoords","ticks","getTicks","ifIgnoreOnTick","tickCoord","isTwoLabelOverlapped","firstRect","nextRect","getLocalTransform","intersect","axisLabelShow","labelMargin","labels","getFormattedLabels","labelRotation","categoryData","textEls","triggerEvent","tickVal","itemTextStyleModel","textColor","pos","labelBeforeFormat","getLabel","textEl","targetType","decomposeTransform","getMin","firstLabel","getMax","lastLabel","axisName","nameLocation","gap","gapSignal","nameRotation","axisNameAvailableWidth","truncateOpt","ellipsis","maxWidth","truncatedText","truncateText","minChar","placeholder","formatterParams","__fullText","__truncatedText","tooltip","content","formatter","interval","rawTick","37","layoutAxis","gridModel","getZero","theAxis","grid","rawAxisPosition","axisPosition","axisDim","getRect","rectBound","axisOffset","posMap","top","bottom","left","right","dirMap","getLabelInterval","axisBuilderAttrs","selfBuilderAttrs","AxisView","extendComponentView","oldAxisGroup","_axisGroup","getCoordSysModel","axisBuilder","groupTransition","_splitLine","lineColors","lineInterval","gridRect","lineCount","colorIndex","_splitArea","splitAreaModel","areaColors","prevX","prevY","areaInterval","areaStyle","./AxisBuilder","38","./dataZoom/DataZoomModel","./dataZoom/DataZoomView","./dataZoom/InsideZoomModel","./dataZoom/InsideZoomView","./dataZoom/dataZoomAction","./dataZoom/dataZoomProcessor","./dataZoom/typeDefaulter","39","calculateDataExtent","seriesModels","dataExtent","seriesData","coordDimToDataDim","seriesExtent","fixExtentByAxis","setAxisModel","axisProxy","isRestore","getAxisModel","percentWindow","_percentWindow","valueWindow","_valueWindow","precision","getPixelPrecision","useOrigin","setRange","asc","AxisProxy","axisIndex","dataZoomModel","_dimName","_axisIndex","_dataExtent","_dataZoomModel","hostedBy","getDataValueWindow","getDataPercentWindow","getTargetSeriesModels","eachSeries","isCoordSupported","getComponent","getOtherAxisModel","otherAxisDim","coordSysIndexName","isCartesian","foundOtherAxisModel","otherAxisModel","calculateDataWindow","percentExtent","prop","parse","boundValue","boundPercent","reset","dataWindow","restore","filterData","isInWindow","filterMode","setData","filterSelf","40","retrieveRaw","ret","hasOwnProperty","processRangeProp","percentProp","valueProp","rawOption","thisOption","env","eachAxisDim","DataZoomModel","extendComponentModel","orient","xAxisIndex","yAxisIndex","throttle","startValue","endValue","_dataIntervalByAxis","_dataInfo","_axisProxies","_autoThrottle","mergeDefaultAndTheme","doInit","merge","canvasSupported","realtime","_setDefaultThrottle","_resetTarget","_giveAxisProxies","axisProxies","eachTargetAxis","dimNames","dependentModels","__dzAxisProxy","autoMode","_judgeAutoMode","axisIndexName","normalizeToArray","_autoSetAxisIndex","_autoSetOrient","hasIndexSpecified","autoAxisIndex","singleAxisIndex","axisIndices","axisModels","_isSeriesHasAllAxesTypeOf","axisId","is","seriesAxisIndex","globalOption","animation","animationDurationUpdate","getFirstTargetAxisModel","firstAxisModel","indices","callback","context","getAxisProxy","setRawRange","getPercentRange","findRepresentativeAxisProxy","getValueRange","axisDimName","./AxisProxy","zrender/lib/core/env","41","ComponentView","getTargetCoordInfo","save","coordModel","store","coordIndex","item","coordSysLists","../../view/Component","42","disabled","zoomLock","./DataZoomModel","43","fixRange","range","bound","DataZoomView","sliderMove","roams","InsideZoomView","_range","shouldRecordRange","coordInfoList","allCoordIds","coordInfo","generateCoordId","coordId","containsPoint","dataZoomId","throttleRate","panGetRange","_onPan","zoomGetRange","_onZoom","unregister","controller","oldX","oldY","newX","newY","directionInfo","getDirectionInfo","signal","pixel","pixelLength","mouseX","mouseY","percentPoint","pixelStart","oldPoint","newPoint","pointToCoord","../helper/sliderMove","./DataZoomView","./roams","44","linkedNodesFinder","createLinkedNodesFinder","effectedModels","apply","nodes","45","resetSingleAxis","filterSingleAxis","percentRange","valueRange","46","AXIS_DIMS","COORDS","coordType","createNameEach","names","attrs","capitalNames","capitalFirst","capitalAttrs","nameObj","capital","forEachNode","forEachEdgeType","edgeIdGetter","isNodeAbsorded","node","isLinked","hasLink","edgeType","edgeId","records","absorb","sourceNode","processSingleNode","existsLink","47","giveStore","zr","getZr","ATTR","createController","dataZoomInfo","newRecord","RoamController","enable","onPan","onZoom","cleanStore","record","wrapAndDispatch","info","getRange","batch","dataZoomInfos","theDataZoomId","theCoordId","setContainsPoint","createOrUpdate","../../component/helper/RoamController","../../util/throttle","48","registerSubTypeDefaulter","../../model/Component","49","xAxis","yAxis","../util/graphic","./axis","50","mousedown","offsetX","offsetY","_x","_y","_dragging","mousemove","eventTool","gestureEvent","interactionMutex","isTaken","_zr","mouseup","mousewheel","zoomDelta","wheelDelta","zoom","pinch","pinchScale","pinchX","pinchY","zoomX","zoomY","zoomLimit","newZoom","zoomMin","zoomMax","zoomScale","mousedownHandler","mousemoveHandler","mouseupHandler","mousewheelHandler","pinchHandler","Eventful","controlType","disable","isDragging","isPinching","_pinching","./interactionMutex","zrender/lib/core/event","zrender/lib/mixin/Eventful","51","getStore","take","resourceKey","userKey","release","52","positionGroup","positionElement","getBoxLayoutParams","componentModel","getLayoutRect","box","addBackground","padding","normalizeCssArray","boundingRect","subPixelOptimizeRect","../../util/layout","53","targetList","_selectTargetMap","reduce","targetMap","select","unSelect","toggleSelected","54","handleEnds","mode","handleIndex","getRealDelta","handleMinMax","55","./legend/LegendModel","./legend/LegendView","./legend/legendAction","./legend/legendFilter","56","LegendModel","layoutMode","ignoreSize","optionUpdated","_updateData","legendData","hasSelected","dataItem","availableNames","getSeries","_availableNames","align","itemGap","itemWidth","itemHeight","inactiveColor","57","dispatchSelectAction","dispatchHighlightAction","dataName","storage","getDisplayList","useHoverLayer","seriesName","dispatchDownplayAction","symbolCreator","listComponentHelper","_symbolTypeStore","legendModel","selectMode","itemAlign","legendDrawedMap","newline","getSeriesByName","legendSymbolType","_createItem","eachRawSeries","indexOfName","itemIcon","tooltipModel","legendGlobalTooltipModel","hitRect","invisible","legendIndex","../helper/listComponent","58","legendSelectActionHandler","methodName","selectedMap","isToggleSelect","isItemSelected","59","legendModels","findComponents","filterSeries","60","markLine","./marker/MarkLineModel","./marker/MarkLineView","61","markPoint","./marker/MarkPointModel","./marker/MarkPointView","62","./MarkerModel","63","isInifinity","ifMarkLineHasOnlyDim","fromCoord","toCoord","otherDimIndex","containData","markLineFilter","markerHelper","dataFilter","updateSingleMarkerEndLayout","isFrom","xPx","yPx","getValues","createList","mlModel","coordDimsInfos","coordDim","fromData","toData","optData","markLineTransform","filter","to","mlType","valueDataDim","axisInfo","getAxisInfo","numCalculate","valueIndex","mlFrom","mlTo","dataTransform","markLineModel","mlData","__from","__to","markerGroupMap","renderSeries","updateDataVisualAndLayout","setItemVisual","lineDrawMap","lineDraw","lineColor","fromSymbolSize","fromSymbol","toSymbolSize","toSymbol","traverse","dataModel","__keep","../../chart/helper/LineDraw","./MarkerView","./markerHelper","64","65","updateMarkerLayout","mpData","mpModel","markPointModel","symbolDrawMap","../../chart/helper/SymbolDraw","66","fillLabel","LABEL_OPTIONS","addCommas","MarkerModel","extraOpt","createdBySelf","hostSeries","__hostSeries","newOpt","modelPropName","markerOpt","markerModel","seriesIndex","formattedValue","html","dataFormatMixin","67","markerModelKey","68","hasXOrY","parseFloat","hasXAndY","getPrecision","valueAxisDim","markerTypeCalculatorWithExtent","otherDataDim","targetDataDim","otherCoordIndex","targetCoordIndex","coordArr","indexOfNearest","markerTypeCalculator","average","baseDataDim","dataDim","getDimension","dataDimToCoordDim","69","../coord/radar/Radar","../coord/radar/RadarModel","70","radarModel","_buildAxes","_buildSplitLineAndArea","axisBuilders","indicatorAxis","getColorIndex","areaOrLine","areaOrLineColorList","showSplitLine","showSplitArea","splitLineColors","splitAreaColors","splitLines","splitAreas","ticksRadius","Circle","Ring","realSplitNumber","axesTicksPoints","coordToPoint","prevPoints","error","mergePath","../axis/AxisBuilder","71","subtext","subtarget","fontWeight","subtextStyle","subtextStyleModel","textBaseline","subText","subTextEl","link","sublink","window","open","groupRect","layoutOption","layoutRect","alignStyle","margin","../util/layout","72","./tooltip/TooltipModel","./tooltip/TooltipView","73","assembleTransition","duration","transitionText","vendors","vendorPrefix","assembleFont","cssText","assembleCssText","transitionDuration","zrColor","toHex","borderName","camelCase","toCamelCase","TooltipContent","container","document","createElement","appendChild","_container","_show","_hideTimeout","self","onmouseenter","enterable","clearTimeout","_inContent","onmousemove","handler","eventUtil","normalizeEvent","dispatch","onmouseleave","hideLater","_hideDelay","stl","currentStyle","defaultView","getComputedStyle","domStyle","display","innerHTML","setContent","hide","time","setTimeout","isShow","zrender/lib/tool/color","74","showContent","triggerOn","alwaysShowContent","confine","showDelay","hideDelay","borderRadius","extraCssText","axisPointer","animationEasingUpdate","crossStyle","shadowStyle","75","dataEqual","makeLineShape","makeRectShape","makeSectorShape","refixTooltipPosition","clientWidth","clientHeight","confineTooltipPosition","calcTooltipPosition","dom","domWidth","domHeight","rectWidth","rectHeight","updatePosition","positionExpr","ifSeriesSupportAxisTrigger","_axisPointers","tooltipContent","getDom","_tooltipContent","_tooltipModel","_ecModel","_api","_lastHover","_alwaysShowContent","_seriesGroupByAxis","_prepareAxisTriggerData","crossText","_crossText","_lastX","_lastY","_refreshUpdateTimeout","manuallyShowTip","_tryShow","_mousemove","_hide","_showTimeout","seriesHaveDataOnIndex","_series","getSeriesByIndex","isTriggerAxis","getTooltipPosition","findHover","manuallyHideTip","seriesGroupByAxis","globalTrigger","_showAxisTooltip","_ticket","_hideAxisPointer","_resetLastHover","_showItemTooltipContent","dataIndexInside","subTooltipModel","defaultHtml","asyncTicket","random","_showTooltipContent","axisPointerModel","axisPointerType","_showAxisPointer","allNotShow","seriesCoordSysSameAxis","allCoordSys","pointToData","eqNaN","contentNotChange","lastHover","valIndex","_showSinglePointer","_showPolarPointer","_showCartesianPointer","_dispatchAndShowSeriesTooltipContent","moveGridLine","otherExtent","pointerEl","_getPointerElement","moveAnimation","moveGridShadow","bandWidth","span","_updateCrossText","otherAxis","movePolarLine","mouseCoord","movePolarShadow","radian","crossStyleModel","initShape","axisPointers","pointerType","styleModel","isShadow","elementType","seriesList","rootTooltipModel","baseDimIndex","sampleSeriesIndex","payloadBatch","getAxisTooltipDataIndex","paramsList","firstDataIndex","firstLine","seriesTooltipModel","formatTpl","ticket","cbTicket","children","./TooltipContent","76","fixExtentWithBands","nTick","normalizedExtent","Axis","_extent","contain","setExtent","clamp","coordToData","alignWithLabel","bands","getBands","coords","getLabelsCoords","axisExtent","_isBlank","setBlank","../util/number","77","nameRotate","nameTruncate","nameTextStyle","nameGap","inside","splitArea","boundaryGap","timeAxis","logAxis","logBase","78","OrdinalScale","IntervalScale","Scale","axisHelper","getScaleExtent","axisDataLen","scaleType","fixMin","fixMax","originalExtent","getNeedCrossZero","niceScaleExtent","base","niceExtent","minInterval","intervalScale","setInterval","createScaleByModel","getClass","ifAxisCrossZero","getAxisLabelInterval","tickCoords","isAxisHorizontal","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","floor","union","getTicksLabels","tpl","tick","../scale/Interval","../scale/Log","../scale/Ordinal","../scale/Scale","../scale/Time","79","obj","isObject","rangeStart","rangeEnd","resetRange","./axisHelper","80","axisDefault","ComponentModel","AXIS_TYPES","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","inputPositionParams","getLayoutParams","themeModel","getTheme","getDefaultOption","mergeLayoutParam","mergeAll","../model/Component","./axisDefault","81","axisLabelInterval","Axis2D","coordExtent","_labelInterval","toLocalCoord","../Axis","./axisLabelInterval","82","getAxisType","axisModelCreator","AxisModel","restoreData","gridIndex","gridId","extraOption","../axisModelCommonMixin","../axisModelCreator","83","dimAxisMapper","_axes","Cartesian","_dimList","getAxes","toLowerCase","addAxis","_dataCoordConvert","input","dimList","output","84","Cartesian2D","axisX","axisY","dataToPoints","stack","./Cartesian","85","isAxisUsedInTheGrid","getLabelUnionRect","labelCount","ceil","singleRect","getTextRect","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","_model","updateAxisTransfrom","coordBase","axisExtentSum","findAxesModels","axesTypes","getReferringComponents","isCartesian2D","gridProto","_rect","ifAxisCanNotOnZero","axes","axesMap","_updateScale","resize","adjustAxes","axesList","labelUnionRect","axesMapOnDim","getCartesian","coordList","convertToPixel","finder","_findConvertTarget","convertFromPixel","coordsList","createAxisCreator","axisPositionUsed","axesCount","unionExtent","unionExtentFromData","grids","../../coord/axisHelper","./Axis2D","./Cartesian2D","./GridModel","86","containLabel","./AxisModel","87","../axisHelper","88","IndicatorAxis","89","Radar","_indicatorAxes","getIndicatorModels","indicatorModel","indicatorIndex","closestAxis","minRadianDiff","closestAxisIdx","coodToData","viewSize","increaseInterval","exp10","pow","log","LN10","radarSeries","rawExtent","fixedMin","fixedMax","nicedSplitNumber","halfSplitNumber","radarList","../../scale/Interval","./IndicatorAxis","90","defaultsShow","valueAxisDefault","axisModelCommonMixin","RadarModel","showName","nameFormatter","indicatorModels","indicatorOpt","indName","../axisDefault","91","defaultKeyGetter","DataDiffer","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","arr","keyArr","keyGetter","existence","func","_add","_update","_remove","oldDataIndexMap","newDataIndexMap","oldDataKeyArr","newDataKeyArr","92","global","normalizeDimensions","cloneListForMapAndSample","original","excludeDimensions","allDimensions","transferProperties","_storage","originalStorage","dimStore","globalObj","Float64Array","Int32Array","dataCtors","float","int","ordinal","number","TRANSFERABLE_PROPERTIES","__wrappedMethods","propName","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","_dimensionInfos","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","listProto","dimensionInfoMap","idList","nameRepeatCount","dimInfo","DataCtor","stackedValue","values","dimData","dimExtent","indexOfRawIndex","rawDataIndex","mid","maxDistance","nearestIdx","minDist","rawIdx","getRawDataItem","getId","dimSize","newIndices","keep","tmpRetValue","retValue","downSample","rate","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","visual","setLayout","clearItemLayouts","ignoreParent","itemVisual","clearAllVisual","setItemDataAndSeriesIndex","cloneShallow","dimensionInfoList","wrapMethod","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","../model/Model","../util/model","./DataDiffer","93","defaultNames","extraPrefix","value0","retrieveValue","guessOrdinal","isString","94","createRegisterEventWithLowercaseName","eventName","MessageCenter","ECharts","theme","opts","prioritySortFunc","prio","themeStorage","_dom","zrender","renderer","devicePixelRatio","_throttledZrFlush","flush","_theme","_chartsViews","_chartsMap","_componentsViews","_componentsMap","_coordSysMgr","_messageCenter","_initEvents","_pendingActions","timsort","visualFuncs","dataProcessorFuncs","_onframe","doConvertPixel","coordSysList","parseFinder","updateDirectly","ecIns","condition","view","__viewId","__alive","doDispatchAction","payloadType","actionWrap","actions","cptType","split","updateMethod","parseClassType","IN_MAIN_PROCESS","payloads","batched","eventObj","eventObjBatch","isHighDown","batchItem","action","main","OPTION_UPDATED","updateMethods","prepareAndUpdate","flushPendingActions","pendingActions","shift","triggerUpdatedEvent","invokeUpdateMethod","component","__model","updateZ","chart","updateProgressiveAndBlend","updateHoverLayerStatus","prepareView","isComponent","viewList","viewMap","viewId","classType","Clazz","__id","splice","processData","process","stackSeriesData","stackedDataMap","previousStack","doLayout","isLayout","doVisualEncoding","excludesLayout","clearColorPalette","doRender","componentView","chartView","elCount","isGroup","frameDrawNum","needProgressive","blendMode","enableConnect","updateConnectedChartsStatus","charts","STATUS_KEY","eventActionMap","actionType","eventType","connectedGroups","makeActionFromEvent","otherCharts","instances","otherChart","GlobalModel","OptionManager","colorTool","ACTION_REG","one","echartsProto","setOption","notMerge","lazyUpdate","assert","optionManager","__lastOnlyGraphic","optionPreprocessorFuncs","setTheme","getOption","getRenderedCanvas","pixelRatio","painter","getDataURL","excludeComponents","excludesComponentViews","url","toDataURL","getConnectedDataURL","groupId","mathMin","mathMax","MAX_NUMBER","canvasList","dpr","canvas","getBoundingClientRect","targetCanvas","createCanvas","img","Image","image","refreshImmediately","containPixel","models","visualType","defaultMainType","coordSysMgr","isSingleCanvas","configLayer","clearColor","colorArr","stringify","background","updateView","updateVisual","resetOption","_loadingFX","showLoading","cfg","hideLoading","loadingEffects","browser","weChat","MOUSE_EVENT_NAMES","eveName","isDisposed","_disposed","clear","idBase","Date","groupIdBase","version","isDom","nodeName","toUpperCase","setAttribute","connect","disConnect","getInstanceByDom","getAttribute","getInstanceById","registerTheme","preprocessorFunc","priority","processorFunc","test","registerCoordinateSystem","layoutFunc","visualFunc","registerLoading","loadingFx","setCanvasCreator","format","util","FILTER","VISUAL","LAYOUT","GLOBAL","CHART","COMPONENT","BRUSH","./CoordinateSystem","./ExtensionAPI","./data/List","./loading/default","./model/Component","./model/Global","./model/Model","./model/OptionManager","./model/Series","./preprocessor/backwardCompat","./util/format","./util/graphic","./util/model","./util/number","./util/throttle","./view/Chart","./view/Component","./visual/seriesColor","zrender/lib/core/matrix","zrender/lib/core/timsort","95","getSeriesStackId","getAxisKey","calBarWidthAndOffset","barSeries","columnsMap","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","stacks","stackId","barWidth","barMaxWidth","barGap","barCategoryGap","barGapPercent","autoWidth","column","lastColumn","widthSum","barWidthAndOffset","getSeriesByType","isSeriesFiltered","lastStackCoords","lastStackCoordsOrigin","columnLayoutInfo","columnOffset","columnWidth","valueAxisStart","lastCoord","lastCoordOrigin","96","97","maskColor","mask","arc","Arc","labelRect","textDistance","animateShape","delay","98","getDependencies","deps","getClassesByMainType","arrayPush","clazzUtil","componentUtil","$constructor","getUID","newCptOption","hasOwn","optList","Class","superClass","set","enableClassManagement","registerWhenExtend","enableSubTypeDefaulter","enableTopologicalTravel","../util/clazz","../util/component","./Model","./mixin/boxLayout","99","mergeTheme","themeItem","hasClass","initBase","baseOption","OPTION_INNER_KEY","_seriesIndices","globalDefault","getComponentsByTypes","componentsMap","types","determineSubType","existComponent","createSeriesIndices","filterBySubType","components","cpt","assertSeriesInitialized","_optionManager","optionChanged","mountOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","mediaOption","visitComponent","newCptOptionList","mapResult","mappingToExists","makeIdAndName","keyInfo","exist","resultItem","ComponentModelClass","newCptTypes","componentOption","topologicalTravel","getAllClassMainTypes","isIdInner","cpts","isIdArray","isNameArray","queryCond","q","indexAttr","idAttr","nameAttr","queryResult","oneSeries","rawSeriesIndex","eachRawSeriesByType","filteredSeries","componentTypes","./Component","./globalDefault","./mixin/colorPalette","100","doGet","pathArr","getParent","path","getParentMethod","parsePath","thisParentModel","Ctor","setReadOnly","properties","customizeGetParent","enableClassExtend","./mixin/areaStyle","./mixin/itemStyle","./mixin/lineStyle","./mixin/textStyle","101","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","parseRawOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","options","media","singleMedia","preProcess","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","matched","match","QUERY_REG","operator","compare","real","expect","indicesEquals","indices1","indices2","oldOption","newCptOpt","oldCptOpt","oldOptionBackup","newParsedOption","isRecreate","optionBackup","timelineModel","getCurrentIndex","102","classUtil","colorPaletteMixin","visualColorAccessPath","fillDataTextStyle","newSeriesOption","getLinkedData","multipleSeries","valStr","dimType","formatTime","colorEl","animationEnabled","getColorFromPalette","scope","../util/format","103","platform","navigator","fontFamily","fontStyle","animationDuration","animationThreshold","progressiveThreshold","104","./makeStyleMapper","105","106","colorIdx","colorNameMap","colorPalette","../../util/clazz","107","lineType","108","getLineDash","dotSize","dashSize","109","110","gTextStyleModel","containerWidth","111","overwrite","compatLayoutProperties","LAYOUT_PROPERTIES","compatStyle","COMPATITABLE_COMPONENTS","COMPATITABLE_SERIES","clockWise","pointerColor","dataRange","visualMap","componentName","./helper/compatStyle","112","compatItemStyle","itemStyleOpt","POSSIBLE_STYLES","styleName","normalItemStyleOpt","emphasisItemStyleOpt","113","114","samplers","frame","nearest","indexSampler","sampler","115","mathFloor","mathCeil","getPrecisionSafe","roundingErrorFix","_interval","thisExtent","other","niceTicks","_niceExtent","nice","./Scale","116","fixRoundingError","originalVal","scaleProto","intervalScaleProto","mathPow","mathLog","LogScale","_originalScale","originalScale","powVal","__fixMin","__fixMax","approxTickNum","quantity","err","./Interval","117","rank","118","119","bisect","lo","hi","TimeScale","stepLvl","_stepLvl","date","ONE_HOUR","getFullYear","getMonth","getDate","approxInterval","scaleLevelsLen","scaleLevels","level","yearSpan","parseDate","ONE_SECOND","ONE_MINUTE","ONE_DAY","120","checkClassType","args","clazz","IS_CONTAINER","host","RootClass","mandatoryMethods","proto","ExtendedClass","entity","makeContainer","registerClass","componentMainType","throwWhenNotFound","hasSubTypes","originalExtend","121","subTypeDefaulters","defaulter","componentTypeMain","dependencyGetter","makeDepndencyGraph","fullNameList","graph","noEntryList","thisItem","createDependencyGraphItem","originalDeps","availableDeps","getAvailableDependencies","entryCount","dependentName","predecessor","thatItem","successor","dep","targetNameList","removeEdge","succComponentType","removeEdgeAndAdd","targetNameSet","currComponentType","currVertex","isInTargetNameSet","./clazz","122","str","upperCaseFirst","group1","charAt","source","String","TPL_VAR_ALIAS","wrapVar","varName","seriesIdx","encode","seriesLen","alias","s2d","M","h","getHours","m","getMinutes","getSeconds","substr","./number","123","hasFillOrStroke","fillOrStroke","liftColor","lift","cacheElementStl","__hoverStlDirty","__hoverStl","__normalStl","doSingleEnterHover","__isHover","__zr","addHover","doSingleLeaveHover","normalStl","removeHover","doEnterHover","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__hoverSilentOnTouch","zrByTouch","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","props","animatableModel","postfix","animationDelay","getAnimationDelayParams","pathTool","CompoundPath","RadialGradient","BoundingRect","extendPath","pathData","extendFromString","makePath","createFromString","aspect","resizePath","pathRect","calculateTransform","param","subPixelOptimize","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","hoverSilentOnTouch","labelColor","textOffset","getTransform","ancestor","mat","identity","mul","vertex","invert","transformDirection","hBase","vBase","g1","g2","getAnimatableProps","elMap1","g","elMap","oldEl","newProp","zrender/lib/container/Group","zrender/lib/core/BoundingRect","zrender/lib/graphic/CompoundPath","zrender/lib/graphic/Image","zrender/lib/graphic/LinearGradient","zrender/lib/graphic/RadialGradient","zrender/lib/graphic/Text","zrender/lib/graphic/shape/Arc","zrender/lib/graphic/shape/BezierCurve","zrender/lib/graphic/shape/Circle","zrender/lib/graphic/shape/Line","zrender/lib/graphic/shape/Polygon","zrender/lib/graphic/shape/Polyline","zrender/lib/graphic/shape/Rect","zrender/lib/graphic/shape/Ring","zrender/lib/graphic/shape/Sector","zrender/lib/tool/path","124","boxLayout","maxHeight","currentLineMaxSize","nextX","nextY","nextChild","nextChildRect","moveX","moveY","LOCATION_PARAMS","vbox","hbox","getAvailableSize","positionInfo","containerRect","containerHeight","verticalMargin","horizontalMargin","hv","boundingMode","needLocalTransform","elPos","targetOption","newParams","newValueCount","merged","mergedValueCount","enoughParamNumber","hasProp","hNames","vNames","hResult","vResult","copyLayoutParams","./format","125","has","nubmerUtil","subOpts","emphasisOpt","normalOpt","subOptName","createDataFormatModel","rawValue","componentSubType","exists","newCptOptions","cptOption","idMap","existCpt","idNum","compressBatches","batchA","batchB","makeMap","sourceBatch","otherMap","dataIndices","otherDataIndices","lenj","mapToArray","isData","mapA","mapB","parsedKey","queryType","queryParam","126","_trim","domain","subDomain","subRange","all","toString","dotIndex","pixelExtent","dataQuantity","sizeQuantity","MAX_SAFE_INTEGER","pi2","reformIntervals","littleThan","lg","close","curr","currClose","isNumeric","127","Triangle","Diamond","Pin","w","asin","tanX","tanY","cpLen","cpLen2","Arrow","symbolCtors","roundRect","square","circle","diamond","pin","arrow","triangle","symbolShapeMakers","symbolBuildProxies","beforeBrush","inBundle","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","./graphic","128","lib","ORIGIN_METHOD","RATE","fn","debounce","exec","lastExec","getTime","timer","currCall","lastCall","fnAttr","throttleType","originFn","lastThrottleType","129","Chart","elSetState","childCount","toggleHighlight","dataIdx","chartProto","130","Component","componentProto","131","paletteScope","dataAll","idxMap","filteredIdx","singleDataColor","132","Gradient","encodeColor","colorAccessPath","zrender/lib/graphic/Gradient","133","defaultSymbolType","legendSymbol","itemSymbolType","itemSymbolSize","134","guid","Transformable","Animatable","Element","afterUpdate","attrKV","refresh","addSelfToZr","__clipTarget","removeSelfFromZr","addAnimator","removeAnimator","./core/guid","./core/util","./mixin/Animatable","./mixin/Eventful","./mixin/Transformable","135","makeEventPacket","eveType","cancelBubble","zrX","zrY","zrDelta","EmptyProxy","isHover","displayable","rectHover","Draggable","handlerNames","Handler","proxy","painterRoot","_hovered","_lastTouchMoment","hovered","lastHovered","setCursor","dispatchToElement","mouseout","innerDom","element","toElement","relatedTarget","nodeType","eventArgs","setCursorStyle","cursorStyle","targetEl","eventHandler","eventPacket","eachOtherLayer","layer","exclude","_downel","_upel","./mixin/Draggable","136","returnFalse","createDom","newDom","newDomStyle","config","Style","Pattern","Layer","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","initContext","getContext","createBackBuffer","clearAll","haveMotionBLur","globalCompositeOperation","drawImage","clearRect","clearColorGradientOrPattern","__canvasGradient","getGradient","getCanvasPattern","fillStyle","fillRect","globalAlpha","./config","./graphic/Pattern","./graphic/Style","137","parseInt10","parseInt","isLayerValid","isBuildin","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","tmpRect","viewRect","isClipPathChanged","clipPaths","prevClipPaths","doClip","setTransform","beginPath","clip","restoreTransform","createRoot","domRoot","requestAnimationFrame","Painter","root","singleCanvas","_opts","_singleCanvas","rootStyle","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","_domRoot","_getSize","pathToImage","_createPathToImage","_progressiveLayers","_hoverlayer","_hoverElements","getViewportRoot","paintAll","_paintList","refreshHover","_startProgessive","__hoverMir","elMirror","hoverElements","clearHover","hoverLayer","displayableSortFunc","getLayer","originalEl","invTransform","__clipPaths","_doPaintEl","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuildinLayer","flushProgressiveLayer","shadowBlur","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","MAX_PROGRESSIVE_LAYER_NUMBER","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","prevEl","brush","afterBrush","insertLayer","layersMap","prevLayer","prevDom","nextSibling","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","removeChild","clearLayer","imageLayer","displayList","whIdx","wh","cwh","plt","prb","_pathToImage","pathTransform","ImageShape","imgShape","me","./Layer","./animation/requestAnimationFrame","./core/BoundingRect","./core/log","./core/timsort","./graphic/Image","138","shapeCompareFunc","Storage","_elements","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","roots","_updateAndAddDisplayable","userSetClipPath","currentClipPath","parentClipPath","_children","addRoot","addChildrenToStorage","addToMap","delRoot","elId","delChildrenFromStorage","delFromMap","__storage","elements","_renderList","./container/Group","./core/env","139","Dispatcher","Animator","Animation","stage","onframe","_clips","_running","_time","_pausedTime","_pauseStart","_paused","addClip","animator","clips","getClips","removeClip","deferredEvents","deferredClips","_needsRemove","fire","_startLoop","pause","resume","loop","getter","setter","../core/event","../core/util","./Animator","./requestAnimationFrame","140","defaultGetter","defaultSetter","interpolateNumber","p0","interpolateString","interpolateArray","out","arrDim","fillArr","arr0","arr1","arr0Len","arr1Len","arraySlice","isArraySame","catmullRomInterpolateArray","p3","t2","t3","catmullRomInterpolate","v0","v1","cloneValue","isArrayLike","rgba2String","rgba","createTrackClip","easing","oneTrackDone","keyframes","_getter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","lastValue","_target","lastFrame","lastFramePercent","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","_doneCallback","doneList","lastClip","clipCount","oldOnFrame","forwardToLast","clipList","done","../tool/color","./Clip","141","_life","_initialized","onrestart","easingFuncs","globalTime","_startTime","easingFunc","schedule","restart","remainder","arg","./easing","142","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","143","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","144","debugMode","145","normalizeRadian","containStroke","anticlockwise","_l","./util","146","curve","x0","y0","cubicProjectPoint","../core/curve","147","_a","_b","148","isAroundEqual","EPSILON","swapExtrema","extrema","windingCubic","nRoots","cubicRootAt","y0_","y1_","nExtrema","unit","cubicAt","cubicExtrema","windingQuadratic","quadraticRootAt","quadraticExtremum","y_","quadraticAt","x_","windingArc","containPath","isStroke","xi","yi","CMD","windingLine","L","C","cubic","Q","quadratic","A","rx","ry","theta","dTheta","R","Z","../core/PathProxy","./arc","./cubic","./line","./quadratic","./windingLine","149","quadraticProjectPoint","150","getTextWidth","textWidthCache","textLines","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","textLineLen","lineHeight","adjustTextPositionOnRect","textHeight","halfHeight","maxIterations","cnCharWidth","ascCharWidth","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","../core/BoundingRect","151","152","153","_doAdd","addBefore","includeChildren","tmpMat","childRect","../Element","154","lt","rb","lb","rt","maxX","maxY","sx","sy","translate","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","./matrix","./vector","155","pointPair","GestureMgr","_track","recognize","_doTrack","_recognize","touches","trackItem","touch","clientToLocal","recognizers","gestureInfo","track","pinchEnd","pinchPre","pinchCenter","./event","156","LinkedList","head","tail","_len","linkedListProto","insert","entry","Entry","insertEntry","prev","LRU","maxSize","_list","_map","_maxSize","LRUProto","put","leastUsedEntry","157","min2","max2","mathSqrt","mathAbs","hasTypedArray","Float32Array","PathProxy","_ctx","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","setScale","addData","exceedUnit","_needsDash","_dashedLineTo","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","arcTo","toStatic","setLineDash","lineDashSum","setLineDashOffset","appendPath","appendSize","appendPathData","_expandData","_prevCmd","dash","dashSum","nDash","bezierLen","tmpLen","fromLine","fromCubic","fromQuadratic","fromArc","rebuildPath","ux","uy","psi","fs","scaleX","scaleY","isEllipse","../config","./BoundingRect","./bbox","./curve","158","extremity","fromPoints","xDim","yDim","tx","ty","159","isAroundZero","isNotAroundZero","onet","cubicDerivativeAt","c","B","t1","disc","K","discSqrt","Y1","Y2","ONE_THIRD","T","acos","ASqrt","THREE_SQRT","cubicSubdivide","p01","p12","p23","p012","p123","p0123","d1","d2","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticDerivativeAt","divider","quadraticSubdivide","v2Create","distSquare","160","os","ua","firefox","ie","edge","touchEventsSupported","pointerEventsSupported","userAgent","161","calculate","defaultGetZrXY","layerX","layerY","clientX","clientY","targetTouches","changedTouches","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","preventDefault","stopPropagation","returnValue","../mixin/Eventful","./env","162","idStart","163","164","ArrayCtor","m1","m2","out0","out1","out2","out3","out4","out5","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","165","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","array","runHi","reverseRun","binaryInsertionSort","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","remaining","ts","minRun","force","166","typeStr","objToString","TYPED_ARRAY","BUILTIN_OBJECT","targetProp","sourceProp","isBuildInObject","targetAndSources","overlay","baseClazz","F","clazzPrototype","forEach","nativeForEach","nativeMap","memo","nativeReduce","nativeFilter","find","nativeSlice","isFunction","ownerDocument","Function","message","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","Object","arrayProto","167","v2","lenSquare","div","dot","distanceSquare","negate","lerp","lengthSquare","168","eventNameFix","processGesture","gestureMgr","_gestureMgr","setTouchTimer","instance","_touching","_touchTimer","isPointerFromTouch","initDomHandler","makeMouseHandler","touchHandlerNames","_handlers","domHandlers","pointerHandlerNames","mouseHandlerNames","HandlerDomProxy","mountHandlers","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","nm","touchstart","touchmove","touchend","click","handlerDomProxyProto","../core/GestureMgr","../core/env","169","paths","_updatePathDirty","dirtyPath","__dirtyPath","getGlobalScale","./Path","170","Displayable","RectText","dragging","rectContain","transformCoordToLocal","animateStyle","./Style","./mixin/RectText","171","addColorStop","172","ZImage","globalImageCache","src","_image","cachedImgObj","onload","pending","sWidth","sHeight","drawRectText","../core/LRU","./Displayable","173","globalCoord","./Gradient","174","pathContain","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","_fillGradient","_strokeGradient","strokeStyle","lineDashOffset","ctxLineDash","shapeCfg","needsUpdateRect","rectWithStroke","_rectWithStroke","lineScale","getLineScale","localPos","Sub","extendFrom","defaultShape","thisShape","../contain/path","./Pattern","175","repeat","_canvasPattern","createPattern","176","177","createLinearGradient","createRadialGradient","STYLE_COMMON_PROPS","shadowOffsetX","shadowOffsetY","textStroke","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","blend","prevStyle","firstDraw","otherStyle","newStyle","canvasGradient","styleProto","178","fillText","strokeText","../contain/text","179","smoothSpline","smoothBezier","controlPoints","cp2","./smoothBezier","./smoothSpline","180","r1","r2","r3","r4","total","181","v2Min","v2Max","v2Scale","v2Distance","v2Add","isLoop","constraint","prevPoint","nextPoint","cps","d0","../../core/vector","182","interpolate","segs","w2","w3","183","maxValue","lastIndexOf","baseline","shadowColor","textShadowColor","../../contain/text","../../core/BoundingRect","184","../Path","185","someVectorAt","isTangent","cpx2","cpy2","curveTool","../../core/curve","186","187","188","../helper/poly","189","190","roundRectHelper","../helper/roundRect","191","192","shadowTemp","modified","../../core/env","193","animatingShape","pathSplitted","_animateToShallow","objShallow","propertyCount","../animation/Animator","../core/log","194","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","dropTarget","lastDropTarget","_dropTarget","195","arrySlice","_$handlers","_h","newList","argLen","triggerWithContext","196","mIdentity","transformableProto","parentHasTransform","tmpTransform","transformCoordToGlobal","../core/matrix","../core/vector","197","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseCssFloat","cssHueToRgb","colorStr","kCSSColorTable","op","ep","fname","alpha","hsla2rgba","iv","hsla","rgba2hsla","H","S","G","vMin","vMax","deltaR","deltaG","deltaB","fastMapToColor","normalizedValue","colors","leftIndex","rightIndex","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","198","processArc","fa","psiDeg","xp","yp","lambda","cxp","cyp","vAngle","vRatio","createPathProxyFromString","cs","cc","RegExp","prevCmd","cpx","cpy","ctlPtx","ctlPty","createPathOptions","pathProxy","transformPath","vMag","pathEls","pathList","pathEl","pathBundle","../graphic/Path","./transformPath","199","nPoint","mathAtan2","200","delInstance","HandlerProxy","useVML","painterCtors","ZRender","getInstance","registerPainter","rendererType","vml","handerProxy","_needsRefresh","oldDelFromMap","oldAddToMap","zLevel","_needsRefreshHover","refreshHoverImmediately","clearAnimation","./Handler","./Painter","./Storage","./animation/Animation","./dom/HandlerProxy","201","echarts/lib/chart/bar","echarts/lib/chart/gauge","echarts/lib/chart/line","echarts/lib/chart/pie","echarts/lib/chart/radar","echarts/lib/component/dataZoomInside","echarts/lib/component/legend","echarts/lib/component/markLine","echarts/lib/component/markPoint","echarts/lib/component/title","echarts/lib/component/tooltip","echarts/lib/echarts"],"mappings":"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","file":"echarts.bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * Interface of Coordinate System Class\n     *\n     * create:\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {module:echarts/ExtensionAPI} api\n     *     @return {Object} coordinate system instance\n     *\n     * update:\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {module:echarts/ExtensionAPI} api\n     *\n     * convertToPixel:\n     * convertFromPixel:\n     *     These two methods is also responsible for determine whether this\n     *     coodinate system is applicable to the given `finder`.\n     *     Each coordinate system will be tried, util one returns none\n     *     null/undefined value.\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {Object} finder\n     *     @param {Array|number} value\n     *     @return {Array|number} convert result.\n     *\n     * containPoint:\n     *     @param {Array.<number>} point In pixel coordinate system.\n     *     @return {boolean}\n     */\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n},{\"zrender/lib/core/util\":166}],2:[function(require,module,exports){\n'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\n    ];\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n},{\"zrender/lib/core/util\":166}],3:[function(require,module,exports){\n\n    var echarts = require('../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n    module.exports = function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent(\n                    {mainType: 'series', subType: seriesType, query: payload},\n                    function (seriesModel) {\n                        if (seriesModel[actionInfo.method]) {\n                            seriesModel[actionInfo.method](payload.name);\n                        }\n                        var data = seriesModel.getData();\n                        // Create selected map\n                        data.each(function (idx) {\n                            var name = data.getName(idx);\n                            selected[name] = seriesModel.isSelected(name) || false;\n                        });\n                    }\n                );\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n\n},{\"../echarts\":94,\"zrender/lib/core/util\":166}],4:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    require('../coord/cartesian/Grid');\n\n    require('./bar/BarSeries');\n    require('./bar/BarView');\n\n    var barLayoutGrid = require('../layout/barGrid');\n    var echarts = require('../echarts');\n\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n\n    // In case developer forget to include grid component\n    require('../component/grid');\n\n},{\"../component/grid\":49,\"../coord/cartesian/Grid\":85,\"../echarts\":94,\"../layout/barGrid\":95,\"./bar/BarSeries\":5,\"./bar/BarView\":6,\"zrender/lib/core/util\":166}],5:[function(require,module,exports){\n\n\n    module.exports = require('./BaseBarSeries').extend({\n\n        type: 'series.bar',\n\n        dependencies: ['grid', 'polar'],\n\n        brushSelector: 'rect'\n    });\n\n},{\"./BaseBarSeries\":7}],6:[function(require,module,exports){\n'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var helper = require('./helper');\n\n    var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth'];\n\n    // FIXME\n    // Just for compatible with ec2.\n    zrUtil.extend(require('../../model/Model').prototype, require('./barItemStyle'));\n\n    var BarView = require('../../echarts').extendChartView({\n\n        type: 'bar',\n\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n            if (coordinateSystemType === 'cartesian2d') {\n                this._renderOnCartesian(seriesModel, ecModel, api);\n            }\n\n            return this.group;\n        },\n\n        dispose: zrUtil.noop,\n\n        _renderOnCartesian: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var isHorizontal = baseAxis.isHorizontal();\n            var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n\n            data.diff(oldData)\n                .add(function (dataIndex) {\n                    if (!data.hasValue(dataIndex)) {\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(dataIndex);\n                    var layout = getRectItemLayout(data, dataIndex, itemModel);\n                    var el = createRect(data, dataIndex, itemModel, layout, isHorizontal, animationModel);\n                    data.setItemGraphicEl(dataIndex, el);\n                    group.add(el);\n\n                    updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal);\n                })\n                .update(function (newIndex, oldIndex) {\n                    var el = oldData.getItemGraphicEl(oldIndex);\n\n                    if (!data.hasValue(newIndex)) {\n                        group.remove(el);\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(newIndex);\n                    var layout = getRectItemLayout(data, newIndex, itemModel);\n\n                    if (el) {\n                        graphic.updateProps(el, {shape: layout}, animationModel, newIndex);\n                    }\n                    else {\n                        el = createRect(data, newIndex, itemModel, layout, isHorizontal, animationModel, true);\n                    }\n\n                    data.setItemGraphicEl(newIndex, el);\n                    // Add back\n                    group.add(el);\n\n                    updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontal);\n                })\n                .remove(function (dataIndex) {\n                    var el = oldData.getItemGraphicEl(dataIndex);\n                    el && removeRect(dataIndex, animationModel, el);\n                })\n                .execute();\n\n            this._data = data;\n        },\n\n        remove: function (ecModel, api) {\n            var group = this.group;\n            var data = this._data;\n            if (ecModel.get('animation')) {\n                if (data) {\n                    data.eachItemGraphicEl(function (el) {\n                        removeRect(el.dataIndex, ecModel, el);\n                    });\n                }\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    });\n\n    function createRect(data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n        var rect = new graphic.Rect({shape: zrUtil.extend({}, layout)});\n\n        // Animation\n        if (animationModel) {\n            var rectShape = rect.shape;\n            var animateProperty = isHorizontal ? 'height' : 'width';\n            var animateTarget = {};\n            rectShape[animateProperty] = 0;\n            animateTarget[animateProperty] = layout[animateProperty];\n            graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n                shape: animateTarget\n            }, animationModel, dataIndex);\n        }\n\n        return rect;\n    }\n\n    function removeRect(dataIndex, animationModel, el) {\n        // Not show text when animating\n        el.style.text = '';\n        graphic.updateProps(el, {\n            shape: {\n                width: 0\n            }\n        }, animationModel, dataIndex, function () {\n            el.parent && el.parent.remove(el);\n        });\n    }\n\n    function getRectItemLayout(data, dataIndex, itemModel) {\n        var layout = data.getItemLayout(dataIndex);\n        var fixedLineWidth = getLineWidth(itemModel, layout);\n\n        // fix layout with lineWidth\n        var signX = layout.width > 0 ? 1 : -1;\n        var signY = layout.height > 0 ? 1 : -1;\n        return {\n            x: layout.x + signX * fixedLineWidth / 2,\n            y: layout.y + signY * fixedLineWidth / 2,\n            width: layout.width - signX * fixedLineWidth,\n            height: layout.height - signY * fixedLineWidth\n        };\n    }\n\n    function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal) {\n        var color = data.getItemVisual(dataIndex, 'color');\n        var opacity = data.getItemVisual(dataIndex, 'opacity');\n        var itemStyleModel = itemModel.getModel('itemStyle.normal');\n        var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n        el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n\n        el.useStyle(zrUtil.defaults(\n            {\n                fill: color,\n                opacity: opacity\n            },\n            itemStyleModel.getBarItemStyle()\n        ));\n\n        var labelPositionOutside = isHorizontal\n            ? (layout.height > 0 ? 'bottom' : 'top')\n            : (layout.width > 0 ? 'left' : 'right');\n\n        helper.setLabel(\n            el.style, hoverStyle, itemModel, color,\n            seriesModel, dataIndex, labelPositionOutside\n        );\n\n        graphic.setHoverStyle(el, hoverStyle);\n    }\n\n    // In case width or height are too small.\n    function getLineWidth(itemModel, rawLayout) {\n        var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n        return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n    }\n\n    module.exports = BarView;\n\n},{\"../../echarts\":94,\"../../model/Model\":100,\"../../util/graphic\":123,\"./barItemStyle\":8,\"./helper\":9,\"zrender/lib/core/util\":166}],7:[function(require,module,exports){\n'use strict';\n\n\n    var SeriesModel = require('../../model/Series');\n    var createListFromArray = require('../helper/createListFromArray');\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.__base_bar__',\n\n        getInitialData: function (option, ecModel) {\n            if (__DEV__) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'cartesian2d') {\n                    throw new Error('Bar only support cartesian2d coordinateSystem');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [NaN, NaN];\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            // stack: null\n\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // 0\n            barMinHeight: 0,\n\n            // barMaxWidth: null,\n            // \n            // barWidth: null,\n            // 30%\n            // barGap: '30%',\n            // 20%\n            // barCategoryGap: '20%',\n            // label: {\n            //     normal: {\n            //         show: false\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    // color: ''\n                },\n                emphasis: {}\n            }\n        }\n    });\n\n},{\"../../model/Series\":102,\"../helper/createListFromArray\":19}],8:[function(require,module,exports){\n\n\n\n    var getBarItemStyle = require('../../model/mixin/makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            // Compatitable with 2\n            ['stroke', 'barBorderColor'],\n            ['lineWidth', 'barBorderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n\n},{\"../../model/mixin/makeStyleMapper\":109}],9:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n\n    var helper = {};\n\n    helper.setLabel = function (\n        normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside\n    ) {\n        var labelModel = itemModel.getModel('label.normal');\n        var hoverLabelModel = itemModel.getModel('label.emphasis');\n\n        if (labelModel.get('show')) {\n            setLabel(\n                normalStyle, labelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'normal'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            normalStyle.text = '';\n        }\n\n        if (hoverLabelModel.get('show')) {\n            setLabel(\n                hoverStyle, hoverLabelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'emphasis'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            hoverStyle.text = '';\n        }\n    };\n\n    function setLabel(style, model, color, labelText, labelPositionOutside) {\n        graphic.setText(style, model, color);\n        style.text = labelText;\n        if (style.textPosition === 'outside') {\n            style.textPosition = labelPositionOutside;\n        }\n    }\n\n    module.exports = helper;\n\n},{\"../../util/graphic\":123,\"zrender/lib/core/util\":166}],10:[function(require,module,exports){\n\n    require('./gauge/GaugeSeries');\n    require('./gauge/GaugeView');\n\n},{\"./gauge/GaugeSeries\":11,\"./gauge/GaugeView\":12}],11:[function(require,module,exports){\n\n\n    var List = require('../../data/List');\n    var SeriesModel = require('../../model/Series');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var GaugeSeries = SeriesModel.extend({\n\n        type: 'series.gauge',\n\n        getInitialData: function (option, ecModel) {\n            var list = new List(['value'], this);\n            var dataOpt = option.data || [];\n            if (!zrUtil.isArray(dataOpt)) {\n                dataOpt = [dataOpt];\n            }\n            // Only use the first data item\n            list.initData(dataOpt);\n            return list;\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            // \n            center: ['50%', '50%'],\n            legendHoverLink: true,\n            radius: '75%',\n            startAngle: 225,\n            endAngle: -45,\n            clockwise: true,\n            // \n            min: 0,\n            // \n            max: 100,\n            // 10\n            splitNumber: 10,\n            // \n            axisLine: {\n                // show\n                show: true,\n                lineStyle: {       // lineStyle\n                    color: [[0.2, '#91c7ae'], [0.8, '#63869e'], [1, '#c23531']],\n                    width: 30\n                }\n            },\n            // \n            splitLine: {\n                // show\n                show: true,\n                // length\n                length: 30,\n                // lineStylelineStyle\n                lineStyle: {\n                    color: '#eee',\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            // \n            axisTick: {\n                // show\n                show: true,\n                // split\n                splitNumber: 5,\n                // length\n                length: 8,\n                // lineStyle\n                lineStyle: {\n                    color: '#eee',\n                    width: 1,\n                    type: 'solid'\n                }\n            },\n            axisLabel: {\n                show: true,\n                distance: 5,\n                // formatter: null,\n                textStyle: {       // TEXTSTYLE\n                    color: 'auto'\n                }\n            },\n            pointer: {\n                show: true,\n                length: '80%',\n                width: 8\n            },\n            itemStyle: {\n                normal: {\n                    color: 'auto'\n                }\n            },\n            title: {\n                show: true,\n                // x, ypx\n                offsetCenter: [0, '-40%'],\n                // TEXTSTYLE\n                textStyle: {\n                    color: '#333',\n                    fontSize: 15\n                }\n            },\n            detail: {\n                show: true,\n                backgroundColor: 'rgba(0,0,0,0)',\n                borderWidth: 0,\n                borderColor: '#ccc',\n                width: 100,\n                height: 40,\n                // x, ypx\n                offsetCenter: [0, '40%'],\n                // formatter: null,\n                // TEXTSTYLE\n                textStyle: {\n                    color: 'auto',\n                    fontSize: 30\n                }\n            }\n        }\n    });\n\n    module.exports = GaugeSeries;\n\n},{\"../../data/List\":92,\"../../model/Series\":102,\"zrender/lib/core/util\":166}],12:[function(require,module,exports){\n\n\n    var PointerPath = require('./PointerPath');\n\n    var graphic = require('../../util/graphic');\n    var numberUtil = require('../../util/number');\n    var parsePercent = numberUtil.parsePercent;\n\n    function parsePosition(seriesModel, api) {\n        var center = seriesModel.get('center');\n        var width = api.getWidth();\n        var height = api.getHeight();\n        var size = Math.min(width, height);\n        var cx = parsePercent(center[0], api.getWidth());\n        var cy = parsePercent(center[1], api.getHeight());\n        var r = parsePercent(seriesModel.get('radius'), size / 2);\n\n        return {\n            cx: cx,\n            cy: cy,\n            r: r\n        };\n    }\n\n    function formatLabel(label, labelFormatter) {\n        if (labelFormatter) {\n            if (typeof labelFormatter === 'string') {\n                label = labelFormatter.replace('{value}', label != null ? label : '');\n            }\n            else if (typeof labelFormatter === 'function') {\n                label = labelFormatter(label);\n            }\n        }\n\n        return label;\n    }\n\n    var PI2 = Math.PI * 2;\n\n    var GaugeView = require('../../view/Chart').extend({\n\n        type: 'gauge',\n\n        render: function (seriesModel, ecModel, api) {\n\n            this.group.removeAll();\n\n            var colorList = seriesModel.get('axisLine.lineStyle.color');\n            var posInfo = parsePosition(seriesModel, api);\n\n            this._renderMain(\n                seriesModel, ecModel, api, colorList, posInfo\n            );\n        },\n\n        dispose: function () {},\n\n        _renderMain: function (seriesModel, ecModel, api, colorList, posInfo) {\n            var group = this.group;\n\n            var axisLineModel = seriesModel.getModel('axisLine');\n            var lineStyleModel = axisLineModel.getModel('lineStyle');\n\n            var clockwise = seriesModel.get('clockwise');\n            var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n            var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n\n            var angleRangeSpan = (endAngle - startAngle) % PI2;\n\n            var prevEndAngle = startAngle;\n            var axisLineWidth = lineStyleModel.get('width');\n\n            for (var i = 0; i < colorList.length; i++) {\n                // Clamp\n                var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n                var endAngle = startAngle + angleRangeSpan * percent;\n                var sector = new graphic.Sector({\n                    shape: {\n                        startAngle: prevEndAngle,\n                        endAngle: endAngle,\n                        cx: posInfo.cx,\n                        cy: posInfo.cy,\n                        clockwise: clockwise,\n                        r0: posInfo.r - axisLineWidth,\n                        r: posInfo.r\n                    },\n                    silent: true\n                });\n\n                sector.setStyle({\n                    fill: colorList[i][1]\n                });\n\n                sector.setStyle(lineStyleModel.getLineStyle(\n                    // Because we use sector to simulate arc\n                    // so the properties for stroking are useless\n                    ['color', 'borderWidth', 'borderColor']\n                ));\n\n                group.add(sector);\n\n                prevEndAngle = endAngle;\n            }\n\n            var getColor = function (percent) {\n                // Less than 0\n                if (percent <= 0) {\n                    return colorList[0][1];\n                }\n                for (var i = 0; i < colorList.length; i++) {\n                    if (colorList[i][0] >= percent\n                        && (i === 0 ? 0 : colorList[i - 1][0]) < percent\n                    ) {\n                        return colorList[i][1];\n                    }\n                }\n                // More than 1\n                return colorList[i - 1][1];\n            };\n\n            if (!clockwise) {\n                var tmp = startAngle;\n                startAngle = endAngle;\n                endAngle = tmp;\n            }\n\n            this._renderTicks(\n                seriesModel, ecModel, api, getColor, posInfo,\n                startAngle, endAngle, clockwise\n            );\n\n            this._renderPointer(\n                seriesModel, ecModel, api, getColor, posInfo,\n                startAngle, endAngle, clockwise\n            );\n\n            this._renderTitle(\n                seriesModel, ecModel, api, getColor, posInfo\n            );\n            this._renderDetail(\n                seriesModel, ecModel, api, getColor, posInfo\n            );\n        },\n\n        _renderTicks: function (\n            seriesModel, ecModel, api, getColor, posInfo,\n            startAngle, endAngle, clockwise\n        ) {\n            var group = this.group;\n            var cx = posInfo.cx;\n            var cy = posInfo.cy;\n            var r = posInfo.r;\n\n            var minVal = +seriesModel.get('min');\n            var maxVal = +seriesModel.get('max');\n\n            var splitLineModel = seriesModel.getModel('splitLine');\n            var tickModel = seriesModel.getModel('axisTick');\n            var labelModel = seriesModel.getModel('axisLabel');\n\n            var splitNumber = seriesModel.get('splitNumber');\n            var subSplitNumber = tickModel.get('splitNumber');\n\n            var splitLineLen = parsePercent(\n                splitLineModel.get('length'), r\n            );\n            var tickLen = parsePercent(\n                tickModel.get('length'), r\n            );\n\n            var angle = startAngle;\n            var step = (endAngle - startAngle) / splitNumber;\n            var subStep = step / subSplitNumber;\n\n            var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n            var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n            var textStyleModel = labelModel.getModel('textStyle');\n\n            for (var i = 0; i <= splitNumber; i++) {\n                var unitX = Math.cos(angle);\n                var unitY = Math.sin(angle);\n                // Split line\n                if (splitLineModel.get('show')) {\n                    var splitLine = new graphic.Line({\n                        shape: {\n                            x1: unitX * r + cx,\n                            y1: unitY * r + cy,\n                            x2: unitX * (r - splitLineLen) + cx,\n                            y2: unitY * (r - splitLineLen) + cy\n                        },\n                        style: splitLineStyle,\n                        silent: true\n                    });\n                    if (splitLineStyle.stroke === 'auto') {\n                        splitLine.setStyle({\n                            stroke: getColor(i / splitNumber)\n                        });\n                    }\n\n                    group.add(splitLine);\n                }\n\n                // Label\n                if (labelModel.get('show')) {\n                    var label = formatLabel(\n                        numberUtil.round(i / splitNumber * (maxVal - minVal) + minVal),\n                        labelModel.get('formatter')\n                    );\n                    var distance = labelModel.get('distance');\n\n                    var text = new graphic.Text({\n                        style: {\n                            text: label,\n                            x: unitX * (r - splitLineLen - distance) + cx,\n                            y: unitY * (r - splitLineLen - distance) + cy,\n                            fill: textStyleModel.getTextColor(),\n                            textFont: textStyleModel.getFont(),\n                            textVerticalAlign: unitY < -0.4 ? 'top' : (unitY > 0.4 ? 'bottom' : 'middle'),\n                            textAlign: unitX < -0.4 ? 'left' : (unitX > 0.4 ? 'right' : 'center')\n                        },\n                        silent: true\n                    });\n                    if (text.style.fill === 'auto') {\n                        text.setStyle({\n                            fill: getColor(i / splitNumber)\n                        });\n                    }\n\n                    group.add(text);\n                }\n\n                // Axis tick\n                if (tickModel.get('show') && i !== splitNumber) {\n                    for (var j = 0; j <= subSplitNumber; j++) {\n                        var unitX = Math.cos(angle);\n                        var unitY = Math.sin(angle);\n                        var tickLine = new graphic.Line({\n                            shape: {\n                                x1: unitX * r + cx,\n                                y1: unitY * r + cy,\n                                x2: unitX * (r - tickLen) + cx,\n                                y2: unitY * (r - tickLen) + cy\n                            },\n                            silent: true,\n                            style: tickLineStyle\n                        });\n\n                        if (tickLineStyle.stroke === 'auto') {\n                            tickLine.setStyle({\n                                stroke: getColor((i + j / subSplitNumber) / splitNumber)\n                            });\n                        }\n\n                        group.add(tickLine);\n                        angle += subStep;\n                    }\n                    angle -= subStep;\n                }\n                else {\n                    angle += step;\n                }\n            }\n        },\n\n        _renderPointer: function (\n            seriesModel, ecModel, api, getColor, posInfo,\n            startAngle, endAngle, clockwise\n        ) {\n\n            var group = this.group;\n            var oldData = this._data;\n\n            if (!seriesModel.get('pointer.show')) {\n                // Remove old element\n                oldData.eachItemGraphicEl(function (el) {\n                    group.remove(el);\n                });\n                return;\n            }\n\n            var valueExtent = [+seriesModel.get('min'), +seriesModel.get('max')];\n            var angleExtent = [startAngle, endAngle];\n\n            var data = seriesModel.getData();\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var pointer = new PointerPath({\n                        shape: {\n                            angle: startAngle\n                        }\n                    });\n\n                    graphic.updateProps(pointer, {\n                        shape: {\n                            angle: numberUtil.linearMap(data.get('value', idx), valueExtent, angleExtent, true)\n                        }\n                    }, seriesModel);\n\n                    group.add(pointer);\n                    data.setItemGraphicEl(idx, pointer);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var pointer = oldData.getItemGraphicEl(oldIdx);\n\n                    graphic.updateProps(pointer, {\n                        shape: {\n                            angle: numberUtil.linearMap(data.get('value', newIdx), valueExtent, angleExtent, true)\n                        }\n                    }, seriesModel);\n\n                    group.add(pointer);\n                    data.setItemGraphicEl(newIdx, pointer);\n                })\n                .remove(function (idx) {\n                    var pointer = oldData.getItemGraphicEl(idx);\n                    group.remove(pointer);\n                })\n                .execute();\n\n            data.eachItemGraphicEl(function (pointer, idx) {\n                var itemModel = data.getItemModel(idx);\n                var pointerModel = itemModel.getModel('pointer');\n\n                pointer.setShape({\n                    x: posInfo.cx,\n                    y: posInfo.cy,\n                    width: parsePercent(\n                        pointerModel.get('width'), posInfo.r\n                    ),\n                    r: parsePercent(pointerModel.get('length'), posInfo.r)\n                });\n\n                pointer.useStyle(itemModel.getModel('itemStyle.normal').getItemStyle());\n\n                if (pointer.style.fill === 'auto') {\n                    pointer.setStyle('fill', getColor(\n                        (data.get('value', idx) - valueExtent[0]) / (valueExtent[1] - valueExtent[0])\n                    ));\n                }\n\n                graphic.setHoverStyle(\n                    pointer, itemModel.getModel('itemStyle.emphasis').getItemStyle()\n                );\n            });\n\n            this._data = data;\n        },\n\n        _renderTitle: function (\n            seriesModel, ecModel, api, getColor, posInfo\n        ) {\n            var titleModel = seriesModel.getModel('title');\n            if (titleModel.get('show')) {\n                var textStyleModel = titleModel.getModel('textStyle');\n                var offsetCenter = titleModel.get('offsetCenter');\n                var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);\n                var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);\n                var text = new graphic.Text({\n                    style: {\n                        x: x,\n                        y: y,\n                        // FIXME First data name ?\n                        text: seriesModel.getData().getName(0),\n                        fill: textStyleModel.getTextColor(),\n                        textFont: textStyleModel.getFont(),\n                        textAlign: 'center',\n                        textVerticalAlign: 'middle'\n                    }\n                });\n                this.group.add(text);\n            }\n        },\n\n        _renderDetail: function (\n            seriesModel, ecModel, api, getColor, posInfo\n        ) {\n            var detailModel = seriesModel.getModel('detail');\n            var minVal = +seriesModel.get('min');\n            var maxVal = +seriesModel.get('max');\n            if (detailModel.get('show')) {\n                var textStyleModel = detailModel.getModel('textStyle');\n                var offsetCenter = detailModel.get('offsetCenter');\n                var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);\n                var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);\n                var width = parsePercent(detailModel.get('width'), posInfo.r);\n                var height = parsePercent(detailModel.get('height'), posInfo.r);\n                var value = seriesModel.getData().get('value', 0);\n                var rect = new graphic.Rect({\n                    shape: {\n                        x: x - width / 2,\n                        y: y - height / 2,\n                        width: width,\n                        height: height\n                    },\n                    style: {\n                        text: formatLabel(\n                            // FIXME First data name ?\n                            value, detailModel.get('formatter')\n                        ),\n                        fill: detailModel.get('backgroundColor'),\n                        textFill: textStyleModel.getTextColor(),\n                        textFont: textStyleModel.getFont()\n                    }\n                });\n                if (rect.style.textFill === 'auto') {\n                    rect.setStyle('textFill', getColor(\n                        numberUtil.linearMap(value, [minVal, maxVal], [0, 1], true)\n                    ));\n                }\n                rect.setStyle(detailModel.getItemStyle(['color']));\n                this.group.add(rect);\n            }\n        }\n    });\n\n    module.exports = GaugeView;\n\n},{\"../../util/graphic\":123,\"../../util/number\":126,\"../../view/Chart\":129,\"./PointerPath\":13}],13:[function(require,module,exports){\n\n\n    module.exports = require('zrender/lib/graphic/Path').extend({\n\n        type: 'echartsGaugePointer',\n\n        shape: {\n            angle: 0,\n\n            width: 10,\n\n            r: 10,\n\n            x: 0,\n\n            y: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var mathCos = Math.cos;\n            var mathSin = Math.sin;\n\n            var r = shape.r;\n            var width = shape.width;\n            var angle = shape.angle;\n            var x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2);\n            var y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2);\n\n            angle = shape.angle - Math.PI / 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(\n                shape.x + mathCos(angle) * width,\n                shape.y + mathSin(angle) * width\n            );\n            ctx.lineTo(\n                shape.x + mathCos(shape.angle) * r,\n                shape.y + mathSin(shape.angle) * r\n            );\n            ctx.lineTo(\n                shape.x - mathCos(angle) * width,\n                shape.y - mathSin(angle) * width\n            );\n            ctx.lineTo(x, y);\n            return;\n        }\n    });\n\n},{\"zrender/lib/graphic/Path\":174}],14:[function(require,module,exports){\n/**\n * @module echarts/chart/helper/Line\n */\n\n\n    var symbolUtil = require('../../util/symbol');\n    var vector = require('zrender/lib/core/vector');\n    // var matrix = require('zrender/lib/core/matrix');\n    var LinePath = require('./LinePath');\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../../util/number');\n\n    var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];\n    function makeSymbolTypeKey(symbolCategory) {\n        return '_' + symbolCategory + 'Type';\n    }\n    /**\n     * @inner\n     */\n    function createSymbol(name, lineData, idx) {\n        var color = lineData.getItemVisual(idx, 'color');\n        var symbolType = lineData.getItemVisual(idx, name);\n        var symbolSize = lineData.getItemVisual(idx, name + 'Size');\n\n        if (!symbolType || symbolType === 'none') {\n            return;\n        }\n\n        if (!zrUtil.isArray(symbolSize)) {\n            symbolSize = [symbolSize, symbolSize];\n        }\n        var symbolPath = symbolUtil.createSymbol(\n            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\n            symbolSize[0], symbolSize[1], color\n        );\n\n        symbolPath.name = name;\n\n        return symbolPath;\n    }\n\n    function createLine(points) {\n        var line = new LinePath({\n            name: 'line'\n        });\n        setLinePoints(line.shape, points);\n        return line;\n    }\n\n    function setLinePoints(targetShape, points) {\n        var p1 = points[0];\n        var p2 = points[1];\n        var cp1 = points[2];\n        targetShape.x1 = p1[0];\n        targetShape.y1 = p1[1];\n        targetShape.x2 = p2[0];\n        targetShape.y2 = p2[1];\n        targetShape.percent = 1;\n\n        if (cp1) {\n            targetShape.cpx1 = cp1[0];\n            targetShape.cpy1 = cp1[1];\n        }\n        else {\n            targetShape.cpx1 = NaN;\n            targetShape.cpy1 = NaN;\n        }\n    }\n\n    function updateSymbolAndLabelBeforeLineUpdate () {\n        var lineGroup = this;\n        var symbolFrom = lineGroup.childOfName('fromSymbol');\n        var symbolTo = lineGroup.childOfName('toSymbol');\n        var label = lineGroup.childOfName('label');\n        // Quick reject\n        if (!symbolFrom && !symbolTo && label.ignore) {\n            return;\n        }\n\n        var invScale = 1;\n        var parentNode = this.parent;\n        while (parentNode) {\n            if (parentNode.scale) {\n                invScale /= parentNode.scale[0];\n            }\n            parentNode = parentNode.parent;\n        }\n\n        var line = lineGroup.childOfName('line');\n        // If line not changed\n        // FIXME Parent scale changed\n        if (!this.__dirty && !line.__dirty) {\n            return;\n        }\n\n        var percent = line.shape.percent;\n        var fromPos = line.pointAt(0);\n        var toPos = line.pointAt(percent);\n\n        var d = vector.sub([], toPos, fromPos);\n        vector.normalize(d, d);\n\n        if (symbolFrom) {\n            symbolFrom.attr('position', fromPos);\n            var tangent = line.tangentAt(0);\n            symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(\n                tangent[1], tangent[0]\n            ));\n            symbolFrom.attr('scale', [invScale * percent, invScale * percent]);\n        }\n        if (symbolTo) {\n            symbolTo.attr('position', toPos);\n            var tangent = line.tangentAt(1);\n            symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(\n                tangent[1], tangent[0]\n            ));\n            symbolTo.attr('scale', [invScale * percent, invScale * percent]);\n        }\n\n        if (!label.ignore) {\n            label.attr('position', toPos);\n\n            var textPosition;\n            var textAlign;\n            var textVerticalAlign;\n\n            var distance = 5 * invScale;\n            // End\n            if (label.__position === 'end') {\n                textPosition = [d[0] * distance + toPos[0], d[1] * distance + toPos[1]];\n                textAlign = d[0] > 0.8 ? 'left' : (d[0] < -0.8 ? 'right' : 'center');\n                textVerticalAlign = d[1] > 0.8 ? 'top' : (d[1] < -0.8 ? 'bottom' : 'middle');\n            }\n            // Middle\n            else if (label.__position === 'middle') {\n                var halfPercent = percent / 2;\n                var tangent = line.tangentAt(halfPercent);\n                var n = [tangent[1], -tangent[0]];\n                var cp = line.pointAt(halfPercent);\n                if (n[1] > 0) {\n                    n[0] = -n[0];\n                    n[1] = -n[1];\n                }\n                textPosition = [cp[0] + n[0] * distance, cp[1] + n[1] * distance];\n                textAlign = 'center';\n                textVerticalAlign = 'bottom';\n                var rotation = -Math.atan2(tangent[1], tangent[0]);\n                if (toPos[0] < fromPos[0]) {\n                    rotation = Math.PI + rotation;\n                }\n                label.attr('rotation', rotation);\n            }\n            // Start\n            else {\n                textPosition = [-d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1]];\n                textAlign = d[0] > 0.8 ? 'right' : (d[0] < -0.8 ? 'left' : 'center');\n                textVerticalAlign = d[1] > 0.8 ? 'bottom' : (d[1] < -0.8 ? 'top' : 'middle');\n            }\n            label.attr({\n                style: {\n                    // Use the user specified text align and baseline first\n                    textVerticalAlign: label.__verticalAlign || textVerticalAlign,\n                    textAlign: label.__textAlign || textAlign\n                },\n                position: textPosition,\n                scale: [invScale, invScale]\n            });\n        }\n    }\n\n    /**\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     * @alias {module:echarts/chart/helper/Line}\n     */\n    function Line(lineData, idx, seriesScope) {\n        graphic.Group.call(this);\n\n        this._createLine(lineData, idx, seriesScope);\n    }\n\n    var lineProto = Line.prototype;\n\n    // Update symbol position and rotation\n    lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;\n\n    lineProto._createLine = function (lineData, idx, seriesScope) {\n        var seriesModel = lineData.hostModel;\n        var linePoints = lineData.getItemLayout(idx);\n\n        var line = createLine(linePoints);\n        line.shape.percent = 0;\n        graphic.initProps(line, {\n            shape: {\n                percent: 1\n            }\n        }, seriesModel, idx);\n\n        this.add(line);\n\n        var label = new graphic.Text({\n            name: 'label'\n        });\n        this.add(label);\n\n        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n            var symbol = createSymbol(symbolCategory, lineData, idx);\n            // symbols must added after line to make sure\n            // it will be updated after line#update.\n            // Or symbol position and rotation update in line#beforeUpdate will be one frame slow\n            this.add(symbol);\n            this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);\n        }, this);\n\n        this._updateCommonStl(lineData, idx, seriesScope);\n    };\n\n    lineProto.updateData = function (lineData, idx, seriesScope) {\n        var seriesModel = lineData.hostModel;\n\n        var line = this.childOfName('line');\n        var linePoints = lineData.getItemLayout(idx);\n        var target = {\n            shape: {}\n        };\n        setLinePoints(target.shape, linePoints);\n        graphic.updateProps(line, target, seriesModel, idx);\n\n        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n            var symbolType = lineData.getItemVisual(idx, symbolCategory);\n            var key = makeSymbolTypeKey(symbolCategory);\n            // Symbol changed\n            if (this[key] !== symbolType) {\n                this.remove(this.childOfName(symbolCategory));\n                var symbol = createSymbol(symbolCategory, lineData, idx);\n                this.add(symbol);\n            }\n            this[key] = symbolType;\n        }, this);\n\n        this._updateCommonStl(lineData, idx, seriesScope);\n    };\n\n    lineProto._updateCommonStl = function (lineData, idx, seriesScope) {\n        var seriesModel = lineData.hostModel;\n\n        var line = this.childOfName('line');\n\n        var lineStyle = seriesScope && seriesScope.lineStyle;\n        var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;\n        var labelModel = seriesScope && seriesScope.labelModel;\n        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n\n        // Optimization for large dataset\n        if (!seriesScope || lineData.hasItemOption) {\n            var itemModel = lineData.getItemModel(idx);\n\n            lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle();\n            hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n\n            labelModel = itemModel.getModel('label.normal');\n            hoverLabelModel = itemModel.getModel('label.emphasis');\n        }\n\n        var visualColor = lineData.getItemVisual(idx, 'color');\n        var visualOpacity = zrUtil.retrieve(\n            lineData.getItemVisual(idx, 'opacity'),\n            lineStyle.opacity,\n            1\n        );\n\n        line.useStyle(zrUtil.defaults(\n            {\n                strokeNoScale: true,\n                fill: 'none',\n                stroke: visualColor,\n                opacity: visualOpacity\n            },\n            lineStyle\n        ));\n        line.hoverStyle = hoverLineStyle;\n\n        // Update symbol\n        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n            var symbol = this.childOfName(symbolCategory);\n            if (symbol) {\n                symbol.setColor(visualColor);\n                symbol.setStyle({\n                    opacity: visualOpacity\n                });\n            }\n        }, this);\n\n        var showLabel = labelModel.getShallow('show');\n        var hoverShowLabel = hoverLabelModel.getShallow('show');\n\n        var label = this.childOfName('label');\n        var defaultLabelColor;\n        var defaultText;\n\n        if (showLabel || hoverShowLabel) {\n            var rawVal = seriesModel.getRawValue(idx);\n            defaultText = rawVal == null\n                ? defaultText = lineData.getName(idx)\n                : isFinite(rawVal)\n                ? numberUtil.round(rawVal)\n                : rawVal;\n            defaultLabelColor = visualColor || '#000';\n        }\n\n        // label.afterUpdate = lineAfterUpdate;\n        if (showLabel) {\n            var textStyleModel = labelModel.getModel('textStyle');\n            label.setStyle({\n                text: zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType),\n                    defaultText\n                ),\n                textFont: textStyleModel.getFont(),\n                fill: textStyleModel.getTextColor() || defaultLabelColor\n            });\n\n            label.__textAlign = textStyleModel.get('align');\n            label.__verticalAlign = textStyleModel.get('baseline');\n            label.__position = labelModel.get('position');\n        }\n        else {\n            label.setStyle('text', '');\n        }\n        if (hoverShowLabel) {\n            var textStyleHoverModel = hoverLabelModel.getModel('textStyle');\n\n            label.hoverStyle = {\n                text: zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType),\n                    defaultText\n                ),\n                textFont: textStyleHoverModel.getFont(),\n                fill: textStyleHoverModel.getTextColor() || defaultLabelColor\n            };\n        }\n        else {\n            label.hoverStyle = {\n                text: ''\n            };\n        }\n\n        label.ignore = !showLabel && !hoverShowLabel;\n\n        graphic.setHoverStyle(this);\n    };\n\n    lineProto.updateLayout = function (lineData, idx) {\n        this.setLinePoints(lineData.getItemLayout(idx));\n    };\n\n    lineProto.setLinePoints = function (points) {\n        var linePath = this.childOfName('line');\n        setLinePoints(linePath.shape, points);\n        linePath.dirty();\n    };\n\n    zrUtil.inherits(Line, graphic.Group);\n\n    module.exports = Line;\n\n},{\"../../util/graphic\":123,\"../../util/number\":126,\"../../util/symbol\":127,\"./LinePath\":16,\"zrender/lib/core/util\":166,\"zrender/lib/core/vector\":167}],15:[function(require,module,exports){\n/**\n * @module echarts/chart/helper/LineDraw\n */\n\n\n    var graphic = require('../../util/graphic');\n    var LineGroup = require('./Line');\n\n\n    function isPointNaN(pt) {\n        return isNaN(pt[0]) || isNaN(pt[1]);\n    }\n    function lineNeedsDraw(pts) {\n        return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);\n    }\n    /**\n     * @alias module:echarts/component/marker/LineDraw\n     * @constructor\n     */\n    function LineDraw(ctor) {\n        this._ctor = ctor || LineGroup;\n        this.group = new graphic.Group();\n    }\n\n    var lineDrawProto = LineDraw.prototype;\n\n    /**\n     * @param {module:echarts/data/List} lineData\n     */\n    lineDrawProto.updateData = function (lineData) {\n\n        var oldLineData = this._lineData;\n        var group = this.group;\n        var LineCtor = this._ctor;\n\n        var hostModel = lineData.hostModel;\n\n        var seriesScope = {\n            lineStyle: hostModel.getModel('lineStyle.normal').getLineStyle(),\n            hoverLineStyle: hostModel.getModel('lineStyle.emphasis').getLineStyle(),\n            labelModel: hostModel.getModel('label.normal'),\n            hoverLabelModel: hostModel.getModel('label.emphasis')\n        };\n\n        lineData.diff(oldLineData)\n            .add(function (idx) {\n                if (!lineNeedsDraw(lineData.getItemLayout(idx))) {\n                    return;\n                }\n                var lineGroup = new LineCtor(lineData, idx, seriesScope);\n\n                lineData.setItemGraphicEl(idx, lineGroup);\n\n                group.add(lineGroup);\n            })\n            .update(function (newIdx, oldIdx) {\n                var lineGroup = oldLineData.getItemGraphicEl(oldIdx);\n                if (!lineNeedsDraw(lineData.getItemLayout(newIdx))) {\n                    group.remove(lineGroup);\n                    return;\n                }\n\n                if (!lineGroup) {\n                    lineGroup = new LineCtor(lineData, newIdx, seriesScope);\n                }\n                else {\n                    lineGroup.updateData(lineData, newIdx, seriesScope);\n                }\n\n                lineData.setItemGraphicEl(newIdx, lineGroup);\n\n                group.add(lineGroup);\n            })\n            .remove(function (idx) {\n                group.remove(oldLineData.getItemGraphicEl(idx));\n            })\n            .execute();\n\n        this._lineData = lineData;\n    };\n\n    lineDrawProto.updateLayout = function () {\n        var lineData = this._lineData;\n        lineData.eachItemGraphicEl(function (el, idx) {\n            el.updateLayout(lineData, idx);\n        }, this);\n    };\n\n    lineDrawProto.remove = function () {\n        this.group.removeAll();\n    };\n\n    module.exports = LineDraw;\n\n},{\"../../util/graphic\":123,\"./Line\":14}],16:[function(require,module,exports){\n/**\n * Line path for bezier and straight line draw\n */\n\n    var graphic = require('../../util/graphic');\n    var vec2 = require('zrender/lib/core/vector');\n\n    var straightLineProto = graphic.Line.prototype;\n    var bezierCurveProto = graphic.BezierCurve.prototype;\n\n    function isLine(shape) {\n        return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);\n    }\n\n    module.exports = graphic.extendShape({\n\n        type: 'ec-line',\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            percent: 1,\n            cpx1: null,\n            cpy1: null\n        },\n\n        buildPath: function (ctx, shape) {\n            (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);\n        },\n\n        pointAt: function (t) {\n            return isLine(this.shape)\n                ? straightLineProto.pointAt.call(this, t)\n                : bezierCurveProto.pointAt.call(this, t);\n        },\n\n        tangentAt: function (t) {\n            var shape = this.shape;\n            var p = isLine(shape)\n                ? [shape.x2 - shape.x1, shape.y2 - shape.y1]\n                : bezierCurveProto.tangentAt.call(this, t);\n            return vec2.normalize(p, p);\n        }\n    });\n\n},{\"../../util/graphic\":123,\"zrender/lib/core/vector\":167}],17:[function(require,module,exports){\n/**\n * @module echarts/chart/helper/Symbol\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolUtil = require('../../util/symbol');\n    var graphic = require('../../util/graphic');\n    var numberUtil = require('../../util/number');\n\n    function getSymbolSize(data, idx) {\n        var symbolSize = data.getItemVisual(idx, 'symbolSize');\n        return symbolSize instanceof Array\n            ? symbolSize.slice()\n            : [+symbolSize, +symbolSize];\n    }\n\n    function getScale(symbolSize) {\n        return [symbolSize[0] / 2, symbolSize[1] / 2];\n    }\n\n    /**\n     * @constructor\n     * @alias {module:echarts/chart/helper/Symbol}\n     * @param {module:echarts/data/List} data\n     * @param {number} idx\n     * @extends {module:zrender/graphic/Group}\n     */\n    function Symbol(data, idx, seriesScope) {\n        graphic.Group.call(this);\n\n        this.updateData(data, idx, seriesScope);\n    }\n\n    var symbolProto = Symbol.prototype;\n\n    function driftSymbol(dx, dy) {\n        this.parent.drift(dx, dy);\n    }\n\n    symbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n        // Remove paths created before\n        this.removeAll();\n\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // var symbolPath = symbolUtil.createSymbol(\n        //     symbolType, -0.5, -0.5, 1, 1, color\n        // );\n        // If width/height are set too small (e.g., set to 1) on ios10\n        // and macOS Sierra, a circle stroke become a rect, no matter what\n        // the scale is set. So we set width/height as 2. See #4150.\n        var symbolPath = symbolUtil.createSymbol(\n            symbolType, -1, -1, 2, 2, color\n        );\n\n        symbolPath.attr({\n            z2: 100,\n            culling: true,\n            scale: [0, 0]\n        });\n        // Rewrite drift method\n        symbolPath.drift = driftSymbol;\n\n        graphic.initProps(symbolPath, {\n            scale: getScale(symbolSize)\n        }, seriesModel, idx);\n        this._symbolType = symbolType;\n\n        this.add(symbolPath);\n    };\n\n    /**\n     * Stop animation\n     * @param {boolean} toLastFrame\n     */\n    symbolProto.stopSymbolAnimation = function (toLastFrame) {\n        this.childAt(0).stopAnimation(toLastFrame);\n    };\n\n    /**\n     * Get symbol path element\n     */\n    symbolProto.getSymbolPath = function () {\n        return this.childAt(0);\n    };\n\n    /**\n     * Get scale(aka, current symbol size).\n     * Including the change caused by animation\n     */\n    symbolProto.getScale = function () {\n        return this.childAt(0).scale;\n    };\n\n    /**\n     * Highlight symbol\n     */\n    symbolProto.highlight = function () {\n        this.childAt(0).trigger('emphasis');\n    };\n\n    /**\n     * Downplay symbol\n     */\n    symbolProto.downplay = function () {\n        this.childAt(0).trigger('normal');\n    };\n\n    /**\n     * @param {number} zlevel\n     * @param {number} z\n     */\n    symbolProto.setZ = function (zlevel, z) {\n        var symbolPath = this.childAt(0);\n        symbolPath.zlevel = zlevel;\n        symbolPath.z = z;\n    };\n\n    symbolProto.setDraggable = function (draggable) {\n        var symbolPath = this.childAt(0);\n        symbolPath.draggable = draggable;\n        symbolPath.cursor = draggable ? 'move' : 'pointer';\n    };\n\n    /**\n     * Update symbol properties\n     * @param  {module:echarts/data/List} data\n     * @param  {number} idx\n     */\n    symbolProto.updateData = function (data, idx, seriesScope) {\n        this.silent = false;\n\n        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n        var seriesModel = data.hostModel;\n        var symbolSize = getSymbolSize(data, idx);\n\n        if (symbolType !== this._symbolType) {\n            this._createSymbol(symbolType, data, idx, symbolSize);\n        }\n        else {\n            var symbolPath = this.childAt(0);\n            graphic.updateProps(symbolPath, {\n                scale: getScale(symbolSize)\n            }, seriesModel, idx);\n        }\n        this._updateCommon(data, idx, symbolSize, seriesScope);\n        this._seriesModel = seriesModel;\n    };\n\n    // Update common properties\n    var normalStyleAccessPath = ['itemStyle', 'normal'];\n    var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\n    var normalLabelAccessPath = ['label', 'normal'];\n    var emphasisLabelAccessPath = ['label', 'emphasis'];\n\n    symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n        var symbolPath = this.childAt(0);\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // Reset style\n        if (symbolPath.type !== 'image') {\n            symbolPath.useStyle({\n                strokeNoScale: true\n            });\n        }\n\n        seriesScope = seriesScope || null;\n\n        var itemStyle = seriesScope && seriesScope.itemStyle;\n        var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n        var symbolRotate = seriesScope && seriesScope.symbolRotate;\n        var symbolOffset = seriesScope && seriesScope.symbolOffset;\n        var labelModel = seriesScope && seriesScope.labelModel;\n        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n        var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n\n        if (!seriesScope || data.hasItemOption) {\n            var itemModel = data.getItemModel(idx);\n\n            // Color must be excluded.\n            // Because symbol provide setColor individually to set fill and stroke\n            itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n            hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n\n            symbolRotate = itemModel.getShallow('symbolRotate');\n            symbolOffset = itemModel.getShallow('symbolOffset');\n\n            labelModel = itemModel.getModel(normalLabelAccessPath);\n            hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n            hoverAnimation = itemModel.getShallow('hoverAnimation');\n        }\n        else {\n            hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n        }\n\n        var elStyle = symbolPath.style;\n\n        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n        if (symbolOffset) {\n            symbolPath.attr('position', [\n                numberUtil.parsePercent(symbolOffset[0], symbolSize[0]),\n                numberUtil.parsePercent(symbolOffset[1], symbolSize[1])\n            ]);\n        }\n\n        // PENDING setColor before setStyle!!!\n        symbolPath.setColor(color);\n\n        symbolPath.setStyle(itemStyle);\n\n        var opacity = data.getItemVisual(idx, 'opacity');\n        if (opacity != null) {\n            elStyle.opacity = opacity;\n        }\n\n        // Get last value dim\n        var dimensions = data.dimensions.slice();\n        var valueDim;\n        var dataType;\n        while (dimensions.length && (\n            valueDim = dimensions.pop(),\n            dataType = data.getDimensionInfo(valueDim).type,\n            dataType === 'ordinal' || dataType === 'time'\n        )) {} // jshint ignore:line\n\n        if (valueDim != null && labelModel.getShallow('show')) {\n            graphic.setText(elStyle, labelModel, color);\n            elStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(idx, 'normal'),\n                data.get(valueDim, idx)\n            );\n        }\n        else {\n            elStyle.text = '';\n        }\n\n        if (valueDim != null && hoverLabelModel.getShallow('show')) {\n            graphic.setText(hoverItemStyle, hoverLabelModel, color);\n            hoverItemStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(idx, 'emphasis'),\n                data.get(valueDim, idx)\n            );\n        }\n        else {\n            hoverItemStyle.text = '';\n        }\n\n        symbolPath.off('mouseover')\n            .off('mouseout')\n            .off('emphasis')\n            .off('normal');\n\n        symbolPath.hoverStyle = hoverItemStyle;\n\n        graphic.setHoverStyle(symbolPath);\n\n        var scale = getScale(symbolSize);\n\n        if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n            var onEmphasis = function() {\n                var ratio = scale[1] / scale[0];\n                this.animateTo({\n                    scale: [\n                        Math.max(scale[0] * 1.1, scale[0] + 3),\n                        Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)\n                    ]\n                }, 400, 'elasticOut');\n            };\n            var onNormal = function() {\n                this.animateTo({\n                    scale: scale\n                }, 400, 'elasticOut');\n            };\n            symbolPath.on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n    };\n\n    symbolProto.fadeOut = function (cb) {\n        var symbolPath = this.childAt(0);\n        // Avoid mistaken hover when fading out\n        this.silent = true;\n        // Not show text when animating\n        symbolPath.style.text = '';\n        graphic.updateProps(symbolPath, {\n            scale: [0, 0]\n        }, this._seriesModel, this.dataIndex, cb);\n    };\n\n    zrUtil.inherits(Symbol, graphic.Group);\n\n    module.exports = Symbol;\n\n},{\"../../util/graphic\":123,\"../../util/number\":126,\"../../util/symbol\":127,\"zrender/lib/core/util\":166}],18:[function(require,module,exports){\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n\n    var graphic = require('../../util/graphic');\n    var Symbol = require('./Symbol');\n\n    /**\n     * @constructor\n     * @alias module:echarts/chart/helper/SymbolDraw\n     * @param {module:zrender/graphic/Group} [symbolCtor]\n     */\n    function SymbolDraw(symbolCtor) {\n        this.group = new graphic.Group();\n\n        this._symbolCtor = symbolCtor || Symbol;\n    }\n\n    var symbolDrawProto = SymbolDraw.prototype;\n\n    function symbolNeedsDraw(data, idx, isIgnore) {\n        var point = data.getItemLayout(idx);\n        // Is an object\n        // if (point && point.hasOwnProperty('point')) {\n        //     point = point.point;\n        // }\n        return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx))\n                    && data.getItemVisual(idx, 'symbol') !== 'none';\n    }\n    /**\n     * Update symbols draw by new data\n     * @param {module:echarts/data/List} data\n     * @param {Array.<boolean>} [isIgnore]\n     */\n    symbolDrawProto.updateData = function (data, isIgnore) {\n        var group = this.group;\n        var seriesModel = data.hostModel;\n        var oldData = this._data;\n\n        var SymbolCtor = this._symbolCtor;\n\n        var seriesScope = {\n            itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n            hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n            symbolRotate: seriesModel.get('symbolRotate'),\n            symbolOffset: seriesModel.get('symbolOffset'),\n            hoverAnimation: seriesModel.get('hoverAnimation'),\n\n            labelModel: seriesModel.getModel('label.normal'),\n            hoverLabelModel: seriesModel.getModel('label.emphasis')\n        };\n\n        data.diff(oldData)\n            .add(function (newIdx) {\n                var point = data.getItemLayout(newIdx);\n                if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n                    symbolEl.attr('position', point);\n                    data.setItemGraphicEl(newIdx, symbolEl);\n                    group.add(symbolEl);\n                }\n            })\n            .update(function (newIdx, oldIdx) {\n                var symbolEl = oldData.getItemGraphicEl(oldIdx);\n                var point = data.getItemLayout(newIdx);\n                if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    group.remove(symbolEl);\n                    return;\n                }\n                if (!symbolEl) {\n                    symbolEl = new SymbolCtor(data, newIdx);\n                    symbolEl.attr('position', point);\n                }\n                else {\n                    symbolEl.updateData(data, newIdx, seriesScope);\n                    graphic.updateProps(symbolEl, {\n                        position: point\n                    }, seriesModel);\n                }\n\n                // Add back\n                group.add(symbolEl);\n\n                data.setItemGraphicEl(newIdx, symbolEl);\n            })\n            .remove(function (oldIdx) {\n                var el = oldData.getItemGraphicEl(oldIdx);\n                el && el.fadeOut(function () {\n                    group.remove(el);\n                });\n            })\n            .execute();\n\n        this._data = data;\n    };\n\n    symbolDrawProto.updateLayout = function () {\n        var data = this._data;\n        if (data) {\n            // Not use animation\n            data.eachItemGraphicEl(function (el, idx) {\n                var point = data.getItemLayout(idx);\n                el.attr('position', point);\n            });\n        }\n    };\n\n    symbolDrawProto.remove = function (enableAnimation) {\n        var group = this.group;\n        var data = this._data;\n        if (data) {\n            if (enableAnimation) {\n                data.eachItemGraphicEl(function (el) {\n                    el.fadeOut(function () {\n                        group.remove(el);\n                    });\n                });\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    };\n\n    module.exports = SymbolDraw;\n\n},{\"../../util/graphic\":123,\"./Symbol\":17}],19:[function(require,module,exports){\n'use strict';\n\n\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var CoordinateSystem = require('../../CoordinateSystem');\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && registeredCoordSys.dimensions) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n        }\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            completeDimensions(dimensions, data, ['x', 'y', 'z']);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        singleAxis: function (data, seriesModel, ecModel) {\n\n            var singleAxisModel = ecModel.queryComponents({\n                mainType: 'singleAxis',\n                index: seriesModel.get('singleAxisIndex'),\n                id: seriesModel.get('singleAxisId')\n            })[0];\n\n            if (__DEV__) {\n                if (!singleAxisModel) {\n                    throw new Error('singleAxis should be specified.');\n                }\n            }\n\n            var singleAxisType = singleAxisModel.get('type');\n            var isCategory = singleAxisType === 'category';\n\n            var dimensions = [{\n                name: 'single',\n                type: getDimTypeByAxis(singleAxisType),\n                stackable: isStackable(singleAxisType)\n            }];\n\n            completeDimensions(dimensions, data);\n\n            var categoryAxesModels = {};\n            if (isCategory) {\n                categoryAxesModels.single = singleAxisModel;\n            }\n\n            return {\n                dimensions: dimensions,\n                categoryIndex: isCategory ? 0 : -1,\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            completeDimensions(dimensions, data, ['radius', 'angle', 'value']);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel) {\n            // TODO Region\n            // \n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, ['lng', 'lat', 'value'])\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n},{\"../../CoordinateSystem\":1,\"../../data/List\":92,\"../../data/helper/completeDimensions\":93,\"../../util/model\":125,\"zrender/lib/core/util\":166}],20:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n    var PRIORITY = echarts.PRIORITY;\n\n    require('./line/LineSeries');\n    require('./line/LineView');\n\n    echarts.registerVisual(zrUtil.curry(\n        require('../visual/symbol'), 'line', 'circle', 'line'\n    ));\n    echarts.registerLayout(zrUtil.curry(\n        require('../layout/points'), 'line'\n    ));\n\n    // Down sample after filter\n    echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(\n        require('../processor/dataSample'), 'line'\n    ));\n\n    // In case developer forget to include grid component\n    require('../component/grid');\n\n},{\"../component/grid\":49,\"../echarts\":94,\"../layout/points\":96,\"../processor/dataSample\":114,\"../visual/symbol\":133,\"./line/LineSeries\":21,\"./line/LineView\":22,\"zrender/lib/core/util\":166}],21:[function(require,module,exports){\n'use strict';\n\n\n    var createListFromArray = require('../helper/createListFromArray');\n    var SeriesModel = require('../../model/Series');\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.line',\n\n        dependencies: ['grid', 'polar'],\n\n        getInitialData: function (option, ecModel) {\n            if (__DEV__) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {\n                    throw new Error('Line not support coordinateSystem besides cartesian and polar');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // stack: null\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // polarIndex: 0,\n\n            // If clip the overflow value\n            clipOverflow: true,\n\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // itemStyle: {\n            //     normal: {},\n            //     emphasis: {}\n            // },\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            // areaStyle: {},\n            // false, 'start', 'end', 'middle'\n            step: false,\n\n            // Disabled if step is true\n            smooth: false,\n            smoothMonotone: null,\n            // \n            symbol: 'emptyCircle',\n            // \n            symbolSize: 4,\n            // \n            symbolRotate: null,\n\n            //  symbol,  tooltip hover \n            showSymbol: true,\n            // \n            showAllSymbol: false,\n\n            // \n            connectNulls: false,\n\n            // 'average', 'max', 'min', 'sum'\n            sampling: 'none',\n\n            animationEasing: 'linear',\n\n            // Disable progressive\n            progressive: 0,\n            hoverLayerThreshold: Infinity\n        }\n    });\n\n},{\"../../model/Series\":102,\"../helper/createListFromArray\":19}],22:[function(require,module,exports){\n'use strict';\n// FIXME step not support polar\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var SymbolDraw = require('../helper/SymbolDraw');\n    var Symbol = require('../helper/Symbol');\n    var lineAnimationDiff = require('./lineAnimationDiff');\n    var graphic = require('../../util/graphic');\n    var modelUtil = require('../../util/model');\n    var polyHelper = require('./poly');\n    var ChartView = require('../../view/Chart');\n\n    function isPointsSame(points1, points2) {\n        if (points1.length !== points2.length) {\n            return;\n        }\n        for (var i = 0; i < points1.length; i++) {\n            var p1 = points1[i];\n            var p2 = points2[i];\n            if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n                return;\n            }\n        }\n        return true;\n    }\n\n    function getSmooth(smooth) {\n        return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);\n    }\n\n    function getAxisExtentWithGap(axis) {\n        var extent = axis.getGlobalExtent();\n        if (axis.onBand) {\n            // Remove extra 1px to avoid line miter in clipped edge\n            var halfBandWidth = axis.getBandWidth() / 2 - 1;\n            var dir = extent[1] > extent[0] ? 1 : -1;\n            extent[0] += dir * halfBandWidth;\n            extent[1] -= dir * halfBandWidth;\n        }\n        return extent;\n    }\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n    /**\n     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n     * @param {module:echarts/data/List} data\n     * @param {Array.<Array.<number>>} points\n     * @private\n     */\n    function getStackedOnPoints(coordSys, data) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        return data.mapArray([valueDim], function (val, idx) {\n            var stackedOnSameSign;\n            var stackedOn = data.stackedOn;\n            // Find first stacked value with same sign\n            while (stackedOn &&\n                sign(stackedOn.get(valueDim, idx)) === sign(val)\n            ) {\n                stackedOnSameSign = stackedOn;\n                break;\n            }\n            var stackedData = [];\n            stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n            stackedData[1 - baseDataOffset] = stackedOnSameSign\n                ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n            return coordSys.dataToPoint(stackedData);\n        }, true);\n    }\n\n    function createGridClipShape(cartesian, hasAnimation, seriesModel) {\n        var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n        var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n        var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n\n        var x = Math.min(xExtent[0], xExtent[1]);\n        var y = Math.min(yExtent[0], yExtent[1]);\n        var width = Math.max(xExtent[0], xExtent[1]) - x;\n        var height = Math.max(yExtent[0], yExtent[1]) - y;\n        var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;\n        // Expand clip shape to avoid clipping when line value exceeds axis\n        var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n        if (isHorizontal) {\n            y -= expandSize;\n            height += expandSize * 2;\n        }\n        else {\n            x -= expandSize;\n            width += expandSize * 2;\n        }\n\n        var clipPath = new graphic.Rect({\n            shape: {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n            graphic.initProps(clipPath, {\n                shape: {\n                    width: width,\n                    height: height\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createPolarClipShape(polar, hasAnimation, seriesModel) {\n        var angleAxis = polar.getAngleAxis();\n        var radiusAxis = polar.getRadiusAxis();\n\n        var radiusExtent = radiusAxis.getExtent();\n        var angleExtent = angleAxis.getExtent();\n\n        var RADIAN = Math.PI / 180;\n\n        var clipPath = new graphic.Sector({\n            shape: {\n                cx: polar.cx,\n                cy: polar.cy,\n                r0: radiusExtent[0],\n                r: radiusExtent[1],\n                startAngle: -angleExtent[0] * RADIAN,\n                endAngle: -angleExtent[1] * RADIAN,\n                clockwise: angleAxis.inverse\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: -angleExtent[1] * RADIAN\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createClipShape(coordSys, hasAnimation, seriesModel) {\n        return coordSys.type === 'polar'\n            ? createPolarClipShape(coordSys, hasAnimation, seriesModel)\n            : createGridClipShape(coordSys, hasAnimation, seriesModel);\n    }\n\n    function turnPointsIntoStep(points, coordSys, stepTurnAt) {\n        var baseAxis = coordSys.getBaseAxis();\n        var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\n        var stepPoints = [];\n        for (var i = 0; i < points.length - 1; i++) {\n            var nextPt = points[i + 1];\n            var pt = points[i];\n            stepPoints.push(pt);\n\n            var stepPt = [];\n            switch (stepTurnAt) {\n                case 'end':\n                    stepPt[baseIndex] = nextPt[baseIndex];\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n                    break;\n                case 'middle':\n                    // default is start\n                    var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n                    var stepPt2 = [];\n                    stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n                    stepPoints.push(stepPt);\n                    stepPoints.push(stepPt2);\n                    break;\n                default:\n                    stepPt[baseIndex] = pt[baseIndex];\n                    stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n            }\n        }\n        // Last points\n        points[i] && stepPoints.push(points[i]);\n        return stepPoints;\n    }\n\n    function getVisualGradient(data, coordSys) {\n        var visualMetaList = data.getVisual('visualMeta');\n        if (!visualMetaList || !visualMetaList.length || !data.count()) {\n            // When data.count() is 0, gradient range can not be calculated.\n            return;\n        }\n\n        var visualMeta;\n        for (var i = visualMetaList.length - 1; i >= 0; i--) {\n            // Can only be x or y\n            if (visualMetaList[i].dimension < 2) {\n                visualMeta = visualMetaList[i];\n                break;\n            }\n        }\n        if (!visualMeta || coordSys.type !== 'cartesian2d') {\n            if (__DEV__) {\n                console.warn('Visual map on line style only support x or y dimension.');\n            }\n            return;\n        }\n\n        // If the area to be rendered is bigger than area defined by LinearGradient,\n        // the canvas spec prescribes that the color of the first stop and the last\n        // stop should be used. But if two stops are added at offset 0, in effect\n        // browsers use the color of the second stop to render area outside\n        // LinearGradient. So we can only infinitesimally extend area defined in\n        // LinearGradient to render `outerColors`.\n\n        var dimension = visualMeta.dimension;\n        var dimName = data.dimensions[dimension];\n        var axis = coordSys.getAxis(dimName);\n\n        // dataToCoor mapping may not be linear, but must be monotonic.\n        var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n            return {\n                coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n                color: stop.color\n            };\n        });\n        var stopLen = colorStops.length;\n        var outerColors = visualMeta.outerColors.slice();\n\n        if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n            colorStops.reverse();\n            outerColors.reverse();\n        }\n\n        var tinyExtent = 10; // Arbitrary value: 10px\n        var minCoord = colorStops[0].coord - tinyExtent;\n        var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n        var coordSpan = maxCoord - minCoord;\n\n        if (coordSpan < 1e-3) {\n            return 'transparent';\n        }\n\n        zrUtil.each(colorStops, function (stop) {\n            stop.offset = (stop.coord - minCoord) / coordSpan;\n        });\n        colorStops.push({\n            offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n            color: outerColors[1] || 'transparent'\n        });\n        colorStops.unshift({ // notice colorStops.length have been changed.\n            offset: stopLen ? colorStops[0].offset : 0.5,\n            color: outerColors[0] || 'transparent'\n        });\n\n        // zrUtil.each(colorStops, function (colorStop) {\n        //     // Make sure each offset has rounded px to avoid not sharp edge\n        //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n        // });\n\n        var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n        gradient[dimName] = minCoord;\n        gradient[dimName + '2'] = maxCoord;\n\n        return gradient;\n    }\n\n    module.exports = ChartView.extend({\n\n        type: 'line',\n\n        init: function () {\n            var lineGroup = new graphic.Group();\n\n            var symbolDraw = new SymbolDraw();\n            this.group.add(symbolDraw.group);\n\n            this._symbolDraw = symbolDraw;\n            this._lineGroup = lineGroup;\n        },\n\n        render: function (seriesModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var group = this.group;\n            var data = seriesModel.getData();\n            var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n            var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n\n            var points = data.mapArray(data.getItemLayout, true);\n\n            var isCoordSysPolar = coordSys.type === 'polar';\n            var prevCoordSys = this._coordSys;\n\n            var symbolDraw = this._symbolDraw;\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n\n            var lineGroup = this._lineGroup;\n\n            var hasAnimation = seriesModel.get('animation');\n\n            var isAreaChart = !areaStyleModel.isEmpty();\n            var stackedOnPoints = getStackedOnPoints(coordSys, data);\n\n            var showSymbol = seriesModel.get('showSymbol');\n\n            var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol')\n                && this._getSymbolIgnoreFunc(data, coordSys);\n\n            // Remove temporary symbols\n            var oldData = this._data;\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            // Remove previous created symbols if showSymbol changed to false\n            if (!showSymbol) {\n                symbolDraw.remove();\n            }\n\n            group.add(lineGroup);\n\n            // FIXME step not support polar\n            var step = !isCoordSysPolar && seriesModel.get('step');\n            // Initialization animation or coordinate system changed\n            if (\n                !(polyline && prevCoordSys.type === coordSys.type && step === this._step)\n            ) {\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                if (step) {\n                    // TODO If stacked series is not step\n                    points = turnPointsIntoStep(points, coordSys, step);\n                    stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                }\n\n                polyline = this._newPolyline(points, coordSys, hasAnimation);\n                if (isAreaChart) {\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n            }\n            else {\n                if (isAreaChart && !polygon) {\n                    // If areaStyle is added\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                else if (polygon && !isAreaChart) {\n                    // If areaStyle is removed\n                    lineGroup.remove(polygon);\n                    polygon = this._polygon = null;\n                }\n\n                // Update clipPath\n                lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));\n\n                // Always update, or it is wrong in the case turning on legend\n                // because points are not changed\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                // Stop symbol animation and sync with line points\n                // FIXME performance?\n                data.eachItemGraphicEl(function (el) {\n                    el.stopAnimation(true);\n                });\n\n                // In the case data zoom triggerred refreshing frequently\n                // Data may not change if line has a category axis. So it should animate nothing\n                if (!isPointsSame(this._stackedOnPoints, stackedOnPoints)\n                    || !isPointsSame(this._points, points)\n                ) {\n                    if (hasAnimation) {\n                        this._updateAnimation(\n                            data, stackedOnPoints, coordSys, api, step\n                        );\n                    }\n                    else {\n                        // Not do it in update with animation\n                        if (step) {\n                            // TODO If stacked series is not step\n                            points = turnPointsIntoStep(points, coordSys, step);\n                            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                        }\n\n                        polyline.setShape({\n                            points: points\n                        });\n                        polygon && polygon.setShape({\n                            points: points,\n                            stackedOnPoints: stackedOnPoints\n                        });\n                    }\n                }\n            }\n\n            var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n\n            polyline.useStyle(zrUtil.defaults(\n                // Use color in lineStyle first\n                lineStyleModel.getLineStyle(),\n                {\n                    fill: 'none',\n                    stroke: visualColor,\n                    lineJoin: 'bevel'\n                }\n            ));\n\n            var smooth = seriesModel.get('smooth');\n            smooth = getSmooth(seriesModel.get('smooth'));\n            polyline.setShape({\n                smooth: smooth,\n                smoothMonotone: seriesModel.get('smoothMonotone'),\n                connectNulls: seriesModel.get('connectNulls')\n            });\n\n            if (polygon) {\n                var stackedOn = data.stackedOn;\n                var stackedOnSmooth = 0;\n\n                polygon.useStyle(zrUtil.defaults(\n                    areaStyleModel.getAreaStyle(),\n                    {\n                        fill: visualColor,\n                        opacity: 0.7,\n                        lineJoin: 'bevel'\n                    }\n                ));\n\n                if (stackedOn) {\n                    var stackedOnSeries = stackedOn.hostModel;\n                    stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n                }\n\n                polygon.setShape({\n                    smooth: smooth,\n                    stackedOnSmooth: stackedOnSmooth,\n                    smoothMonotone: seriesModel.get('smoothMonotone'),\n                    connectNulls: seriesModel.get('connectNulls')\n                });\n            }\n\n            this._data = data;\n            // Save the coordinate system for transition animation when data changed\n            this._coordSys = coordSys;\n            this._stackedOnPoints = stackedOnPoints;\n            this._points = points;\n            this._step = step;\n        },\n\n        dispose: function () {},\n\n        highlight: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n            if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (!symbol) {\n                    // Create a temporary symbol if it is not exists\n                    var pt = data.getItemLayout(dataIndex);\n                    if (!pt) {\n                        // Null data\n                        return;\n                    }\n                    symbol = new Symbol(data, dataIndex);\n                    symbol.position = pt;\n                    symbol.setZ(\n                        seriesModel.get('zlevel'),\n                        seriesModel.get('z')\n                    );\n                    symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n                    symbol.__temp = true;\n                    data.setItemGraphicEl(dataIndex, symbol);\n\n                    // Stop scale animation\n                    symbol.stopSymbolAnimation(true);\n\n                    this.group.add(symbol);\n                }\n                symbol.highlight();\n            }\n            else {\n                // Highlight whole series\n                ChartView.prototype.highlight.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        downplay: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n            if (dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (symbol) {\n                    if (symbol.__temp) {\n                        data.setItemGraphicEl(dataIndex, null);\n                        this.group.remove(symbol);\n                    }\n                    else {\n                        symbol.downplay();\n                    }\n                }\n            }\n            else {\n                // Downplay whole series\n                ChartView.prototype.downplay.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolyline: function (points) {\n            var polyline = this._polyline;\n            // Remove previous created polyline\n            if (polyline) {\n                this._lineGroup.remove(polyline);\n            }\n\n            polyline = new polyHelper.Polyline({\n                shape: {\n                    points: points\n                },\n                silent: true,\n                z2: 10\n            });\n\n            this._lineGroup.add(polyline);\n\n            this._polyline = polyline;\n\n            return polyline;\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} stackedOnPoints\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolygon: function (points, stackedOnPoints) {\n            var polygon = this._polygon;\n            // Remove previous created polygon\n            if (polygon) {\n                this._lineGroup.remove(polygon);\n            }\n\n            polygon = new polyHelper.Polygon({\n                shape: {\n                    points: points,\n                    stackedOnPoints: stackedOnPoints\n                },\n                silent: true\n            });\n\n            this._lineGroup.add(polygon);\n\n            this._polygon = polygon;\n            return polygon;\n        },\n        /**\n         * @private\n         */\n        _getSymbolIgnoreFunc: function (data, coordSys) {\n            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n            // `getLabelInterval` is provided by echarts/component/axis\n            if (categoryAxis && categoryAxis.isLabelIgnored) {\n                return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n            }\n        },\n\n        /**\n         * @private\n         */\n        // FIXME Two value axis\n        _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n            var seriesModel = data.hostModel;\n\n            var diff = lineAnimationDiff(\n                this._data, data,\n                this._stackedOnPoints, stackedOnPoints,\n                this._coordSys, coordSys\n            );\n\n            var current = diff.current;\n            var stackedOnCurrent = diff.stackedOnCurrent;\n            var next = diff.next;\n            var stackedOnNext = diff.stackedOnNext;\n            if (step) {\n                // TODO If stacked series is not step\n                current = turnPointsIntoStep(diff.current, coordSys, step);\n                stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n                next = turnPointsIntoStep(diff.next, coordSys, step);\n                stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n            }\n            // `diff.current` is subset of `current` (which should be ensured by\n            // turnPointsIntoStep), so points in `__points` can be updated when\n            // points in `current` are update during animation.\n            polyline.shape.__points = diff.current;\n            polyline.shape.points = current;\n\n            graphic.updateProps(polyline, {\n                shape: {\n                    points: next\n                }\n            }, seriesModel);\n\n            if (polygon) {\n                polygon.setShape({\n                    points: current,\n                    stackedOnPoints: stackedOnCurrent\n                });\n                graphic.updateProps(polygon, {\n                    shape: {\n                        points: next,\n                        stackedOnPoints: stackedOnNext\n                    }\n                }, seriesModel);\n            }\n\n            var updatedDataInfo = [];\n            var diffStatus = diff.status;\n\n            for (var i = 0; i < diffStatus.length; i++) {\n                var cmd = diffStatus[i].cmd;\n                if (cmd === '=') {\n                    var el = data.getItemGraphicEl(diffStatus[i].idx1);\n                    if (el) {\n                        updatedDataInfo.push({\n                            el: el,\n                            ptIdx: i    // Index of points\n                        });\n                    }\n                }\n            }\n\n            if (polyline.animators && polyline.animators.length) {\n                polyline.animators[0].during(function () {\n                    for (var i = 0; i < updatedDataInfo.length; i++) {\n                        var el = updatedDataInfo[i].el;\n                        el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n                    }\n                });\n            }\n        },\n\n        remove: function (ecModel) {\n            var group = this.group;\n            var oldData = this._data;\n            this._lineGroup.removeAll();\n            this._symbolDraw.remove(true);\n            // Remove temporary created elements when highlighting\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            this._polyline =\n            this._polygon =\n            this._coordSys =\n            this._points =\n            this._stackedOnPoints =\n            this._data = null;\n        }\n    });\n\n},{\"../../util/graphic\":123,\"../../util/model\":125,\"../../view/Chart\":129,\"../helper/Symbol\":17,\"../helper/SymbolDraw\":18,\"./lineAnimationDiff\":23,\"./poly\":24,\"zrender/lib/core/util\":166}],23:[function(require,module,exports){\n\n\n    // var arrayDiff = require('zrender/lib/core/arrayDiff');\n    // 'zrender/core/arrayDiff' has been used before, but it did\n    // not do well in performance when roam with fixed dataZoom window.\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n\n    function getStackedOnPoint(coordSys, data, idx) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        var stackedOnSameSign;\n        var stackedOn = data.stackedOn;\n        var val = data.get(valueDim, idx);\n        // Find first stacked value with same sign\n        while (stackedOn &&\n            sign(stackedOn.get(valueDim, idx)) === sign(val)\n        ) {\n            stackedOnSameSign = stackedOn;\n            break;\n        }\n        var stackedData = [];\n        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n        stackedData[1 - baseDataOffset] = stackedOnSameSign\n            ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n        return coordSys.dataToPoint(stackedData);\n    }\n\n    // function convertToIntId(newIdList, oldIdList) {\n    //     // Generate int id instead of string id.\n    //     // Compare string maybe slow in score function of arrDiff\n\n    //     // Assume id in idList are all unique\n    //     var idIndicesMap = {};\n    //     var idx = 0;\n    //     for (var i = 0; i < newIdList.length; i++) {\n    //         idIndicesMap[newIdList[i]] = idx;\n    //         newIdList[i] = idx++;\n    //     }\n    //     for (var i = 0; i < oldIdList.length; i++) {\n    //         var oldId = oldIdList[i];\n    //         // Same with newIdList\n    //         if (idIndicesMap[oldId]) {\n    //             oldIdList[i] = idIndicesMap[oldId];\n    //         }\n    //         else {\n    //             oldIdList[i] = idx++;\n    //         }\n    //     }\n    // }\n\n    function diffData(oldData, newData) {\n        var diffResult = [];\n\n        newData.diff(oldData)\n            .add(function (idx) {\n                diffResult.push({cmd: '+', idx: idx});\n            })\n            .update(function (newIdx, oldIdx) {\n                diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx});\n            })\n            .remove(function (idx) {\n                diffResult.push({cmd: '-', idx: idx});\n            })\n            .execute();\n\n        return diffResult;\n    }\n\n    module.exports = function (\n        oldData, newData,\n        oldStackedOnPoints, newStackedOnPoints,\n        oldCoordSys, newCoordSys\n    ) {\n        var diff = diffData(oldData, newData);\n\n        // var newIdList = newData.mapArray(newData.getId);\n        // var oldIdList = oldData.mapArray(oldData.getId);\n\n        // convertToIntId(newIdList, oldIdList);\n\n        // // FIXME One data ?\n        // diff = arrayDiff(oldIdList, newIdList);\n\n        var currPoints = [];\n        var nextPoints = [];\n        // Points for stacking base line\n        var currStackedPoints = [];\n        var nextStackedPoints = [];\n\n        var status = [];\n        var sortedIndices = [];\n        var rawIndices = [];\n        var dims = newCoordSys.dimensions;\n        for (var i = 0; i < diff.length; i++) {\n            var diffItem = diff[i];\n            var pointAdded = true;\n\n            // FIXME, animation is not so perfect when dataZoom window moves fast\n            // Which is in case remvoing or add more than one data in the tail or head\n            switch (diffItem.cmd) {\n                case '=':\n                    var currentPt = oldData.getItemLayout(diffItem.idx);\n                    var nextPt = newData.getItemLayout(diffItem.idx1);\n                    // If previous data is NaN, use next point directly\n                    if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n                        currentPt = nextPt.slice();\n                    }\n                    currPoints.push(currentPt);\n                    nextPoints.push(nextPt);\n\n                    currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n                    nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n\n                    rawIndices.push(newData.getRawIndex(diffItem.idx1));\n                    break;\n                case '+':\n                    var idx = diffItem.idx;\n                    currPoints.push(\n                        oldCoordSys.dataToPoint([\n                            newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)\n                        ])\n                    );\n\n                    nextPoints.push(newData.getItemLayout(idx).slice());\n\n                    currStackedPoints.push(\n                        getStackedOnPoint(oldCoordSys, newData, idx)\n                    );\n                    nextStackedPoints.push(newStackedOnPoints[idx]);\n\n                    rawIndices.push(newData.getRawIndex(idx));\n                    break;\n                case '-':\n                    var idx = diffItem.idx;\n                    var rawIndex = oldData.getRawIndex(idx);\n                    // Data is replaced. In the case of dynamic data queue\n                    // FIXME FIXME FIXME\n                    if (rawIndex !== idx) {\n                        currPoints.push(oldData.getItemLayout(idx));\n                        nextPoints.push(newCoordSys.dataToPoint([\n                            oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)\n                        ]));\n\n                        currStackedPoints.push(oldStackedOnPoints[idx]);\n                        nextStackedPoints.push(\n                            getStackedOnPoint(\n                                newCoordSys, oldData, idx\n                            )\n                        );\n\n                        rawIndices.push(rawIndex);\n                    }\n                    else {\n                        pointAdded = false;\n                    }\n            }\n\n            // Original indices\n            if (pointAdded) {\n                status.push(diffItem);\n                sortedIndices.push(sortedIndices.length);\n            }\n        }\n\n        // Diff result may be crossed if all items are changed\n        // Sort by data index\n        sortedIndices.sort(function (a, b) {\n            return rawIndices[a] - rawIndices[b];\n        });\n\n        var sortedCurrPoints = [];\n        var sortedNextPoints = [];\n\n        var sortedCurrStackedPoints = [];\n        var sortedNextStackedPoints = [];\n\n        var sortedStatus = [];\n        for (var i = 0; i < sortedIndices.length; i++) {\n            var idx = sortedIndices[i];\n            sortedCurrPoints[i] = currPoints[idx];\n            sortedNextPoints[i] = nextPoints[idx];\n\n            sortedCurrStackedPoints[i] = currStackedPoints[idx];\n            sortedNextStackedPoints[i] = nextStackedPoints[idx];\n\n            sortedStatus[i] = status[idx];\n        }\n\n        return {\n            current: sortedCurrPoints,\n            next: sortedNextPoints,\n\n            stackedOnCurrent: sortedCurrStackedPoints,\n            stackedOnNext: sortedNextStackedPoints,\n\n            status: sortedStatus\n        };\n    };\n\n},{}],24:[function(require,module,exports){\n// Poly path support NaN point\n\n\n    var Path = require('zrender/lib/graphic/Path');\n    var vec2 = require('zrender/lib/core/vector');\n\n    var vec2Min = vec2.min;\n    var vec2Max = vec2.max;\n\n    var scaleAndAdd = vec2.scaleAndAdd;\n    var v2Copy = vec2.copy;\n\n    // Temporary variable\n    var v = [];\n    var cp0 = [];\n    var cp1 = [];\n\n    function isPointNull(p) {\n        return isNaN(p[0]) || isNaN(p[1]);\n    }\n\n    function drawSegment(\n        ctx, points, start, segLen, allLen,\n        dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls\n    ) {\n        var prevIdx = 0;\n        var idx = start;\n        for (var k = 0; k < segLen; k++) {\n            var p = points[idx];\n            if (idx >= allLen || idx < 0) {\n                break;\n            }\n            if (isPointNull(p)) {\n                if (connectNulls) {\n                    idx += dir;\n                    continue;\n                }\n                break;\n            }\n\n            if (idx === start) {\n                ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n                v2Copy(cp0, p);\n            }\n            else {\n                if (smooth > 0) {\n                    var nextIdx = idx + dir;\n                    var nextP = points[nextIdx];\n                    if (connectNulls) {\n                        // Find next point not null\n                        while (nextP && isPointNull(points[nextIdx])) {\n                            nextIdx += dir;\n                            nextP = points[nextIdx];\n                        }\n                    }\n\n                    var ratioNextSeg = 0.5;\n                    var prevP = points[prevIdx];\n                    var nextP = points[nextIdx];\n                    // Last point\n                    if (!nextP || isPointNull(nextP)) {\n                        v2Copy(cp1, p);\n                    }\n                    else {\n                        // If next data is null in not connect case\n                        if (isPointNull(nextP) && !connectNulls) {\n                            nextP = p;\n                        }\n\n                        vec2.sub(v, nextP, prevP);\n\n                        var lenPrevSeg;\n                        var lenNextSeg;\n                        if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n                            var dim = smoothMonotone === 'x' ? 0 : 1;\n                            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n                            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n                        }\n                        else {\n                            lenPrevSeg = vec2.dist(p, prevP);\n                            lenNextSeg = vec2.dist(p, nextP);\n                        }\n\n                        // Use ratio of seg length\n                        ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n\n                        scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n                    }\n                    // Smooth constraint\n                    vec2Min(cp0, cp0, smoothMax);\n                    vec2Max(cp0, cp0, smoothMin);\n                    vec2Min(cp1, cp1, smoothMax);\n                    vec2Max(cp1, cp1, smoothMin);\n\n                    ctx.bezierCurveTo(\n                        cp0[0], cp0[1],\n                        cp1[0], cp1[1],\n                        p[0], p[1]\n                    );\n                    // cp0 of next segment\n                    scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n                }\n                else {\n                    ctx.lineTo(p[0], p[1]);\n                }\n            }\n\n            prevIdx = idx;\n            idx += dir;\n        }\n\n        return k;\n    }\n\n    function getBoundingBox(points, smoothConstraint) {\n        var ptMin = [Infinity, Infinity];\n        var ptMax = [-Infinity, -Infinity];\n        if (smoothConstraint) {\n            for (var i = 0; i < points.length; i++) {\n                var pt = points[i];\n                if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; }\n                if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; }\n                if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; }\n                if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; }\n            }\n        }\n        return {\n            min: smoothConstraint ? ptMin : ptMax,\n            max: smoothConstraint ? ptMax : ptMin\n        };\n    }\n\n    module.exports = {\n\n        Polyline: Path.extend({\n\n            type: 'ec-polyline',\n\n            shape: {\n                points: [],\n\n                smooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            style: {\n                fill: null,\n\n                stroke: '#000'\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n\n                var i = 0;\n                var len = points.length;\n\n                var result = getBoundingBox(points, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    i += drawSegment(\n                        ctx, points, i, len, len,\n                        1, result.min, result.max, shape.smooth,\n                        shape.smoothMonotone, shape.connectNulls\n                    ) + 1;\n                }\n            }\n        }),\n\n        Polygon: Path.extend({\n\n            type: 'ec-polygon',\n\n            shape: {\n                points: [],\n\n                // Offset between stacked base points and points\n                stackedOnPoints: [],\n\n                smooth: 0,\n\n                stackedOnSmooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n                var stackedOnPoints = shape.stackedOnPoints;\n\n                var i = 0;\n                var len = points.length;\n                var smoothMonotone = shape.smoothMonotone;\n                var bbox = getBoundingBox(points, shape.smoothConstraint);\n                var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    var k = drawSegment(\n                        ctx, points, i, len, len,\n                        1, bbox.min, bbox.max, shape.smooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    drawSegment(\n                        ctx, stackedOnPoints, i + k - 1, k, len,\n                        -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    i += k + 1;\n\n                    ctx.closePath();\n                }\n            }\n        })\n    };\n\n},{\"zrender/lib/core/vector\":167,\"zrender/lib/graphic/Path\":174}],25:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('./pie/PieSeries');\n    require('./pie/PieView');\n\n    require('../action/createDataSelectAction')('pie', [{\n        type: 'pieToggleSelect',\n        event: 'pieselectchanged',\n        method: 'toggleSelected'\n    }, {\n        type: 'pieSelect',\n        event: 'pieselected',\n        method: 'select'\n    }, {\n        type: 'pieUnSelect',\n        event: 'pieunselected',\n        method: 'unSelect'\n    }]);\n\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n\n    echarts.registerLayout(zrUtil.curry(\n        require('./pie/pieLayout'), 'pie'\n    ));\n\n    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n\n},{\"../action/createDataSelectAction\":3,\"../echarts\":94,\"../processor/dataFilter\":113,\"../visual/dataColor\":131,\"./pie/PieSeries\":26,\"./pie/PieView\":27,\"./pie/pieLayout\":29,\"zrender/lib/core/util\":166}],26:[function(require,module,exports){\n'use strict';\n\n\n    var List = require('../../data/List');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n\n    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n\n    var PieSeries = require('../../echarts').extendSeriesModel({\n\n        type: 'series.pie',\n\n        // Overwrite\n        init: function (option) {\n            PieSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n\n            this.updateSelectedMap(option.data);\n\n            this._defaultLabelLine(option);\n        },\n\n        // Overwrite\n        mergeOption: function (newOption) {\n            PieSeries.superCall(this, 'mergeOption', newOption);\n            this.updateSelectedMap(this.option.data);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        // Overwrite\n        getDataParams: function (dataIndex) {\n            var data = this.getData();\n            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n            var sum = data.getSum('value');\n            // FIXME toFixed?\n            //\n            // Percent is 0 if sum is 0\n            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\n            params.$vars.push('percent');\n            return params;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // \n            center: ['50%', '50%'],\n            radius: [0, '75%'],\n            // \n            clockwise: true,\n            startAngle: 90,\n            // 0\n            minAngle: 0,\n            // \n            selectedOffset: 10,\n\n            // If use strategy to avoid label overlapping\n            avoidLabelOverlap: true,\n            // singlemultiple\n            // selectedMode: false,\n            // 'radius' | 'area'\n            // roseType: null,\n\n            // If still show when all data zero.\n            stillShowZeroSum: true,\n\n            label: {\n                normal: {\n                    // If rotate around circle\n                    rotate: false,\n                    show: true,\n                    // 'outer', 'inside', 'center'\n                    position: 'outer'\n                    // formatter: Tooltip.formatter\n                    // textStyle: null      // TEXTSTYLE\n                    // distance: positioninnerlabel()\n                },\n                emphasis: {}\n            },\n            // Enabled when label.normal.position is 'outer'\n            labelLine: {\n                normal: {\n                    show: true,\n                    // \n                    length: 15,\n                    // \n                    length2: 15,\n                    smooth: false,\n                    lineStyle: {\n                        // color: ,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 1\n                },\n                emphasis: {}\n            },\n\n            // Animation type canbe expansion, scale\n            animationType: 'expansion',\n\n            animationEasing: 'cubicOut',\n\n            data: []\n        }\n    });\n\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\n    module.exports = PieSeries;\n\n},{\"../../component/helper/selectableMixin\":53,\"../../data/List\":92,\"../../data/helper/completeDimensions\":93,\"../../echarts\":94,\"../../util/model\":125,\"zrender/lib/core/util\":166}],27:[function(require,module,exports){\n\n\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n\n        data.each(function (idx) {\n            toggleItemSelected(\n                data.getItemGraphicEl(idx),\n                data.getItemLayout(idx),\n                seriesModel.isSelected(data.getName(idx)),\n                selectedOffset,\n                hasAnimation\n            );\n        });\n    }\n\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [dx * offset, dy * offset];\n\n        hasAnimation\n            // animateTo will stop revious animation like update transition\n            ? el.animate()\n                .when(200, {\n                    position: position\n                })\n                .start('bounceOut')\n            : el.attr('position', position);\n    }\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var sector = new graphic.Sector({\n            z2: 2\n        });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var piePieceProto = PiePiece.prototype;\n\n    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        return {\n            fill: textStyleModel.getTextColor()\n                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            opacity: data.getItemVisual(idx, 'opacity'),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(\n                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n            )\n        };\n    }\n\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n\n        var sector = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n\n            var animationType = seriesModel.getShallow('animationType');\n            if (animationType === 'scale') {\n                sector.shape.r = layout.r0;\n                graphic.initProps(sector, {\n                    shape: {\n                        r: layout.r\n                    }\n                }, seriesModel, idx);\n            }\n            // Expansion\n            else {\n                sector.shape.endAngle = layout.startAngle;\n                graphic.updateProps(sector, {\n                    shape: {\n                        endAngle: layout.endAngle\n                    }\n                }, seriesModel, idx);\n            }\n\n        }\n        else {\n            graphic.updateProps(sector, {\n                shape: sectorShape\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        sector.useStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'bevel',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle()\n            )\n        );\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        // Toggle selected\n        toggleItemSelected(\n            this,\n            data.getItemLayout(idx),\n            itemModel.get('selected'),\n            seriesModel.get('selectedOffset'),\n            seriesModel.get('animation')\n        );\n\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r + 10\n                }\n            }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r\n                }\n            }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n            sector\n                .on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    piePieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n                ]\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textVerticalAlign: labelLayout.verticalAlign,\n                textAlign: labelLayout.textAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({\n            smooth: smooth\n        });\n    };\n\n    zrUtil.inherits(PiePiece, graphic.Group);\n\n\n    // Pie view\n    var Pie = require('../../view/Chart').extend({\n\n        type: 'pie',\n\n        init: function () {\n            var sectorGroup = new graphic.Group();\n            this._sectorGroup = sectorGroup;\n        },\n\n        render: function (seriesModel, ecModel, api, payload) {\n            if (payload && (payload.from === this.uid)) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var group = this.group;\n\n            var hasAnimation = ecModel.get('animation');\n            var isFirstRender = !oldData;\n            var animationType = seriesModel.get('animationType');\n\n            var onSectorClick = zrUtil.curry(\n                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n            );\n\n            var selectedMode = seriesModel.get('selectedMode');\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    // Default expansion animation\n                    if (isFirstRender && animationType !== 'scale') {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n\n                    selectedMode && piePiece.on('click', onSectorClick);\n\n                    data.setItemGraphicEl(idx, piePiece);\n\n                    group.add(piePiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            if (\n                hasAnimation && isFirstRender && data.count() > 0\n                // Default expansion animation\n                && animationType !== 'scale'\n            ) {\n                var shape = data.getItemLayout(0);\n                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\n                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                group.setClipPath(this._createClipPath(\n                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n                ));\n            }\n\n            this._data = data;\n        },\n\n        dispose: function () {},\n\n        _createClipPath: function (\n            cx, cy, r, startAngle, clockwise, cb, seriesModel\n        ) {\n            var clipPath = new graphic.Sector({\n                shape: {\n                    cx: cx,\n                    cy: cy,\n                    r0: 0,\n                    r: r,\n                    startAngle: startAngle,\n                    endAngle: startAngle,\n                    clockwise: clockwise\n                }\n            });\n\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n                }\n            }, seriesModel, cb);\n\n            return clipPath;\n        },\n\n        /**\n         * @implement\n         */\n        containPoint: function (point, seriesModel) {\n            var data = seriesModel.getData();\n            var itemLayout = data.getItemLayout(0);\n            if (itemLayout) {\n                var dx = point[0] - itemLayout.cx;\n                var dy = point[1] - itemLayout.cy;\n                var radius = Math.sqrt(dx * dx + dy * dy);\n                return radius <= itemLayout.r && radius >= itemLayout.r0;\n            }\n        }\n\n    });\n\n    module.exports = Pie;\n\n},{\"../../util/graphic\":123,\"../../view/Chart\":129,\"zrender/lib/core/util\":166}],28:[function(require,module,exports){\n'use strict';\n// FIXME emphasis label position is not same with normal label position\n\n\n    var textContain = require('zrender/lib/contain/text');\n\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n\n        // \n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start\n                    && j + 1 < end\n                    && list[j + 1].y > list[j].y + list[j].height\n                ) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n\n            shiftUp(end - 1, delta / 2);\n        }\n\n        // \n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0\n                    && list[j].y > list[j - 1].y + list[j - 1].height\n                ) {\n                    break;\n                }\n            }\n        }\n\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0\n                ? isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0                     // \n                : isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0;                    // \n\n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = (deltaY < r + length)\n                    ? Math.sqrt(\n                          (r + length + length2) * (r + length + length2)\n                          - deltaY * deltaY\n                      )\n                    : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX + 10;\n                }\n\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            }\n            else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            }\n            else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                }\n                else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n\n    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n\n            cx = layout.cx;\n            cy = layout.cy;\n\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            }\n            else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n                    var y3 = y2;\n\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n                }\n\n                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n            }\n            var font = labelModel.getModel('textStyle').getFont();\n\n            var labelRotate = labelModel.get('rotate')\n                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal')\n                        || data.getName(idx);\n            var textRect = textContain.getBoundingRect(\n                text, font, textAlign, 'top'\n            );\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                font: font,\n                rotation: labelRotate\n            };\n\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n\n},{\"zrender/lib/contain/text\":150}],29:[function(require,module,exports){\n// TODO minAngle\n\n\n\n    var numberUtil = require('../../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = require('./labelLayout');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n\n    module.exports = function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n\n            if (!zrUtil.isArray(radius)) {\n                radius = [0, radius];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [center, center];\n            }\n\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n\n            var data = seriesModel.getData();\n\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\n            var clockwise = seriesModel.get('clockwise');\n\n            var roseType = seriesModel.get('roseType');\n            var stillShowZeroSum = seriesModel.get('stillShowZeroSum');\n\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n\n            var currentAngle = startAngle;\n\n            var dir = clockwise ? 1 : -1;\n            data.each('value', function (value, idx) {\n                var angle;\n                if (isNaN(value)) {\n                    data.setItemLayout(idx, {\n                        angle: NaN,\n                        startAngle: NaN,\n                        endAngle: NaN,\n                        clockwise: clockwise,\n                        cx: cx,\n                        cy: cy,\n                        r0: r0,\n                        r: roseType\n                            ? NaN\n                            : r\n                    });\n                    return;\n                }\n\n                // FIXME  2.0  roseType  area \n                if (roseType !== 'area') {\n                    angle = (sum === 0 && stillShowZeroSum)\n                        ? unitRadian : (value * unitRadian);\n                }\n                else {\n                    angle = PI2 / (data.count() || 1);\n                }\n\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                }\n                else {\n                    valueSumLargerThanMinAngle += value;\n                }\n\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType\n                        ? numberUtil.linearMap(value, extent, [r0, r])\n                        : r\n                });\n\n                currentAngle = endAngle;\n            }, true);\n\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 1e-3) {\n                    var angle = PI2 / data.count();\n                    data.each(function (idx) {\n                        var layout = data.getItemLayout(idx);\n                        layout.startAngle = startAngle + dir * idx * angle;\n                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                    });\n                }\n                else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        var layout = data.getItemLayout(idx);\n                        var angle = layout.angle === minAngle\n                            ? minAngle : value * unitRadian;\n                        layout.startAngle = currentAngle;\n                        layout.endAngle = currentAngle + dir * angle;\n                        currentAngle += dir * angle;\n                    });\n                }\n            }\n\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n\n},{\"../../util/number\":126,\"./labelLayout\":28,\"zrender/lib/core/util\":166}],30:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    // Must use radar component\n    require('../component/radar');\n\n    require('./radar/RadarSeries');\n    require('./radar/RadarView');\n\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'radar'));\n    echarts.registerVisual(zrUtil.curry(\n        require('../visual/symbol'), 'radar', 'circle', null\n    ));\n    echarts.registerLayout(require('./radar/radarLayout'));\n\n    echarts.registerProcessor(\n        zrUtil.curry(require('../processor/dataFilter'), 'radar')\n    );\n\n    echarts.registerPreprocessor(require('./radar/backwardCompat'));\n\n},{\"../component/radar\":69,\"../echarts\":94,\"../processor/dataFilter\":113,\"../visual/dataColor\":131,\"../visual/symbol\":133,\"./radar/RadarSeries\":31,\"./radar/RadarView\":32,\"./radar/backwardCompat\":33,\"./radar/radarLayout\":34,\"zrender/lib/core/util\":166}],31:[function(require,module,exports){\n'use strict';\n\n\n    var SeriesModel = require('../../model/Series');\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/lib/core/util');\n    var encodeHTML = require('../../util/format').encodeHTML;\n\n    var RadarSeries = SeriesModel.extend({\n\n        type: 'series.radar',\n\n        dependencies: ['radar'],\n\n\n        // Overwrite\n        init: function (option) {\n            RadarSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n        },\n\n        getInitialData: function (option, ecModel) {\n            var data = option.data || [];\n            var dimensions = completeDimensions(\n                [], data, [], 'indicator_'\n            );\n            var list = new List(dimensions, this);\n            list.initData(data);\n            return list;\n        },\n\n        formatTooltip: function (dataIndex) {\n            var value = this.getRawValue(dataIndex);\n            var coordSys = this.coordinateSystem;\n            var indicatorAxes = coordSys.getIndicatorAxes();\n            var name = this.getData().getName(dataIndex);\n            return encodeHTML(name === '' ? this.name : name) + '<br/>'\n                + zrUtil.map(indicatorAxes, function (axis, idx) {\n                    return encodeHTML(axis.name + ' : ' + value[idx]);\n                }).join('<br />');\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            coordinateSystem: 'radar',\n            legendHoverLink: true,\n            radarIndex: 0,\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // areaStyle: {\n            // },\n            // itemStyle: {}\n            symbol: 'emptyCircle',\n            symbolSize: 4\n            // symbolRotate: null\n        }\n    });\n\n    module.exports = RadarSeries;\n\n},{\"../../data/List\":92,\"../../data/helper/completeDimensions\":93,\"../../model/Series\":102,\"../../util/format\":122,\"zrender/lib/core/util\":166}],32:[function(require,module,exports){\n\n\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolUtil = require('../../util/symbol');\n\n    function normalizeSymbolSize(symbolSize) {\n        if (!zrUtil.isArray(symbolSize)) {\n            symbolSize = [+symbolSize, +symbolSize];\n        }\n        return symbolSize;\n    }\n    module.exports = require('../../echarts').extendChartView({\n        type: 'radar',\n\n        render: function (seriesModel, ecModel, api) {\n            var polar = seriesModel.coordinateSystem;\n            var group = this.group;\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            function createSymbol(data, idx) {\n                var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n                var color = data.getItemVisual(idx, 'color');\n                if (symbolType === 'none') {\n                    return;\n                }\n                var symbolPath = symbolUtil.createSymbol(\n                    symbolType, -0.5, -0.5, 1, 1, color\n                );\n                symbolPath.attr({\n                    style: {\n                        strokeNoScale: true\n                    },\n                    z2: 100,\n                    scale: normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'))\n                });\n                return symbolPath;\n            }\n\n            function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {\n                // Simply rerender all\n                symbolGroup.removeAll();\n                for (var i = 0; i < newPoints.length - 1; i++) {\n                    var symbolPath = createSymbol(data, idx);\n                    if (symbolPath) {\n                        symbolPath.__dimIdx = i;\n                        if (oldPoints[i]) {\n                            symbolPath.attr('position', oldPoints[i]);\n                            graphic[isInit ? 'initProps' : 'updateProps'](\n                                symbolPath, {\n                                    position: newPoints[i]\n                                }, seriesModel, idx\n                            );\n                        }\n                        else {\n                            symbolPath.attr('position', newPoints[i]);\n                        }\n                        symbolGroup.add(symbolPath);\n                    }\n                }\n            }\n\n            function getInitialPoints(points) {\n                return zrUtil.map(points, function (pt) {\n                    return [polar.cx, polar.cy];\n                });\n            }\n            data.diff(oldData)\n                .add(function (idx) {\n                    var points = data.getItemLayout(idx);\n                    if (!points) {\n                        return;\n                    }\n                    var polygon = new graphic.Polygon();\n                    var polyline = new graphic.Polyline();\n                    var target = {\n                        shape: {\n                            points: points\n                        }\n                    };\n                    polygon.shape.points = getInitialPoints(points);\n                    polyline.shape.points = getInitialPoints(points);\n                    graphic.initProps(polygon, target, seriesModel, idx);\n                    graphic.initProps(polyline, target, seriesModel, idx);\n\n                    var itemGroup = new graphic.Group();\n                    var symbolGroup = new graphic.Group();\n                    itemGroup.add(polyline);\n                    itemGroup.add(polygon);\n                    itemGroup.add(symbolGroup);\n\n                    updateSymbols(\n                        polyline.shape.points, points, symbolGroup, data, idx, true\n                    );\n\n                    data.setItemGraphicEl(idx, itemGroup);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var itemGroup = oldData.getItemGraphicEl(oldIdx);\n                    var polyline = itemGroup.childAt(0);\n                    var polygon = itemGroup.childAt(1);\n                    var symbolGroup = itemGroup.childAt(2);\n                    var target = {\n                        shape: {\n                            points: data.getItemLayout(newIdx)\n                        }\n                    };\n                    if (!target.shape.points) {\n                        return;\n                    }\n                    updateSymbols(\n                        polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false\n                    );\n\n                    graphic.updateProps(polyline, target, seriesModel);\n                    graphic.updateProps(polygon, target, seriesModel);\n\n                    data.setItemGraphicEl(newIdx, itemGroup);\n                })\n                .remove(function (idx) {\n                    group.remove(oldData.getItemGraphicEl(idx));\n                })\n                .execute();\n\n            data.eachItemGraphicEl(function (itemGroup, idx) {\n                var itemModel = data.getItemModel(idx);\n                var polyline = itemGroup.childAt(0);\n                var polygon = itemGroup.childAt(1);\n                var symbolGroup = itemGroup.childAt(2);\n                var color = data.getItemVisual(idx, 'color');\n\n                group.add(itemGroup);\n\n                polyline.useStyle(\n                    zrUtil.defaults(\n                        itemModel.getModel('lineStyle.normal').getLineStyle(),\n                        {\n                            fill: 'none',\n                            stroke: color\n                        }\n                    )\n                );\n                polyline.hoverStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n\n                var areaStyleModel = itemModel.getModel('areaStyle.normal');\n                var hoverAreaStyleModel = itemModel.getModel('areaStyle.emphasis');\n                var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();\n                var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();\n\n                hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;\n                polygon.ignore = polygonIgnore;\n\n                polygon.useStyle(\n                    zrUtil.defaults(\n                        areaStyleModel.getAreaStyle(),\n                        {\n                            fill: color,\n                            opacity: 0.7\n                        }\n                    )\n                );\n                polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();\n\n                var itemStyle = itemModel.getModel('itemStyle.normal').getItemStyle(['color']);\n                var itemHoverStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle();\n                var labelModel = itemModel.getModel('label.normal');\n                var labelHoverModel = itemModel.getModel('label.emphasis');\n                symbolGroup.eachChild(function (symbolPath) {\n                    symbolPath.setStyle(itemStyle);\n                    symbolPath.hoverStyle = zrUtil.clone(itemHoverStyle);\n\n                    var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);\n                    graphic.setText(symbolPath.style, labelModel, color);\n                    symbolPath.setStyle({\n                        text: labelModel.get('show') ? zrUtil.retrieve(\n                            seriesModel.getFormattedLabel(\n                                idx, 'normal', null, symbolPath.__dimIdx\n                            ),\n                            defaultText\n                        ) : ''\n                    });\n\n                    graphic.setText(symbolPath.hoverStyle, labelHoverModel, color);\n                    symbolPath.hoverStyle.text = labelHoverModel.get('show') ? zrUtil.retrieve(\n                        seriesModel.getFormattedLabel(\n                            idx, 'emphasis', null, symbolPath.__dimIdx\n                        ),\n                        defaultText\n                    ) : '';\n                });\n\n                function onEmphasis() {\n                    polygon.attr('ignore', hoverPolygonIgnore);\n                }\n\n                function onNormal() {\n                    polygon.attr('ignore', polygonIgnore);\n                }\n\n                itemGroup.off('mouseover').off('mouseout').off('normal').off('emphasis');\n                itemGroup.on('emphasis', onEmphasis)\n                    .on('mouseover', onEmphasis)\n                    .on('normal', onNormal)\n                    .on('mouseout', onNormal);\n\n                graphic.setHoverStyle(itemGroup);\n            });\n\n            this._data = data;\n        },\n\n        remove: function () {\n            this.group.removeAll();\n            this._data = null;\n        },\n\n        dispose: function () {}\n    });\n\n},{\"../../echarts\":94,\"../../util/graphic\":123,\"../../util/symbol\":127,\"zrender/lib/core/util\":166}],33:[function(require,module,exports){\n// Backward compat for radar chart in 2\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = function (option) {\n        var polarOptArr = option.polar;\n        if (polarOptArr) {\n            if (!zrUtil.isArray(polarOptArr)) {\n                polarOptArr = [polarOptArr];\n            }\n            var polarNotRadar = [];\n            zrUtil.each(polarOptArr, function (polarOpt, idx) {\n                if (polarOpt.indicator) {\n                    if (polarOpt.type && !polarOpt.shape) {\n                        polarOpt.shape = polarOpt.type;\n                    }\n                    option.radar = option.radar || [];\n                    if (!zrUtil.isArray(option.radar)) {\n                        option.radar = [option.radar];\n                    }\n                    option.radar.push(polarOpt);\n                }\n                else {\n                    polarNotRadar.push(polarOpt);\n                }\n            });\n            option.polar = polarNotRadar;\n        }\n        zrUtil.each(option.series, function (seriesOpt) {\n            if (seriesOpt.type === 'radar' && seriesOpt.polarIndex) {\n                seriesOpt.radarIndex = seriesOpt.polarIndex;\n            }\n        });\n    };\n\n},{\"zrender/lib/core/util\":166}],34:[function(require,module,exports){\n\n\n    module.exports = function (ecModel) {\n        ecModel.eachSeriesByType('radar', function (seriesModel) {\n            var data = seriesModel.getData();\n            var points = [];\n            var coordSys = seriesModel.coordinateSystem;\n            if (!coordSys) {\n                return;\n            }\n\n            function pointsConverter(val, idx) {\n                points[idx] = points[idx] || [];\n                points[idx][i] = coordSys.dataToPoint(val, i);\n            }\n            for (var i = 0; i < coordSys.getIndicatorAxes().length; i++) {\n                var dim = data.dimensions[i];\n                data.each(dim, pointsConverter);\n            }\n\n            data.each(function (idx) {\n                // Close polygon\n                points[idx][0] && points[idx].push(points[idx][0].slice());\n                data.setItemLayout(idx, points[idx]);\n            });\n        });\n    };\n\n},{}],35:[function(require,module,exports){\n'use strict';\n// TODO boundaryGap\n\n\n    require('../coord/cartesian/AxisModel');\n\n    require('./axis/AxisView');\n\n},{\"../coord/cartesian/AxisModel\":82,\"./axis/AxisView\":37}],36:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var numberUtil = require('../../util/number');\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = require('zrender/lib/core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTick: function () {\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n\n            if (!axisModel.get('axisTick.show') || axis.isBlank()) {\n                return;\n            }\n\n            var tickModel = axisModel.getModel('axisTick');\n            var opt = this.opt;\n\n            var lineStyleModel = tickModel.getModel('lineStyle');\n            var tickLen = tickModel.get('length');\n\n            var tickInterval = getInterval(tickModel, opt.labelInterval);\n            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n            var ticks = axis.scale.getTicks();\n\n            var pt1 = [];\n            var pt2 = [];\n            var matrix = this._transform;\n\n            for (var i = 0; i < ticksCoords.length; i++) {\n                // Only ordinal scale support tick interval\n                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                     continue;\n                }\n\n                var tickCoord = ticksCoords[i];\n\n                pt1[0] = tickCoord;\n                pt1[1] = 0;\n                pt2[0] = tickCoord;\n                pt2[1] = opt.tickDirection * tickLen;\n\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                // Tick line, Not use group transform to have better line draw\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                    // Id for animation\n                    anid: 'tick_' + ticks[i],\n\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.defaults(\n                        lineStyleModel.getLineStyle(),\n                        {\n                            stroke: axisModel.get('axisLine.lineStyle.color')\n                        }\n                    ),\n                    z2: 2,\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @private\n         */\n        axisLabel: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n            if (!show || axis.isBlank()) {\n                return;\n            }\n\n            var labelModel = axisModel.getModel('axisLabel');\n            var textStyleModel = labelModel.getModel('textStyle');\n            var labelMargin = labelModel.get('margin');\n            var ticks = axis.scale.getTicks();\n            var labels = axisModel.getFormattedLabels();\n\n            // Special label rotate.\n            var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n            // To radian.\n            labelRotation = labelRotation * PI / 180;\n\n            var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n            var categoryData = axisModel.get('data');\n\n            var textEls = [];\n            var silent = isSilent(axisModel);\n            var triggerEvent = axisModel.get('triggerEvent');\n\n            zrUtil.each(ticks, function (tickVal, index) {\n                if (ifIgnoreOnTick(axis, index, opt.labelInterval)) {\n                     return;\n                }\n\n                var itemTextStyleModel = textStyleModel;\n                if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n                    itemTextStyleModel = new Model(\n                        categoryData[tickVal].textStyle, textStyleModel, axisModel.ecModel\n                    );\n                }\n                var textColor = itemTextStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color');\n\n                var tickCoord = axis.dataToCoord(tickVal);\n                var pos = [\n                    tickCoord,\n                    opt.labelOffset + opt.labelDirection * labelMargin\n                ];\n                var labelBeforeFormat = axis.scale.getLabel(tickVal);\n\n                var textEl = new graphic.Text({\n\n                    // Id for animation\n                    anid: 'label_' + tickVal,\n\n                    style: {\n                        text: labels[index],\n                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n                        textFont: itemTextStyleModel.getFont(),\n                        fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n                    },\n                    position: pos,\n                    rotation: labelLayout.rotation,\n                    silent: silent,\n                    z2: 10\n                });\n\n                // Pack data for mouse event\n                if (triggerEvent) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisLabel';\n                    textEl.eventData.value = labelBeforeFormat;\n                }\n\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n\n                textEls.push(textEl);\n                this.group.add(textEl);\n\n                textEl.decomposeTransform();\n\n            }, this);\n\n            function isTwoLabelOverlapped(current, next) {\n                var firstRect = current && current.getBoundingRect().clone();\n                var nextRect = next && next.getBoundingRect().clone();\n                if (firstRect && nextRect) {\n                    firstRect.applyTransform(current.getLocalTransform());\n                    nextRect.applyTransform(next.getLocalTransform());\n                    return firstRect.intersect(nextRect);\n                }\n            }\n\n            // If min or max are user set, we need to check\n            // If the tick on min(max) are overlap on their neighbour tick\n            // If they are overlapped, we need to hide the min(max) tick label\n            if (axisModel.getMin() != null) {\n                var firstLabel = textEls[0];\n                var nextLabel = textEls[1];\n                if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n                    firstLabel.ignore = true;\n                }\n            }\n            if (axisModel.getMax() != null) {\n                var lastLabel = textEls[textEls.length - 1];\n                var prevLabel = textEls[textEls.length - 2];\n                if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n                    lastLabel.ignore = true;\n                }\n            }\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (nameLocation === 'middle') {\n                labelLayout = innerTextLayout(\n                    opt,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                style: {\n                    text: truncatedText,\n                    textFont: textFont,\n                    fill: textStyleModel.getTextColor()\n                        || axisModel.get('axisLine.lineStyle.color'),\n                    textAlign: labelLayout.textAlign,\n                    textVerticalAlign: labelLayout.verticalAlign\n                },\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @inner\n     */\n    function innerTextLayout(opt, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            verticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            verticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            verticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            verticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            verticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            verticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    module.exports = AxisBuilder;\n\n\n},{\"../../model/Model\":100,\"../../util/format\":122,\"../../util/graphic\":123,\"../../util/number\":126,\"zrender/lib/core/util\":166,\"zrender/lib/core/vector\":167}],37:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var AxisBuilder = require('./AxisBuilder');\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n    var selfBuilderAttrs = [\n        'splitArea', 'splitLine'\n    ];\n\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n\n    var AxisView = require('../../echarts').extendComponentView({\n\n        type: 'axis',\n\n        render: function (axisModel, ecModel) {\n\n            this.group.removeAll();\n\n            var oldAxisGroup = this._axisGroup;\n            this._axisGroup = new graphic.Group();\n\n            this.group.add(this._axisGroup);\n\n            if (!axisModel.get('show')) {\n                return;\n            }\n\n            var gridModel = axisModel.getCoordSysModel();\n\n            var layout = layoutAxis(gridModel, axisModel);\n\n            var axisBuilder = new AxisBuilder(axisModel, layout);\n\n            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n            this._axisGroup.add(axisBuilder.getGroup());\n\n            zrUtil.each(selfBuilderAttrs, function (name) {\n                if (axisModel.get(name + '.show')) {\n                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n                }\n            }, this);\n\n            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitLine: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.isBlank()) {\n                return;\n            }\n\n            var splitLineModel = axisModel.getModel('splitLine');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var lineColors = lineStyleModel.get('color');\n\n            var lineInterval = getInterval(splitLineModel, labelInterval);\n\n            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n            var isHorizontal = axis.isHorizontal();\n\n            var lineCount = 0;\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitLineModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var p1 = [];\n            var p2 = [];\n            // Simple optimization\n            // Batching the lines if color are the same\n            var lineStyle = lineStyleModel.getLineStyle();\n            for (var i = 0; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                if (isHorizontal) {\n                    p1[0] = tickCoord;\n                    p1[1] = gridRect.y;\n                    p2[0] = tickCoord;\n                    p2[1] = gridRect.y + gridRect.height;\n                }\n                else {\n                    p1[0] = gridRect.x;\n                    p1[1] = tickCoord;\n                    p2[0] = gridRect.x + gridRect.width;\n                    p2[1] = tickCoord;\n                }\n\n                var colorIndex = (lineCount++) % lineColors.length;\n                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line_' + ticks[i],\n\n                    shape: {\n                        x1: p1[0],\n                        y1: p1[1],\n                        x2: p2[0],\n                        y2: p2[1]\n                    },\n                    style: zrUtil.defaults({\n                        stroke: lineColors[colorIndex]\n                    }, lineStyle),\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitArea: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.isBlank()) {\n                return;\n            }\n\n            var splitAreaModel = axisModel.getModel('splitArea');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n            var areaColors = areaStyleModel.get('color');\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitAreaModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\n            var count = 0;\n\n            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\n            var areaStyle = areaStyleModel.getAreaStyle();\n            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n            for (var i = 1; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                var x;\n                var y;\n                var width;\n                var height;\n                if (axis.isHorizontal()) {\n                    x = prevX;\n                    y = gridRect.y;\n                    width = tickCoord - x;\n                    height = gridRect.height;\n                }\n                else {\n                    x = gridRect.x;\n                    y = prevY;\n                    width = gridRect.width;\n                    height = tickCoord - y;\n                }\n\n                var colorIndex = (count++) % areaColors.length;\n                this._axisGroup.add(new graphic.Rect({\n                    anid: 'area_' + ticks[i],\n\n                    shape: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    style: zrUtil.defaults({\n                        fill: areaColors[colorIndex]\n                    }, areaStyle),\n                    silent: true\n                }));\n\n                prevX = x + width;\n                prevY = y + height;\n            }\n        }\n    });\n\n    AxisView.extend({\n        type: 'xAxis'\n    });\n    AxisView.extend({\n        type: 'yAxis'\n    });\n\n    /**\n     * @inner\n     */\n    function layoutAxis(gridModel, axisModel) {\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\n        var axisOffset = axisModel.get('offset') || 0;\n\n        var posMap = {\n            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n        };\n\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n        // Tick and label direction, x y is axisDim\n        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        if (axis.onZero) {\n            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n        }\n\n        if (axisModel.getModel('axisTick').get('inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (axisModel.getModel('axisLabel').get('inside')) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n\n        // Special label rotation\n        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n\n        return layout;\n    }\n\n},{\"../../echarts\":94,\"../../util/graphic\":123,\"./AxisBuilder\":36,\"zrender/lib/core/util\":166}],38:[function(require,module,exports){\n/**\n * DataZoom component entry\n */\n\n\n    require('./dataZoom/typeDefaulter');\n\n    require('./dataZoom/DataZoomModel');\n    require('./dataZoom/DataZoomView');\n\n    require('./dataZoom/InsideZoomModel');\n    require('./dataZoom/InsideZoomView');\n\n    require('./dataZoom/dataZoomProcessor');\n    require('./dataZoom/dataZoomAction');\n\n\n},{\"./dataZoom/DataZoomModel\":40,\"./dataZoom/DataZoomView\":41,\"./dataZoom/InsideZoomModel\":42,\"./dataZoom/InsideZoomView\":43,\"./dataZoom/dataZoomAction\":44,\"./dataZoom/dataZoomProcessor\":45,\"./dataZoom/typeDefaulter\":48}],39:[function(require,module,exports){\n/**\n * @file Axis operator\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../../util/number');\n    var helper = require('./helper');\n    var each = zrUtil.each;\n    var asc = numberUtil.asc;\n\n    /**\n     * Operate single axis.\n     * One axis can only operated by one axis operator.\n     * Different dataZoomModels may be defined to operate the same axis.\n     * (i.e. 'inside' data zoom and 'slider' data zoom components)\n     * So dataZoomModels share one axisProxy in that case.\n     *\n     * @class\n     */\n    var AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n\n        /**\n         * @private\n         * @type {string}\n         */\n        this._dimName = dimName;\n\n        /**\n         * @private\n         */\n        this._axisIndex = axisIndex;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._valueWindow;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._percentWindow;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._dataExtent;\n\n        /**\n         * @readOnly\n         * @type {module: echarts/model/Global}\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @private\n         * @type {module: echarts/component/dataZoom/DataZoomModel}\n         */\n        this._dataZoomModel = dataZoomModel;\n    };\n\n    AxisProxy.prototype = {\n\n        constructor: AxisProxy,\n\n        /**\n         * Whether the axisProxy is hosted by dataZoomModel.\n         *\n         * @public\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         * @return {boolean}\n         */\n        hostedBy: function (dataZoomModel) {\n            return this._dataZoomModel === dataZoomModel;\n        },\n\n        /**\n         * @return {Array.<number>} Value can only be NaN or finite value.\n         */\n        getDataValueWindow: function () {\n            return this._valueWindow.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getDataPercentWindow: function () {\n            return this._percentWindow.slice();\n        },\n\n        /**\n         * @public\n         * @param {number} axisIndex\n         * @return {Array} seriesModels\n         */\n        getTargetSeriesModels: function () {\n            var seriesModels = [];\n            var ecModel = this.ecModel;\n\n            ecModel.eachSeries(function (seriesModel) {\n                if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n                    var dimName = this._dimName;\n                    var axisModel = ecModel.queryComponents({\n                        mainType: dimName + 'Axis',\n                        index: seriesModel.get(dimName + 'AxisIndex'),\n                        id: seriesModel.get(dimName + 'AxisId')\n                    })[0];\n                    if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n                        seriesModels.push(seriesModel);\n                    }\n                }\n            }, this);\n\n            return seriesModels;\n        },\n\n        getAxisModel: function () {\n            return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n        },\n\n        getOtherAxisModel: function () {\n            var axisDim = this._dimName;\n            var ecModel = this.ecModel;\n            var axisModel = this.getAxisModel();\n            var isCartesian = axisDim === 'x' || axisDim === 'y';\n            var otherAxisDim;\n            var coordSysIndexName;\n            if (isCartesian) {\n                coordSysIndexName = 'gridIndex';\n                otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n            }\n            else {\n                coordSysIndexName = 'polarIndex';\n                otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n            }\n            var foundOtherAxisModel;\n            ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n                if ((otherAxisModel.get(coordSysIndexName) || 0)\n                    === (axisModel.get(coordSysIndexName) || 0)\n                ) {\n                    foundOtherAxisModel = otherAxisModel;\n                }\n            });\n            return foundOtherAxisModel;\n        },\n\n        /**\n         * Only calculate by given range and this._dataExtent, do not change anything.\n         *\n         * @param {Object} opt\n         * @param {number} [opt.start]\n         * @param {number} [opt.end]\n         * @param {number} [opt.startValue]\n         * @param {number} [opt.endValue]\n         */\n        calculateDataWindow: function (opt) {\n            var dataExtent = this._dataExtent;\n            var axisModel = this.getAxisModel();\n            var scale = axisModel.axis.scale;\n            var percentExtent = [0, 100];\n            var percentWindow = [\n                opt.start,\n                opt.end\n            ];\n            var valueWindow = [];\n\n            // In percent range is used and axis min/max/scale is set,\n            // window should be based on min/max/0, but should not be\n            // based on the extent of filtered data.\n            dataExtent = dataExtent.slice();\n            fixExtentByAxis(dataExtent, axisModel);\n\n            each(['startValue', 'endValue'], function (prop) {\n                valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n            });\n\n            // Normalize bound.\n            each([0, 1], function (idx) {\n                var boundValue = valueWindow[idx];\n                var boundPercent = percentWindow[idx];\n\n                // start/end has higher priority over startValue/endValue,\n                // because start/end can be consistent among different type\n                // of axis but startValue/endValue not.\n\n                if (boundPercent != null || boundValue == null) {\n                    if (boundPercent == null) {\n                        boundPercent = percentExtent[idx];\n                    }\n                    // Use scale.parse to math round for category or time axis.\n                    boundValue = scale.parse(numberUtil.linearMap(\n                        boundPercent, percentExtent, dataExtent, true\n                    ));\n                }\n                else { // boundPercent == null && boundValue != null\n                    boundPercent = numberUtil.linearMap(\n                        boundValue, dataExtent, percentExtent, true\n                    );\n                }\n                // valueWindow[idx] = round(boundValue);\n                // percentWindow[idx] = round(boundPercent);\n                valueWindow[idx] = boundValue;\n                percentWindow[idx] = boundPercent;\n            });\n\n            return {\n                valueWindow: asc(valueWindow),\n                percentWindow: asc(percentWindow)\n            };\n        },\n\n        /**\n         * Notice: reset should not be called before series.restoreData() called,\n         * so it is recommanded to be called in \"process stage\" but not \"model init\n         * stage\".\n         *\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        reset: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            // Culculate data window and data extent, and record them.\n            this._dataExtent = calculateDataExtent(\n                this._dimName, this.getTargetSeriesModels()\n            );\n            var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n            this._valueWindow = dataWindow.valueWindow;\n            this._percentWindow = dataWindow.percentWindow;\n\n            // Update axis setting then.\n            setAxisModel(this);\n        },\n\n        /**\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        restore: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            this._valueWindow = this._percentWindow = null;\n            setAxisModel(this, true);\n        },\n\n        /**\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        filterData: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            var axisDim = this._dimName;\n            var seriesModels = this.getTargetSeriesModels();\n            var filterMode = dataZoomModel.get('filterMode');\n            var valueWindow = this._valueWindow;\n\n            // FIXME\n            // Toolbox may has dataZoom injected. And if there are stacked bar chart\n            // with NaN data, NaN will be filtered and stack will be wrong.\n            // So we need to force the mode to be set empty.\n            // In fect, it is not a big deal that do not support filterMode-'filter'\n            // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n            // selection\" some day, which might need \"adapt to data extent on the\n            // otherAxis\", which is disabled by filterMode-'empty'.\n            var otherAxisModel = this.getOtherAxisModel();\n            if (dataZoomModel.get('$fromToolbox')\n                && otherAxisModel\n                && otherAxisModel.get('type') === 'category'\n            ) {\n                filterMode = 'empty';\n            }\n\n            // Process series data\n            each(seriesModels, function (seriesModel) {\n                var seriesData = seriesModel.getData();\n\n                seriesData && each(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n                    if (filterMode === 'empty') {\n                        seriesModel.setData(\n                            seriesData.map(dim, function (value) {\n                                return !isInWindow(value) ? NaN : value;\n                            })\n                        );\n                    }\n                    else {\n                        seriesData.filterSelf(dim, isInWindow);\n                    }\n                });\n            });\n\n            function isInWindow(value) {\n                return value >= valueWindow[0] && value <= valueWindow[1];\n            }\n        }\n    };\n\n    function calculateDataExtent(axisDim, seriesModels) {\n        var dataExtent = [Infinity, -Infinity];\n\n        each(seriesModels, function (seriesModel) {\n            var seriesData = seriesModel.getData();\n            if (seriesData) {\n                each(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n                    var seriesExtent = seriesData.getDataExtent(dim);\n                    seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n                    seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n                });\n            }\n        }, this);\n\n        if (dataExtent[1] < dataExtent[0]) {\n            dataExtent = [NaN, NaN];\n        }\n\n        return dataExtent;\n    }\n\n    function fixExtentByAxis(dataExtent, axisModel) {\n        var min = axisModel.getMin(true);\n        if (min != null && min !== 'dataMin') {\n            dataExtent[0] = min;\n        }\n        var max = axisModel.getMax(true);\n        if (max != null && max !== 'dataMax') {\n            dataExtent[1] = max;\n        }\n\n        if (!axisModel.get('scale', true)) {\n            dataExtent[0] > 0 && (dataExtent[0] = 0);\n            dataExtent[1] < 0 && (dataExtent[1] = 0);\n        }\n\n        return dataExtent;\n    }\n\n    function setAxisModel(axisProxy, isRestore) {\n        var axisModel = axisProxy.getAxisModel();\n\n        var percentWindow = axisProxy._percentWindow;\n        var valueWindow = axisProxy._valueWindow;\n\n        if (!percentWindow) {\n            return;\n        }\n\n        // [0, 500]: arbitrary value, guess axis extent.\n        var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n        // isRestore or isFull\n        var useOrigin = isRestore || (percentWindow[0] === 0 && percentWindow[1] === 100);\n\n        axisModel.setRange(\n            useOrigin ? null : +valueWindow[0].toFixed(precision),\n            useOrigin ? null : +valueWindow[1].toFixed(precision)\n        );\n    }\n\n    module.exports = AxisProxy;\n\n\n},{\"../../util/number\":126,\"./helper\":46,\"zrender/lib/core/util\":166}],40:[function(require,module,exports){\n/**\n * @file Data zoom model\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var env = require('zrender/lib/core/env');\n    var echarts = require('../../echarts');\n    var modelUtil = require('../../util/model');\n    var helper = require('./helper');\n    var AxisProxy = require('./AxisProxy');\n    var each = zrUtil.each;\n    var eachAxisDim = helper.eachAxisDim;\n\n    var DataZoomModel = echarts.extendComponentModel({\n\n        type: 'dataZoom',\n\n        dependencies: [\n            'xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'\n        ],\n\n        /**\n         * @protected\n         */\n        defaultOption: {\n            zlevel: 0,\n            z: 4,                   // Higher than normal component (z: 2).\n            orient: null,           // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n            xAxisIndex: null,       // Default the first horizontal category axis.\n            yAxisIndex: null,       // Default the first vertical category axis.\n\n            filterMode: 'filter',   // Possible values: 'filter' or 'empty'.\n                                    // 'filter': data items which are out of window will be removed.\n                                    //           This option is applicable when filtering outliers.\n                                    // 'empty': data items which are out of window will be set to empty.\n                                    //          This option is applicable when user should not neglect\n                                    //          that there are some data items out of window.\n                                    // Taking line chart as an example, line will be broken in\n                                    // the filtered points when filterModel is set to 'empty', but\n                                    // be connected when set to 'filter'.\n\n            throttle: null,         // Dispatch action by the fixed rate, avoid frequency.\n                                    // default 100. Do not throttle when use null/undefined.\n                                    // If animation === true and animationDurationUpdate > 0,\n                                    // default value is 100, otherwise 20.\n            start: 0,               // Start percent. 0 ~ 100\n            end: 100,               // End percent. 0 ~ 100\n            startValue: null,       // Start value. If startValue specified, start is ignored.\n            endValue: null          // End value. If endValue specified, end is ignored.\n        },\n\n        /**\n         * @override\n         */\n        init: function (option, parentModel, ecModel) {\n\n            /**\n             * key like x_0, y_1\n             * @private\n             * @type {Object}\n             */\n            this._dataIntervalByAxis = {};\n\n            /**\n             * @private\n             */\n            this._dataInfo = {};\n\n            /**\n             * key like x_0, y_1\n             * @private\n             */\n            this._axisProxies = {};\n\n            /**\n             * @readOnly\n             */\n            this.textStyleModel;\n\n            /**\n             * @private\n             */\n            this._autoThrottle = true;\n\n            var rawOption = retrieveRaw(option);\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            this.doInit(rawOption);\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function (newOption) {\n            var rawOption = retrieveRaw(newOption);\n\n            //FIX #2591\n            zrUtil.merge(this.option, newOption, true);\n\n            this.doInit(rawOption);\n        },\n\n        /**\n         * @protected\n         */\n        doInit: function (rawOption) {\n            var thisOption = this.option;\n\n            // Disable realtime view update if canvas is not supported.\n            if (!env.canvasSupported) {\n                thisOption.realtime = false;\n            }\n\n            this._setDefaultThrottle(rawOption);\n\n            processRangeProp('start', 'startValue', rawOption, thisOption);\n            processRangeProp('end', 'endValue', rawOption, thisOption);\n\n            this.textStyleModel = this.getModel('textStyle');\n\n            this._resetTarget();\n\n            this._giveAxisProxies();\n        },\n\n        /**\n         * @private\n         */\n        _giveAxisProxies: function () {\n            var axisProxies = this._axisProxies;\n\n            this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n                var axisModel = this.dependentModels[dimNames.axis][axisIndex];\n\n                // If exists, share axisProxy with other dataZoomModels.\n                var axisProxy = axisModel.__dzAxisProxy || (\n                    // Use the first dataZoomModel as the main model of axisProxy.\n                    axisModel.__dzAxisProxy = new AxisProxy(\n                        dimNames.name, axisIndex, this, ecModel\n                    )\n                );\n                // FIXME\n                // dispose __dzAxisProxy\n\n                axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n            }, this);\n        },\n\n        /**\n         * @private\n         */\n        _resetTarget: function () {\n            var thisOption = this.option;\n\n            var autoMode = this._judgeAutoMode();\n\n            eachAxisDim(function (dimNames) {\n                var axisIndexName = dimNames.axisIndex;\n                thisOption[axisIndexName] = modelUtil.normalizeToArray(\n                    thisOption[axisIndexName]\n                );\n            }, this);\n\n            if (autoMode === 'axisIndex') {\n                this._autoSetAxisIndex();\n            }\n            else if (autoMode === 'orient') {\n                this._autoSetOrient();\n            }\n        },\n\n        /**\n         * @private\n         */\n        _judgeAutoMode: function () {\n            // Auto set only works for setOption at the first time.\n            // The following is user's reponsibility. So using merged\n            // option is OK.\n            var thisOption = this.option;\n\n            var hasIndexSpecified = false;\n            eachAxisDim(function (dimNames) {\n                // When user set axisIndex as a empty array, we think that user specify axisIndex\n                // but do not want use auto mode. Because empty array may be encountered when\n                // some error occured.\n                if (thisOption[dimNames.axisIndex] != null) {\n                    hasIndexSpecified = true;\n                }\n            }, this);\n\n            var orient = thisOption.orient;\n\n            if (orient == null && hasIndexSpecified) {\n                return 'orient';\n            }\n            else if (!hasIndexSpecified) {\n                if (orient == null) {\n                    thisOption.orient = 'horizontal';\n                }\n                return 'axisIndex';\n            }\n        },\n\n        /**\n         * @private\n         */\n        _autoSetAxisIndex: function () {\n            var autoAxisIndex = true;\n            var orient = this.get('orient', true);\n            var thisOption = this.option;\n            var dependentModels = this.dependentModels;\n\n            if (autoAxisIndex) {\n                // Find axis that parallel to dataZoom as default.\n                var dimName = orient === 'vertical' ? 'y' : 'x';\n\n                if (dependentModels[dimName + 'Axis'].length) {\n                    thisOption[dimName + 'AxisIndex'] = [0];\n                    autoAxisIndex = false;\n                }\n                else {\n                    each(dependentModels.singleAxis, function (singleAxisModel) {\n                        if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {\n                            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];\n                            autoAxisIndex = false;\n                        }\n                    });\n                }\n            }\n\n            if (autoAxisIndex) {\n                // Find the first category axis as default. (consider polar)\n                eachAxisDim(function (dimNames) {\n                    if (!autoAxisIndex) {\n                        return;\n                    }\n                    var axisIndices = [];\n                    var axisModels = this.dependentModels[dimNames.axis];\n                    if (axisModels.length && !axisIndices.length) {\n                        for (var i = 0, len = axisModels.length; i < len; i++) {\n                            if (axisModels[i].get('type') === 'category') {\n                                axisIndices.push(i);\n                            }\n                        }\n                    }\n                    thisOption[dimNames.axisIndex] = axisIndices;\n                    if (axisIndices.length) {\n                        autoAxisIndex = false;\n                    }\n                }, this);\n            }\n\n            if (autoAxisIndex) {\n                // FIXME\n                // ec2xAxisIndexyAxisIndexscatterdataZoom\n                // Grid.js#getScaleByOptiontimelogaxis type\n\n                // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n                // dataZoom component auto adopts series that reference to\n                // both xAxis and yAxis which type is 'value'.\n                this.ecModel.eachSeries(function (seriesModel) {\n                    if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n                        eachAxisDim(function (dimNames) {\n                            var axisIndices = thisOption[dimNames.axisIndex];\n\n                            var axisIndex = seriesModel.get(dimNames.axisIndex);\n                            var axisId = seriesModel.get(dimNames.axisId);\n\n                            var axisModel = seriesModel.ecModel.queryComponents({\n                                mainType: dimNames.axis,\n                                index: axisIndex,\n                                id: axisId\n                            })[0];\n\n                            if (__DEV__) {\n                                if (!axisModel) {\n                                    throw new Error(\n                                        dimNames.axis + ' \"' + zrUtil.retrieve(\n                                            axisIndex,\n                                            axisId,\n                                            0\n                                        ) + '\" not found'\n                                    );\n                                }\n                            }\n                            axisIndex = axisModel.componentIndex;\n\n                            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n                                axisIndices.push(axisIndex);\n                            }\n                        });\n                    }\n                }, this);\n            }\n        },\n\n        /**\n         * @private\n         */\n        _autoSetOrient: function () {\n            var dim;\n\n            // Find the first axis\n            this.eachTargetAxis(function (dimNames) {\n                !dim && (dim = dimNames.name);\n            }, this);\n\n            this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n        },\n\n        /**\n         * @private\n         */\n        _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n            // FIXME\n            // seriesxAxisIndexyAxisIndex\n            // series.type === scatter\n\n            var is = true;\n            eachAxisDim(function (dimNames) {\n                var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n                var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n                if (!axisModel || axisModel.get('type') !== axisType) {\n                    is = false;\n                }\n            }, this);\n            return is;\n        },\n\n        /**\n         * @private\n         */\n        _setDefaultThrottle: function (rawOption) {\n            // When first time user set throttle, auto throttle ends.\n            if (rawOption.hasOwnProperty('throttle')) {\n                this._autoThrottle = false;\n            }\n            if (this._autoThrottle) {\n                var globalOption = this.ecModel.option;\n                this.option.throttle =\n                    (globalOption.animation && globalOption.animationDurationUpdate > 0)\n                    ? 100 : 20;\n            }\n        },\n\n        /**\n         * @public\n         */\n        getFirstTargetAxisModel: function () {\n            var firstAxisModel;\n            eachAxisDim(function (dimNames) {\n                if (firstAxisModel == null) {\n                    var indices = this.get(dimNames.axisIndex);\n                    if (indices.length) {\n                        firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n                    }\n                }\n            }, this);\n\n            return firstAxisModel;\n        },\n\n        /**\n         * @public\n         * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n         */\n        eachTargetAxis: function (callback, context) {\n            var ecModel = this.ecModel;\n            eachAxisDim(function (dimNames) {\n                each(\n                    this.get(dimNames.axisIndex),\n                    function (axisIndex) {\n                        callback.call(context, dimNames, axisIndex, this, ecModel);\n                    },\n                    this\n                );\n            }, this);\n        },\n\n        getAxisProxy: function (dimName, axisIndex) {\n            return this._axisProxies[dimName + '_' + axisIndex];\n        },\n\n        /**\n         * If not specified, set to undefined.\n         *\n         * @public\n         * @param {Object} opt\n         * @param {number} [opt.start]\n         * @param {number} [opt.end]\n         * @param {number} [opt.startValue]\n         * @param {number} [opt.endValue]\n         */\n        setRawRange: function (opt) {\n            each(['start', 'end', 'startValue', 'endValue'], function (name) {\n                // If any of those prop is null/undefined, we should alos set\n                // them, because only one pair between start/end and\n                // startValue/endValue can work.\n                this.option[name] = opt[name];\n            }, this);\n        },\n\n        /**\n         * @public\n         * @return {Array.<number>} [startPercent, endPercent]\n         */\n        getPercentRange: function () {\n            var axisProxy = this.findRepresentativeAxisProxy();\n            if (axisProxy) {\n                return axisProxy.getDataPercentWindow();\n            }\n        },\n\n        /**\n         * @public\n         * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n         *\n         * @param {string} [axisDimName]\n         * @param {number} [axisIndex]\n         * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.\n         */\n        getValueRange: function (axisDimName, axisIndex) {\n            if (axisDimName == null && axisIndex == null) {\n                var axisProxy = this.findRepresentativeAxisProxy();\n                if (axisProxy) {\n                    return axisProxy.getDataValueWindow();\n                }\n            }\n            else {\n                return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n            }\n        },\n\n        /**\n         * @public\n         * @return {module:echarts/component/dataZoom/AxisProxy}\n         */\n        findRepresentativeAxisProxy: function () {\n            // Find the first hosted axisProxy\n            var axisProxies = this._axisProxies;\n            for (var key in axisProxies) {\n                if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n                    return axisProxies[key];\n                }\n            }\n\n            // If no hosted axis find not hosted axisProxy.\n            // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n            // and the option.start or option.end settings are different. The percentRange\n            // should follow axisProxy.\n            // (We encounter this problem in toolbox data zoom.)\n            for (var key in axisProxies) {\n                if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n                    return axisProxies[key];\n                }\n            }\n        }\n\n    });\n\n    function retrieveRaw(option) {\n        var ret = {};\n        each(\n            ['start', 'end', 'startValue', 'endValue', 'throttle'],\n            function (name) {\n                option.hasOwnProperty(name) && (ret[name] = option[name]);\n            }\n        );\n        return ret;\n    }\n\n    function processRangeProp(percentProp, valueProp, rawOption, thisOption) {\n        // start/end has higher priority over startValue/endValue,\n        // but we should make chart.setOption({endValue: 1000}) effective,\n        // rather than chart.setOption({endValue: 1000, end: null}).\n        if (rawOption[valueProp] != null && rawOption[percentProp] == null) {\n            thisOption[percentProp] = null;\n        }\n        // Otherwise do nothing and use the merge result.\n    }\n\n    module.exports = DataZoomModel;\n\n\n},{\"../../echarts\":94,\"../../util/model\":125,\"./AxisProxy\":39,\"./helper\":46,\"zrender/lib/core/env\":160,\"zrender/lib/core/util\":166}],41:[function(require,module,exports){\n\n\n    var ComponentView = require('../../view/Component');\n\n    module.exports = ComponentView.extend({\n\n        type: 'dataZoom',\n\n        render: function (dataZoomModel, ecModel, api, payload) {\n            this.dataZoomModel = dataZoomModel;\n            this.ecModel = ecModel;\n            this.api = api;\n        },\n\n        /**\n         * Find the first target coordinate system.\n         *\n         * @protected\n         * @return {Object} {\n         *                   grid: [\n         *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n         *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n         *                       ...\n         *                   ],  // cartesians must not be null/undefined.\n         *                   polar: [\n         *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n         *                       ...\n         *                   ],  // polars must not be null/undefined.\n         *                   singleAxis: [\n         *                       {model: coord0, axisModels: [], coordIndex: 0}\n         *                   ]\n         */\n        getTargetCoordInfo: function () {\n            var dataZoomModel = this.dataZoomModel;\n            var ecModel = this.ecModel;\n            var coordSysLists = {};\n\n            dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n                var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n                if (axisModel) {\n                    var coordModel = axisModel.getCoordSysModel();\n                    coordModel && save(\n                        coordModel,\n                        axisModel,\n                        coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []),\n                        coordModel.componentIndex\n                    );\n                }\n            }, this);\n\n            function save(coordModel, axisModel, store, coordIndex) {\n                var item;\n                for (var i = 0; i < store.length; i++) {\n                    if (store[i].model === coordModel) {\n                        item = store[i];\n                        break;\n                    }\n                }\n                if (!item) {\n                    store.push(item = {\n                        model: coordModel, axisModels: [], coordIndex: coordIndex\n                    });\n                }\n                item.axisModels.push(axisModel);\n            }\n\n            return coordSysLists;\n        }\n\n    });\n\n\n},{\"../../view/Component\":130}],42:[function(require,module,exports){\n/**\n * @file Data zoom model\n */\n\n\n    module.exports = require('./DataZoomModel').extend({\n\n        type: 'dataZoom.inside',\n\n        /**\n         * @protected\n         */\n        defaultOption: {\n            disabled: false,   // Whether disable this inside zoom.\n            zoomLock: false  // Whether disable zoom but only pan.\n        }\n    });\n\n},{\"./DataZoomModel\":40}],43:[function(require,module,exports){\n\n\n    var DataZoomView = require('./DataZoomView');\n    var zrUtil = require('zrender/lib/core/util');\n    var sliderMove = require('../helper/sliderMove');\n    var roams = require('./roams');\n    var bind = zrUtil.bind;\n\n    var InsideZoomView = DataZoomView.extend({\n\n        type: 'dataZoom.inside',\n\n        /**\n         * @override\n         */\n        init: function (ecModel, api) {\n            /**\n             * 'throttle' is used in this.dispatchAction, so we save range\n             * to avoid missing some 'pan' info.\n             * @private\n             * @type {Array.<number>}\n             */\n            this._range;\n        },\n\n        /**\n         * @override\n         */\n        render: function (dataZoomModel, ecModel, api, payload) {\n            InsideZoomView.superApply(this, 'render', arguments);\n\n            // Notice: origin this._range should be maintained, and should not be re-fetched\n            // from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'\n            // info will be missed because of 'throttle' of this.dispatchAction.\n            if (roams.shouldRecordRange(payload, dataZoomModel.id)) {\n                this._range = dataZoomModel.getPercentRange();\n            }\n\n            // Reset controllers.\n            zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) {\n\n                var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {\n                    return roams.generateCoordId(coordInfo.model);\n                });\n\n                zrUtil.each(coordInfoList, function (coordInfo) {\n                    var coordModel = coordInfo.model;\n\n                    roams.register(\n                        api,\n                        {\n                            coordId: roams.generateCoordId(coordModel),\n                            allCoordIds: allCoordIds,\n                            containsPoint: function (x, y) {\n                                return coordModel.coordinateSystem.containPoint([x, y]);\n                            },\n                            dataZoomId: dataZoomModel.id,\n                            throttleRate: dataZoomModel.get('throttle', true),\n                            panGetRange: bind(this._onPan, this, coordInfo, coordSysName),\n                            zoomGetRange: bind(this._onZoom, this, coordInfo, coordSysName)\n                        }\n                    );\n                }, this);\n\n            }, this);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function () {\n            roams.unregister(this.api, this.dataZoomModel.id);\n            InsideZoomView.superApply(this, 'dispose', arguments);\n            this._range = null;\n        },\n\n        /**\n         * @private\n         */\n        _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) {\n            if (this.dataZoomModel.option.disabled) {\n                return this._range;\n            }\n\n            var range = this._range.slice();\n\n            // Calculate transform by the first axis.\n            var axisModel = coordInfo.axisModels[0];\n            if (!axisModel) {\n                return;\n            }\n\n            var directionInfo = getDirectionInfo[coordSysName](\n                [oldX, oldY], [newX, newY], axisModel, controller, coordInfo\n            );\n\n            var percentDelta = directionInfo.signal\n                * (range[1] - range[0])\n                * directionInfo.pixel / directionInfo.pixelLength;\n\n            sliderMove(percentDelta, range, [0, 100], 'rigid');\n\n            return (this._range = range);\n        },\n\n        /**\n         * @private\n         */\n        _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) {\n            var option = this.dataZoomModel.option;\n\n            if (option.disabled || option.zoomLock) {\n                return this._range;\n            }\n\n            var range = this._range.slice();\n\n            // Calculate transform by the first axis.\n            var axisModel = coordInfo.axisModels[0];\n            if (!axisModel) {\n                return;\n            }\n\n            var directionInfo = getDirectionInfo[coordSysName](\n                null, [mouseX, mouseY], axisModel, controller, coordInfo\n            );\n\n            var percentPoint = (directionInfo.pixel - directionInfo.pixelStart) /\n                directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n\n            scale = Math.max(1 / scale, 0);\n            range[0] = (range[0] - percentPoint) * scale + percentPoint;\n            range[1] = (range[1] - percentPoint) * scale + percentPoint;\n            return (this._range = fixRange(range));\n        }\n\n    });\n\n    var getDirectionInfo = {\n\n        grid: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n            var axis = axisModel.axis;\n            var ret = {};\n            var rect = coordInfo.model.coordinateSystem.getRect();\n            oldPoint = oldPoint || [0, 0];\n\n            if (axis.dim === 'x') {\n                ret.pixel = newPoint[0] - oldPoint[0];\n                ret.pixelLength = rect.width;\n                ret.pixelStart = rect.x;\n                ret.signal = axis.inverse ? 1 : -1;\n            }\n            else { // axis.dim === 'y'\n                ret.pixel = newPoint[1] - oldPoint[1];\n                ret.pixelLength = rect.height;\n                ret.pixelStart = rect.y;\n                ret.signal = axis.inverse ? -1 : 1;\n            }\n\n            return ret;\n        },\n\n        polar: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n            var axis = axisModel.axis;\n            var ret = {};\n            var polar = coordInfo.model.coordinateSystem;\n            var radiusExtent = polar.getRadiusAxis().getExtent();\n            var angleExtent = polar.getAngleAxis().getExtent();\n\n            oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n            newPoint = polar.pointToCoord(newPoint);\n\n            if (axisModel.mainType === 'radiusAxis') {\n                ret.pixel = newPoint[0] - oldPoint[0];\n                // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);\n                // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);\n                ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n                ret.pixelStart = radiusExtent[0];\n                ret.signal = axis.inverse ? 1 : -1;\n            }\n            else { // 'angleAxis'\n                ret.pixel = newPoint[1] - oldPoint[1];\n                // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);\n                // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);\n                ret.pixelLength = angleExtent[1] - angleExtent[0];\n                ret.pixelStart = angleExtent[0];\n                ret.signal = axis.inverse ? -1 : 1;\n            }\n\n            return ret;\n        },\n\n        singleAxis: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n            var axis = axisModel.axis;\n            var rect = coordInfo.model.coordinateSystem.getRect();\n            var ret = {};\n\n            oldPoint = oldPoint || [0, 0];\n\n            if (axis.orient === 'horizontal') {\n                ret.pixel = newPoint[0] - oldPoint[0];\n                ret.pixelLength = rect.width;\n                ret.pixelStart = rect.x;\n                ret.signal = axis.inverse ? 1 : -1;\n            }\n            else { // 'vertical'\n                ret.pixel = newPoint[1] - oldPoint[1];\n                ret.pixelLength = rect.height;\n                ret.pixelStart = rect.y;\n                ret.signal = axis.inverse ? -1 : 1;\n            }\n\n            return ret;\n        }\n    };\n\n    function fixRange(range) {\n        // Clamp, using !(<= or >=) to handle NaN.\n        // jshint ignore:start\n        var bound = [0, 100];\n        !(range[0] <= bound[1]) && (range[0] = bound[1]);\n        !(range[1] <= bound[1]) && (range[1] = bound[1]);\n        !(range[0] >= bound[0]) && (range[0] = bound[0]);\n        !(range[1] >= bound[0]) && (range[1] = bound[0]);\n        // jshint ignore:end\n\n        return range;\n    }\n\n    module.exports = InsideZoomView;\n\n},{\"../helper/sliderMove\":54,\"./DataZoomView\":41,\"./roams\":47,\"zrender/lib/core/util\":166}],44:[function(require,module,exports){\n/**\n * @file Data zoom action\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var helper = require('./helper');\n    var echarts = require('../../echarts');\n\n\n    echarts.registerAction('dataZoom', function (payload, ecModel) {\n\n        var linkedNodesFinder = helper.createLinkedNodesFinder(\n            zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'),\n            helper.eachAxisDim,\n            function (model, dimNames) {\n                return model.get(dimNames.axisIndex);\n            }\n        );\n\n        var effectedModels = [];\n\n        ecModel.eachComponent(\n            {mainType: 'dataZoom', query: payload},\n            function (model, index) {\n                effectedModels.push.apply(\n                    effectedModels, linkedNodesFinder(model).nodes\n                );\n            }\n        );\n\n        zrUtil.each(effectedModels, function (dataZoomModel, index) {\n            dataZoomModel.setRawRange({\n                start: payload.start,\n                end: payload.end,\n                startValue: payload.startValue,\n                endValue: payload.endValue\n            });\n        });\n\n    });\n\n\n},{\"../../echarts\":94,\"./helper\":46,\"zrender/lib/core/util\":166}],45:[function(require,module,exports){\n/**\n * @file Data zoom processor\n */\n\n\n    var echarts = require('../../echarts');\n\n    echarts.registerProcessor(function (ecModel, api) {\n\n        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n            // We calculate window and reset axis here but not in model\n            // init stage and not after action dispatch handler, because\n            // reset should be called after seriesData.restoreData.\n            dataZoomModel.eachTargetAxis(resetSingleAxis);\n\n            // Caution: data zoom filtering is order sensitive when using\n            // percent range and no min/max/scale set on axis.\n            // For example, we have dataZoom definition:\n            // [\n            //      {xAxisIndex: 0, start: 30, end: 70},\n            //      {yAxisIndex: 0, start: 20, end: 80}\n            // ]\n            // In this case, [20, 80] of y-dataZoom should be based on data\n            // that have filtered by x-dataZoom using range of [30, 70],\n            // but should not be based on full raw data. Thus sliding\n            // x-dataZoom will change both ranges of xAxis and yAxis,\n            // while sliding y-dataZoom will only change the range of yAxis.\n            // So we should filter x-axis after reset x-axis immediately,\n            // and then reset y-axis and filter y-axis.\n            dataZoomModel.eachTargetAxis(filterSingleAxis);\n        });\n\n        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n            // Fullfill all of the range props so that user\n            // is able to get them from chart.getOption().\n            var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n            var percentRange = axisProxy.getDataPercentWindow();\n            var valueRange = axisProxy.getDataValueWindow();\n\n            dataZoomModel.setRawRange({\n                start: percentRange[0],\n                end: percentRange[1],\n                startValue: valueRange[0],\n                endValue: valueRange[1]\n            });\n        });\n    });\n\n    function resetSingleAxis(dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);\n    }\n\n    function filterSingleAxis(dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);\n    }\n\n\n\n},{\"../../echarts\":94}],46:[function(require,module,exports){\n\n    var formatUtil = require('../../util/format');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var helper = {};\n\n    var AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single'];\n    // Supported coords.\n    var COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n\n    /**\n     * @param {string} coordType\n     * @return {boolean}\n     */\n    helper.isCoordSupported = function (coordType) {\n        return zrUtil.indexOf(COORDS, coordType) >= 0;\n    };\n\n    /**\n     * Create \"each\" method to iterate names.\n     *\n     * @pubilc\n     * @param  {Array.<string>} names\n     * @param  {Array.<string>=} attrs\n     * @return {Function}\n     */\n    helper.createNameEach = function (names, attrs) {\n        names = names.slice();\n        var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n        attrs = (attrs || []).slice();\n        var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n\n        return function (callback, context) {\n            zrUtil.each(names, function (name, index) {\n                var nameObj = {name: name, capital: capitalNames[index]};\n\n                for (var j = 0; j < attrs.length; j++) {\n                    nameObj[attrs[j]] = name + capitalAttrs[j];\n                }\n\n                callback.call(context, nameObj);\n            });\n        };\n    };\n\n    /**\n     * Iterate each dimension name.\n     *\n     * @public\n     * @param {Function} callback The parameter is like:\n     *                            {\n     *                                name: 'angle',\n     *                                capital: 'Angle',\n     *                                axis: 'angleAxis',\n     *                                axisIndex: 'angleAixs',\n     *                                index: 'angleIndex'\n     *                            }\n     * @param {Object} context\n     */\n    helper.eachAxisDim = helper.createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n\n    /**\n     * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n     * dataZoomModels and 'links' make up one or more graphics.\n     * This function finds the graphic where the source dataZoomModel is in.\n     *\n     * @public\n     * @param {Function} forEachNode Node iterator.\n     * @param {Function} forEachEdgeType edgeType iterator\n     * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n     * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n     */\n    helper.createLinkedNodesFinder = function (forEachNode, forEachEdgeType, edgeIdGetter) {\n\n        return function (sourceNode) {\n            var result = {\n                nodes: [],\n                records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n            };\n\n            forEachEdgeType(function (edgeType) {\n                result.records[edgeType.name] = {};\n            });\n\n            if (!sourceNode) {\n                return result;\n            }\n\n            absorb(sourceNode, result);\n\n            var existsLink;\n            do {\n                existsLink = false;\n                forEachNode(processSingleNode);\n            }\n            while (existsLink);\n\n            function processSingleNode(node) {\n                if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n                    absorb(node, result);\n                    existsLink = true;\n                }\n            }\n\n            return result;\n        };\n\n        function isNodeAbsorded(node, result) {\n            return zrUtil.indexOf(result.nodes, node) >= 0;\n        }\n\n        function isLinked(node, result) {\n            var hasLink = false;\n            forEachEdgeType(function (edgeType) {\n                zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n                    result.records[edgeType.name][edgeId] && (hasLink = true);\n                });\n            });\n            return hasLink;\n        }\n\n        function absorb(node, result) {\n            result.nodes.push(node);\n            forEachEdgeType(function (edgeType) {\n                zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n                    result.records[edgeType.name][edgeId] = true;\n                });\n            });\n        }\n    };\n\n    module.exports = helper;\n\n},{\"../../util/format\":122,\"zrender/lib/core/util\":166}],47:[function(require,module,exports){\n/**\n * @file Roam controller manager.\n */\n\n\n    // Only create one roam controller for each coordinate system.\n    // one roam controller might be refered by two inside data zoom\n    // components (for example, one for x and one for y). When user\n    // pan or zoom, only dispatch one action for those data zoom\n    // components.\n\n    var zrUtil = require('zrender/lib/core/util');\n    var RoamController = require('../../component/helper/RoamController');\n    var throttle = require('../../util/throttle');\n    var curry = zrUtil.curry;\n\n    var ATTR = '\\0_ec_dataZoom_roams';\n\n    var roams = {\n\n        /**\n         * @public\n         * @param {module:echarts/ExtensionAPI} api\n         * @param {Object} dataZoomInfo\n         * @param {string} dataZoomInfo.coordId\n         * @param {Function} dataZoomInfo.containsPoint\n         * @param {Array.<string>} dataZoomInfo.allCoordIds\n         * @param {string} dataZoomInfo.dataZoomId\n         * @param {number} dataZoomInfo.throttleRate\n         * @param {Function} dataZoomInfo.panGetRange\n         * @param {Function} dataZoomInfo.zoomGetRange\n         */\n        register: function (api, dataZoomInfo) {\n            var store = giveStore(api);\n            var theDataZoomId = dataZoomInfo.dataZoomId;\n            var theCoordId = dataZoomInfo.coordId;\n\n            // Do clean when a dataZoom changes its target coordnate system.\n            // Avoid memory leak, dispose all not-used-registered.\n            zrUtil.each(store, function (record, coordId) {\n                var dataZoomInfos = record.dataZoomInfos;\n                if (dataZoomInfos[theDataZoomId]\n                    && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0\n                ) {\n                    delete dataZoomInfos[theDataZoomId];\n                    record.count--;\n                }\n            });\n\n            cleanStore(store);\n\n            var record = store[theCoordId];\n            // Create if needed.\n            if (!record) {\n                record = store[theCoordId] = {\n                    coordId: theCoordId,\n                    dataZoomInfos: {},\n                    count: 0\n                };\n                record.controller = createController(api, dataZoomInfo, record);\n                record.dispatchAction = zrUtil.curry(dispatchAction, api);\n            }\n\n            // Consider resize, area should be always updated.\n            record.controller.setContainsPoint(dataZoomInfo.containsPoint);\n\n            // Update throttle.\n            throttle.createOrUpdate(\n                record,\n                'dispatchAction',\n                dataZoomInfo.throttleRate,\n                'fixRate'\n            );\n\n            // Update reference of dataZoom.\n            !(record.dataZoomInfos[theDataZoomId]) && record.count++;\n            record.dataZoomInfos[theDataZoomId] = dataZoomInfo;\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/ExtensionAPI} api\n         * @param {string} dataZoomId\n         */\n        unregister: function (api, dataZoomId) {\n            var store = giveStore(api);\n\n            zrUtil.each(store, function (record) {\n                record.controller.dispose();\n                var dataZoomInfos = record.dataZoomInfos;\n                if (dataZoomInfos[dataZoomId]) {\n                    delete dataZoomInfos[dataZoomId];\n                    record.count--;\n                }\n            });\n\n            cleanStore(store);\n        },\n\n        /**\n         * @public\n         */\n        shouldRecordRange: function (payload, dataZoomId) {\n            if (payload && payload.type === 'dataZoom' && payload.batch) {\n                for (var i = 0, len = payload.batch.length; i < len; i++) {\n                    if (payload.batch[i].dataZoomId === dataZoomId) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        },\n\n        /**\n         * @public\n         */\n        generateCoordId: function (coordModel) {\n            return coordModel.type + '\\0_' + coordModel.id;\n        }\n    };\n\n    /**\n     * Key: coordId, value: {dataZoomInfos: [], count, controller}\n     * @type {Array.<Object>}\n     */\n    function giveStore(api) {\n        // Mount store on zrender instance, so that we do not\n        // need to worry about dispose.\n        var zr = api.getZr();\n        return zr[ATTR] || (zr[ATTR] = {});\n    }\n\n    function createController(api, dataZoomInfo, newRecord) {\n        var controller = new RoamController(api.getZr());\n        controller.enable();\n        controller.on('pan', curry(onPan, newRecord));\n        controller.on('zoom', curry(onZoom, newRecord));\n\n        return controller;\n    }\n\n    function cleanStore(store) {\n        zrUtil.each(store, function (record, coordId) {\n            if (!record.count) {\n                record.controller.dispose();\n                delete store[coordId];\n            }\n        });\n    }\n\n    function onPan(record, dx, dy, oldX, oldY, newX, newY) {\n        wrapAndDispatch(record, function (info) {\n            return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY);\n        });\n    }\n\n    function onZoom(record, scale, mouseX, mouseY) {\n        wrapAndDispatch(record, function (info) {\n            return info.zoomGetRange(record.controller, scale, mouseX, mouseY);\n        });\n    }\n\n    function wrapAndDispatch(record, getRange) {\n        var batch = [];\n\n        zrUtil.each(record.dataZoomInfos, function (info) {\n            var range = getRange(info);\n            range && batch.push({\n                dataZoomId: info.dataZoomId,\n                start: range[0],\n                end: range[1]\n            });\n        });\n\n        record.dispatchAction(batch);\n    }\n\n    /**\n     * This action will be throttled.\n     */\n    function dispatchAction(api, batch) {\n        api.dispatchAction({\n            type: 'dataZoom',\n            batch: batch\n        });\n    }\n\n    module.exports = roams;\n\n\n},{\"../../component/helper/RoamController\":50,\"../../util/throttle\":128,\"zrender/lib/core/util\":166}],48:[function(require,module,exports){\n\n\n    require('../../model/Component').registerSubTypeDefaulter('dataZoom', function (option) {\n        // Default 'slider' when no type specified.\n        return 'slider';\n    });\n\n\n},{\"../../model/Component\":98}],49:[function(require,module,exports){\n'use strict';\n\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('../coord/cartesian/Grid');\n\n    require('./axis');\n\n    // Grid view\n    echarts.extendComponentView({\n\n        type: 'grid',\n\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({\n                        fill: gridModel.get('backgroundColor')\n                    }, gridModel.getItemStyle()),\n                    silent: true,\n                    z2: -1\n                }));\n            }\n        }\n\n    });\n\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n\n},{\"../coord/cartesian/Grid\":85,\"../echarts\":94,\"../util/graphic\":123,\"./axis\":35,\"zrender/lib/core/util\":166}],50:[function(require,module,exports){\n/**\n * @module echarts/component/helper/RoamController\n */\n\n\n\n    var Eventful = require('zrender/lib/mixin/Eventful');\n    var zrUtil = require('zrender/lib/core/util');\n    var eventTool = require('zrender/lib/core/event');\n    var interactionMutex = require('./interactionMutex');\n\n    function mousedown(e) {\n        if (e.target && e.target.draggable) {\n            return;\n        }\n\n        var x = e.offsetX;\n        var y = e.offsetY;\n\n        if (this.containsPoint && this.containsPoint(x, y)) {\n            this._x = x;\n            this._y = y;\n            this._dragging = true;\n        }\n    }\n\n    function mousemove(e) {\n        if (!this._dragging) {\n            return;\n        }\n\n        eventTool.stop(e.event);\n\n        if (e.gestureEvent !== 'pinch') {\n\n            if (interactionMutex.isTaken(this._zr, 'globalPan')) {\n                return;\n            }\n\n            var x = e.offsetX;\n            var y = e.offsetY;\n\n            var oldX = this._x;\n            var oldY = this._y;\n\n            var dx = x - oldX;\n            var dy = y - oldY;\n\n            this._x = x;\n            this._y = y;\n\n            var target = this.target;\n\n            if (target) {\n                var pos = target.position;\n                pos[0] += dx;\n                pos[1] += dy;\n                target.dirty();\n            }\n\n            eventTool.stop(e.event);\n            this.trigger('pan', dx, dy, oldX, oldY, x, y);\n        }\n    }\n\n    function mouseup(e) {\n        this._dragging = false;\n    }\n\n    function mousewheel(e) {\n        // Convenience:\n        // Mac and VM Windows on Mac: scroll up: zoom out.\n        // Windows: scroll up: zoom in.\n        var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\n        zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);\n    }\n\n    function pinch(e) {\n        if (interactionMutex.isTaken(this._zr, 'globalPan')) {\n            return;\n        }\n        var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;\n        zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);\n    }\n\n    function zoom(e, zoomDelta, zoomX, zoomY) {\n        if (this.containsPoint && this.containsPoint(zoomX, zoomY)) {\n            // When mouse is out of roamController rect,\n            // default befavoius should be be disabled, otherwise\n            // page sliding is disabled, contrary to expectation.\n            eventTool.stop(e.event);\n\n            var target = this.target;\n            var zoomLimit = this.zoomLimit;\n\n            if (target) {\n                var pos = target.position;\n                var scale = target.scale;\n\n                var newZoom = this.zoom = this.zoom || 1;\n                newZoom *= zoomDelta;\n                if (zoomLimit) {\n                    var zoomMin = zoomLimit.min || 0;\n                    var zoomMax = zoomLimit.max || Infinity;\n                    newZoom = Math.max(\n                        Math.min(zoomMax, newZoom),\n                        zoomMin\n                    );\n                }\n                var zoomScale = newZoom / this.zoom;\n                this.zoom = newZoom;\n                // Keep the mouse center when scaling\n                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\n                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\n                scale[0] *= zoomScale;\n                scale[1] *= zoomScale;\n\n                target.dirty();\n            }\n\n            this.trigger('zoom', zoomDelta, zoomX, zoomY);\n        }\n    }\n\n    /**\n     * @alias module:echarts/component/helper/RoamController\n     * @constructor\n     * @mixin {module:zrender/mixin/Eventful}\n     *\n     * @param {module:zrender/zrender~ZRender} zr\n     * @param {module:zrender/Element} target\n     */\n    function RoamController(zr, target) {\n\n        /**\n         * @type {module:zrender/Element}\n         */\n        this.target = target;\n\n        /**\n         * @type {Function}\n         */\n        this.containsPoint;\n\n        /**\n         * { min: 1, max: 2 }\n         * @type {Object}\n         */\n        this.zoomLimit;\n\n        /**\n         * @type {number}\n         */\n        this.zoom;\n        /**\n         * @type {module:zrender}\n         */\n        this._zr = zr;\n\n        // Avoid two roamController bind the same handler\n        var bind = zrUtil.bind;\n        var mousedownHandler = bind(mousedown, this);\n        var mousemoveHandler = bind(mousemove, this);\n        var mouseupHandler = bind(mouseup, this);\n        var mousewheelHandler = bind(mousewheel, this);\n        var pinchHandler = bind(pinch, this);\n\n        Eventful.call(this);\n\n        /**\n         * @param {Function} containsPoint\n         *                   input: x, y\n         *                   output: boolean\n         */\n        this.setContainsPoint = function (containsPoint) {\n            this.containsPoint = containsPoint;\n        };\n\n        /**\n         * Notice: only enable needed types. For example, if 'zoom'\n         * is not needed, 'zoom' should not be enabled, otherwise\n         * default mousewheel behaviour (scroll page) will be disabled.\n         *\n         * @param  {boolean|string} [controlType=true] Specify the control type,\n         *                          which can be null/undefined or true/false\n         *                          or 'pan/move' or 'zoom'/'scale'\n         */\n        this.enable = function (controlType) {\n            // Disable previous first\n            this.disable();\n\n            if (controlType == null) {\n                controlType = true;\n            }\n\n            if (controlType === true || (controlType === 'move' || controlType === 'pan')) {\n                zr.on('mousedown', mousedownHandler);\n                zr.on('mousemove', mousemoveHandler);\n                zr.on('mouseup', mouseupHandler);\n            }\n            if (controlType === true || (controlType === 'scale' || controlType === 'zoom')) {\n                zr.on('mousewheel', mousewheelHandler);\n                zr.on('pinch', pinchHandler);\n            }\n        };\n\n        this.disable = function () {\n            zr.off('mousedown', mousedownHandler);\n            zr.off('mousemove', mousemoveHandler);\n            zr.off('mouseup', mouseupHandler);\n            zr.off('mousewheel', mousewheelHandler);\n            zr.off('pinch', pinchHandler);\n        };\n\n        this.dispose = this.disable;\n\n        this.isDragging = function () {\n            return this._dragging;\n        };\n\n        this.isPinching = function () {\n            return this._pinching;\n        };\n    }\n\n    zrUtil.mixin(RoamController, Eventful);\n\n    module.exports = RoamController;\n\n},{\"./interactionMutex\":51,\"zrender/lib/core/event\":161,\"zrender/lib/core/util\":166,\"zrender/lib/mixin/Eventful\":195}],51:[function(require,module,exports){\n\n\n    var ATTR = '\\0_ec_interaction_mutex';\n\n    var interactionMutex = {\n\n        take: function (zr, resourceKey, userKey) {\n            var store = getStore(zr);\n            store[resourceKey] = userKey;\n        },\n\n        release: function (zr, resourceKey, userKey) {\n            var store = getStore(zr);\n            var uKey = store[resourceKey];\n\n            if (uKey === userKey) {\n                store[resourceKey] = null;\n            }\n        },\n\n        isTaken: function (zr, resourceKey) {\n            return !!getStore(zr)[resourceKey];\n        }\n    };\n\n    function getStore(zr) {\n        return zr[ATTR] || (zr[ATTR] = {});\n    }\n\n    /**\n     * payload: {\n     *     type: 'takeGlobalCursor',\n     *     key: 'dataZoomSelect', or 'brush', or ...,\n     *         If no userKey, release global cursor.\n     * }\n     */\n    require('../../echarts').registerAction(\n        {type: 'takeGlobalCursor', event: 'globalCursorTaken', update: 'update'},\n        function () {}\n    );\n\n    module.exports = interactionMutex;\n\n},{\"../../echarts\":94}],52:[function(require,module,exports){\n\n    // List layout\n    var layout = require('../../util/layout');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n\n    function positionGroup(group, model, api) {\n        layout.positionElement(\n            group, model.getBoxLayoutParams(),\n            {\n                width: api.getWidth(),\n                height: api.getHeight()\n            },\n            model.get('padding')\n        );\n    }\n\n    module.exports = {\n        /**\n         * Layout list like component.\n         * It will box layout each items in group of component and then position the whole group in the viewport\n         * @param {module:zrender/group/Group} group\n         * @param {module:echarts/model/Component} componentModel\n         * @param {module:echarts/ExtensionAPI}\n         */\n        layout: function (group, componentModel, api) {\n            var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }, componentModel.get('padding'));\n            layout.box(\n                componentModel.get('orient'),\n                group,\n                componentModel.get('itemGap'),\n                rect.width,\n                rect.height\n            );\n\n            positionGroup(group, componentModel, api);\n        },\n\n        addBackground: function (group, componentModel) {\n            var padding = formatUtil.normalizeCssArray(\n                componentModel.get('padding')\n            );\n            var boundingRect = group.getBoundingRect();\n            var style = componentModel.getItemStyle(['color', 'opacity']);\n            style.fill = componentModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: boundingRect.x - padding[3],\n                    y: boundingRect.y - padding[0],\n                    width: boundingRect.width + padding[1] + padding[3],\n                    height: boundingRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true,\n                z2: -1\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    };\n\n},{\"../../util/format\":122,\"../../util/graphic\":123,\"../../util/layout\":124}],53:[function(require,module,exports){\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n *\n * @module echarts/chart/helper/DataSelectable\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = {\n\n        updateSelectedMap: function (targetList) {\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap[target.name] = target;\n                return targetMap;\n            }, {});\n        },\n        /**\n         * @param {string} name\n         */\n        // PENGING If selectedMode is null ?\n        select: function (name) {\n            var targetMap = this._selectTargetMap;\n            var target = targetMap[name];\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                zrUtil.each(targetMap, function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            var target = this._selectTargetMap[name];\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name);\n                return target.selected;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            return target && target.selected;\n        }\n    };\n\n},{\"zrender/lib/core/util\":166}],54:[function(require,module,exports){\n\n\n    /**\n     * Calculate slider move result.\n     *\n     * @param {number} delta Move length.\n     * @param {Array.<number>} handleEnds handleEnds[0] and be bigger then handleEnds[1].\n     *                                    handleEnds will be modified in this method.\n     * @param {Array.<number>} extent handleEnds is restricted by extent.\n     *                                extent[0] should less or equals than extent[1].\n     * @param {string} mode 'rigid': Math.abs(handleEnds[0] - handleEnds[1]) remain unchanged,\n     *                      'cross' handleEnds[0] can be bigger then handleEnds[1],\n     *                      'push' handleEnds[0] can not be bigger then handleEnds[1],\n     *                              when they touch, one push other.\n     * @param {number} handleIndex If mode is 'rigid', handleIndex is not required.\n     * @param {Array.<number>} The input handleEnds.\n     */\n    module.exports = function (delta, handleEnds, extent, mode, handleIndex) {\n        if (!delta) {\n            return handleEnds;\n        }\n\n        if (mode === 'rigid') {\n            delta = getRealDelta(delta, handleEnds, extent);\n            handleEnds[0] += delta;\n            handleEnds[1] += delta;\n        }\n        else {\n            delta = getRealDelta(delta, handleEnds[handleIndex], extent);\n            handleEnds[handleIndex] += delta;\n\n            if (mode === 'push' && handleEnds[0] > handleEnds[1]) {\n                handleEnds[1 - handleIndex] = handleEnds[handleIndex];\n            }\n        }\n\n        return handleEnds;\n\n        function getRealDelta(delta, handleEnds, extent) {\n            var handleMinMax = !handleEnds.length\n                ? [handleEnds, handleEnds]\n                : handleEnds.slice();\n            handleEnds[0] > handleEnds[1] && handleMinMax.reverse();\n\n            if (delta < 0 && handleMinMax[0] + delta < extent[0]) {\n                delta = extent[0] - handleMinMax[0];\n            }\n            if (delta > 0 && handleMinMax[1] + delta > extent[1]) {\n                delta = extent[1] - handleMinMax[1];\n            }\n            return delta;\n        }\n    };\n\n},{}],55:[function(require,module,exports){\n/**\n * Legend component entry file8\n */\n\n\n    require('./legend/LegendModel');\n    require('./legend/legendAction');\n    require('./legend/LegendView');\n\n    var echarts = require('../echarts');\n    // Series Filter\n    echarts.registerProcessor(require('./legend/legendFilter'));\n\n},{\"../echarts\":94,\"./legend/LegendModel\":56,\"./legend/LegendView\":57,\"./legend/legendAction\":58,\"./legend/legendFilter\":59}],56:[function(require,module,exports){\n'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Model = require('../../model/Model');\n\n    var LegendModel = require('../../echarts').extendComponentModel({\n\n        type: 'legend',\n\n        dependencies: ['series'],\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        init: function (option, parentModel, ecModel) {\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            option.selected = option.selected || {};\n        },\n\n        mergeOption: function (option) {\n            LegendModel.superCall(this, 'mergeOption', option);\n        },\n\n        optionUpdated: function () {\n            this._updateData(this.ecModel);\n\n            var legendData = this._data;\n\n            // If selectedMode is single, try to select one\n            if (legendData[0] && this.get('selectedMode') === 'single') {\n                var hasSelected = false;\n                // If has any selected in option.selected\n                for (var i = 0; i < legendData.length; i++) {\n                    var name = legendData[i].get('name');\n                    if (this.isSelected(name)) {\n                        // Force to unselect others\n                        this.select(name);\n                        hasSelected = true;\n                        break;\n                    }\n                }\n                // Try select the first if selectedMode is single\n                !hasSelected && this.select(legendData[0].get('name'));\n            }\n        },\n\n        _updateData: function (ecModel) {\n            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n                // Can be string or number\n                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n                    dataItem = {\n                        name: dataItem\n                    };\n                }\n                return new Model(dataItem, this, this.ecModel);\n            }, this);\n            this._data = legendData;\n\n            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n                return series.name;\n            });\n            ecModel.eachSeries(function (seriesModel) {\n                if (seriesModel.legendDataProvider) {\n                    var data = seriesModel.legendDataProvider();\n                    availableNames = availableNames.concat(data.mapArray(data.getName));\n                }\n            });\n            /**\n             * @type {Array.<string>}\n             * @private\n             */\n            this._availableNames = availableNames;\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Model>}\n         */\n        getData: function () {\n            return this._data;\n        },\n\n        /**\n         * @param {string} name\n         */\n        select: function (name) {\n            var selected = this.option.selected;\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                var data = this._data;\n                zrUtil.each(data, function (dataItem) {\n                    selected[dataItem.get('name')] = false;\n                });\n            }\n            selected[name] = true;\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            if (this.get('selectedMode') !== 'single') {\n                this.option.selected[name] = false;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var selected = this.option.selected;\n            // Default is true\n            if (!selected.hasOwnProperty(name)) {\n                selected[name] = true;\n            }\n            this[selected[name] ? 'unSelect' : 'select'](name);\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var selected = this.option.selected;\n            return !(selected.hasOwnProperty(name) && !selected[name])\n                && zrUtil.indexOf(this._availableNames, name) >= 0;\n        },\n\n        defaultOption: {\n            // \n            zlevel: 0,\n            // \n            z: 4,\n            show: true,\n\n            // \n            // 'horizontal' | 'vertical'\n            orient: 'horizontal',\n\n            left: 'center',\n            // right: 'center',\n\n            top: 'top',\n            // bottom: 'top',\n\n            // \n            // 'auto' | 'left' | 'right'\n            //  'auto',  x \n            align: 'auto',\n\n            backgroundColor: 'rgba(0,0,0,0)',\n            // \n            borderColor: '#ccc',\n            // px0\n            borderWidth: 0,\n            // px5\n            // css\n            padding: 5,\n            // itempx10\n            // \n            itemGap: 10,\n            // \n            itemWidth: 25,\n            // \n            itemHeight: 14,\n\n            // \n            inactiveColor: '#ccc',\n\n            textStyle: {\n                // \n                color: '#333'\n            },\n            // formatter: '',\n            // \n            selectedMode: true,\n            // LEGEND.SELECTED\n            // selected: null,\n            // legend.dataitem\n            // data: [],\n\n            // Tooltip \n            tooltip: {\n                show: false\n            }\n        }\n    });\n\n    module.exports = LegendModel;\n\n},{\"../../echarts\":94,\"../../model/Model\":100,\"zrender/lib/core/util\":166}],57:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolCreator = require('../../util/symbol');\n    var graphic = require('../../util/graphic');\n    var listComponentHelper = require('../helper/listComponent');\n\n    var curry = zrUtil.curry;\n\n    function dispatchSelectAction(name, api) {\n        api.dispatchAction({\n            type: 'legendToggleSelect',\n            name: name\n        });\n    }\n\n    function dispatchHighlightAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'highlight',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    function dispatchDownplayAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'downplay',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    module.exports = require('../../echarts').extendComponentView({\n\n        type: 'legend',\n\n        init: function () {\n            this._symbolTypeStore = {};\n        },\n\n        render: function (legendModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!legendModel.get('show')) {\n                return;\n            }\n\n            var selectMode = legendModel.get('selectedMode');\n            var itemAlign = legendModel.get('align');\n\n            if (itemAlign === 'auto') {\n                itemAlign = (legendModel.get('left') === 'right'\n                    && legendModel.get('orient') === 'vertical')\n                    ? 'right' : 'left';\n            }\n\n            var legendDrawedMap = {};\n\n            zrUtil.each(legendModel.getData(), function (itemModel) {\n                var name = itemModel.get('name');\n\n                // Use empty string or \\n as a newline string\n                if (name === '' || name === '\\n') {\n                    group.add(new graphic.Group({\n                        newline: true\n                    }));\n                    return;\n                }\n\n                var seriesModel = ecModel.getSeriesByName(name)[0];\n\n                if (legendDrawedMap[name]) {\n                    // Have been drawed\n                    return;\n                }\n\n                // Series legend\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var color = data.getVisual('color');\n\n                    // If color is a callback function\n                    if (typeof color === 'function') {\n                        // Use the first data\n                        color = color(seriesModel.getDataParams(0));\n                    }\n\n                    // Using rect symbol defaultly\n                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n                    var symbolType = data.getVisual('symbol');\n\n                    var itemGroup = this._createItem(\n                        name, itemModel, legendModel,\n                        legendSymbolType, symbolType,\n                        itemAlign, color,\n                        selectMode\n                    );\n\n                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\n                    legendDrawedMap[name] = true;\n                }\n                else {\n                    // Data legend of pie, funnel\n                    ecModel.eachRawSeries(function (seriesModel) {\n                        // In case multiple series has same data name\n                        if (legendDrawedMap[name]) {\n                            return;\n                        }\n                        if (seriesModel.legendDataProvider) {\n                            var data = seriesModel.legendDataProvider();\n                            var idx = data.indexOfName(name);\n                            if (idx < 0) {\n                                return;\n                            }\n\n                            var color = data.getItemVisual(idx, 'color');\n\n                            var legendSymbolType = 'roundRect';\n\n                            var itemGroup = this._createItem(\n                                name, itemModel, legendModel,\n                                legendSymbolType, null,\n                                itemAlign, color,\n                                selectMode\n                            );\n\n                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                                // FIXME Should not specify the series name\n                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\n                            legendDrawedMap[name] = true;\n                        }\n                    }, this);\n                }\n\n                if (__DEV__) {\n                    if (!legendDrawedMap[name]) {\n                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n                    }\n                }\n            }, this);\n\n            listComponentHelper.layout(group, legendModel, api);\n            // Render background after group is layout\n            // FIXME\n            listComponentHelper.addBackground(group, legendModel);\n        },\n\n        _createItem: function (\n            name, itemModel, legendModel,\n            legendSymbolType, symbolType,\n            itemAlign, color, selectMode\n        ) {\n            var itemWidth = legendModel.get('itemWidth');\n            var itemHeight = legendModel.get('itemHeight');\n            var inactiveColor = legendModel.get('inactiveColor');\n\n            var isSelected = legendModel.isSelected(name);\n            var itemGroup = new graphic.Group();\n\n            var textStyleModel = itemModel.getModel('textStyle');\n\n            var itemIcon = itemModel.get('icon');\n\n            var tooltipModel = itemModel.getModel('tooltip');\n            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\n            // Use user given icon first\n            legendSymbolType = itemIcon || legendSymbolType;\n            itemGroup.add(symbolCreator.createSymbol(\n                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n            ));\n\n            // Compose symbols\n            // PENDING\n            if (!itemIcon && symbolType\n                // At least show one symbol, can't be all none\n                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n            ) {\n                var size = itemHeight * 0.8;\n                if (symbolType === 'none') {\n                    symbolType = 'circle';\n                }\n                // Put symbol in the center\n                itemGroup.add(symbolCreator.createSymbol(\n                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n                    isSelected ? color : inactiveColor\n                ));\n            }\n\n            // Text\n            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n            var textAlign = itemAlign;\n\n            var formatter = legendModel.get('formatter');\n            var content = name;\n            if (typeof formatter === 'string' && formatter) {\n                content = formatter.replace('{name}', name != null ? name : '');\n            }\n            else if (typeof formatter === 'function') {\n                content = formatter(name);\n            }\n\n            var text = new graphic.Text({\n                style: {\n                    text: content,\n                    x: textX,\n                    y: itemHeight / 2,\n                    fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n                    textFont: textStyleModel.getFont(),\n                    textAlign: textAlign,\n                    textVerticalAlign: 'middle'\n                }\n            });\n            itemGroup.add(text);\n\n            // Add a invisible rect to increase the area of mouse hover\n            var hitRect = new graphic.Rect({\n                shape: itemGroup.getBoundingRect(),\n                invisible: true,\n                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n                    content: name,\n                    // Defaul formatter\n                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n                        return name;\n                    },\n                    formatterParams: {\n                        componentType: 'legend',\n                        legendIndex: legendModel.componentIndex,\n                        name: name,\n                        $vars: ['name']\n                    }\n                }, tooltipModel.option) : null\n            });\n            itemGroup.add(hitRect);\n\n            itemGroup.eachChild(function (child) {\n                child.silent = true;\n            });\n\n            hitRect.silent = !selectMode;\n\n\n\n            this.group.add(itemGroup);\n\n            graphic.setHoverStyle(itemGroup);\n\n            return itemGroup;\n        }\n    });\n\n},{\"../../echarts\":94,\"../../util/graphic\":123,\"../../util/symbol\":127,\"../helper/listComponent\":52,\"zrender/lib/core/util\":166}],58:[function(require,module,exports){\n/**\n * @file Legend action\n */\n\n\n    var echarts = require('../../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function legendSelectActionHandler(methodName, payload, ecModel) {\n        var selectedMap = {};\n        var isToggleSelect = methodName === 'toggleSelected';\n        var isSelected;\n        // Update all legend components\n        ecModel.eachComponent('legend', function (legendModel) {\n            if (isToggleSelect && isSelected != null) {\n                // Force other legend has same selected status\n                // Or the first is toggled to true and other are toggled to false\n                // In the case one legend has some item unSelected in option. And if other legend\n                // doesn't has the item, they will assume it is selected.\n                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n            }\n            else {\n                legendModel[methodName](payload.name);\n                isSelected = legendModel.isSelected(payload.name);\n            }\n            var legendData = legendModel.getData();\n            zrUtil.each(legendData, function (model) {\n                var name = model.get('name');\n                // Wrap element\n                if (name === '\\n' || name === '') {\n                    return;\n                }\n                var isItemSelected = legendModel.isSelected(name);\n                if (name in selectedMap) {\n                    // Unselected if any legend is unselected\n                    selectedMap[name] = selectedMap[name] && isItemSelected;\n                }\n                else {\n                    selectedMap[name] = isItemSelected;\n                }\n            });\n        });\n        // Return the event explicitly\n        return {\n            name: payload.name,\n            selected: selectedMap\n        };\n    }\n    /**\n     * @event legendToggleSelect\n     * @type {Object}\n     * @property {string} type 'legendToggleSelect'\n     * @property {string} [from]\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendToggleSelect', 'legendselectchanged',\n        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n    );\n\n    /**\n     * @event legendSelect\n     * @type {Object}\n     * @property {string} type 'legendSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendSelect', 'legendselected',\n        zrUtil.curry(legendSelectActionHandler, 'select')\n    );\n\n    /**\n     * @event legendUnSelect\n     * @type {Object}\n     * @property {string} type 'legendUnSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendUnSelect', 'legendunselected',\n        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n    );\n\n},{\"../../echarts\":94,\"zrender/lib/core/util\":166}],59:[function(require,module,exports){\n\n   module.exports = function (ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (legendModels && legendModels.length) {\n            ecModel.filterSeries(function (series) {\n                // If in any legend component the status is not selected.\n                // Because in legend series is assumed selected when it is not in the legend data.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(series.name)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    };\n\n},{}],60:[function(require,module,exports){\n\n\n    require('./marker/MarkLineModel');\n    require('./marker/MarkLineView');\n\n    require('../echarts').registerPreprocessor(function (opt) {\n        // Make sure markLine component is enabled\n        opt.markLine = opt.markLine || {};\n    });\n\n},{\"../echarts\":94,\"./marker/MarkLineModel\":62,\"./marker/MarkLineView\":63}],61:[function(require,module,exports){\n// HINT Markpoint can't be used too much\n\n\n    require('./marker/MarkPointModel');\n    require('./marker/MarkPointView');\n\n    require('../echarts').registerPreprocessor(function (opt) {\n        // Make sure markPoint component is enabled\n        opt.markPoint = opt.markPoint || {};\n    });\n\n},{\"../echarts\":94,\"./marker/MarkPointModel\":64,\"./marker/MarkPointView\":65}],62:[function(require,module,exports){\n\n\n    module.exports = require('./MarkerModel').extend({\n\n        type: 'markLine',\n\n        defaultOption: {\n            zlevel: 0,\n            z: 5,\n\n            symbol: ['circle', 'arrow'],\n            symbolSize: [8, 16],\n\n            //symbolRotate: 0,\n\n            precision: 2,\n            tooltip: {\n                trigger: 'item'\n            },\n            label: {\n                normal: {\n                    show: true,\n                    position: 'end'\n                },\n                emphasis: {\n                    show: true\n                }\n            },\n            lineStyle: {\n                normal: {\n                    type: 'dashed'\n                },\n                emphasis: {\n                    width: 3\n                }\n            },\n            animationEasing: 'linear'\n        }\n    });\n\n},{\"./MarkerModel\":66}],63:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var List = require('../../data/List');\n    var numberUtil = require('../../util/number');\n\n    var markerHelper = require('./markerHelper');\n\n    var LineDraw = require('../../chart/helper/LineDraw');\n\n    var markLineTransform = function (seriesModel, coordSys, mlModel, item) {\n        var data = seriesModel.getData();\n        // Special type markLine like 'min', 'max', 'average'\n        var mlType = item.type;\n\n        if (!zrUtil.isArray(item)\n            && (\n                mlType === 'min' || mlType === 'max' || mlType === 'average'\n                // In case\n                // data: [{\n                //   yAxis: 10\n                // }]\n                || (item.xAxis != null || item.yAxis != null)\n            )\n        ) {\n            var valueAxis;\n            var valueDataDim;\n            var value;\n\n            if (item.yAxis != null || item.xAxis != null) {\n                valueDataDim = item.yAxis != null ? 'y' : 'x';\n                valueAxis = coordSys.getAxis(valueDataDim);\n\n                value = zrUtil.retrieve(item.yAxis, item.xAxis);\n            }\n            else {\n                var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);\n                valueDataDim = axisInfo.valueDataDim;\n                valueAxis = axisInfo.valueAxis;\n                value = markerHelper.numCalculate(data, valueDataDim, mlType);\n            }\n            var valueIndex = valueDataDim === 'x' ? 0 : 1;\n            var baseIndex = 1 - valueIndex;\n\n            var mlFrom = zrUtil.clone(item);\n            var mlTo = {};\n\n            mlFrom.type = null;\n\n            mlFrom.coord = [];\n            mlTo.coord = [];\n            mlFrom.coord[baseIndex] = -Infinity;\n            mlTo.coord[baseIndex] = Infinity;\n\n            var precision = mlModel.get('precision');\n            if (precision >= 0 && typeof value === 'number') {\n                value = +value.toFixed(precision);\n            }\n\n            mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;\n\n            item = [mlFrom, mlTo, { // Extra option for tooltip and label\n                type: mlType,\n                valueIndex: item.valueIndex,\n                // Force to use the value of calculated value.\n                value: value\n            }];\n        }\n\n        item = [\n            markerHelper.dataTransform(seriesModel, item[0]),\n            markerHelper.dataTransform(seriesModel, item[1]),\n            zrUtil.extend({}, item[2])\n        ];\n\n        // Avoid line data type is extended by from(to) data type\n        item[2].type = item[2].type || '';\n\n        // Merge from option and to option into line option\n        zrUtil.merge(item[2], item[0]);\n        zrUtil.merge(item[2], item[1]);\n\n        return item;\n    };\n\n    function isInifinity(val) {\n        return !isNaN(val) && !isFinite(val);\n    }\n\n    // If a markLine has one dim\n    function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n        var otherDimIndex = 1 - dimIndex;\n        var dimName = coordSys.dimensions[dimIndex];\n        return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex])\n            && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);\n    }\n\n    function markLineFilter(coordSys, item) {\n        if (coordSys.type === 'cartesian2d') {\n            var fromCoord = item[0].coord;\n            var toCoord = item[1].coord;\n            // In case\n            // {\n            //  markLine: {\n            //    data: [{ yAxis: 2 }]\n            //  }\n            // }\n            if (\n                fromCoord && toCoord &&\n                (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys)\n                || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))\n            ) {\n                return true;\n            }\n        }\n        return markerHelper.dataFilter(coordSys, item[0])\n            && markerHelper.dataFilter(coordSys, item[1]);\n    }\n\n    function updateSingleMarkerEndLayout(\n        data, idx, isFrom, seriesModel, api\n    ) {\n        var coordSys = seriesModel.coordinateSystem;\n        var itemModel = data.getItemModel(idx);\n\n        var point;\n        var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n        var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n        if (!isNaN(xPx) && !isNaN(yPx)) {\n            point = [xPx, yPx];\n        }\n        else {\n            // Chart like bar may have there own marker positioning logic\n            if (seriesModel.getMarkerPosition) {\n                // Use the getMarkerPoisition\n                point = seriesModel.getMarkerPosition(\n                    data.getValues(data.dimensions, idx)\n                );\n            }\n            else {\n                var dims = coordSys.dimensions;\n                var x = data.get(dims[0], idx);\n                var y = data.get(dims[1], idx);\n                point = coordSys.dataToPoint([x, y]);\n            }\n            // Expand line to the edge of grid if value on one axis is Inifnity\n            // In case\n            //  markLine: {\n            //    data: [{\n            //      yAxis: 2\n            //      // or\n            //      type: 'average'\n            //    }]\n            //  }\n            if (coordSys.type === 'cartesian2d') {\n                var xAxis = coordSys.getAxis('x');\n                var yAxis = coordSys.getAxis('y');\n                var dims = coordSys.dimensions;\n                if (isInifinity(data.get(dims[0], idx))) {\n                    point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);\n                }\n                else if (isInifinity(data.get(dims[1], idx))) {\n                    point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);\n                }\n            }\n\n            // Use x, y if has any\n            if (!isNaN(xPx)) {\n                point[0] = xPx;\n            }\n            if (!isNaN(yPx)) {\n                point[1] = yPx;\n            }\n        }\n\n        data.setItemLayout(idx, point);\n    }\n\n    require('./MarkerView').extend({\n\n        type: 'markLine',\n\n        updateLayout: function (markLineModel, ecModel, api) {\n            ecModel.eachSeries(function (seriesModel) {\n                var mlModel = seriesModel.markLineModel;\n                if (mlModel) {\n                    var mlData = mlModel.getData();\n                    var fromData = mlModel.__from;\n                    var toData = mlModel.__to;\n                    // Update visual and layout of from symbol and to symbol\n                    fromData.each(function (idx) {\n                        updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);\n                        updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);\n                    });\n                    // Update layout of line\n                    mlData.each(function (idx) {\n                        mlData.setItemLayout(idx, [\n                            fromData.getItemLayout(idx),\n                            toData.getItemLayout(idx)\n                        ]);\n                    });\n\n                    this.markerGroupMap[seriesModel.name].updateLayout();\n\n                }\n            }, this);\n        },\n\n        renderSeries: function (seriesModel, mlModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesName = seriesModel.name;\n            var seriesData = seriesModel.getData();\n\n            var lineDrawMap = this.markerGroupMap;\n            var lineDraw = lineDrawMap[seriesName];\n            if (!lineDraw) {\n                lineDraw = lineDrawMap[seriesName] = new LineDraw();\n            }\n            this.group.add(lineDraw.group);\n\n            var mlData = createList(coordSys, seriesModel, mlModel);\n\n            var fromData = mlData.from;\n            var toData = mlData.to;\n            var lineData = mlData.line;\n\n            mlModel.__from = fromData;\n            mlModel.__to = toData;\n            // Line data for tooltip and formatter\n            mlModel.setData(lineData);\n\n            var symbolType = mlModel.get('symbol');\n            var symbolSize = mlModel.get('symbolSize');\n            if (!zrUtil.isArray(symbolType)) {\n                symbolType = [symbolType, symbolType];\n            }\n            if (typeof symbolSize === 'number') {\n                symbolSize = [symbolSize, symbolSize];\n            }\n\n            // Update visual and layout of from symbol and to symbol\n            mlData.from.each(function (idx) {\n                updateDataVisualAndLayout(fromData, idx, true);\n                updateDataVisualAndLayout(toData, idx, false);\n            });\n\n            // Update visual and layout of line\n            lineData.each(function (idx) {\n                var lineColor = lineData.getItemModel(idx).get('lineStyle.normal.color');\n                lineData.setItemVisual(idx, {\n                    color: lineColor || fromData.getItemVisual(idx, 'color')\n                });\n                lineData.setItemLayout(idx, [\n                    fromData.getItemLayout(idx),\n                    toData.getItemLayout(idx)\n                ]);\n\n                lineData.setItemVisual(idx, {\n                    'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),\n                    'fromSymbol': fromData.getItemVisual(idx, 'symbol'),\n                    'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),\n                    'toSymbol': toData.getItemVisual(idx, 'symbol')\n                });\n            });\n\n            lineDraw.updateData(lineData);\n\n            // Set host model for tooltip\n            // FIXME\n            mlData.line.eachItemGraphicEl(function (el, idx) {\n                el.traverse(function (child) {\n                    child.dataModel = mlModel;\n                });\n            });\n\n            function updateDataVisualAndLayout(data, idx, isFrom) {\n                var itemModel = data.getItemModel(idx);\n\n                updateSingleMarkerEndLayout(\n                    data, idx, isFrom, seriesModel, api\n                );\n\n                data.setItemVisual(idx, {\n                    symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],\n                    symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],\n                    color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color')\n                });\n            }\n\n            lineDraw.__keep = true;\n\n            lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');\n        }\n    });\n\n    /**\n     * @inner\n     * @param {module:echarts/coord/*} coordSys\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {module:echarts/model/Model} mpModel\n     */\n    function createList(coordSys, seriesModel, mlModel) {\n\n        var coordDimsInfos;\n        if (coordSys) {\n            coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n                var info = seriesModel.getData().getDimensionInfo(\n                    seriesModel.coordDimToDataDim(coordDim)[0]\n                ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n                info.name = coordDim;\n                return info;\n            });\n        }\n        else {\n            coordDimsInfos =[{\n                name: 'value',\n                type: 'float'\n            }];\n        }\n\n        var fromData = new List(coordDimsInfos, mlModel);\n        var toData = new List(coordDimsInfos, mlModel);\n        // No dimensions\n        var lineData = new List([], mlModel);\n\n        var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry(\n            markLineTransform, seriesModel, coordSys, mlModel\n        ));\n        if (coordSys) {\n            optData = zrUtil.filter(\n                optData, zrUtil.curry(markLineFilter, coordSys)\n            );\n        }\n        var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {\n            return item.value;\n        };\n        fromData.initData(\n            zrUtil.map(optData, function (item) { return item[0]; }),\n            null, dimValueGetter\n        );\n        toData.initData(\n            zrUtil.map(optData, function (item) { return item[1]; }),\n            null, dimValueGetter\n        );\n        lineData.initData(\n            zrUtil.map(optData, function (item) { return item[2]; })\n        );\n        lineData.hasItemOption = true;\n        return {\n            from: fromData,\n            to: toData,\n            line: lineData\n        };\n    }\n\n},{\"../../chart/helper/LineDraw\":15,\"../../data/List\":92,\"../../util/number\":126,\"./MarkerView\":67,\"./markerHelper\":68,\"zrender/lib/core/util\":166}],64:[function(require,module,exports){\n\n\n    module.exports = require('./MarkerModel').extend({\n\n        type: 'markPoint',\n\n        defaultOption: {\n            zlevel: 0,\n            z: 5,\n            symbol: 'pin',\n            symbolSize: 50,\n            //symbolRotate: 0,\n            //symbolOffset: [0, 0]\n            tooltip: {\n                trigger: 'item'\n            },\n            label: {\n                normal: {\n                    show: true,\n                    position: 'inside'\n                },\n                emphasis: {\n                    show: true\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 2\n                }\n            }\n        }\n    });\n\n},{\"./MarkerModel\":66}],65:[function(require,module,exports){\n\n\n    var SymbolDraw = require('../../chart/helper/SymbolDraw');\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../../util/number');\n\n    var List = require('../../data/List');\n\n    var markerHelper = require('./markerHelper');\n\n    function updateMarkerLayout(mpData, seriesModel, api) {\n        var coordSys = seriesModel.coordinateSystem;\n        mpData.each(function (idx) {\n            var itemModel = mpData.getItemModel(idx);\n            var point;\n            var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n            var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n            if (!isNaN(xPx) && !isNaN(yPx)) {\n                point = [xPx, yPx];\n            }\n            // Chart like bar may have there own marker positioning logic\n            else if (seriesModel.getMarkerPosition) {\n                // Use the getMarkerPoisition\n                point = seriesModel.getMarkerPosition(\n                    mpData.getValues(mpData.dimensions, idx)\n                );\n            }\n            else if (coordSys) {\n                var x = mpData.get(coordSys.dimensions[0], idx);\n                var y = mpData.get(coordSys.dimensions[1], idx);\n                point = coordSys.dataToPoint([x, y]);\n\n            }\n\n            // Use x, y if has any\n            if (!isNaN(xPx)) {\n                point[0] = xPx;\n            }\n            if (!isNaN(yPx)) {\n                point[1] = yPx;\n            }\n\n            mpData.setItemLayout(idx, point);\n        });\n    }\n\n    require('./MarkerView').extend({\n\n        type: 'markPoint',\n\n        updateLayout: function (markPointModel, ecModel, api) {\n            ecModel.eachSeries(function (seriesModel) {\n                var mpModel = seriesModel.markPointModel;\n                if (mpModel) {\n                    updateMarkerLayout(mpModel.getData(), seriesModel, api);\n                    this.markerGroupMap[seriesModel.name].updateLayout(mpModel);\n                }\n            }, this);\n        },\n\n        renderSeries: function (seriesModel, mpModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesName = seriesModel.name;\n            var seriesData = seriesModel.getData();\n\n            var symbolDrawMap = this.markerGroupMap;\n            var symbolDraw = symbolDrawMap[seriesName];\n            if (!symbolDraw) {\n                symbolDraw = symbolDrawMap[seriesName] = new SymbolDraw();\n            }\n\n            var mpData = createList(coordSys, seriesModel, mpModel);\n\n            // FIXME\n            mpModel.setData(mpData);\n\n            updateMarkerLayout(mpModel.getData(), seriesModel, api);\n\n            mpData.each(function (idx) {\n                var itemModel = mpData.getItemModel(idx);\n                var symbolSize = itemModel.getShallow('symbolSize');\n                if (typeof symbolSize === 'function') {\n                    // FIXME  ECharts 2.x2.x \n                    symbolSize = symbolSize(\n                        mpModel.getRawValue(idx), mpModel.getDataParams(idx)\n                    );\n                }\n                mpData.setItemVisual(idx, {\n                    symbolSize: symbolSize,\n                    color: itemModel.get('itemStyle.normal.color')\n                        || seriesData.getVisual('color'),\n                    symbol: itemModel.getShallow('symbol')\n                });\n            });\n\n            // TODO Text are wrong\n            symbolDraw.updateData(mpData);\n            this.group.add(symbolDraw.group);\n\n            // Set host model for tooltip\n            // FIXME\n            mpData.eachItemGraphicEl(function (el) {\n                el.traverse(function (child) {\n                    child.dataModel = mpModel;\n                });\n            });\n\n            symbolDraw.__keep = true;\n\n            symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');\n        }\n    });\n\n    /**\n     * @inner\n     * @param {module:echarts/coord/*} [coordSys]\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {module:echarts/model/Model} mpModel\n     */\n    function createList(coordSys, seriesModel, mpModel) {\n        var coordDimsInfos;\n        if (coordSys) {\n            coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n                var info = seriesModel.getData().getDimensionInfo(\n                    seriesModel.coordDimToDataDim(coordDim)[0]\n                ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n                info.name = coordDim;\n                return info;\n            });\n        }\n        else {\n            coordDimsInfos =[{\n                name: 'value',\n                type: 'float'\n            }];\n        }\n\n        var mpData = new List(coordDimsInfos, mpModel);\n        var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(\n                markerHelper.dataTransform, seriesModel\n            ));\n        if (coordSys) {\n            dataOpt = zrUtil.filter(\n                dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys)\n            );\n        }\n\n        mpData.initData(dataOpt, null,\n            coordSys ? markerHelper.dimValueGetter : function (item) {\n                return item.value;\n            }\n        );\n        return mpData;\n    }\n\n\n},{\"../../chart/helper/SymbolDraw\":18,\"../../data/List\":92,\"../../util/number\":126,\"./MarkerView\":67,\"./markerHelper\":68,\"zrender/lib/core/util\":166}],66:[function(require,module,exports){\n\n\n    var modelUtil = require('../../util/model');\n    var zrUtil = require('zrender/lib/core/util');\n    var env = require('zrender/lib/core/env');\n\n    var formatUtil = require('../../util/format');\n    var addCommas = formatUtil.addCommas;\n    var encodeHTML = formatUtil.encodeHTML;\n\n    function fillLabel(opt) {\n        modelUtil.defaultEmphasis(\n            opt.label,\n            modelUtil.LABEL_OPTIONS\n        );\n    }\n    var MarkerModel = require('../../echarts').extendComponentModel({\n\n        type: 'marker',\n\n        dependencies: ['series', 'grid', 'polar', 'geo'],\n        /**\n         * @overrite\n         */\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            if (__DEV__) {\n                if (this.type === 'marker') {\n                    throw new Error('Marker component is abstract component. Use markLine, markPoint, markArea instead.');\n                }\n            }\n            this.mergeDefaultAndTheme(option, ecModel);\n            this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var hostSeries = this.__hostSeries;\n            return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();\n        },\n\n        mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {\n            var MarkerModel = this.constructor;\n            var modelPropName = this.mainType + 'Model';\n            if (!createdBySelf) {\n                ecModel.eachSeries(function (seriesModel) {\n\n                    var markerOpt = seriesModel.get(this.mainType);\n\n                    var markerModel = seriesModel[modelPropName];\n                    if (!markerOpt || !markerOpt.data) {\n                        seriesModel[modelPropName] = null;\n                        return;\n                    }\n                    if (!markerModel) {\n                        if (isInit) {\n                            // Default label emphasis `position` and `show`\n                            fillLabel(markerOpt);\n                        }\n                        zrUtil.each(markerOpt.data, function (item) {\n                            // FIXME Overwrite fillLabel method ?\n                            if (item instanceof Array) {\n                                fillLabel(item[0]);\n                                fillLabel(item[1]);\n                            }\n                            else {\n                                fillLabel(item);\n                            }\n                        });\n\n                        markerModel = new MarkerModel(\n                            markerOpt, this, ecModel\n                        );\n\n                        zrUtil.extend(markerModel, {\n                            mainType: this.mainType,\n                            // Use the same series index and name\n                            seriesIndex: seriesModel.seriesIndex,\n                            name: seriesModel.name,\n                            createdBySelf: true\n                        });\n\n                        markerModel.__hostSeries = seriesModel;\n                    }\n                    else {\n                        markerModel.mergeOption(markerOpt, ecModel, true);\n                    }\n                    seriesModel[modelPropName] = markerModel;\n                }, this);\n            }\n        },\n\n        formatTooltip: function (dataIndex) {\n            var data = this.getData();\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);\n            var name = data.getName(dataIndex);\n            var html = encodeHTML(this.name);\n            if (value != null || name) {\n                html += '<br />';\n            }\n            if (name) {\n                html += encodeHTML(name);\n                if (value != null) {\n                    html += ' : ';\n                }\n            }\n            if (value != null) {\n                html += encodeHTML(formattedValue);\n            }\n            return html;\n        },\n\n        getData: function () {\n            return this._data;\n        },\n\n        setData: function (data) {\n            this._data = data;\n        }\n    });\n\n    zrUtil.mixin(MarkerModel, modelUtil.dataFormatMixin);\n\n    module.exports = MarkerModel;\n\n},{\"../../echarts\":94,\"../../util/format\":122,\"../../util/model\":125,\"zrender/lib/core/env\":160,\"zrender/lib/core/util\":166}],67:[function(require,module,exports){\n\n\n    module.exports = require('../../echarts').extendComponentView({\n\n        type: 'marker',\n\n        init: function () {\n            /**\n             * Markline grouped by series\n             * @private\n             * @type {Object}\n             */\n            this.markerGroupMap = {};\n        },\n\n        render: function (markerModel, ecModel, api) {\n            var markerGroupMap = this.markerGroupMap;\n            for (var name in markerGroupMap) {\n                if (markerGroupMap.hasOwnProperty(name)) {\n                    markerGroupMap[name].__keep = false;\n                }\n            }\n\n            var markerModelKey = this.type + 'Model';\n            ecModel.eachSeries(function (seriesModel) {\n                var markerModel = seriesModel[markerModelKey];\n                markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);\n            }, this);\n\n            for (var name in markerGroupMap) {\n                if (markerGroupMap.hasOwnProperty(name) && !markerGroupMap[name].__keep) {\n                    this.group.remove(markerGroupMap[name].group);\n                }\n            }\n        },\n\n        renderSeries: function () {}\n    });\n\n},{\"../../echarts\":94}],68:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../../util/number');\n    var indexOf = zrUtil.indexOf;\n\n    function hasXOrY(item) {\n        return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n    }\n\n    function hasXAndY(item) {\n        return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n    }\n\n    function getPrecision(data, valueAxisDim, dataIndex) {\n        var precision = -1;\n        do {\n            precision = Math.max(\n                numberUtil.getPrecision(data.get(\n                    valueAxisDim, dataIndex\n                )),\n                precision\n            );\n            data = data.stackedOn;\n        } while (data);\n\n        return precision;\n    }\n\n    function markerTypeCalculatorWithExtent(\n        mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex\n    ) {\n        var coordArr = [];\n        var value = numCalculate(data, targetDataDim, mlType);\n\n        var dataIndex = data.indexOfNearest(targetDataDim, value, true);\n        coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex, true);\n        coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex, true);\n\n        var precision = getPrecision(data, targetDataDim, dataIndex);\n        if (precision >= 0) {\n            coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n        }\n\n        return coordArr;\n    }\n\n    var curry = zrUtil.curry;\n    // TODO Specified percent\n    var markerTypeCalculator = {\n        /**\n         * @method\n         * @param {module:echarts/data/List} data\n         * @param {string} baseAxisDim\n         * @param {string} valueAxisDim\n         */\n        min: curry(markerTypeCalculatorWithExtent, 'min'),\n        /**\n         * @method\n         * @param {module:echarts/data/List} data\n         * @param {string} baseAxisDim\n         * @param {string} valueAxisDim\n         */\n        max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n        /**\n         * @method\n         * @param {module:echarts/data/List} data\n         * @param {string} baseAxisDim\n         * @param {string} valueAxisDim\n         */\n        average: curry(markerTypeCalculatorWithExtent, 'average')\n    };\n\n    /**\n     * Transform markPoint data item to format used in List by do the following\n     * 1. Calculate statistic like `max`, `min`, `average`\n     * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n     * @param  {module:echarts/model/Series} seriesModel\n     * @param  {module:echarts/coord/*} [coordSys]\n     * @param  {Object} item\n     * @return {Object}\n     */\n    var dataTransform = function (seriesModel, item) {\n        var data = seriesModel.getData();\n        var coordSys = seriesModel.coordinateSystem;\n\n        // 1. If not specify the position with pixel directly\n        // 2. If `coord` is not a data array. Which uses `xAxis`,\n        // `yAxis` to specify the coord on each dimension\n\n        // parseFloat first because item.x and item.y can be percent string like '20%'\n        if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n            var dims = coordSys.dimensions;\n            var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);\n\n            // Clone the option\n            // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n            item = zrUtil.clone(item);\n\n            if (item.type\n                && markerTypeCalculator[item.type]\n                && axisInfo.baseAxis && axisInfo.valueAxis\n            ) {\n                var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n                var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n\n                item.coord = markerTypeCalculator[item.type](\n                    data, axisInfo.baseDataDim, axisInfo.valueDataDim,\n                    otherCoordIndex, targetCoordIndex\n                );\n                // Force to use the value of calculated value.\n                item.value = item.coord[targetCoordIndex];\n            }\n            else {\n                // FIXME Only has one of xAxis and yAxis.\n                var coord = [\n                    item.xAxis != null ? item.xAxis : item.radiusAxis,\n                    item.yAxis != null ? item.yAxis : item.angleAxis\n                ];\n                // Each coord support max, min, average\n                for (var i = 0; i < 2; i++) {\n                    if (markerTypeCalculator[coord[i]]) {\n                        var dataDim = seriesModel.coordDimToDataDim(dims[i])[0];\n                        coord[i] = numCalculate(data, dataDim, coord[i]);\n                    }\n                }\n                item.coord = coord;\n            }\n        }\n        return item;\n    };\n\n    var getAxisInfo = function (item, data, coordSys, seriesModel) {\n        var ret = {};\n\n        if (item.valueIndex != null || item.valueDim != null) {\n            ret.valueDataDim = item.valueIndex != null\n                ? data.getDimension(item.valueIndex) : item.valueDim;\n            ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));\n            ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n            ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n        }\n        else {\n            ret.baseAxis = seriesModel.getBaseAxis();\n            ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n            ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n            ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];\n        }\n\n        return ret;\n    };\n\n    /**\n     * Filter data which is out of coordinateSystem range\n     * [dataFilter description]\n     * @param  {module:echarts/coord/*} [coordSys]\n     * @param  {Object} item\n     * @return {boolean}\n     */\n    var dataFilter = function (coordSys, item) {\n        // Alwalys return true if there is no coordSys\n        return (coordSys && coordSys.containData && item.coord && !hasXOrY(item))\n            ? coordSys.containData(item.coord) : true;\n    };\n\n    var dimValueGetter = function (item, dimName, dataIndex, dimIndex) {\n        // x, y, radius, angle\n        if (dimIndex < 2) {\n            return item.coord && item.coord[dimIndex];\n        }\n        return item.value;\n    };\n\n    var numCalculate = function (data, valueDataDim, type) {\n        if (type === 'average') {\n            var sum = 0;\n            var count = 0;\n            data.each(valueDataDim, function (val, idx) {\n                if (!isNaN(val)) {\n                    sum += val;\n                    count++;\n                }\n            }, true);\n            return sum / count;\n        }\n        else {\n            return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n        }\n    };\n\n    module.exports = {\n        dataTransform: dataTransform,\n        dataFilter: dataFilter,\n        dimValueGetter: dimValueGetter,\n        getAxisInfo: getAxisInfo,\n        numCalculate: numCalculate\n    };\n\n},{\"../../util/number\":126,\"zrender/lib/core/util\":166}],69:[function(require,module,exports){\n\n\n    require('../coord/radar/Radar');\n    require('../coord/radar/RadarModel');\n\n    require('./radar/RadarView');\n\n},{\"../coord/radar/Radar\":89,\"../coord/radar/RadarModel\":90,\"./radar/RadarView\":70}],70:[function(require,module,exports){\n\n\n    var AxisBuilder = require('../axis/AxisBuilder');\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n\n    module.exports = require('../../echarts').extendComponentView({\n\n        type: 'radar',\n\n        render: function (radarModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            this._buildAxes(radarModel);\n            this._buildSplitLineAndArea(radarModel);\n        },\n\n        _buildAxes: function (radarModel) {\n            var radar = radarModel.coordinateSystem;\n            var indicatorAxes = radar.getIndicatorAxes();\n            var axisBuilders = zrUtil.map(indicatorAxes, function (indicatorAxis) {\n                var axisBuilder = new AxisBuilder(indicatorAxis.model, {\n                    position: [radar.cx, radar.cy],\n                    rotation: indicatorAxis.angle,\n                    labelDirection: -1,\n                    tickDirection: -1,\n                    nameDirection: 1\n                });\n                return axisBuilder;\n            });\n\n            zrUtil.each(axisBuilders, function (axisBuilder) {\n                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n                this.group.add(axisBuilder.getGroup());\n            }, this);\n        },\n\n        _buildSplitLineAndArea: function (radarModel) {\n            var radar = radarModel.coordinateSystem;\n            var indicatorAxes = radar.getIndicatorAxes();\n            if (!indicatorAxes.length) {\n                return;\n            }\n            var shape = radarModel.get('shape');\n            var splitLineModel = radarModel.getModel('splitLine');\n            var splitAreaModel = radarModel.getModel('splitArea');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\n            var showSplitLine = splitLineModel.get('show');\n            var showSplitArea = splitAreaModel.get('show');\n            var splitLineColors = lineStyleModel.get('color');\n            var splitAreaColors = areaStyleModel.get('color');\n\n            splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors];\n            splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];\n\n            var splitLines = [];\n            var splitAreas = [];\n\n            function getColorIndex(areaOrLine, areaOrLineColorList, idx) {\n                var colorIndex = idx % areaOrLineColorList.length;\n                areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];\n                return colorIndex;\n            }\n\n            if (shape === 'circle') {\n                var ticksRadius = indicatorAxes[0].getTicksCoords();\n                var cx = radar.cx;\n                var cy = radar.cy;\n                for (var i = 0; i < ticksRadius.length; i++) {\n                    if (showSplitLine) {\n                        var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n                        splitLines[colorIndex].push(new graphic.Circle({\n                            shape: {\n                                cx: cx,\n                                cy: cy,\n                                r: ticksRadius[i]\n                            }\n                        }));\n                    }\n                    if (showSplitArea && i < ticksRadius.length - 1) {\n                        var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);\n                        splitAreas[colorIndex].push(new graphic.Ring({\n                            shape: {\n                                cx: cx,\n                                cy: cy,\n                                r0: ticksRadius[i],\n                                r: ticksRadius[i + 1]\n                            }\n                        }));\n                    }\n                }\n            }\n            // Polyyon\n            else {\n                var realSplitNumber = -1;\n                var axesTicksPoints = zrUtil.map(indicatorAxes, function (indicatorAxis, idx) {\n                    var ticksCoords = indicatorAxis.getTicksCoords();\n                    realSplitNumber = Math.max(ticksCoords.length - 1, realSplitNumber);\n                    return zrUtil.map(ticksCoords, function (tickCoord) {\n                        return radar.coordToPoint(tickCoord, idx);\n                    });\n                });\n\n                var prevPoints = [];\n                for (var i = 0; i <= realSplitNumber; i++) {\n                    var points = [];\n                    for (var j = 0; j < indicatorAxes.length; j++) {\n                        points.push(axesTicksPoints[j][i]);\n                    }\n                    // Close\n                    if (points[0]) {\n                        points.push(points[0].slice());\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.error('Can\\'t draw value axis ' + i);\n                        }\n                    }\n                    if (showSplitLine) {\n                        var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n                        splitLines[colorIndex].push(new graphic.Polyline({\n                            shape: {\n                                points: points\n                            }\n                        }));\n                    }\n                    if (showSplitArea && prevPoints) {\n                        var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);\n                        splitAreas[colorIndex].push(new graphic.Polygon({\n                            shape: {\n                                points: points.concat(prevPoints)\n                            }\n                        }));\n                    }\n                    prevPoints = points.slice().reverse();\n                }\n            }\n\n            var lineStyle = lineStyleModel.getLineStyle();\n            var areaStyle = areaStyleModel.getAreaStyle();\n            // Add splitArea before splitLine\n            zrUtil.each(splitAreas, function (splitAreas, idx) {\n                this.group.add(graphic.mergePath(\n                    splitAreas, {\n                        style: zrUtil.defaults({\n                            stroke: 'none',\n                            fill: splitAreaColors[idx % splitAreaColors.length]\n                        }, areaStyle),\n                        silent: true\n                    }\n                ));\n            }, this);\n\n            zrUtil.each(splitLines, function (splitLines, idx) {\n                this.group.add(graphic.mergePath(\n                    splitLines, {\n                        style: zrUtil.defaults({\n                            fill: 'none',\n                            stroke: splitLineColors[idx % splitLineColors.length]\n                        }, lineStyle),\n                        silent: true\n                    }\n                ));\n            }, this);\n\n        }\n    });\n\n},{\"../../echarts\":94,\"../../util/graphic\":123,\"../axis/AxisBuilder\":36,\"zrender/lib/core/util\":166}],71:[function(require,module,exports){\n'use strict';\n\n\n    var echarts = require('../echarts');\n    var graphic = require('../util/graphic');\n    var layout = require('../util/layout');\n\n    // Model\n    echarts.extendComponentModel({\n\n        type: 'title',\n\n        layoutMode: {type: 'box', ignoreSize: true},\n\n        defaultOption: {\n            // \n            zlevel: 0,\n            // \n            z: 6,\n            show: true,\n\n            text: '',\n            // \n            // link: null,\n            // self | blank\n            target: 'blank',\n            subtext: '',\n\n            // \n            // sublink: null,\n            // self | blank\n            subtarget: 'blank',\n\n            // 'center'  'left'  'right'\n            //  {number}xpx\n            left: 0,\n            // 'top'  'bottom'  'center'\n            //  {number}ypx\n            top: 0,\n\n            // \n            // 'auto' | 'left' | 'right' | 'center'\n            //  left \n            // textAlign: null\n            //\n            // \n            // 'auto' | 'top' | 'bottom' | 'middle'\n            //  top \n            // textBaseline: null\n\n            backgroundColor: 'rgba(0,0,0,0)',\n\n            // \n            borderColor: '#ccc',\n\n            // px0\n            borderWidth: 0,\n\n            // px5\n            // css\n            padding: 5,\n\n            // px10\n            itemGap: 10,\n            textStyle: {\n                fontSize: 18,\n                fontWeight: 'bolder',\n                color: '#333'\n            },\n            subtextStyle: {\n                color: '#aaa'\n            }\n        }\n    });\n\n    // View\n    echarts.extendComponentView({\n\n        type: 'title',\n\n        render: function (titleModel, ecModel, api) {\n            this.group.removeAll();\n\n            if (!titleModel.get('show')) {\n                return;\n            }\n\n            var group = this.group;\n\n            var textStyleModel = titleModel.getModel('textStyle');\n            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\n            var textAlign = titleModel.get('textAlign');\n            var textBaseline = titleModel.get('textBaseline');\n\n            var textEl = new graphic.Text({\n                style: {\n                    text: titleModel.get('text'),\n                    textFont: textStyleModel.getFont(),\n                    fill: textStyleModel.getTextColor()\n                },\n                z2: 10\n            });\n\n            var textRect = textEl.getBoundingRect();\n\n            var subText = titleModel.get('subtext');\n            var subTextEl = new graphic.Text({\n                style: {\n                    text: subText,\n                    textFont: subtextStyleModel.getFont(),\n                    fill: subtextStyleModel.getTextColor(),\n                    y: textRect.height + titleModel.get('itemGap'),\n                    textBaseline: 'top'\n                },\n                z2: 10\n            });\n\n            var link = titleModel.get('link');\n            var sublink = titleModel.get('sublink');\n\n            textEl.silent = !link;\n            subTextEl.silent = !sublink;\n\n            if (link) {\n                textEl.on('click', function () {\n                    window.open(link, '_' + titleModel.get('target'));\n                });\n            }\n            if (sublink) {\n                subTextEl.on('click', function () {\n                    window.open(sublink, '_' + titleModel.get('subtarget'));\n                });\n            }\n\n            group.add(textEl);\n            subText && group.add(subTextEl);\n            // If no subText, but add subTextEl, there will be an empty line.\n\n            var groupRect = group.getBoundingRect();\n            var layoutOption = titleModel.getBoxLayoutParams();\n            layoutOption.width = groupRect.width;\n            layoutOption.height = groupRect.height;\n            var layoutRect = layout.getLayoutRect(\n                layoutOption, {\n                    width: api.getWidth(),\n                    height: api.getHeight()\n                }, titleModel.get('padding')\n            );\n            // Adjust text align based on position\n            if (!textAlign) {\n                // Align left if title is on the left. center and right is same\n                textAlign = titleModel.get('left') || titleModel.get('right');\n                if (textAlign === 'middle') {\n                    textAlign = 'center';\n                }\n                // Adjust layout by text align\n                if (textAlign === 'right') {\n                    layoutRect.x += layoutRect.width;\n                }\n                else if (textAlign === 'center') {\n                    layoutRect.x += layoutRect.width / 2;\n                }\n            }\n            if (!textBaseline) {\n                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n                if (textBaseline === 'center') {\n                    textBaseline = 'middle';\n                }\n                if (textBaseline === 'bottom') {\n                    layoutRect.y += layoutRect.height;\n                }\n                else if (textBaseline === 'middle') {\n                    layoutRect.y += layoutRect.height / 2;\n                }\n\n                textBaseline = textBaseline || 'top';\n            }\n\n            group.attr('position', [layoutRect.x, layoutRect.y]);\n            var alignStyle = {\n                textAlign: textAlign,\n                textVerticalAlign: textBaseline\n            };\n            textEl.setStyle(alignStyle);\n            subTextEl.setStyle(alignStyle);\n\n            // Render background\n            // Get groupRect again because textAlign has been changed\n            groupRect = group.getBoundingRect();\n            var padding = layoutRect.margin;\n            var style = titleModel.getItemStyle(['color', 'opacity']);\n            style.fill = titleModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: groupRect.x - padding[3],\n                    y: groupRect.y - padding[0],\n                    width: groupRect.width + padding[1] + padding[3],\n                    height: groupRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    });\n\n},{\"../echarts\":94,\"../util/graphic\":123,\"../util/layout\":124}],72:[function(require,module,exports){\n// FIXME Better way to pack data in graphic element\n\n\n    require('./tooltip/TooltipModel');\n\n    require('./tooltip/TooltipView');\n\n    // Show tip action\n    /**\n     * @action\n     * @property {string} type\n     * @property {number} seriesIndex\n     * @property {number} dataIndex\n     * @property {number} [x]\n     * @property {number} [y]\n     */\n    require('../echarts').registerAction(\n        {\n            type: 'showTip',\n            event: 'showTip',\n            update: 'tooltip:manuallyShowTip'\n        },\n        // noop\n        function () {}\n    );\n    // Hide tip action\n    require('../echarts').registerAction(\n        {\n            type: 'hideTip',\n            event: 'hideTip',\n            update: 'tooltip:manuallyHideTip'\n        },\n        // noop\n        function () {}\n    );\n\n},{\"../echarts\":94,\"./tooltip/TooltipModel\":74,\"./tooltip/TooltipView\":75}],73:[function(require,module,exports){\n/**\n * @module echarts/component/tooltip/TooltipContent\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var zrColor = require('zrender/lib/tool/color');\n    var eventUtil = require('zrender/lib/core/event');\n    var formatUtil = require('../../util/format');\n    var each = zrUtil.each;\n    var toCamelCase = formatUtil.toCamelCase;\n    var env = require('zrender/lib/core/env');\n\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    /**\n     * @param {number} duration\n     * @return {string}\n     * @inner\n     */\n    function assembleTransition(duration) {\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                            + 'top ' + duration + 's ' + transitionCurve;\n        return zrUtil.map(vendors, function (vendorPrefix) {\n            return vendorPrefix + 'transition:' + transitionText;\n        }).join(';');\n    }\n\n    /**\n     * @param {Object} textStyle\n     * @return {string}\n     * @inner\n     */\n    function assembleFont(textStyleModel) {\n        var cssText = [];\n\n        var fontSize = textStyleModel.get('fontSize');\n        var color = textStyleModel.getTextColor();\n\n        color && cssText.push('color:' + color);\n\n        cssText.push('font:' + textStyleModel.getFont());\n\n        fontSize &&\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n        each(['decoration', 'align'], function (name) {\n            var val = textStyleModel.get(name);\n            val && cssText.push('text-' + name + ':' + val);\n        });\n\n        return cssText.join(';');\n    }\n\n    /**\n     * @param {Object} tooltipModel\n     * @return {string}\n     * @inner\n     */\n    function assembleCssText(tooltipModel) {\n\n        tooltipModel = tooltipModel;\n\n        var cssText = [];\n\n        var transitionDuration = tooltipModel.get('transitionDuration');\n        var backgroundColor = tooltipModel.get('backgroundColor');\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        var padding = tooltipModel.get('padding');\n\n        // Animation transition\n        transitionDuration &&\n            cssText.push(assembleTransition(transitionDuration));\n\n        if (backgroundColor) {\n            if (env.canvasSupported) {\n                cssText.push('background-Color:' + backgroundColor);\n            }\n            else {\n                // for ie\n                cssText.push(\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\n                );\n                cssText.push('filter:alpha(opacity=70)');\n            }\n        }\n\n        // Border style\n        each(['width', 'color', 'radius'], function (name) {\n            var borderName = 'border-' + name;\n            var camelCase = toCamelCase(borderName);\n            var val = tooltipModel.get(camelCase);\n            val != null &&\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n        });\n\n        // Text style\n        cssText.push(assembleFont(textStyleModel));\n\n        // Padding\n        if (padding != null) {\n            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n        }\n\n        return cssText.join(';') + ';';\n    }\n\n    /**\n     * @alias module:echarts/component/tooltip/TooltipContent\n     * @constructor\n     */\n    function TooltipContent(container, api) {\n        var el = document.createElement('div');\n        var zr = api.getZr();\n\n        this.el = el;\n\n        this._x = api.getWidth() / 2;\n        this._y = api.getHeight() / 2;\n\n        container.appendChild(el);\n\n        this._container = container;\n\n        this._show = false;\n\n        /**\n         * @private\n         */\n        this._hideTimeout;\n\n        var self = this;\n        el.onmouseenter = function () {\n            // clear the timeout in hideLater and keep showing tooltip\n            if (self.enterable) {\n                clearTimeout(self._hideTimeout);\n                self._show = true;\n            }\n            self._inContent = true;\n        };\n        el.onmousemove = function (e) {\n            e = e || window.event;\n            if (!self.enterable) {\n                // Try trigger zrender event to avoid mouse\n                // in and out shape too frequently\n                var handler = zr.handler;\n                eventUtil.normalizeEvent(container, e, true);\n                handler.dispatch('mousemove', e);\n            }\n        };\n        el.onmouseleave = function () {\n            if (self.enterable) {\n                if (self._show) {\n                    self.hideLater(self._hideDelay);\n                }\n            }\n            self._inContent = false;\n        };\n    }\n\n    TooltipContent.prototype = {\n\n        constructor: TooltipContent,\n\n        enterable: true,\n\n        /**\n         * Update when tooltip is rendered\n         */\n        update: function () {\n            var container = this._container;\n            var stl = container.currentStyle\n                || document.defaultView.getComputedStyle(container);\n            var domStyle = container.style;\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n                domStyle.position = 'relative';\n            }\n            // Hide the tooltip\n            // PENDING\n            // this.hide();\n        },\n\n        show: function (tooltipModel) {\n            clearTimeout(this._hideTimeout);\n            var el = this.el;\n\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n                + (tooltipModel.get('extraCssText') || '');\n\n            el.style.display = el.innerHTML ?  'block' : 'none';\n\n            this._show = true;\n        },\n\n        setContent: function (content) {\n            var el = this.el;\n            el.innerHTML = content;\n            el.style.display = content ? 'block' : 'none';\n        },\n\n        moveTo: function (x, y) {\n            var style = this.el.style;\n            style.left = x + 'px';\n            style.top = y + 'px';\n\n            this._x = x;\n            this._y = y;\n        },\n\n        hide: function () {\n            this.el.style.display = 'none';\n            this._show = false;\n        },\n\n        // showLater: function ()\n\n        hideLater: function (time) {\n            if (this._show && !(this._inContent && this.enterable)) {\n                if (time) {\n                    this._hideDelay = time;\n                    // Set show false to avoid invoke hideLater mutiple times\n                    this._show = false;\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n                }\n                else {\n                    this.hide();\n                }\n            }\n        },\n\n        isShow: function () {\n            return this._show;\n        }\n    };\n\n    module.exports = TooltipContent;\n\n},{\"../../util/format\":122,\"zrender/lib/core/env\":160,\"zrender/lib/core/event\":161,\"zrender/lib/core/util\":166,\"zrender/lib/tool/color\":197}],74:[function(require,module,exports){\n\n\n    require('../../echarts').extendComponentModel({\n\n        type: 'tooltip',\n\n        defaultOption: {\n            zlevel: 0,\n\n            z: 8,\n\n            show: true,\n\n            // tooltip\n            showContent: true,\n\n            // 'item'  'axis'\n            trigger: 'item',\n\n            //  'click' | 'mousemove' | 'none'\n            triggerOn: 'mousemove',\n\n            //  content\n            alwaysShowContent: false,\n\n            //  {Array} | {Function}\n            // position: null\n\n            //  content  viewRect  false \n            confine: false,\n\n            // {string}Template  {Function}\n            // formatter: null\n\n            showDelay: 0,\n\n            // ms\n            hideDelay: 100,\n\n            // s\n            transitionDuration: 0.4,\n\n            enterable: false,\n\n            // 0.7\n            backgroundColor: 'rgba(50,50,50,0.7)',\n\n            // \n            borderColor: '#333',\n\n            // px4\n            borderRadius: 4,\n\n            // px0\n            borderWidth: 0,\n\n            // px5\n            // css\n            padding: 5,\n\n            // Extra css text\n            extraCssText: '',\n\n            // \n            axisPointer: {\n                // \n                // 'line' | 'shadow' | 'cross'\n                type: 'line',\n\n                // type  line  tooltip line \n                //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n                //  'auto' cateogry  x \n                //  angle \n                axis: 'auto',\n\n                animation: true,\n                animationDurationUpdate: 200,\n                animationEasingUpdate: 'exponentialOut',\n\n                // \n                lineStyle: {\n                    color: '#555',\n                    width: 1,\n                    type: 'solid'\n                },\n\n                crossStyle: {\n                    color: '#555',\n                    width: 1,\n                    type: 'dashed',\n\n                    // TODO formatter\n                    textStyle: {}\n                },\n\n                // \n                shadowStyle: {\n                    color: 'rgba(150,150,150,0.3)'\n                }\n            },\n            textStyle: {\n                color: '#fff',\n                fontSize: 14\n            }\n        }\n    });\n\n},{\"../../echarts\":94}],75:[function(require,module,exports){\n\n\n    var TooltipContent = require('./TooltipContent');\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var numberUtil = require('../../util/number');\n    var modelUtil = require('../../util/model');\n    var parsePercent = numberUtil.parsePercent;\n    var env = require('zrender/lib/core/env');\n    var Model = require('../../model/Model');\n\n    function dataEqual(a, b) {\n        if (!a || !b) {\n            return false;\n        }\n        var round = numberUtil.round;\n        return round(a[0]) === round(b[0])\n            && round(a[1]) === round(b[1]);\n    }\n    /**\n     * @inner\n     */\n    function makeLineShape(x1, y1, x2, y2) {\n        return {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function makeRectShape(x, y, width, height) {\n        return {\n            x: x,\n            y: y,\n            width: width,\n            height: height\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n        return {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            clockwise: true\n        };\n    }\n\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n        var gap = 20;\n\n        if (x + width + gap > viewWidth) {\n            x -= width + gap;\n        }\n        else {\n            x += gap;\n        }\n        if (y + height + gap > viewHeight) {\n            y -= height + gap;\n        }\n        else {\n            y += gap;\n        }\n        return [x, y];\n    }\n\n    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        x = Math.min(x + width, viewWidth) - width;\n        y = Math.min(y + height, viewHeight) - height;\n        x = Math.max(x, 0);\n        y = Math.max(y, 0);\n\n        return [x, y];\n    }\n\n    function calcTooltipPosition(position, rect, dom) {\n        var domWidth = dom.clientWidth;\n        var domHeight = dom.clientHeight;\n        var gap = 5;\n        var x = 0;\n        var y = 0;\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n        switch (position) {\n            case 'inside':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'top':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y - domHeight - gap;\n                break;\n            case 'bottom':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight + gap;\n                break;\n            case 'left':\n                x = rect.x - domWidth - gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'right':\n                x = rect.x + rectWidth + gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n        }\n        return [x, y];\n    }\n\n    /**\n     * @param  {string|Function|Array.<number>} positionExpr\n     * @param  {number} x Mouse x\n     * @param  {number} y Mouse y\n     * @param  {boolean} confine Whether confine tooltip content in view rect.\n     * @param  {module:echarts/component/tooltip/TooltipContent} content\n     * @param  {Object|<Array.<Object>} params\n     * @param  {module:zrender/Element} el target element\n     * @param  {module:echarts/ExtensionAPI} api\n     * @return {Array.<number>}\n     */\n    function updatePosition(positionExpr, x, y, confine, content, params, el, api) {\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n\n        var rect = el && el.getBoundingRect().clone();\n        el && rect.applyTransform(el.transform);\n        if (typeof positionExpr === 'function') {\n            // Callback of position can be an array or a string specify the position\n            positionExpr = positionExpr([x, y], params, content.el, rect);\n        }\n\n        if (zrUtil.isArray(positionExpr)) {\n            x = parsePercent(positionExpr[0], viewWidth);\n            y = parsePercent(positionExpr[1], viewHeight);\n        }\n        // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n        else if (typeof positionExpr === 'string' && el) {\n            var pos = calcTooltipPosition(\n                positionExpr, rect, content.el\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n        else {\n            var pos = refixTooltipPosition(\n                x, y, content.el, viewWidth, viewHeight\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n\n        if (confine) {\n            var pos = confineTooltipPosition(\n                x, y, content.el, viewWidth, viewHeight\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n\n        content.moveTo(x, y);\n    }\n\n    function ifSeriesSupportAxisTrigger(seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n        var trigger = seriesModel.get('tooltip.trigger', true);\n        // Ignore series use item tooltip trigger and series coordinate system is not cartesian or\n        return !(!coordSys\n            || (coordSys.type !== 'cartesian2d' && coordSys.type !== 'polar' && coordSys.type !== 'singleAxis')\n            || trigger === 'item');\n    }\n\n    require('../../echarts').extendComponentView({\n\n        type: 'tooltip',\n\n        _axisPointers: {},\n\n        init: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var tooltipContent = new TooltipContent(api.getDom(), api);\n            this._tooltipContent = tooltipContent;\n        },\n\n        render: function (tooltipModel, ecModel, api) {\n            if (env.node) {\n                return;\n            }\n\n            // Reset\n            this.group.removeAll();\n\n            /**\n             * @type {Object}\n             * @private\n             */\n            this._axisPointers = {};\n\n            /**\n             * @private\n             * @type {module:echarts/component/tooltip/TooltipModel}\n             */\n            this._tooltipModel = tooltipModel;\n\n            /**\n             * @private\n             * @type {module:echarts/model/Global}\n             */\n            this._ecModel = ecModel;\n\n            /**\n             * @private\n             * @type {module:echarts/ExtensionAPI}\n             */\n            this._api = api;\n\n            /**\n             * @type {Object}\n             * @private\n             */\n            this._lastHover = {\n                // data\n                // payloadBatch\n            };\n\n            var tooltipContent = this._tooltipContent;\n            tooltipContent.update();\n            tooltipContent.enterable = tooltipModel.get('enterable');\n            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n            /**\n             * @type {Object.<string, Array>}\n             */\n            this._seriesGroupByAxis = this._prepareAxisTriggerData(\n                tooltipModel, ecModel\n            );\n\n            var crossText = this._crossText;\n            if (crossText) {\n                this.group.add(crossText);\n            }\n\n            var triggerOn = tooltipModel.get('triggerOn');\n\n            // Try to keep the tooltip show when refreshing\n            if (this._lastX != null\n                && this._lastY != null\n                // When user is willing to control tooltip totally using API,\n                // self.manuallyShowTip({x, y}) might cause tooltip hide,\n                // which is not expected.\n                && triggerOn !== 'none'\n            ) {\n                var self = this;\n                clearTimeout(this._refreshUpdateTimeout);\n                this._refreshUpdateTimeout = setTimeout(function () {\n                    // Show tip next tick after other charts are rendered\n                    // In case highlight action has wrong result\n                    // FIXME\n                    self.manuallyShowTip(tooltipModel, ecModel, api, {\n                        x: self._lastX,\n                        y: self._lastY\n                    });\n                });\n            }\n\n            var zr = this._api.getZr();\n            zr.off('click', this._tryShow);\n            zr.off('mousemove', this._mousemove);\n            zr.off('mouseout', this._hide);\n            zr.off('globalout', this._hide);\n\n            if (triggerOn === 'click') {\n                zr.on('click', this._tryShow, this);\n            }\n            else if (triggerOn === 'mousemove') {\n                zr.on('mousemove', this._mousemove, this);\n                zr.on('mouseout', this._hide, this);\n                zr.on('globalout', this._hide, this);\n            }\n            // else triggerOn is 'none', which enable user\n            // to control tooltip totally using API.\n        },\n\n        _mousemove: function (e) {\n            var showDelay = this._tooltipModel.get('showDelay');\n            var self = this;\n            clearTimeout(this._showTimeout);\n            if (showDelay > 0) {\n                this._showTimeout = setTimeout(function () {\n                    self._tryShow(e);\n                }, showDelay);\n            }\n            else {\n                this._tryShow(e);\n            }\n        },\n\n        /**\n         * Show tip manually by\n         * dispatchAction({\n         *     type: 'showTip',\n         *     x: 10,\n         *     y: 10\n         * });\n         * Or\n         * dispatchAction({\n         *      type: 'showTip',\n         *      seriesIndex: 0,\n         *      dataIndex or dataIndexInside or name\n         * });\n         *\n         *  TODO Batch\n         */\n        manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n            // From self\n            if (payload.from === this.uid) {\n                return;\n            }\n\n            var ecModel = this._ecModel;\n            var seriesIndex = payload.seriesIndex;\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n            var api = this._api;\n\n            var isTriggerAxis = this._tooltipModel.get('trigger') === 'axis';\n            function seriesHaveDataOnIndex(_series) {\n                var data = _series.getData();\n                var dataIndex = modelUtil.queryDataIndex(data, payload);\n                // Have single dataIndex\n                if (dataIndex != null && !zrUtil.isArray(dataIndex)\n                    && data.hasValue(dataIndex)\n                ) {\n                    return true;\n                }\n            }\n\n            if (payload.x == null || payload.y == null) {\n                if (isTriggerAxis) {\n                    // Find another series.\n                    if (seriesModel && !seriesHaveDataOnIndex(seriesModel)) {\n                        seriesModel = null;\n                    }\n                    if (!seriesModel) {\n                        // Find the first series can use axis trigger And data is not null\n                        ecModel.eachSeries(function (_series) {\n                            if (ifSeriesSupportAxisTrigger(_series) && !seriesModel) {\n                                if (seriesHaveDataOnIndex(_series)) {\n                                    seriesModel = _series;\n                                }\n                            }\n                        });\n                    }\n                }\n                else {\n                    // Use the first series by default.\n                    seriesModel = seriesModel || ecModel.getSeriesByIndex(0);\n                }\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n                    if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n                        return;\n                    }\n\n                    var el = data.getItemGraphicEl(dataIndex);\n                    var cx;\n                    var cy;\n                    // Try to get the point in coordinate system\n                    var coordSys = seriesModel.coordinateSystem;\n                    if (seriesModel.getTooltipPosition) {\n                        var point = seriesModel.getTooltipPosition(dataIndex) || [];\n                        cx = point[0];\n                        cy = point[1];\n                    }\n                    else if (coordSys && coordSys.dataToPoint) {\n                        var point = coordSys.dataToPoint(\n                            data.getValues(\n                                zrUtil.map(coordSys.dimensions, function (dim) {\n                                    return seriesModel.coordDimToDataDim(dim)[0];\n                                }), dataIndex, true\n                            )\n                        );\n                        cx = point && point[0];\n                        cy = point && point[1];\n                    }\n                    else if (el) {\n                        // Use graphic bounding rect\n                        var rect = el.getBoundingRect().clone();\n                        rect.applyTransform(el.transform);\n                        cx = rect.x + rect.width / 2;\n                        cy = rect.y + rect.height / 2;\n                    }\n\n                    if (cx != null && cy != null) {\n                        this._tryShow({\n                            offsetX: cx,\n                            offsetY: cy,\n                            position: payload.position,\n                            target: el,\n                            event: {}\n                        });\n                    }\n                }\n            }\n            else {\n                var el = api.getZr().handler.findHover(payload.x, payload.y);\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    target: el,\n                    event: {}\n                });\n            }\n        },\n\n        manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n            if (payload.from === this.uid) {\n                return;\n            }\n\n            this._hide();\n        },\n\n        _prepareAxisTriggerData: function (tooltipModel, ecModel) {\n            // Prepare data for axis trigger\n            var seriesGroupByAxis = {};\n            ecModel.eachSeries(function (seriesModel) {\n                if (ifSeriesSupportAxisTrigger(seriesModel)) {\n                    var coordSys = seriesModel.coordinateSystem;\n                    var baseAxis;\n                    var key;\n\n                    // Only cartesian2d, polar and single support axis trigger\n                    if (coordSys.type === 'cartesian2d') {\n                        // FIXME `axisPointer.axis` is not baseAxis\n                        baseAxis = coordSys.getBaseAxis();\n                        key = baseAxis.dim + baseAxis.index;\n                    }\n                    else if (coordSys.type === 'singleAxis') {\n                        baseAxis = coordSys.getAxis();\n                        key = baseAxis.dim + baseAxis.type;\n                    }\n                    else {\n                        baseAxis = coordSys.getBaseAxis();\n                        key = baseAxis.dim + coordSys.name;\n                    }\n\n                    seriesGroupByAxis[key] = seriesGroupByAxis[key] || {\n                        coordSys: [],\n                        series: []\n                    };\n                    seriesGroupByAxis[key].coordSys.push(coordSys);\n                    seriesGroupByAxis[key].series.push(seriesModel);\n                }\n            }, this);\n\n            return seriesGroupByAxis;\n        },\n\n        /**\n         * mousemove handler\n         * @param {Object} e\n         * @private\n         */\n        _tryShow: function (e) {\n            var el = e.target;\n            var tooltipModel = this._tooltipModel;\n            var globalTrigger = tooltipModel.get('trigger');\n            var ecModel = this._ecModel;\n            var api = this._api;\n\n            if (!tooltipModel) {\n                return;\n            }\n\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n            this._lastX = e.offsetX;\n            this._lastY = e.offsetY;\n\n            // Always show item tooltip if mouse is on the element with dataIndex\n            if (el && el.dataIndex != null) {\n                // Use dataModel in element if possible\n                // Used when mouseover on a element like markPoint or edge\n                // In which case, the data is not main data in series.\n                var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                var dataIndex = el.dataIndex;\n                var data = dataModel.getData();\n                var itemModel = data.getItemModel(dataIndex);\n                // Series or single data may use item trigger when global is axis trigger\n                if ((itemModel.get('tooltip.trigger') || globalTrigger) === 'axis') {\n                    this._showAxisTooltip(tooltipModel, ecModel, e);\n                }\n                else {\n                    // Reset ticket\n                    this._ticket = '';\n                    // If either single data or series use item trigger\n                    this._hideAxisPointer();\n                    // Reset last hover and dispatch downplay action\n                    this._resetLastHover();\n\n                    this._showItemTooltipContent(dataModel, dataIndex, el.dataType, e);\n                }\n\n                api.dispatchAction({\n                    type: 'showTip',\n                    from: this.uid,\n                    dataIndexInside: dataIndex,\n                    dataIndex: data.getRawIndex(dataIndex), // expose to user.\n                    seriesIndex: el.seriesIndex\n                });\n            }\n            // Tooltip provided directly. Like legend\n            else if (el && el.tooltip) {\n                var tooltipOpt = el.tooltip;\n                if (typeof tooltipOpt === 'string') {\n                    var content = tooltipOpt;\n                    tooltipOpt = {\n                        content: content,\n                        // Fixed formatter\n                        formatter: content\n                    };\n                }\n                var subTooltipModel = new Model(tooltipOpt, tooltipModel);\n                var defaultHtml = subTooltipModel.get('content');\n                var asyncTicket = Math.random();\n                this._showTooltipContent(\n                    // TODO params\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el, api\n                );\n            }\n            else {\n                if (globalTrigger === 'item') {\n                    this._hide();\n                }\n                else {\n                    // Try show axis tooltip\n                    this._showAxisTooltip(tooltipModel, ecModel, e);\n                }\n\n                // Action of cross pointer\n                // other pointer types will trigger action in _dispatchAndShowSeriesTooltipContent method\n                if (tooltipModel.get('axisPointer.type') === 'cross') {\n                    api.dispatchAction({\n                        type: 'showTip',\n                        from: this.uid,\n                        x: e.offsetX,\n                        y: e.offsetY\n                    });\n                }\n            }\n        },\n\n        /**\n         * Show tooltip on axis\n         * @param {module:echarts/component/tooltip/TooltipModel} tooltipModel\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Object} e\n         * @private\n         */\n        _showAxisTooltip: function (tooltipModel, ecModel, e) {\n            var axisPointerModel = tooltipModel.getModel('axisPointer');\n            var axisPointerType = axisPointerModel.get('type');\n\n            if (axisPointerType === 'cross') {\n                var el = e.target;\n                if (el && el.dataIndex != null) {\n                    var seriesModel = ecModel.getSeriesByIndex(el.seriesIndex);\n                    var dataIndex = el.dataIndex;\n                    this._showItemTooltipContent(seriesModel, dataIndex, el.dataType, e);\n                }\n            }\n\n            this._showAxisPointer();\n            var allNotShow = true;\n            zrUtil.each(this._seriesGroupByAxis, function (seriesCoordSysSameAxis) {\n                // Try show the axis pointer\n                var allCoordSys = seriesCoordSysSameAxis.coordSys;\n                var coordSys = allCoordSys[0];\n\n                // If mouse position is not in the grid or polar\n                var point = [e.offsetX, e.offsetY];\n\n                if (!coordSys.containPoint(point)) {\n                    // Hide axis pointer\n                    this._hideAxisPointer(coordSys.name);\n                    return;\n                }\n\n                allNotShow = false;\n                // Make sure point is discrete on cateogry axis\n                var dimensions = coordSys.dimensions;\n                var value = coordSys.pointToData(point, true);\n                point = coordSys.dataToPoint(value);\n\n                var baseAxis = coordSys.getBaseAxis();\n                var axisType = axisPointerModel.get('axis');\n                if (axisType === 'auto') {\n                    axisType = baseAxis.dim;\n                }\n\n                if (baseAxis.isBlank() || zrUtil.eqNaN(point[0]) || zrUtil.eqNaN(point[1])) {\n                    this._hideAxisPointer(coordSys.name);\n                    return;\n                }\n\n                var contentNotChange = false;\n                var lastHover = this._lastHover;\n                if (axisPointerType === 'cross') {\n                    // If hover data not changed\n                    // Possible when two axes are all category\n                    if (dataEqual(lastHover.data, value)) {\n                        contentNotChange = true;\n                    }\n                    lastHover.data = value;\n                }\n                else {\n                    var valIndex = zrUtil.indexOf(dimensions, axisType);\n\n                    // If hover data not changed on the axis dimension\n                    if (lastHover.data === value[valIndex]) {\n                        contentNotChange = true;\n                    }\n                    lastHover.data = value[valIndex];\n                }\n\n                var enableAnimation = tooltipModel.get('animation');\n\n                if (coordSys.type === 'cartesian2d' && !contentNotChange) {\n                    this._showCartesianPointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n                else if (coordSys.type === 'polar' && !contentNotChange) {\n                    this._showPolarPointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n                else if (coordSys.type === 'singleAxis' && !contentNotChange) {\n                    this._showSinglePointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n\n                if (axisPointerType !== 'cross') {\n                    this._dispatchAndShowSeriesTooltipContent(\n                        coordSys, seriesCoordSysSameAxis.series, point, value, contentNotChange, e.position\n                    );\n                }\n            }, this);\n\n            if (!this._tooltipModel.get('show')) {\n                this._hideAxisPointer();\n            }\n\n            if (allNotShow) {\n                this._hide();\n            }\n        },\n\n        /**\n         * Show tooltip on axis of cartesian coordinate\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @param {module:echarts/coord/cartesian/Cartesian2D} cartesians\n         * @param {string} axisType\n         * @param {Array.<number>} point\n         * @private\n         */\n        _showCartesianPointer: function (axisPointerModel, cartesian, axisType, point, enableAnimation) {\n            var self = this;\n\n            var axisPointerType = axisPointerModel.get('type');\n            var baseAxis = cartesian.getBaseAxis();\n            var moveAnimation = enableAnimation\n                && axisPointerType !== 'cross'\n                && baseAxis.type === 'category'\n                && baseAxis.getBandWidth() > 20;\n\n            if (axisPointerType === 'cross') {\n                moveGridLine('x', point, cartesian.getAxis('y').getGlobalExtent());\n                moveGridLine('y', point, cartesian.getAxis('x').getGlobalExtent());\n\n                this._updateCrossText(cartesian, point, axisPointerModel);\n            }\n            else {\n                var otherAxis = cartesian.getAxis(axisType === 'x' ? 'y' : 'x');\n                var otherExtent = otherAxis.getGlobalExtent();\n\n                if (cartesian.type === 'cartesian2d') {\n                    (axisPointerType === 'line' ? moveGridLine : moveGridShadow)(\n                        axisType, point, otherExtent\n                    );\n                }\n            }\n\n            /**\n             * @inner\n             */\n            function moveGridLine(axisType, point, otherExtent) {\n                var targetShape = axisType === 'x'\n                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\n                var pointerEl = self._getPointerElement(\n                    cartesian, axisPointerModel, axisType, targetShape\n                );\n                graphic.subPixelOptimizeLine({\n                    shape: targetShape,\n                    style: pointerEl.style\n                });\n\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n            /**\n             * @inner\n             */\n            function moveGridShadow(axisType, point, otherExtent) {\n                var axis = cartesian.getAxis(axisType);\n                var bandWidth = axis.getBandWidth();\n                var span = otherExtent[1] - otherExtent[0];\n                var targetShape = axisType === 'x'\n                    ? makeRectShape(point[0] - bandWidth / 2, otherExtent[0], bandWidth, span)\n                    : makeRectShape(otherExtent[0], point[1] - bandWidth / 2, span, bandWidth);\n\n                var pointerEl = self._getPointerElement(\n                    cartesian, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n        },\n\n        _showSinglePointer: function (axisPointerModel, single, axisType, point, enableAnimation) {\n            var self = this;\n            var axisPointerType = axisPointerModel.get('type');\n            var moveAnimation =\n                enableAnimation\n                && axisPointerType !== 'cross'\n                && single.getBaseAxis().type === 'category';\n            var rect = single.getRect();\n            var otherExtent = [rect.y, rect.y + rect.height];\n\n            moveSingleLine(axisType, point, otherExtent);\n\n            /**\n             * @inner\n             */\n            function moveSingleLine(axisType, point, otherExtent) {\n                var axis = single.getAxis();\n                var orient = axis.orient;\n\n                var targetShape = orient === 'horizontal'\n                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\n                var pointerEl = self._getPointerElement(\n                    single, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n        },\n\n        /**\n         * Show tooltip on axis of polar coordinate\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @param {Array.<module:echarts/coord/polar/Polar>} polar\n         * @param {string} axisType\n         * @param {Array.<number>} point\n         */\n        _showPolarPointer: function (axisPointerModel, polar, axisType, point, enableAnimation) {\n            var self = this;\n\n            var axisPointerType = axisPointerModel.get('type');\n\n            var angleAxis = polar.getAngleAxis();\n            var radiusAxis = polar.getRadiusAxis();\n\n            var moveAnimation = enableAnimation\n                && axisPointerType !== 'cross'\n                && polar.getBaseAxis().type === 'category';\n\n            if (axisPointerType === 'cross') {\n                movePolarLine('angle', point, radiusAxis.getExtent());\n                movePolarLine('radius', point, angleAxis.getExtent());\n\n                this._updateCrossText(polar, point, axisPointerModel);\n            }\n            else {\n                var otherAxis = polar.getAxis(axisType === 'radius' ? 'angle' : 'radius');\n                var otherExtent = otherAxis.getExtent();\n\n                (axisPointerType === 'line' ? movePolarLine : movePolarShadow)(\n                    axisType, point, otherExtent\n                );\n            }\n            /**\n             * @inner\n             */\n            function movePolarLine(axisType, point, otherExtent) {\n                var mouseCoord = polar.pointToCoord(point);\n\n                var targetShape;\n\n                if (axisType === 'angle') {\n                    var p1 = polar.coordToPoint([otherExtent[0], mouseCoord[1]]);\n                    var p2 = polar.coordToPoint([otherExtent[1], mouseCoord[1]]);\n                    targetShape = makeLineShape(p1[0], p1[1], p2[0], p2[1]);\n                }\n                else {\n                    targetShape = {\n                        cx: polar.cx,\n                        cy: polar.cy,\n                        r: mouseCoord[0]\n                    };\n                }\n\n                var pointerEl = self._getPointerElement(\n                    polar, axisPointerModel, axisType, targetShape\n                );\n\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n            /**\n             * @inner\n             */\n            function movePolarShadow(axisType, point, otherExtent) {\n                var axis = polar.getAxis(axisType);\n                var bandWidth = axis.getBandWidth();\n\n                var mouseCoord = polar.pointToCoord(point);\n\n                var targetShape;\n\n                var radian = Math.PI / 180;\n\n                if (axisType === 'angle') {\n                    targetShape = makeSectorShape(\n                        polar.cx, polar.cy,\n                        otherExtent[0], otherExtent[1],\n                        // In ECharts y is negative if angle is positive\n                        (-mouseCoord[1] - bandWidth / 2) * radian,\n                        (-mouseCoord[1] + bandWidth / 2) * radian\n                    );\n                }\n                else {\n                    targetShape = makeSectorShape(\n                        polar.cx, polar.cy,\n                        mouseCoord[0] - bandWidth / 2,\n                        mouseCoord[0] + bandWidth / 2,\n                        0, Math.PI * 2\n                    );\n                }\n\n                var pointerEl = self._getPointerElement(\n                    polar, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n        },\n\n        _updateCrossText: function (coordSys, point, axisPointerModel) {\n            var crossStyleModel = axisPointerModel.getModel('crossStyle');\n            var textStyleModel = crossStyleModel.getModel('textStyle');\n\n            var tooltipModel = this._tooltipModel;\n\n            var text = this._crossText;\n            if (!text) {\n                text = this._crossText = new graphic.Text({\n                    style: {\n                        textAlign: 'left',\n                        textVerticalAlign: 'bottom'\n                    }\n                });\n                this.group.add(text);\n            }\n\n            var value = coordSys.pointToData(point);\n\n            var dims = coordSys.dimensions;\n            value = zrUtil.map(value, function (val, idx) {\n                var axis = coordSys.getAxis(dims[idx]);\n                if (axis.type === 'category' || axis.type === 'time') {\n                    val = axis.scale.getLabel(val);\n                }\n                else {\n                    val = formatUtil.addCommas(\n                        val.toFixed(axis.getPixelPrecision())\n                    );\n                }\n                return val;\n            });\n\n            text.setStyle({\n                fill: textStyleModel.getTextColor() || crossStyleModel.get('color'),\n                textFont: textStyleModel.getFont(),\n                text: value.join(', '),\n                x: point[0] + 5,\n                y: point[1] - 5\n            });\n            text.z = tooltipModel.get('z');\n            text.zlevel = tooltipModel.get('zlevel');\n        },\n\n        _getPointerElement: function (coordSys, pointerModel, axisType, initShape) {\n            var tooltipModel = this._tooltipModel;\n            var z = tooltipModel.get('z');\n            var zlevel = tooltipModel.get('zlevel');\n            var axisPointers = this._axisPointers;\n            var coordSysName = coordSys.name;\n            axisPointers[coordSysName] = axisPointers[coordSysName] || {};\n            if (axisPointers[coordSysName][axisType]) {\n                return axisPointers[coordSysName][axisType];\n            }\n\n            // Create if not exists\n            var pointerType = pointerModel.get('type');\n            var styleModel = pointerModel.getModel(pointerType + 'Style');\n            var isShadow = pointerType === 'shadow';\n            var style = styleModel[isShadow ? 'getAreaStyle' : 'getLineStyle']();\n\n            var elementType = coordSys.type === 'polar'\n                ? (isShadow ? 'Sector' : (axisType === 'radius' ? 'Circle' : 'Line'))\n                : (isShadow ? 'Rect' : 'Line');\n\n            isShadow ? (style.stroke = null) : (style.fill = null);\n\n            var el = axisPointers[coordSysName][axisType] = new graphic[elementType]({\n                style: style,\n                z: z,\n                zlevel: zlevel,\n                silent: true,\n                shape: initShape\n            });\n\n            this.group.add(el);\n            return el;\n        },\n\n        /**\n         * Dispatch actions and show tooltip on series\n         * @param {Array.<module:echarts/model/Series>} seriesList\n         * @param {Array.<number>} point\n         * @param {Array.<number>} value\n         * @param {boolean} contentNotChange\n         * @param {Array.<number>|string|Function} [positionExpr]\n         */\n        _dispatchAndShowSeriesTooltipContent: function (\n            coordSys, seriesList, point, value, contentNotChange, positionExpr\n        ) {\n\n            var rootTooltipModel = this._tooltipModel;\n\n            var baseAxis = coordSys.getBaseAxis();\n            var baseDimIndex = ({x: 1, radius: 1, single: 1})[baseAxis.dim] ? 0 : 1;\n\n            if (!seriesList.length) {\n                return;\n            }\n\n            var payloadBatch = zrUtil.map(seriesList, function (series) {\n                return {\n                    seriesIndex: series.seriesIndex,\n                    dataIndexInside: series.getAxisTooltipDataIndex\n                        ? series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim), value, baseAxis)\n                        : series.getData().indexOfNearest(\n                            series.coordDimToDataDim(baseAxis.dim)[0],\n                            value[baseDimIndex],\n                            // Add a threshold to avoid find the wrong dataIndex when data length is not same\n                            false, baseAxis.type === 'category' ? 0.5 : null\n                        )\n                };\n            });\n            var sampleSeriesIndex;\n            zrUtil.each(payloadBatch, function (payload, idx) {\n                if (seriesList[idx].getData().hasValue(payload.dataIndexInside)) {\n                    sampleSeriesIndex = idx;\n                }\n            });\n            // Fallback to 0.\n            sampleSeriesIndex = sampleSeriesIndex || 0;\n\n            var lastHover = this._lastHover;\n            var api = this._api;\n            // Dispatch downplay action\n            if (lastHover.payloadBatch && !contentNotChange) {\n                api.dispatchAction({\n                    type: 'downplay',\n                    batch: lastHover.payloadBatch\n                });\n            }\n            // Dispatch highlight action\n            if (!contentNotChange) {\n                api.dispatchAction({\n                    type: 'highlight',\n                    batch: payloadBatch\n                });\n                lastHover.payloadBatch = payloadBatch;\n            }\n            // Dispatch showTip action\n            var dataIndex = payloadBatch[sampleSeriesIndex].dataIndexInside;\n            api.dispatchAction({\n                type: 'showTip',\n                dataIndexInside: dataIndex,\n                // expose to user.\n                dataIndex: seriesList[sampleSeriesIndex].getData().getRawIndex(dataIndex),\n                seriesIndex: payloadBatch[sampleSeriesIndex].seriesIndex,\n                from: this.uid\n            });\n\n            if (baseAxis && rootTooltipModel.get('showContent') && rootTooltipModel.get('show')) {\n                var paramsList = zrUtil.map(seriesList, function (series, index) {\n                    return series.getDataParams(payloadBatch[index].dataIndexInside);\n                });\n\n                if (!contentNotChange) {\n                    // Update html content\n                    var firstDataIndex = payloadBatch[sampleSeriesIndex].dataIndexInside;\n\n                    // Default tooltip content\n                    // FIXME\n                    // (1) shold be the first data which has name?\n                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                    var firstLine = baseAxis.type === 'time'\n                        ? baseAxis.scale.getLabel(value[baseDimIndex])\n                        : seriesList[sampleSeriesIndex].getData().getName(firstDataIndex);\n                    var defaultHtml = (firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '')\n                        + zrUtil.map(seriesList, function (series, index) {\n                            return series.formatTooltip(payloadBatch[index].dataIndexInside, true);\n                        }).join('<br />');\n\n                    var asyncTicket = 'axis_' + coordSys.name + '_' + firstDataIndex;\n\n                    this._showTooltipContent(\n                        rootTooltipModel, defaultHtml, paramsList, asyncTicket,\n                        point[0], point[1], positionExpr, null, api\n                    );\n                }\n                else {\n                    updatePosition(\n                        positionExpr || rootTooltipModel.get('position'),\n                        point[0], point[1],\n                        rootTooltipModel.get('confine'),\n                        this._tooltipContent, paramsList, null, api\n                    );\n                }\n            }\n        },\n\n        /**\n         * Show tooltip on item\n         * @param {module:echarts/model/Series} seriesModel\n         * @param {number} dataIndex\n         * @param {string} dataType\n         * @param {Object} e\n         */\n        _showItemTooltipContent: function (seriesModel, dataIndex, dataType, e) {\n            // FIXME Graph data\n            var api = this._api;\n            var data = seriesModel.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var tooltipOpt = itemModel.get('tooltip', true);\n            if (typeof tooltipOpt === 'string') {\n                // In each data item tooltip can be simply write:\n                // {\n                //  value: 10,\n                //  tooltip: 'Something you need to know'\n                // }\n                var tooltipContent = tooltipOpt;\n                tooltipOpt = {\n                    formatter: tooltipContent\n                };\n            }\n            var rootTooltipModel = this._tooltipModel;\n            var seriesTooltipModel = seriesModel.getModel(\n                'tooltip', rootTooltipModel\n            );\n            var tooltipModel = new Model(tooltipOpt, seriesTooltipModel, seriesTooltipModel.ecModel);\n\n            var params = seriesModel.getDataParams(dataIndex, dataType);\n            var defaultHtml = seriesModel.formatTooltip(dataIndex, false, dataType);\n\n            var asyncTicket = 'item_' + seriesModel.name + '_' + dataIndex;\n\n            this._showTooltipContent(\n                tooltipModel, defaultHtml, params, asyncTicket,\n                e.offsetX, e.offsetY, e.position, e.target, api\n            );\n        },\n\n        _showTooltipContent: function (\n            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, target, api\n        ) {\n            // Reset ticket\n            this._ticket = '';\n\n            if (tooltipModel.get('showContent') && tooltipModel.get('show')) {\n                var tooltipContent = this._tooltipContent;\n                var confine = tooltipModel.get('confine');\n\n                var formatter = tooltipModel.get('formatter');\n                positionExpr = positionExpr || tooltipModel.get('position');\n                var html = defaultHtml;\n\n                if (formatter) {\n                    if (typeof formatter === 'string') {\n                        html = formatUtil.formatTpl(formatter, params, true);\n                    }\n                    else if (typeof formatter === 'function') {\n                        var self = this;\n                        var ticket = asyncTicket;\n                        var callback = function (cbTicket, html) {\n                            if (cbTicket === self._ticket) {\n                                tooltipContent.setContent(html);\n\n                                updatePosition(\n                                    positionExpr, x, y, confine,\n                                    tooltipContent, params, target, api\n                                );\n                            }\n                        };\n                        self._ticket = ticket;\n                        html = formatter(params, ticket, callback);\n                    }\n                }\n\n                tooltipContent.show(tooltipModel);\n                tooltipContent.setContent(html);\n\n                updatePosition(\n                    positionExpr, x, y, confine,\n                    tooltipContent, params, target, api\n                );\n            }\n        },\n\n        /**\n         * Show axis pointer\n         * @param {string} [coordSysName]\n         */\n        _showAxisPointer: function (coordSysName) {\n            if (coordSysName) {\n                var axisPointers = this._axisPointers[coordSysName];\n                axisPointers && zrUtil.each(axisPointers, function (el) {\n                    el.show();\n                });\n            }\n            else {\n                this.group.eachChild(function (child) {\n                    child.show();\n                });\n                this.group.show();\n            }\n        },\n\n        _resetLastHover: function () {\n            var lastHover = this._lastHover;\n            if (lastHover.payloadBatch) {\n                this._api.dispatchAction({\n                    type: 'downplay',\n                    batch: lastHover.payloadBatch\n                });\n            }\n            // Reset lastHover\n            this._lastHover = {};\n        },\n        /**\n         * Hide axis pointer\n         * @param {string} [coordSysName]\n         */\n        _hideAxisPointer: function (coordSysName) {\n            if (coordSysName) {\n                var axisPointers = this._axisPointers[coordSysName];\n                axisPointers && zrUtil.each(axisPointers, function (el) {\n                    el.hide();\n                });\n            }\n            else {\n                if (this.group.children().length) {\n                    this.group.hide();\n                }\n            }\n        },\n\n        _hide: function () {\n            clearTimeout(this._showTimeout);\n\n            this._hideAxisPointer();\n            this._resetLastHover();\n            if (!this._alwaysShowContent) {\n                this._tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n            }\n\n            this._api.dispatchAction({\n                type: 'hideTip',\n                from: this.uid\n            });\n\n            this._lastX = this._lastY = null;\n        },\n\n        dispose: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var zr = api.getZr();\n            this._tooltipContent.hide();\n\n            zr.off('click', this._tryShow);\n            zr.off('mousemove', this._mousemove);\n            zr.off('mouseout', this._hide);\n            zr.off('globalout', this._hide);\n        }\n    });\n\n},{\"../../echarts\":94,\"../../model/Model\":100,\"../../util/format\":122,\"../../util/graphic\":123,\"../../util/model\":125,\"../../util/number\":126,\"./TooltipContent\":73,\"zrender/lib/core/env\":160,\"zrender/lib/core/util\":166}],76:[function(require,module,exports){\n\n\n    var numberUtil = require('../util/number');\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = require('zrender/lib/core/util');\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            var ret = this._extent.slice();\n            return ret;\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        },\n\n        /**\n         * When axis extent depends on data and no data exists,\n         * axis ticks should not be drawn, which is named 'blank'.\n         */\n        isBlank: function () {\n            return this._isBlank;\n        },\n\n        /**\n         * When axis extent depends on data and no data exists,\n         * axis ticks should not be drawn, which is named 'blank'.\n         */\n        setBlank: function (isBlank) {\n            this._isBlank = isBlank;\n        }\n\n    };\n\n    module.exports = Axis;\n\n},{\"../util/number\":126,\"zrender/lib/core/util\":166}],77:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var defaultOption = {\n        show: true,\n        zlevel: 0,                  // \n        z: 0,                       // \n        // \n        inverse: false,\n\n        // \n        name: '',\n        // 'start' | 'middle' | 'end'\n        nameLocation: 'end',\n        // degree\n        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n        nameTruncate: {\n            maxWidth: null,\n            ellipsis: '...',\n            placeholder: '.'\n        },\n        // \n        nameTextStyle: {},\n        // \n        nameGap: 15,\n\n        silent: false, // Default false to support tooltip.\n        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n        tooltip: {\n            show: false\n        },\n\n        // \n        axisLine: {\n            // show\n            show: true,\n            onZero: true,\n            // lineStyle\n            lineStyle: {\n                color: '#333',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        axisTick: {\n            // show\n            show: true,\n            // grid\n            inside: false,\n            // length\n            length: 5,\n            // lineStyle\n            lineStyle: {\n                width: 1\n            }\n        },\n        // axis.axisLabel\n        axisLabel: {\n            show: true,\n            // grid\n            inside: false,\n            rotate: 0,\n            margin: 8,\n            // formatter: null,\n            // TEXTSTYLE\n            textStyle: {\n                fontSize: 12\n            }\n        },\n        // \n        splitLine: {\n            // show\n            show: true,\n            // lineStylelineStyle\n            lineStyle: {\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        splitArea: {\n            // show\n            show: false,\n            // areaStyleareaStyle\n            areaStyle: {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    };\n\n    var categoryAxis = zrUtil.merge({\n        // \n        boundaryGap: true,\n        // splitArea: {\n            // show: false\n        // },\n        splitLine: {\n            show: false\n        },\n        // \n        axisTick: {\n            // If tick is align with label when boundaryGap is true\n            // Default with axisTick\n            alignWithLabel: false,\n            interval: 'auto'\n        },\n        // axis.axisLabel\n        axisLabel: {\n            interval: 'auto'\n        }\n    }, defaultOption);\n\n    var valueAxis = zrUtil.merge({\n        // \n        boundaryGap: [0, 0],\n        // ,  'dataMin' \n        // min: null,\n        //  'dataMax' \n        // max: null,\n        // Readonly prop, specifies start value of the range when using data zoom.\n        // rangeStart: null\n        // Readonly prop, specifies end value of the range when using data zoom.\n        // rangeEnd: null\n        // 0_min_max\n        // scale: false,\n        // 5\n        splitNumber: 5\n        // Minimum interval\n        // minInterval: null\n    }, defaultOption);\n\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n        scale: true,\n        min: 'dataMin',\n        max: 'dataMax'\n    }, valueAxis);\n    var logAxis = zrUtil.defaults({\n        logBase: 10\n    }, valueAxis);\n    logAxis.scale = true;\n\n    module.exports = {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n\n},{\"zrender/lib/core/util\":166}],78:[function(require,module,exports){\n\n\n    var OrdinalScale = require('../scale/Ordinal');\n    var IntervalScale = require('../scale/Interval');\n    require('../scale/Time');\n    require('../scale/Log');\n    var Scale = require('../scale/Scale');\n\n    var numberUtil = require('../util/number');\n    var zrUtil = require('zrender/lib/core/util');\n    var textContain = require('zrender/lib/contain/text');\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     * Item of returned array can only be number (including Infinity and NaN).\n     */\n    axisHelper.getScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var scaleType = scale.type;\n\n        var min = model.getMin();\n        var max = model.getMax();\n        var fixMin = min != null;\n        var fixMax = max != null;\n        var originalExtent = scale.getExtent();\n\n        var axisDataLen;\n        var boundaryGap;\n        var span;\n        if (scaleType === 'ordinal') {\n            axisDataLen = (model.get('data') || []).length;\n        }\n        else {\n            boundaryGap = model.get('boundaryGap');\n            if (!zrUtil.isArray(boundaryGap)) {\n                boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n            }\n            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n            span = originalExtent[1] - originalExtent[0];\n        }\n\n        if (min == null) {\n            min = scaleType === 'ordinal'\n                ? (axisDataLen ? 0 : NaN)\n                : originalExtent[0] - boundaryGap[0] * span;\n        }\n        if (max == null) {\n            max = scaleType === 'ordinal'\n                ? (axisDataLen ? axisDataLen - 1 : NaN)\n                : originalExtent[1] + boundaryGap[1] * span;\n        }\n\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n\n        (min == null || !isFinite(min)) && (min = NaN);\n        (max == null || !isFinite(max)) && (max = NaN);\n\n        axis.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max));\n\n        // Evaluate if axis needs cross zero\n        if (model.getNeedCrossZero()) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var extent = axisHelper.getScaleExtent(axis, model);\n        var fixMin = model.getMin() != null;\n        var fixMax = model.getMax() != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent(splitNumber, fixMin, fixMax);\n\n        // Use minInterval to constraint the calculated interval.\n        // If calculated interval is less than minInterval. increase the interval quantity until\n        // it is larger than minInterval.\n        // For example:\n        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n        //  an integer axis.\n        var minInterval = model.get('minInterval');\n        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n            var interval = scale.getInterval();\n            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n            // while (interval < minInterval) {\n            //     var quantity = numberUtil.quantity(interval);\n            //     interval = quantity * 10;\n            //     scaleQuantity *= 10;\n            // }\n            extent = scale.getExtent();\n            var origin = (extent[1] + extent[0]) / 2;\n            scale.setExtent(\n                intervalScale * (extent[0] - origin) + origin,\n                intervalScale * (extent[1] - origin) + origin\n            );\n            scale.niceExtent(splitNumber);\n        }\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // axislabelhorizontalvertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val != null ? val : '');\n                };\n            })(labelFormatter);\n            // Consider empty array\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axis.type === 'category' ? scale.getLabel(tick) : tick,\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    module.exports = axisHelper;\n\n},{\"../scale/Interval\":115,\"../scale/Log\":116,\"../scale/Ordinal\":117,\"../scale/Scale\":118,\"../scale/Time\":119,\"../util/number\":126,\"zrender/lib/contain/text\":150,\"zrender/lib/core/util\":166}],79:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('./axisHelper');\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj;\n        }\n    }\n\n    module.exports = {\n\n        /**\n         * Format labels\n         * @return {Array.<string>}\n         */\n        getFormattedLabels: function () {\n            return axisHelper.getFormattedLabels(\n                this.axis,\n                this.get('axisLabel.formatter')\n            );\n        },\n\n        /**\n         * Get categories\n         */\n        getCategories: function () {\n            return this.get('type') === 'category'\n                && zrUtil.map(this.get('data'), getName);\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n         */\n        getMin: function (origin) {\n            var option = this.option;\n            var min = (!origin && option.rangeStart != null)\n                ? option.rangeStart : option.min;\n\n            if (min != null && min !== 'dataMin' && !zrUtil.eqNaN(min)) {\n                min = this.axis.scale.parse(min);\n            }\n            return min;\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n         */\n        getMax: function (origin) {\n            var option = this.option;\n            var max = (!origin && option.rangeEnd != null)\n                ? option.rangeEnd : option.max;\n\n            if (max != null && max !== 'dataMax' && !zrUtil.eqNaN(max)) {\n                max = this.axis.scale.parse(max);\n            }\n            return max;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * Should be implemented by each axis model if necessary.\n         * @return {module:echarts/model/Component} coordinate system model\n         */\n        getCoordSysModel: zrUtil.noop,\n\n        /**\n         * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n         * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * Reset range\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n},{\"./axisHelper\":78,\"zrender/lib/core/util\":166}],80:[function(require,module,exports){\n\n\n    var axisDefault = require('./axisDefault');\n    var zrUtil = require('zrender/lib/core/util');\n    var ComponentModel = require('../model/Component');\n    var layout = require('../util/layout');\n\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n\n            BaseAxisModelClass.extend({\n\n                type: axisName + 'Axis.' + axisType,\n\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode\n                        ? layout.getLayoutParams(option) : {};\n\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n\n                    option.type = axisTypeDefaulter(axisName, option);\n\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n\n                defaultOption: zrUtil.mergeAll(\n                    [\n                        {},\n                        axisDefault[axisType + 'Axis'],\n                        extraDefaultOption\n                    ],\n                    true\n                )\n            });\n        });\n\n        ComponentModel.registerSubTypeDefaulter(\n            axisName + 'Axis',\n            zrUtil.curry(axisTypeDefaulter, axisName)\n        );\n    };\n\n},{\"../model/Component\":98,\"../util/layout\":124,\"./axisDefault\":77,\"zrender/lib/core/util\":166}],81:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Axis = require('../Axis');\n    var axisLabelInterval = require('./axisLabelInterval');\n\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n\n    Axis2D.prototype = {\n\n        constructor: Axis2D,\n\n        /**\n         * Index of axis, can be used as key\n         */\n        index: 0,\n        /**\n         * If axis is on the zero position of the other axis\n         * @type {boolean}\n         */\n        onZero: false,\n\n        /**\n         * Axis model\n         * @param {module:echarts/coord/cartesian/AxisModel}\n         */\n        model: null,\n\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n\n        getGlobalExtent: function () {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            return ret;\n        },\n\n        /**\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                labelInterval = this._labelInterval = axisLabelInterval(this);\n            }\n            return labelInterval;\n        },\n\n        /**\n         * If label is ignored.\n         * Automatically used when axis is category and label can not be all shown\n         * @param  {number}  idx\n         * @return {boolean}\n         */\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return ((typeof labelInterval === 'function')\n                    && !labelInterval(idx, this.scale.getLabel(idx)))\n                    || idx % (labelInterval + 1);\n            }\n        },\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var localCoord = axis.toLocalCoord(80);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toLocalCoord: null,\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var globalCoord = axis.toLocalCoord(40);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toGlobalCoord: null\n\n    };\n    zrUtil.inherits(Axis2D, Axis);\n\n    module.exports = Axis2D;\n\n},{\"../Axis\":76,\"./axisLabelInterval\":87,\"zrender/lib/core/util\":166}],82:[function(require,module,exports){\n'use strict';\n\n\n    var ComponentModel = require('../../model/Component');\n    var zrUtil = require('zrender/lib/core/util');\n    var axisModelCreator = require('../axisModelCreator');\n\n    var AxisModel = ComponentModel.extend({\n\n        type: 'cartesian2dAxis',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Axis2D}\n         */\n        axis: null,\n\n        /**\n         * @override\n         */\n        init: function () {\n            AxisModel.superApply(this, 'init', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function () {\n            AxisModel.superApply(this, 'mergeOption', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        restoreData: function () {\n            AxisModel.superApply(this, 'restoreData', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         * @return {module:echarts/model/Component}\n         */\n        getCoordSysModel: function () {\n            return this.ecModel.queryComponents({\n                mainType: 'grid',\n                index: this.option.gridIndex,\n                id: this.option.gridId\n            })[0];\n        }\n\n    });\n\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n\n    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n\n    var extraOption = {\n        // gridIndex: 0,\n        // gridId: '',\n\n        // Offset is for multiple axis on the same position\n        offset: 0\n    };\n\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\n    module.exports = AxisModel;\n\n},{\"../../model/Component\":98,\"../axisModelCommonMixin\":79,\"../axisModelCreator\":80,\"zrender/lib/core/util\":166}],83:[function(require,module,exports){\n'use strict';\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n\n        this._dimList = [];\n\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n\n    Cartesian.prototype = {\n\n        constructor: Cartesian,\n\n        type: 'cartesian',\n\n        /**\n         * Get axis\n         * @param  {number|string} dim\n         * @return {module:echarts/coord/Cartesian~Axis}\n         */\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n\n        /**\n         * Get axes list\n         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n         */\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n\n        /**\n         * Get axes list by given scale type\n         */\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(\n                this.getAxes(),\n                function (axis) {\n                    return axis.scale.type === scaleType;\n                }\n            );\n        },\n\n        /**\n         * Add axis\n         * @param {module:echarts/coord/Cartesian.Axis}\n         */\n        addAxis: function (axis) {\n            var dim = axis.dim;\n\n            this._axes[dim] = axis;\n\n            this._dimList.push(dim);\n        },\n\n        /**\n         * Convert data to coord in nd space\n         * @param {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n\n        /**\n         * Convert coord in nd space to data\n         * @param  {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n\n            var output = input instanceof Array ? [] : {};\n\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n\n                output[dim] = axis[method](input[dim]);\n            }\n\n            return output;\n        }\n    };\n\n    module.exports = Cartesian;\n\n},{\"zrender/lib/core/util\":166}],84:[function(require,module,exports){\n'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Cartesian = require('./Cartesian');\n\n    function Cartesian2D(name) {\n\n        Cartesian.call(this, name);\n    }\n\n    Cartesian2D.prototype = {\n\n        constructor: Cartesian2D,\n\n        type: 'cartesian2d',\n\n        /**\n         * @type {Array.<string>}\n         * @readOnly\n         */\n        dimensions: ['x', 'y'],\n\n        /**\n         * Base axis will be used on stacking.\n         *\n         * @return {module:echarts/coord/cartesian/Axis2D}\n         */\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0]\n                || this.getAxesByScale('time')[0]\n                || this.getAxis('x');\n        },\n\n        /**\n         * If contain point\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0]))\n                && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n\n        /**\n         * If contain data\n         * @param {Array.<number>} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0])\n                && this.getAxis('y').containData(data[1]);\n        },\n\n        /**\n         * Convert series data to an array of points\n         * @param {module:echarts/data/List} data\n         * @param {boolean} stack\n         * @return {Array}\n         *  Return array of points. For example:\n         *  `[[10, 10], [20, 20], [30, 30]]`\n         */\n        dataToPoints: function (data, stack) {\n            return data.mapArray(['x', 'y'], function (x, y) {\n                return this.dataToPoint([x, y]);\n            }, stack, this);\n        },\n\n        /**\n         * @param {Array.<number>} data\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n\n        /**\n         * @param {Array.<number>} point\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n\n        /**\n         * Get other axis\n         * @param {module:echarts/coord/cartesian/Axis2D} axis\n         */\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n    };\n\n    zrUtil.inherits(Cartesian2D, Cartesian);\n\n    module.exports = Cartesian2D;\n\n},{\"./Cartesian\":83,\"zrender/lib/core/util\":166}],85:[function(require,module,exports){\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nvar factory = exports;\n\n    var layout = require('../../util/layout');\n    var axisHelper = require('../../coord/axisHelper');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Cartesian2D = require('./Cartesian2D');\n    var Axis2D = require('./Axis2D');\n\n    var each = zrUtil.each;\n\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n\n    //  GridModel, AxisModel \n    require('./GridModel');\n\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.getCoordSysModel() === gridModel;\n    }\n\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var textStyleModel = axisModel.getModel('axisLabel.textStyle');\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = textStyleModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : (rect = singleRect);\n            }\n        }\n        return rect;\n    }\n\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n\n        this._initCartesian(gridModel, ecModel, api);\n\n        this._model = gridModel;\n    }\n\n    var gridProto = Grid.prototype;\n\n    gridProto.type = 'grid';\n\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n\n    gridProto.update = function (ecModel, api) {\n\n        var axesMap = this._axesMap;\n\n        this._updateScale(ecModel, this._model);\n\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                if (axes.hasOwnProperty(idx)) {\n                    var axis = axes[idx];\n                    if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this._model, api);\n    };\n\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api) {\n\n        var gridRect = layout.getLayoutRect(\n            gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n\n        this._rect = gridRect;\n\n        var axesList = this._axesList;\n\n        adjustAxes();\n\n        // Minus label size\n        if (gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        }\n                        else if (axis.position === 'left')  {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n\n            adjustAxes();\n        }\n\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    if (axesMapOnDim.hasOwnProperty(name)) {\n                        return axesMapOnDim[name];\n                    }\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        }\n        else {\n            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n                if (coordList[i].getAxis('x').index === xAxisIndex\n                    || coordList[i].getAxis('y').index === yAxisIndex\n                ) {\n                    return coordList[i];\n                }\n            }\n        }\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertToPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.dataToPoint(value)\n            : target.axis\n            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n            : null;\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertFromPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.pointToData(value)\n            : target.axis\n            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n            : null;\n    };\n\n    /**\n     * @inner\n     */\n    gridProto._findConvertTarget = function (ecModel, finder) {\n        var seriesModel = finder.seriesModel;\n        var xAxisModel = finder.xAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n        var yAxisModel = finder.yAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n        var gridModel = finder.gridModel;\n        var coordsList = this._coordsList;\n        var cartesian;\n        var axis;\n\n        if (seriesModel) {\n            cartesian = seriesModel.coordinateSystem;\n            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n        }\n        else if (xAxisModel && yAxisModel) {\n            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        }\n        else if (xAxisModel) {\n            axis = this.getAxis('x', xAxisModel.componentIndex);\n        }\n        else if (yAxisModel) {\n            axis = this.getAxis('y', yAxisModel.componentIndex);\n        }\n        // Lowest priority.\n        else if (gridModel) {\n            var grid = gridModel.coordinateSystem;\n            if (grid === this) {\n                cartesian = this._coordsList[0];\n            }\n        }\n\n        return {cartesian: cartesian, axis: axis};\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.containPoint = function (point) {\n        var coord = this._coordsList[0];\n        if (coord) {\n            return coord.containPoint(point);\n        }\n    };\n\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n            left: false,\n            right: false,\n            top: false,\n            bottom: false\n        };\n\n        var axesMap = {\n            x: {},\n            y: {}\n        };\n        var axesCount = {\n            x: 0,\n            y: 0\n        };\n\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n\n        this._axesMap = axesMap;\n\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n\n                cartesian.grid = this;\n\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                }\n                else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n\n                var axis = new Axis2D(\n                    axisType, axisHelper.createScaleByModel(axisModel),\n                    [0, 0],\n                    axisModel.get('type'),\n                    axisPosition\n                );\n\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n\n                axis.onZero = axisModel.get('axisLine.onZero');\n\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n\n                // Inject axisModel into axis\n                axis.model = axisModel;\n\n                // Inject grid info axis\n                axis.grid = this;\n\n                // Index of axis, can be used as key\n                axis.index = idx;\n\n                this._axesList.push(axis);\n\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n                 ) {\n                    return;\n                }\n\n                var cartesian = this.getCartesian(\n                    xAxisModel.componentIndex, yAxisModel.componentIndex\n                );\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtentFromData(data, dim);\n            });\n        }\n    };\n\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord + coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n        axis.toLocalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord - coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n    }\n\n    var axesTypes = ['xAxis', 'yAxis'];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\n            if (__DEV__) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n                        seriesModel.get(axisType + 'Index'),\n                        seriesModel.get(axisType + 'Id'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            grid.resize(gridModel, api);\n\n            gridModel.coordinateSystem = grid;\n\n            grids.push(grid);\n        });\n\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            var gridModel = xAxisModel.getCoordSysModel();\n\n            if (__DEV__) {\n                if (!gridModel) {\n                    throw new Error(\n                        'Grid \"' + zrUtil.retrieve(\n                            xAxisModel.get('gridIndex'),\n                            xAxisModel.get('gridId'),\n                            0\n                        ) + '\" not found'\n                    );\n                }\n                if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n\n            var grid = gridModel.coordinateSystem;\n\n            seriesModel.coordinateSystem = grid.getCartesian(\n                xAxisModel.componentIndex, yAxisModel.componentIndex\n            );\n        });\n\n        return grids;\n    };\n\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\n    require('../../CoordinateSystem').register('cartesian2d', Grid);\n\n    module.exports = Grid;\n\n},{\"../../CoordinateSystem\":1,\"../../coord/axisHelper\":78,\"../../util/layout\":124,\"./Axis2D\":81,\"./Cartesian2D\":84,\"./GridModel\":86,\"zrender/lib/core/util\":166}],86:[function(require,module,exports){\n'use strict';\n// Grid \n//  Cartesian2D \n\n\n    require('./AxisModel');\n    var ComponentModel = require('../../model/Component');\n\n    module.exports = ComponentModel.extend({\n\n        type: 'grid',\n\n        dependencies: ['xAxis', 'yAxis'],\n\n        layoutMode: 'box',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Grid}\n         */\n        coordinateSystem: null,\n\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            // If grid size contain label\n            containLabel: false,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n\n},{\"../../model/Component\":98,\"./AxisModel\":82}],87:[function(require,module,exports){\n'use strict';\n/**\n * Helper function for axisLabelInterval calculation\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('../axisHelper');\n\n    module.exports = function (axis) {\n        var axisModel = axis.model;\n        var labelModel = axisModel.getModel('axisLabel');\n        var labelInterval = labelModel.get('interval');\n        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n            return labelInterval === 'auto' ? 0 : labelInterval;\n        }\n\n        return axisHelper.getAxisLabelInterval(\n            zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis),\n            axisModel.getFormattedLabels(),\n            labelModel.getModel('textStyle').getFont(),\n            axis.isHorizontal()\n        );\n    };\n\n},{\"../axisHelper\":78,\"zrender/lib/core/util\":166}],88:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Axis = require('../Axis');\n\n    function IndicatorAxis(dim, scale, radiusExtent) {\n        Axis.call(this, dim, scale, radiusExtent);\n\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = 'value';\n\n        this.angle = 0;\n\n        /**\n         * Indicator name\n         * @type {string}\n         */\n        this.name = '';\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.model;\n    }\n\n    zrUtil.inherits(IndicatorAxis, Axis);\n\n    module.exports = IndicatorAxis;\n\n},{\"../Axis\":76,\"zrender/lib/core/util\":166}],89:[function(require,module,exports){\n// TODO clockwise\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var IndicatorAxis = require('./IndicatorAxis');\n    var IntervalScale = require('../../scale/Interval');\n    var numberUtil = require('../../util/number');\n    var axisHelper = require('../axisHelper');\n\n    function Radar(radarModel, ecModel, api) {\n\n        this._model = radarModel;\n        /**\n         * Radar dimensions\n         * @type {Array.<string>}\n         */\n        this.dimensions = [];\n\n        this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {\n            var dim = 'indicator_' + idx;\n            var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());\n            indicatorAxis.name = indicatorModel.get('name');\n            // Inject model and axis\n            indicatorAxis.model = indicatorModel;\n            indicatorModel.axis = indicatorAxis;\n            this.dimensions.push(dim);\n            return indicatorAxis;\n        }, this);\n\n        this.resize(radarModel, api);\n\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.cx;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.cy;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.r;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.startAngle;\n    }\n\n    Radar.prototype.getIndicatorAxes = function () {\n        return this._indicatorAxes;\n    };\n\n    Radar.prototype.dataToPoint = function (value, indicatorIndex) {\n        var indicatorAxis = this._indicatorAxes[indicatorIndex];\n\n        return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);\n    };\n\n    Radar.prototype.coordToPoint = function (coord, indicatorIndex) {\n        var indicatorAxis = this._indicatorAxes[indicatorIndex];\n        var angle = indicatorAxis.angle;\n        var x = this.cx + coord * Math.cos(angle);\n        var y = this.cy - coord * Math.sin(angle);\n        return [x, y];\n    };\n\n    Radar.prototype.pointToData = function (pt) {\n        var dx = pt[0] - this.cx;\n        var dy = pt[1] - this.cy;\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        dx /= radius;\n        dy /= radius;\n\n        var radian = Math.atan2(-dy, dx);\n\n        // Find the closest angle\n        // FIXME index can calculated directly\n        var minRadianDiff = Infinity;\n        var closestAxis;\n        var closestAxisIdx = -1;\n        for (var i = 0; i < this._indicatorAxes.length; i++) {\n            var indicatorAxis = this._indicatorAxes[i];\n            var diff = Math.abs(radian - indicatorAxis.angle);\n            if (diff < minRadianDiff) {\n                closestAxis = indicatorAxis;\n                closestAxisIdx = i;\n                minRadianDiff = diff;\n            }\n        }\n\n        return [closestAxisIdx, +(closestAxis && closestAxis.coodToData(radius))];\n    };\n\n    Radar.prototype.resize = function (radarModel, api) {\n        var center = radarModel.get('center');\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n        var viewSize = Math.min(viewWidth, viewHeight) / 2;\n        this.cx = numberUtil.parsePercent(center[0], viewWidth);\n        this.cy = numberUtil.parsePercent(center[1], viewHeight);\n\n        this.startAngle = radarModel.get('startAngle') * Math.PI / 180;\n\n        this.r = numberUtil.parsePercent(radarModel.get('radius'), viewSize);\n\n        zrUtil.each(this._indicatorAxes, function (indicatorAxis, idx) {\n            indicatorAxis.setExtent(0, this.r);\n            var angle = (this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length);\n            // Normalize to [-PI, PI]\n            angle = Math.atan2(Math.sin(angle), Math.cos(angle));\n            indicatorAxis.angle = angle;\n        }, this);\n    };\n\n    Radar.prototype.update = function (ecModel, api) {\n        var indicatorAxes = this._indicatorAxes;\n        var radarModel = this._model;\n        zrUtil.each(indicatorAxes, function (indicatorAxis) {\n            indicatorAxis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeriesByType('radar', function (radarSeries, idx) {\n            if (radarSeries.get('coordinateSystem') !== 'radar'\n                || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel\n            ) {\n                return;\n            }\n            var data = radarSeries.getData();\n            zrUtil.each(indicatorAxes, function (indicatorAxis) {\n                indicatorAxis.scale.unionExtentFromData(data, indicatorAxis.dim);\n            });\n        }, this);\n\n        var splitNumber = radarModel.get('splitNumber');\n\n        function increaseInterval(interval) {\n            var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));\n            // Increase interval\n            var f = interval / exp10;\n            if (f === 2) {\n                f = 5;\n            }\n            else { // f is 2 or 5\n                f *= 2;\n            }\n            return f * exp10;\n        }\n        // Force all the axis fixing the maxSplitNumber.\n        zrUtil.each(indicatorAxes, function (indicatorAxis, idx) {\n            var rawExtent = axisHelper.getScaleExtent(indicatorAxis, indicatorAxis.model);\n            axisHelper.niceScaleExtent(indicatorAxis, indicatorAxis.model);\n\n            var axisModel = indicatorAxis.model;\n            var scale = indicatorAxis.scale;\n            var fixedMin = axisModel.getMin();\n            var fixedMax = axisModel.getMax();\n            var interval = scale.getInterval();\n\n            if (fixedMin != null && fixedMax != null) {\n                // User set min, max, divide to get new interval\n                // FIXME precision\n                scale.setInterval(\n                    (fixedMax - fixedMin) / splitNumber\n                );\n            }\n            else if (fixedMin != null) {\n                var max;\n                // User set min, expand extent on the other side\n                do {\n                    max = fixedMin + interval * splitNumber;\n                    scale.setExtent(+fixedMin, max);\n                    // Interval must been set after extent\n                    // FIXME\n                    scale.setInterval(interval);\n\n                    interval = increaseInterval(interval);\n                } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));\n            }\n            else if (fixedMax != null) {\n                var min;\n                // User set min, expand extent on the other side\n                do {\n                    min = fixedMax - interval * splitNumber;\n                    scale.setExtent(min, +fixedMax);\n                    scale.setInterval(interval);\n                    interval = increaseInterval(interval);\n                } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));\n            }\n            else {\n                var nicedSplitNumber = scale.getTicks().length - 1;\n                if (nicedSplitNumber > splitNumber) {\n                    interval = increaseInterval(interval);\n                }\n                // PENDING\n                var center = Math.round((rawExtent[0] + rawExtent[1]) / 2 / interval) * interval;\n                var halfSplitNumber = Math.round(splitNumber / 2);\n                scale.setExtent(\n                    numberUtil.round(center - halfSplitNumber * interval),\n                    numberUtil.round(center + (splitNumber - halfSplitNumber) * interval)\n                );\n                scale.setInterval(interval);\n            }\n        });\n    };\n\n    /**\n     * Radar dimensions is based on the data\n     * @type {Array}\n     */\n    Radar.dimensions = [];\n\n    Radar.create = function (ecModel, api) {\n        var radarList = [];\n        ecModel.eachComponent('radar', function (radarModel) {\n            var radar = new Radar(radarModel, ecModel, api);\n            radarList.push(radar);\n            radarModel.coordinateSystem = radar;\n        });\n        ecModel.eachSeriesByType('radar', function (radarSeries) {\n            if (radarSeries.get('coordinateSystem') === 'radar') {\n                // Inject coordinate system\n                radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];\n            }\n        });\n        return radarList;\n    };\n\n    require('../../CoordinateSystem').register('radar', Radar);\n    module.exports = Radar;\n\n},{\"../../CoordinateSystem\":1,\"../../scale/Interval\":115,\"../../util/number\":126,\"../axisHelper\":78,\"./IndicatorAxis\":88,\"zrender/lib/core/util\":166}],90:[function(require,module,exports){\n\n\n\n    var axisDefault = require('../axisDefault');\n    var valueAxisDefault = axisDefault.valueAxis;\n    var Model = require('../../model/Model');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var axisModelCommonMixin = require('../axisModelCommonMixin');\n\n    function defaultsShow(opt, show) {\n        return zrUtil.defaults({\n            show: show\n        }, opt);\n    }\n\n    var RadarModel = require('../../echarts').extendComponentModel({\n\n        type: 'radar',\n\n        optionUpdated: function () {\n            var boundaryGap = this.get('boundaryGap');\n            var splitNumber = this.get('splitNumber');\n            var scale = this.get('scale');\n            var axisLine = this.get('axisLine');\n            var axisTick = this.get('axisTick');\n            var axisLabel = this.get('axisLabel');\n            var nameTextStyle = this.get('name.textStyle');\n            var showName = this.get('name.show');\n            var nameFormatter = this.get('name.formatter');\n            var nameGap = this.get('nameGap');\n            var triggerEvent = this.get('triggerEvent');\n\n            var indicatorModels = zrUtil.map(this.get('indicator') || [], function (indicatorOpt) {\n                // PENDING\n                if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {\n                    indicatorOpt.min = 0;\n                }\n                else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {\n                    indicatorOpt.max = 0;\n                }\n                // Use same configuration\n                indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), {\n                    boundaryGap: boundaryGap,\n                    splitNumber: splitNumber,\n                    scale: scale,\n                    axisLine: axisLine,\n                    axisTick: axisTick,\n                    axisLabel: axisLabel,\n                    // Competitable with 2 and use text\n                    name: indicatorOpt.text,\n                    nameLocation: 'end',\n                    nameGap: nameGap,\n                    // min: 0,\n                    nameTextStyle: nameTextStyle,\n                    triggerEvent: triggerEvent\n                }, false);\n                if (!showName) {\n                    indicatorOpt.name = '';\n                }\n                if (typeof nameFormatter === 'string') {\n                    var indName = indicatorOpt.name;\n                    indicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');\n                }\n                else if (typeof nameFormatter === 'function') {\n                    indicatorOpt.name = nameFormatter(\n                        indicatorOpt.name, indicatorOpt\n                    );\n                }\n                var model = zrUtil.extend(\n                    new Model(indicatorOpt, null, this.ecModel),\n                    axisModelCommonMixin\n                );\n\n                // For triggerEvent.\n                model.mainType = 'radar';\n                model.componentIndex = this.componentIndex;\n\n                return model;\n            }, this);\n\n            this.getIndicatorModels = function () {\n                return indicatorModels;\n            };\n        },\n\n        defaultOption: {\n\n            zlevel: 0,\n\n            z: 0,\n\n            center: ['50%', '50%'],\n\n            radius: '75%',\n\n            startAngle: 90,\n\n            name: {\n                show: true\n                // formatter: null\n                // textStyle: {}\n            },\n\n            boundaryGap: [0, 0],\n\n            splitNumber: 5,\n\n            nameGap: 15,\n\n            scale: false,\n\n            // Polygon or circle\n            shape: 'polygon',\n\n            axisLine: zrUtil.merge(\n                {\n                    lineStyle: {\n                        color: '#bbb'\n                    }\n                },\n                valueAxisDefault.axisLine\n            ),\n            axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),\n            axisTick: defaultsShow(valueAxisDefault.axisTick, false),\n            splitLine: defaultsShow(valueAxisDefault.splitLine, true),\n            splitArea: defaultsShow(valueAxisDefault.splitArea, true),\n\n            // {text, min, max}\n            indicator: []\n        }\n    });\n\n    module.exports = RadarModel;\n\n},{\"../../echarts\":94,\"../../model/Model\":100,\"../axisDefault\":77,\"../axisModelCommonMixin\":79,\"zrender/lib/core/util\":166}],91:[function(require,module,exports){\n'use strict';\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            var key = keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n},{}],92:[function(require,module,exports){\n(function (global){\n/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = require('../model/Model');\n    var DataDiffer = require('./DataDiffer');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    var transferProperties = function (a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string>} dimensions\n     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n            }\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var size = data.length;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var idList = [];\n        var nameRepeatCount = {};\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var idx = 0; idx < data.length; idx++) {\n            var dataItem = data[idx];\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n            }\n\n            indices.push(idx);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < data.length; i++) {\n            if (!nameList[i]) {\n                if (data[i] && data[i].name != null) {\n                    nameList[i] = data[i].name;\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = data[i] && data[i].id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null) {\n            return NaN;\n        }\n\n        var value = storage[dim] && storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     * @param {Function} filter\n     */\n    listProto.getDataExtent = function (dim, stack, filter) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                if (!filter || filter(value, dim, i)) {\n                    value < min && (min = value);\n                    value > max && (max = value);\n                }\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {number}\n     */\n    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var nearestIdx = -1;\n        if (dimData) {\n            var minDist = Number.MAX_VALUE;\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var diff = value - this.get(dim, i, stack);\n                var dist = Math.abs(diff);\n                if (\n                    diff <= maxDistance\n                    && (dist < minDist\n                        // For the case of two data are same on xAxis, which has sequence data.\n                        // Show the nearest index\n                        // https://github.com/ecomfe/echarts/issues/2869\n                        || (dist === minDist && diff > 0)\n                    )\n                ) {\n                    minDist = dist;\n                    nearestIdx = i;\n                }\n            }\n        }\n        return nearestIdx;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData[this.getRawIndex(idx)];\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        var val;\n        // Use prefix to avoid index to be the same as otherIdList[idx],\n        // which will cause weird udpate animation.\n        var prefix = 'e\\0\\0';\n\n        return new DataDiffer(\n            otherList ? otherList.indices : [],\n            this.indices,\n            function (idx) {\n                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n            },\n            function (idx) {\n                return (val = idList[idx]) != null ? val : prefix + idx;\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} ignoreParent\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../model/Model\":100,\"../util/model\":125,\"./DataDiffer\":91,\"zrender/lib/core/util\":166}],93:[function(require,module,exports){\n/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * Complete the dimensions array guessed from the data structure.\n     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n     * @param  {Array.<string>} [defaultNames]    Default names to fill not necessary dimensions, like ['value']\n     * @param  {string} [extraPrefix]             Prefix of name when filling the left dimensions.\n     * @return {Array.<string>}\n     */\n    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n        if (!data) {\n            return dimensions;\n        }\n\n        var value0 = retrieveValue(data[0]);\n        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\n        defaultNames = defaultNames || [];\n        extraPrefix = extraPrefix || 'extra';\n        for (var i = 0; i < dimSize; i++) {\n            if (!dimensions[i]) {\n                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));\n                dimensions[i] = guessOrdinal(data, i)\n                    ? {type: 'ordinal', name: name}\n                    : name;\n            }\n        }\n\n        return dimensions;\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (zrUtil.isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n},{\"zrender/lib/core/util\":166}],94:[function(require,module,exports){\n(function (global){\n// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = require('zrender/lib/core/env');\n\n    var GlobalModel = require('./model/Global');\n    var ExtensionAPI = require('./ExtensionAPI');\n    var CoordinateSystemManager = require('./CoordinateSystem');\n    var OptionManager = require('./model/OptionManager');\n\n    var ComponentModel = require('./model/Component');\n    var SeriesModel = require('./model/Series');\n\n    var ComponentView = require('./view/Component');\n    var ChartView = require('./view/Chart');\n    var graphic = require('./util/graphic');\n    var modelUtil = require('./util/model');\n    var throttle = require('./util/throttle');\n\n    var zrender = require('zrender');\n    var zrUtil = require('zrender/lib/core/util');\n    var colorTool = require('zrender/lib/tool/color');\n    var Eventful = require('zrender/lib/mixin/Eventful');\n    var timsort = require('zrender/lib/core/timsort');\n\n    var each = zrUtil.each;\n    var parseClassType = ComponentModel.parseClassType;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    // FIXME\n    // necessary?\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flagInMainProcess';\n    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n    var OPTION_UPDATED = '__optionUpdated';\n    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts (dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        var zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * Expect 60 pfs.\n         * @type {Function}\n         * @private\n         */\n        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = new ExtensionAPI(this);\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        zr.animation.on('frame', this._onframe, this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            var silent = this[OPTION_UPDATED].silent;\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n\n            flushPendingActions.call(this, silent);\n\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * Usage:\n     * chart.setOption(option, notMerge, lazyUpdate);\n     * chart.setOption(option, {\n     *     notMerge: ...,\n     *     lazyUpdate: ...,\n     *     silent: ...\n     * });\n     *\n     * @param {Object} option\n     * @param {Object|boolean} [opts] opts or notMerge.\n     * @param {boolean} [opts.notMerge=false]\n     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        var silent;\n        if (zrUtil.isObject(notMerge)) {\n            lazyUpdate = notMerge.lazyUpdate;\n            silent = notMerge.silent;\n            notMerge = notMerge.notMerge;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        // FIXME\n        // ugly\n        this.__lastOnlyGraphic = !!(option && option.graphic);\n        zrUtil.each(option, function (o, mainType) {\n            mainType !== 'graphic' && (this.__lastOnlyGraphic = false);\n        }, this);\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = {silent: silent};\n            this[IN_MAIN_PROCESS] = false;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            // Ensure zr refresh sychronously, and then pixel in canvas can be\n            // fetched after `setOption`.\n            this._zr.flush();\n\n            this[OPTION_UPDATED] = false;\n            this[IN_MAIN_PROCESS] = false;\n\n            flushPendingActions.call(this, silent);\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     * @param {string} [opts.excludeComponents]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.time && console.time('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            // console.time && console.timeEnd('update');\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload, true);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            // FIXME\n            // ugly\n            if (this.__lastOnlyGraphic) {\n                each(this._componentsViews, function (componentView) {\n                    var componentModel = componentView.__model;\n                    if (componentModel && componentModel.mainType === 'graphic') {\n                        componentView.render(componentModel, ecModel, this._api, payload);\n                        updateZ(componentModel, componentView);\n                    }\n                }, this);\n                this.__lastOnlyGraphic = false;\n            }\n            else {\n                updateMethods.update.call(this, payload);\n            }\n        }\n    };\n\n    /**\n     * @private\n     */\n    function updateDirectly(ecIns, method, payload, mainType, subType) {\n        var ecModel = ecIns._model;\n        var query = {};\n        query[mainType + 'Id'] = payload[mainType + 'Id'];\n        query[mainType + 'Index'] = payload[mainType + 'Index'];\n        query[mainType + 'Name'] = payload[mainType + 'Name'];\n\n        var condition = {mainType: mainType, query: query};\n        subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\n        // If dispatchAction before setOption, do nothing.\n        ecModel && ecModel.eachComponent(condition, function (model, index) {\n            var view = ecIns[\n                mainType === 'series' ? '_chartsMap' : '_componentsMap'\n            ][model.__viewId];\n            if (view && view.__alive) {\n                view[method](model, ecModel, ecIns._api, payload);\n            }\n        }, ecIns);\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @param {boolean} [opts.silent=false]\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\n        updateMethods[updateMethod].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        var silent = opts && opts.silent;\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n     * @param {boolean} [opt.silent=false] Whether trigger events.\n     * @param {boolean} [opt.flush=undefined]\n     *                  true: Flush immediately, and then pixel in canvas can be fetched\n     *                      immediately. Caution: it might affect performance.\n     *                  false: Not not flush.\n     *                  undefined: Auto decide whether perform flush.\n     */\n    echartsProto.dispatchAction = function (payload, opt) {\n        if (!zrUtil.isObject(opt)) {\n            opt = {silent: !!opt};\n        }\n\n        if (!actions[payload.type]) {\n            return;\n        }\n\n        // if (__DEV__) {\n        //     zrUtil.assert(\n        //         !this[IN_MAIN_PROCESS],\n        //         '`dispatchAction` should not be called during main process.'\n        //         + 'unless updateMathod is \"none\".'\n        //     );\n        // }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        doDispatchAction.call(this, payload, opt.silent);\n\n        if (opt.flush) {\n            this._zr.flush(true);\n        }\n        else if (opt.flush !== false && env.browser.weChat) {\n            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n            // hang when sliding page (on touch event), which cause that zr does not\n            // refresh util user interaction finished, which is not expected.\n            // But `dispatchAction` may be called too frequently when pan on touch\n            // screen, which impacts performance if do not throttle them.\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, opt.silent);\n\n        triggerUpdatedEvent.call(this, opt.silent);\n    };\n\n    function doDispatchAction(payload, silent) {\n        var payloadType = payload.type;\n        var actionWrap = actions[payloadType];\n        var actionInfo = actionWrap.actionInfo;\n\n        var cptType = (actionInfo.update || 'update').split(':');\n        var updateMethod = cptType.pop();\n        cptType = cptType[0] && parseClassType(cptType[0]);\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\n        for (var i = 0; i < payloads.length; i++) {\n            var batchItem = payloads[i];\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // light update does not perform data process, layout and visual.\n            if (isHighDown) {\n                // method, payload, mainType, subType\n                updateDirectly(this, updateMethod, batchItem, 'series');\n            }\n            else if (cptType) {\n                updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n            }\n        }\n\n        if (updateMethod !== 'none' && !isHighDown && !cptType) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payloadType,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n    }\n\n    function flushPendingActions(silent) {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n        }\n    }\n\n    function triggerUpdatedEvent(silent) {\n        !silent && this.trigger('updated');\n    }\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = viewId;\n            view.__alive = true;\n            view.__id = viewId;\n            view.__model = model;\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                if (previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @param {object} layout\n     * @param {boolean} [excludesLayout]\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload, excludesLayout) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            (!excludesLayout || !visual.isLayout)\n                && visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var actions = [];\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.4.0',\n        dependencies: {\n            zrender: '3.3.0'\n        }\n    };\n\n    function enableConnect(chart) {\n\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n\n    }\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        dom.setAttribute &&\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (zrUtil.isDom(chart)) {\n            chart = echarts.getInstanceByDom(chart);\n        }\n        else if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        return instances[key];\n    };\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        // Validate action type and event name.\n        zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts/*, superClass*/) {\n        // var Clazz = ComponentModel;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts/*, superClass*/) {\n        // var Clazz = ComponentView;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentView.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts/*, superClass*/) {\n        // var Clazz = SeriesModel;\n        // if (superClass) {\n        //     superClass = 'series.' + superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return SeriesModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts/*, superClass*/) {\n        // var Clazz = ChartView;\n        // if (superClass) {\n        //     superClass = superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ChartView.getClass(classType.main, true);\n        // }\n        return ChartView.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n    echarts.registerLoading('default', require('./loading/default'));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n\n    // --------\n    // Exports\n    // --------\n    //\n    echarts.List = require('./data/List');\n    echarts.Model = require('./model/Model');\n\n    echarts.graphic = require('./util/graphic');\n    echarts.number = require('./util/number');\n    echarts.format = require('./util/format');\n    echarts.throttle = throttle.throttle;\n    echarts.matrix = require('zrender/lib/core/matrix');\n    echarts.vector = require('zrender/lib/core/vector');\n    echarts.color = require('zrender/lib/tool/color');\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n            'extend', 'defaults', 'clone'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./CoordinateSystem\":1,\"./ExtensionAPI\":2,\"./data/List\":92,\"./loading/default\":97,\"./model/Component\":98,\"./model/Global\":99,\"./model/Model\":100,\"./model/OptionManager\":101,\"./model/Series\":102,\"./preprocessor/backwardCompat\":111,\"./util/format\":122,\"./util/graphic\":123,\"./util/model\":125,\"./util/number\":126,\"./util/throttle\":128,\"./view/Chart\":129,\"./view/Component\":130,\"./visual/seriesColor\":132,\"zrender\":200,\"zrender/lib/core/env\":160,\"zrender/lib/core/matrix\":164,\"zrender/lib/core/timsort\":165,\"zrender/lib/core/util\":166,\"zrender/lib/core/vector\":167,\"zrender/lib/mixin/Eventful\":195,\"zrender/lib/tool/color\":197}],95:[function(require,module,exports){\n'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var parsePercent = numberUtil.parsePercent;\n\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n    }\n\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n\n    function calBarWidthAndOffset(barSeries, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n\n        zrUtil.each(barSeries, function (seriesModel, idx) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category'\n                ? baseAxis.getBandWidth()\n                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\n            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n                bandWidth: bandWidth,\n                remainedWidth: bandWidth,\n                autoWidthCount: 0,\n                categoryGap: '20%',\n                gap: '30%',\n                stacks: {}\n            };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n\n            var stackId = getSeriesStackId(seriesModel);\n\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n\n            var barWidth = parsePercent(\n                seriesModel.get('barWidth'), bandWidth\n            );\n            var barMaxWidth = parsePercent(\n                seriesModel.get('barMaxWidth'), bandWidth\n            );\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n\n            // Caution: In a single coordinate system, these barGrid attributes\n            // will be shared by series. Consider that they have default values,\n            // only the attributes set on the last series will work.\n            // Do not change this fact unless there will be a break change.\n\n            // TODO\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            (barGap != null) && (columnsOnAxis.gap = barGap);\n            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n\n        var result = {};\n\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\n            result[coordSysName] = {};\n\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (!column.width && maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n\n        var barWidthAndOffset = calBarWidthAndOffset(\n            zrUtil.filter(\n                ecModel.getSeriesByType(seriesType),\n                function (seriesModel) {\n                    return !ecModel.isSeriesFiltered(seriesModel)\n                        && seriesModel.coordinateSystem\n                        && seriesModel.coordinateSystem.type === 'cartesian2d';\n                }\n            )\n        );\n\n        var lastStackCoords = {};\n        var lastStackCoordsOrigin = {};\n\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\n            var valueAxisStart = baseAxis.onZero\n                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n                : valueAxis.getGlobalExtent()[0];\n\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n\n            data.each(valueAxis.dim, function (value, idx) {\n                if (isNaN(value)) {\n                    return;\n                }\n\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                    lastStackCoordsOrigin[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n                var x;\n                var y;\n                var width;\n                var height;\n\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoordOrigin;\n                    height = columnWidth;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += width;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                }\n                else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoordOrigin;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += height;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n\n        }, this);\n    }\n\n    module.exports = barLayoutGrid;\n\n},{\"../util/number\":126,\"zrender/lib/core/util\":166}],96:[function(require,module,exports){\n\n\n    module.exports = function (seriesType, ecModel) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (coordSys) {\n                var dims = coordSys.dimensions;\n\n                if (coordSys.type === 'singleAxis') {\n                    data.each(dims[0], function (x, idx) {\n                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n                        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n                    });\n                }\n                else {\n                    data.each(dims, function (x, y, idx) {\n                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n                        data.setItemLayout(\n                            idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y])\n                        );\n                    }, true);\n                }\n            }\n        });\n    };\n\n},{}],97:[function(require,module,exports){\n\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n},{\"../util/graphic\":123,\"zrender/lib/core/util\":166}],98:[function(require,module,exports){\n/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = require('./Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var arrayPush = Array.prototype.push;\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var layout = require('../util/layout');\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                clazzUtil.set(this, '__defaultOption', defaultOption);\n            }\n            return clazzUtil.get(this, '__defaultOption');\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n\n    module.exports = ComponentModel;\n\n},{\"../util/clazz\":120,\"../util/component\":121,\"../util/layout\":124,\"./Model\":100,\"./mixin/boxLayout\":105,\"zrender/lib/core/util\":166}],99:[function(require,module,exports){\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var Model = require('./Model');\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = require('./Component');\n\n    var globalDefault = require('./globalDefault');\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption();\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            //  component model  merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION \n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap[mainType], newCptOptionList\n                );\n\n                modelUtil.makeIdAndName(mapResult);\n\n                // Set mainType and complete subType.\n                each(mapResult, function (item, index) {\n                    var opt = item.option;\n                    if (isObject(opt)) {\n                        item.keyInfo.mainType = mainType;\n                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                    }\n                });\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap[mainType] = [];\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap[mainType][index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.series);\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap[mainType];\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * If none of index and id and name used, return all components with mainType.\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap[mainType];\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts;\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap[mainType];\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q[indexAttr] != null\n                        || q[idAttr] != null\n                        || q[nameAttr] != null\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                each(componentsMap, function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap[mainType], cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.series[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.series.slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.series, cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.series, cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.series);\n\n            var componentTypes = [];\n            each(componentsMap, function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap[componentType], function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            //  component model  merge  model \n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap[type] || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Series has not been initialized yet.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n\n    module.exports = GlobalModel;\n\n},{\"../util/model\":125,\"./Component\":98,\"./Model\":100,\"./globalDefault\":103,\"./mixin/colorPalette\":106,\"zrender/lib/core/util\":166}],100:[function(require,module,exports){\n/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazzUtil = require('../util/clazz');\n    var env = require('zrender/lib/core/env');\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model \n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         *  Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (path == null) {\n                return this.option;\n            }\n\n            return doGet(\n                this.option,\n                this.parsePath(path),\n                !ignoreParent && getParent(this, path)\n            );\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = !ignoreParent && getParent(this, key);\n            if (val == null && parentModel) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = path == null\n                ? this.option\n                : doGet(this.option, path = this.parsePath(path));\n\n            var thisParentModel;\n            parentModel = parentModel || (\n                (thisParentModel = getParent(this, path))\n                    && thisParentModel.getModel(path)\n            );\n\n            return new Model(obj, parentModel, this.ecModel);\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        },\n\n        // If path is null/undefined, return null/undefined.\n        parsePath: function(path) {\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            return path;\n        },\n\n        /**\n         * @param {Function} getParentMethod\n         *        param {Array.<string>|string} path\n         *        return {module:echarts/model/Model}\n         */\n        customizeGetParent: function (getParentMethod) {\n            clazzUtil.set(this, 'getParent', getParentMethod);\n        },\n\n        isAnimationEnabled: function () {\n            if (!env.node) {\n                if (this.option.animation != null) {\n                    return !!this.option.animation;\n                }\n                else if (this.parentModel) {\n                    return this.parentModel.isAnimationEnabled();\n                }\n            }\n        }\n    };\n\n    function doGet(obj, pathArr, parentModel) {\n        for (var i = 0; i < pathArr.length; i++) {\n            // Ignore empty\n            if (!pathArr[i]) {\n                continue;\n            }\n            // obj could be number/string/... (like 0)\n            obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n            if (obj == null) {\n                break;\n            }\n        }\n        if (obj == null && parentModel) {\n            obj = parentModel.get(pathArr);\n        }\n        return obj;\n    }\n\n    function getParent(model, path) {\n        var getParentMethod = clazzUtil.get(model, 'getParent');\n        return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n    }\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, require('./mixin/lineStyle'));\n    mixin(Model, require('./mixin/areaStyle'));\n    mixin(Model, require('./mixin/textStyle'));\n    mixin(Model, require('./mixin/itemStyle'));\n\n    module.exports = Model;\n\n},{\"../util/clazz\":120,\"./mixin/areaStyle\":104,\"./mixin/itemStyle\":107,\"./mixin/lineStyle\":108,\"./mixin/textStyle\":110,\"zrender/lib/core/env\":160,\"zrender/lib/core/util\":166}],101:[function(require,module,exports){\n/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            //  timeline options  media baseOption\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // resetclone\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // performed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // mediaDefault\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n},{\"../util/model\":125,\"./Component\":98,\"zrender/lib/core/util\":166}],102:[function(require,module,exports){\n'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../util/format');\n    var classUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var colorPaletteMixin = require('./mixin/colorPalette');\n    var env = require('zrender/lib/core/env');\n    var layout = require('../util/layout');\n\n    var set = classUtil.set;\n    var get = classUtil.get;\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            set(this, 'dataBeforeProcessed', this.getInitialData(option, ecModel));\n\n            // If we reverse the order (make data firstly, and then make\n            // dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause data.graph.data !== data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this.restoreData();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                set(this, 'data', data);\n                set(this, 'dataBeforeProcessed', data.cloneShallow());\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            var data = get(this, 'data');\n            return dataType == null ? data : data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            set(this, 'data', data);\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return get(this, 'dataBeforeProcessed');\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return [coordDim];\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return dataDim;\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var result = [];\n\n                zrUtil.each(value, function (val, idx) {\n                    var dimInfo = data.getDimensionInfo(idx);\n                    var dimType = dimInfo && dimInfo.type;\n                    var valStr;\n\n                    if (dimType === 'ordinal') {\n                        valStr = val + '';\n                    }\n                    else if (dimType === 'time') {\n                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val);\n                    }\n                    else {\n                        valStr = addCommas(val);\n                    }\n\n                    valStr && result.push(valStr);\n                });\n\n                return result.join(', ');\n            }\n\n            var data = get(this, 'data');\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = encodeHTML(\n                zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value)\n            );\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:' + encodeHTML(color) + '\"></span>';\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            return !multipleSeries\n                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl\n                    + (name\n                        ? encodeHTML(name) + ' : ' + formattedValue\n                        : formattedValue\n                    )\n                  )\n                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Array.<number>} data indices.\n         */\n        getAxisTooltipDataIndex: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n},{\"../util/clazz\":120,\"../util/format\":122,\"../util/layout\":124,\"../util/model\":125,\"./Component\":98,\"./mixin/colorPalette\":106,\"zrender/lib/core/env\":160,\"zrender/lib/core/util\":166}],103:[function(require,module,exports){\n\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // \n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // \n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // \n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        //  Grid \n        // grid: {},\n        // \n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: true,\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n        // which is unexpected.\n        // see example <echarts/test/heatmap-large.html>.\n        hoverLayerThreshold: 3000\n    };\n\n},{}],104:[function(require,module,exports){\n\n    module.exports = {\n        getAreaStyle: require('./makeStyleMapper')(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n},{\"./makeStyleMapper\":109}],105:[function(require,module,exports){\n\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n},{}],106:[function(require,module,exports){\n\n\n    var classUtil = require('../../util/clazz');\n    var set = classUtil.set;\n    var get = classUtil.get;\n\n    module.exports = {\n        clearColorPalette: function () {\n            set(this, 'colorIdx', 0);\n            set(this, 'colorNameMap', {});\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = get(scope, 'colorIdx') || 0;\n            var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {});\n            if (colorNameMap[name]) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\n            return color;\n        }\n    };\n\n},{\"../../util/clazz\":120}],107:[function(require,module,exports){\n\n    var getItemStyle = require('./makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes) {\n            var style = getItemStyle.call(this, excludes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n},{\"./makeStyleMapper\":109}],108:[function(require,module,exports){\n\n    var getLineStyle = require('./makeStyleMapper')(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n},{\"./makeStyleMapper\":109}],109:[function(require,module,exports){\n// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n},{\"zrender/lib/core/util\":166}],110:[function(require,module,exports){\n\n\n    var textContain = require('zrender/lib/contain/text');\n\n    function getShallow(model, path) {\n        return model && model.getShallow(path);\n    }\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @return {string}\n         */\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (ecModel && ecModel.get('textStyle.color'));\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            var ecModel = this.ecModel;\n            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n            return [\n                // FIXME in node-canvas fontWeight is before fontStyle\n                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n            ].join(' ');\n        },\n\n        getTextRect: function (text) {\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                this.getShallow('align'),\n                this.getShallow('baseline')\n            );\n        },\n\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(\n                text, containerWidth, this.getFont(), ellipsis, options\n            );\n        }\n    };\n\n},{\"zrender/lib/contain/text\":150}],111:[function(require,module,exports){\n// Compatitable with 2.0\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var compatStyle = require('./helper/compatStyle');\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            compatStyle(seriesOpt);\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n},{\"./helper/compatStyle\":112,\"zrender/lib/core/util\":166}],112:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n\n    module.exports = function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    }\n                    else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n\n},{\"zrender/lib/core/util\":166}],113:[function(require,module,exports){\n\n    module.exports = function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n\n},{}],114:[function(require,module,exports){\n\n    var samplers = {\n        average: function (frame) {\n            var sum = 0;\n            var count = 0;\n            for (var i = 0; i < frame.length; i++) {\n                if (!isNaN(frame[i])) {\n                    sum += frame[i];\n                    count++;\n                }\n            }\n            // Return NaN if count is 0\n            return count === 0 ? NaN : sum / count;\n        },\n        sum: function (frame) {\n            var sum = 0;\n            for (var i = 0; i < frame.length; i++) {\n                // Ignore NaN\n                sum += frame[i] || 0;\n            }\n            return sum;\n        },\n        max: function (frame) {\n            var max = -Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] > max && (max = frame[i]);\n            }\n            return max;\n        },\n        min: function (frame) {\n            var min = Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] < min && (min = frame[i]);\n            }\n            return min;\n        },\n        // TODO\n        // Median\n        nearest: function (frame) {\n            return frame[0];\n        }\n    };\n\n    var indexSampler = function (frame, value) {\n        return Math.round(frame.length / 2);\n    };\n    module.exports = function (seriesType, ecModel, api) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var sampling = seriesModel.get('sampling');\n            var coordSys = seriesModel.coordinateSystem;\n            // Only cartesian2d support down sampling\n            if (coordSys.type === 'cartesian2d' && sampling) {\n                var baseAxis = coordSys.getBaseAxis();\n                var valueAxis = coordSys.getOtherAxis(baseAxis);\n                var extent = baseAxis.getExtent();\n                // Coordinste system has been resized\n                var size = extent[1] - extent[0];\n                var rate = Math.round(data.count() / size);\n                if (rate > 1) {\n                    var sampler;\n                    if (typeof sampling === 'string') {\n                        sampler = samplers[sampling];\n                    }\n                    else if (typeof sampling === 'function') {\n                        sampler = sampling;\n                    }\n                    if (sampler) {\n                        data = data.downSample(\n                            valueAxis.dim, 1 / rate, sampler, indexSampler\n                        );\n                        seriesModel.setData(data);\n                    }\n                }\n            }\n        }, this);\n    };\n\n},{}],115:[function(require,module,exports){\n/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var Scale = require('./Scale');\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            var interval = this._interval;\n            var extent = this._extent;\n            var ticks = [];\n\n            // Consider this case: using dataZoom toolbox, zoom and zoom.\n            var safeLimit = 10000;\n\n            if (interval) {\n                var niceExtent = this._niceExtent;\n                var precision = getPrecisionSafe(interval) + 2;\n\n                if (extent[0] < niceExtent[0]) {\n                    ticks.push(extent[0]);\n                }\n                var tick = niceExtent[0];\n\n                while (tick <= niceExtent[1]) {\n                    ticks.push(tick);\n                    // Avoid rounding error\n                    tick = roundingErrorFix(tick + interval, precision);\n                    if (ticks.length > safeLimit) {\n                        return [];\n                    }\n                }\n                // Consider this case: the last item of ticks is smaller\n                // than niceExtent[1] and niceExtent[1] === extent[1].\n                if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceExtent[1])) {\n                    ticks.push(extent[1]);\n                }\n            }\n\n            return ticks;\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} n\n         * @return {number}\n         */\n        getLabel: function (data) {\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         */\n        niceTicks: function (splitNumber) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n            // var niceSpan = numberUtil.nice(span, false);\n            var step = roundingErrorFix(\n                numberUtil.nice(span / splitNumber, true),\n                Math.max(\n                    getPrecisionSafe(extent[0]),\n                    getPrecisionSafe(extent[1])\n                // extent may be [0, 1], and step should have 1 more digits.\n                // To make it safe we add 2 more digits\n                ) + 2\n            );\n\n            var precision = getPrecisionSafe(step) + 2;\n            // Niced extent inside original extent\n            var niceExtent = [\n                roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n                roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n            ];\n\n            this._interval = step;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [splitNumber = 5] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(splitNumber);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n},{\"../util/format\":122,\"../util/number\":126,\"./Scale\":118}],116:[function(require,module,exports){\n/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n    var numberUtil = require('../util/number');\n\n    // Use some method of IntervalScale\n    var IntervalScale = require('./Interval');\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, true, function (val) {\n                return val > 0;\n            }));\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [approxTickNum = 10] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            intervalScaleProto.niceExtent.call(this, splitNumber, fixMin, fixMax);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = fixMin;\n            originalScale.__fixMax = fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n},{\"../util/number\":126,\"./Interval\":115,\"./Scale\":118,\"zrender/lib/core/util\":166}],117:[function(require,module,exports){\n/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, false));\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n},{\"./Scale\":118,\"zrender/lib/core/util\":166}],118:[function(require,module,exports){\n/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = require('../util/clazz');\n\n    function Scale() {\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Set extent from data\n     * @param {module:echarts/data/List} data\n     * @param {string} dim\n     */\n    scaleProto.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, true));\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n},{\"../util/clazz\":120}],119:[function(require,module,exports){\n/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n\n    var IntervalScale = require('./Interval');\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME \n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        // Overwrite\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date);\n        },\n\n        // Overwrite\n        niceExtent: function (approxTickNum, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(approxTickNum);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        // Overwrite\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var niceExtent = [\n                mathCeil(extent[0] / interval) * interval,\n                mathFloor(extent[1] / interval) * interval\n            ];\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function () {\n        return new TimeScale();\n    };\n\n    module.exports = TimeScale;\n\n},{\"../util/format\":122,\"../util/number\":126,\"./Interval\":115,\"zrender/lib/core/util\":166}],120:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    var MEMBER_PRIFIX = '\\0ec_\\0';\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name] = value;` (can be right-value)\n     * @public\n     */\n    clazz.set = function (host, name, value) {\n        return (host[MEMBER_PRIFIX + name] = value);\n    };\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name];`\n     * @public\n     */\n    clazz.get = function (host, name) {\n        return host[MEMBER_PRIFIX + name];\n    };\n\n    /**\n     * For hidden private class member.\n     * The same behavior as `host.hasOwnProperty(name);`\n     * @public\n     */\n    clazz.hasOwn = function (host, name) {\n        return host.hasOwnProperty(MEMBER_PRIFIX + name);\n    };\n\n    /**\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n\n    /**\n     * @public\n     */\n    function checkClassType(componentType) {\n        zrUtil.assert(\n            /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n            'componentType \"' + componentType + '\" illegal'\n        );\n    }\n\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                checkClassType(componentType);\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n            var Clazz = storage[componentMainType];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    !subType\n                        ? componentMainType + '.' + 'type should be specified.'\n                        : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n},{\"zrender/lib/core/util\":166}],121:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazz = require('./clazz');\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n},{\"./clazz\":120,\"zrender/lib/core/util\":166}],122:[function(require,module,exports){\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('./number');\n    var textContain = require('zrender/lib/contain/text');\n\n    var formatUtil = {};\n    /**\n     * ,\n     * @type {string|number} x\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @param {boolean} [upperCaseFirst=false]\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n\n        if (upperCaseFirst && str) {\n            str = str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        return str;\n    };\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        else if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    };\n\n    var encodeHTML = formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param {string} tpl\n     * @param {Array.<Object>|Object} paramsList\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList, encode) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            var val = wrapVar(alias, 0);\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                var val = paramsList[seriesIdx][$vars[k]];\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    encode ? encodeHTML(val) : val\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var y = date.getFullYear();\n        var M = date.getMonth() + 1;\n        var d = date.getDate();\n        var h = date.getHours();\n        var m = date.getMinutes();\n        var s = date.getSeconds();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .toLowerCase()\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    module.exports = formatUtil;\n\n},{\"./number\":126,\"zrender/lib/contain/text\":150,\"zrender/lib/core/util\":166}],123:[function(require,module,exports){\n'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var pathTool = require('zrender/lib/tool/path');\n    var round = Math.round;\n    var Path = require('zrender/lib/graphic/Path');\n    var colorTool = require('zrender/lib/tool/color');\n    var matrix = require('zrender/lib/core/matrix');\n    var vector = require('zrender/lib/core/vector');\n\n    var graphic = {};\n\n    graphic.Group = require('zrender/lib/container/Group');\n\n    graphic.Image = require('zrender/lib/graphic/Image');\n\n    graphic.Text = require('zrender/lib/graphic/Text');\n\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\n\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\n\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\n\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\n\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\n\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\n\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\n\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\n\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\n\n    graphic.CompoundPath = require('zrender/lib/graphic/CompoundPath');\n\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\n\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\n\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            graphic.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     * @param {Object} [opt]\n     * @param {boolean} [opt.hoverSilentOnTouch=false]\n     *        In touch device, mouseover event will be trigger on touchstart event\n     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n     *        conviniently use hoverStyle when tap on touch screen without additional\n     *        code for compatibility.\n     *        But if the chart/component has select feature, which usually also use\n     *        hoverStyle, there might be conflict between 'select-highlight' and\n     *        'hover-highlight' especially when roam is enabled (see geo for example).\n     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n     *        on touch device.\n     */\n    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n\n        // Duplicated function will be auto-ignored, see Eventful.js.\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelOffset = labelModel.getShallow('offset');\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textOffset: labelOffset,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        // Do not check 'animation' property directly here. Consider this case:\n        // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n        // but its parent model (`seriesModel`) does.\n        var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(\n                    dataIndex,\n                    animatableModel.getAnimationDelayParams\n                        ? animatableModel.getAnimationDelayParams(el, dataIndex)\n                        : null\n                );\n            }\n            if (typeof duration === 'function') {\n                duration = duration(dataIndex);\n            }\n\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n                : (el.attr(props), cb && cb());\n        }\n        else {\n            el.attr(props);\n            cb && cb();\n        }\n    }\n\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} vertex [x, y]\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (vertex, transform, invert) {\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], vertex, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    module.exports = graphic;\n\n\n},{\"zrender/lib/container/Group\":153,\"zrender/lib/core/BoundingRect\":154,\"zrender/lib/core/matrix\":164,\"zrender/lib/core/util\":166,\"zrender/lib/core/vector\":167,\"zrender/lib/graphic/CompoundPath\":169,\"zrender/lib/graphic/Image\":172,\"zrender/lib/graphic/LinearGradient\":173,\"zrender/lib/graphic/Path\":174,\"zrender/lib/graphic/RadialGradient\":176,\"zrender/lib/graphic/Text\":178,\"zrender/lib/graphic/shape/Arc\":184,\"zrender/lib/graphic/shape/BezierCurve\":185,\"zrender/lib/graphic/shape/Circle\":186,\"zrender/lib/graphic/shape/Line\":187,\"zrender/lib/graphic/shape/Polygon\":188,\"zrender/lib/graphic/shape/Polyline\":189,\"zrender/lib/graphic/shape/Rect\":190,\"zrender/lib/graphic/shape/Ring\":191,\"zrender/lib/graphic/shape/Sector\":192,\"zrender/lib/tool/color\":197,\"zrender/lib/tool/path\":198}],124:[function(require,module,exports){\n'use strict';\n// Layout helpers for each component positioning\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n    var numberUtil = require('./number');\n    var formatUtil = require('./format');\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n        'left', 'right', 'top', 'bottom', 'width', 'height'\n    ];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n\n    /**\n     * Position a zr element in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * Logic:\n     *     1. Scale (against origin point in parent coord)\n     *     2. Rotate (against origin point in parent coord)\n     *     3. Traslate (with el.position by this method)\n     * So this method only fixes the last step 'Traslate', which does not affect\n     * scaling and rotating.\n     *\n     * If be called repeatly with the same input el, the same result will be gotten.\n     *\n     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @param {Object} [opt]\n     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n     * @param {Array.<number>} [opt.boundingMode='all']\n     *        Specify how to calculate boundingRect when locating.\n     *        'all': Position the boundingRect that is transformed and uioned\n     *               both itself and its descendants.\n     *               This mode simplies confine the elements in the bounding\n     *               of their container (e.g., using 'right: 0').\n     *        'raw': Position the boundingRect that is not transformed and only itself.\n     *               This mode is useful when you want a element can overflow its\n     *               container. (Consider a rotated circle needs to be located in a corner.)\n     *               In this mode positionInfo.width/height can only be number.\n     */\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n        var h = !opt || !opt.hv || opt.hv[0];\n        var v = !opt || !opt.hv || opt.hv[1];\n        var boundingMode = opt && opt.boundingMode || 'all';\n\n        if (!h && !v) {\n            return;\n        }\n\n        var rect;\n        if (boundingMode === 'raw') {\n            rect = el.type === 'group'\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n                : el.getBoundingRect();\n        }\n        else {\n            rect = el.getBoundingRect();\n            if (el.needLocalTransform()) {\n                var transform = el.getLocalTransform();\n                // Notice: raw rect may be inner object of el,\n                // which should not be modified.\n                rect = rect.clone();\n                rect.applyTransform(transform);\n            }\n        }\n\n        positionInfo = layout.getLayoutRect(\n            zrUtil.defaults(\n                {width: rect.width, height: rect.height},\n                positionInfo\n            ),\n            containerRect,\n            margin\n        );\n\n        // Because 'tranlate' is the last step in transform\n        // (see zrender/core/Transformable#getLocalTransfrom),\n        // we can just only modify el.position to get final result.\n        var elPos = el.position;\n        var dx = h ? positionInfo.x - rect.x : 0;\n        var dy = v ? positionInfo.y - rect.y : 0;\n\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n        var hNames = ['width', 'left', 'right']; // Order by priority.\n        var vNames = ['height', 'top', 'bottom']; // Order by priority.\n        var hResult = merge(hNames);\n        var vResult = merge(vNames);\n\n        copy(hNames, targetOption, hResult);\n        copy(vNames, targetOption, vResult);\n\n        function merge(names) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n},{\"./format\":122,\"./number\":126,\"zrender/lib/core/BoundingRect\":154,\"zrender/lib/core/util\":166}],125:[function(require,module,exports){\n\n\n    var formatUtil = require('./format');\n    var nubmerUtil = require('./number');\n    var Model = require('../model/Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n\n    modelUtil.LABEL_OPTIONS = ['position', 'offset', 'show', 'textStyle', 'distance', 'formatter'];\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n\n            var seriesIndex = this.seriesIndex;\n            var seriesName = this.name;\n\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: seriesIndex,\n                seriesName: seriesName,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: data.getItemVisual(dataIndex, 'color'),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get(['label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          index of which is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    // Existing model that already has id should be able to\n                    // mapped to (because after mapping performed model may\n                    // be assigned with a id, whish should not affect next\n                    // mapping), except those has inner id.\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * Make id and name for mapping result (result of mappingToExists)\n     * into `keyInfo` field.\n     *\n     * @public\n     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     * @return {Array.<Object>} The input.\n     */\n    modelUtil.makeIdAndName = function (mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = {};\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && (idMap[existCpt.id] = item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && (idMap[opt.id] = item);\n            !item.keyInfo && (item.keyInfo = {});\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-';\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap[keyInfo.id]);\n            }\n\n            idMap[keyInfo.id] = item;\n        });\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, goeName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = parsedKey[2];\n\n            if (!mainType || !queryType) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            queryParam[queryType.toLowerCase()] = value;\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n},{\"../model/Model\":100,\"./format\":122,\"./number\":126,\"zrender/lib/core/util\":166}],126:[function(require,module,exports){\n/**\n * \n * @module echarts/util/number\n */\n\n\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * Fix rounding error of float numbers\n     * @param {number} x\n     * @return {number}\n     */\n    number.round = function (x, precision) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        return +(+x).toFixed(precision);\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n        var dotIndex = str.indexOf('.');\n        if (dotIndex < 0) {\n            return 0;\n        }\n        return str.length - 1 - dotIndex;\n    };\n\n    /**\n     * Minimal dicernible data precisioin according to a single pixel.\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number} precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        // toFixed() digits argument must be between 0 and 20.\n        var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n        return !isFinite(precision) ? 20 : precision;\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    /**\n     * @param {string|Date|number} value\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Treat as ISO format. See issue #3623\n            var ret = new Date(value);\n            if (isNaN(+ret)) {\n                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n            }\n            return ret;\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n    };\n\n    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n    /**\n     * find a nice number approximately equal to x. Round the number if round = true, take ceiling if round = false\n     * The primary observation is that the nicest numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     * @param  {number} val\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exp10 = number.quantity(val);\n        var f = val / exp10; // between 1 and 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        return nf * exp10;\n    };\n\n    /**\n     * Order intervals asc, and split them when overlap.\n     * expect(numberUtil.reformIntervals([\n     *     {interval: [18, 62], close: [1, 1]},\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [1, 1]},\n     *     {interval: [62, 150], close: [1, 1]},\n     *     {interval: [106, 150], close: [1, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ])).toEqual([\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [0, 1]},\n     *     {interval: [18, 62], close: [0, 1]},\n     *     {interval: [62, 150], close: [0, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ]);\n     * @param {Array.<Object>} list, where `close` mean open or close\n     *        of the interval, and Infinity can be used.\n     * @return {Array.<Object>} The origin list, which has been reformed.\n     */\n    number.reformIntervals = function (list) {\n        list.sort(function (a, b) {\n            return littleThan(a, b, 0) ? -1 : 1;\n        });\n\n        var curr = -Infinity;\n        var currClose = 1;\n        for (var i = 0; i < list.length;) {\n            var interval = list[i].interval;\n            var close = list[i].close;\n\n            for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                    interval[lg] = curr;\n                    close[lg] = !lg ? 1 - currClose : 1;\n                }\n                curr = interval[lg];\n                currClose = close[lg];\n            }\n\n            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n                list.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n\n        return list;\n\n        function littleThan(a, b, lg) {\n            return a.interval[lg] < b.interval[lg]\n                || (\n                    a.interval[lg] === b.interval[lg]\n                    && (\n                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                        || (!lg && littleThan(a, b, 1))\n                    )\n                );\n        }\n    };\n\n    /**\n     * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n     * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n     * subtraction forces infinities to NaN\n     * @param {*} v\n     * @return {boolean}\n     */\n    number.isNumeric = function (v) {\n        return v - parseFloat(v) >= 0;\n    };\n\n    module.exports = number;\n\n},{}],127:[function(require,module,exports){\n'use strict';\n// Symbol factory\n\n\n    var graphic = require('./graphic');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME  onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n},{\"./graphic\":123,\"zrender/lib/core/BoundingRect\":154}],128:[function(require,module,exports){\n\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            diff = currCall - (debounce ? lastCall : lastExec) - delay;\n\n            clearTimeout(timer);\n\n            if (debounce) {\n                timer = setTimeout(exec, delay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n\n},{}],129:[function(require,module,exports){\n\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n},{\"../util/clazz\":120,\"../util/component\":121,\"../util/model\":125,\"zrender/lib/container/Group\":153,\"zrender/lib/core/util\":166}],130:[function(require,module,exports){\n\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n},{\"../util/clazz\":120,\"../util/component\":121,\"zrender/lib/container/Group\":153}],131:[function(require,module,exports){\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\n\n\n    module.exports = function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    var filteredIdx = idxMap[rawIdx];\n\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null\n                        && data.getItemVisual(filteredIdx, 'color', true);\n\n                    if (!singleDataColor) {\n                        // FIXME Performance\n                        var itemModel = dataAll.getItemModel(rawIdx);\n                        var color = itemModel.get('itemStyle.normal.color')\n                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    }\n                    else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n\n},{}],132:[function(require,module,exports){\n\n    var Gradient = require('zrender/lib/graphic/Gradient');\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n},{\"zrender/lib/graphic/Gradient\":171}],133:[function(require,module,exports){\n\n\n    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\n        // Encoding visual for all series include which is filtered for legend drawing\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n\n            var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n            var symbolSize = seriesModel.get('symbolSize');\n\n            data.setVisual({\n                legendSymbol: legendSymbol || symbolType,\n                symbol: symbolType,\n                symbolSize: symbolSize\n            });\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof symbolSize === 'function') {\n                    data.each(function (idx) {\n                        var rawValue = seriesModel.getRawValue(idx);\n                        // FIXME\n                        var params = seriesModel.getDataParams(idx);\n                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n                    });\n                }\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var itemSymbolType = itemModel.getShallow('symbol', true);\n                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n                    // If has item symbol\n                    if (itemSymbolType != null) {\n                        data.setItemVisual(idx, 'symbol', itemSymbolType);\n                    }\n                    if (itemSymbolSize != null) {\n                        // PENDING Transform symbolSize ?\n                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n                    }\n                });\n            }\n        });\n    };\n\n},{}],134:[function(require,module,exports){\n'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * \n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * \n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender  element  zrender \n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * true\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * (shape) Group \n         * \n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n},{\"./core/guid\":162,\"./core/util\":166,\"./mixin/Animatable\":193,\"./mixin/Eventful\":195,\"./mixin/Transformable\":196}],135:[function(require,module,exports){\n'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n\n            this._hovered = hovered;\n\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = null;\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * cursor style\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * \n         *\n         * @private\n         * @param {Object} targetEl \n         * @param {string} eventName \n         * @param {Object} event \n         */\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\n            var el = targetEl;\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                if (!list[i].silent\n                 && list[i] !== exclude\n                 // getDisplayList may include ignored item in VML mode\n                 && !list[i].ignore\n                 && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hovered;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n},{\"./core/util\":166,\"./mixin/Draggable\":194,\"./mixin/Eventful\":195}],136:[function(require,module,exports){\n/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n},{\"./config\":144,\"./core/util\":166,\"./graphic/Pattern\":175,\"./graphic/Style\":177}],137:[function(require,module,exports){\n'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n\n    var Layer = require('./Layer');\n\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.isBuildin) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // \n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        this.pathToImage = this._createPathToImage();\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        /**\n         * \n         * @param {boolean} [paintAll=false] displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.isBuildin && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuildinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuildinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.isBuildin) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         *  zlevel \n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.isBuildin = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(\n                        layer.dom,\n                        prevDom.nextSibling\n                    );\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n\n            layersMap[zlevel] = layer;\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuildinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (! layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuildinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // \n            this.eachBuildinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * hover\n         */\n        clear: function () {\n            this.eachBuildinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * zlevel\n         *\n         * @param {string} zlevel\n         * @param {Object} config \n         * @param {string} [config.clearColor=0] \n         * @param {string} [config.motionBlur=false] \n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 alpha\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {number} zlevel zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * \n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * \n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            return imageLayer.dom;\n        },\n        /**\n         * \n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * \n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        _pathToImage: function (id, path, width, height, dpr) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [0, 0, 0];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                id: id,\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        },\n\n        _createPathToImage: function () {\n            var me = this;\n\n            return function (id, e, width, height) {\n                return me._pathToImage(\n                    id, e, width, height, me.dpr\n                );\n            };\n        }\n    };\n\n    module.exports = Painter;\n\n\n},{\"./Layer\":136,\"./animation/requestAnimationFrame\":143,\"./config\":144,\"./core/BoundingRect\":154,\"./core/log\":163,\"./core/timsort\":165,\"./core/util\":166,\"./graphic/Image\":172}],138:[function(require,module,exports){\n'use strict';\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n    var env = require('./core/env');\n\n    var Group = require('./container/Group');\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // idmap\n        this._elements = {};\n\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [update=false] \n         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n         *\n         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * \n         * GroupShapeShape\n         * zlevel > z > \n         * @param {boolean} [includeIgnore=false]  ignore \n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath  clipPath \n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {string|Array.<string>} [elId] Storage\n         */\n        delRoot: function (elId) {\n            if (elId == null) {\n                // elId\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n\n            var el;\n            if (typeof(elId) == 'string') {\n                el = this._elements[elId];\n            }\n            else {\n                el = elId;\n            }\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n\n            this._elements[el.id] = el;\n\n            return this;\n        },\n\n        get: function (elId) {\n            return this._elements[elId];\n        },\n\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Storage\n         */\n        dispose: function () {\n            this._elements =\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n},{\"./container/Group\":153,\"./core/env\":160,\"./core/timsort\":165,\"./core/util\":166}],139:[function(require,module,exports){\n'use strict';\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = require('./requestAnimationFrame');\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         *  clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         *  animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * \n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * \n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * \n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * \n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * \n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * animator\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] \n         * @param  {Function} [options.getter=null]\n         *         gettergetter\n         * @param  {Function} [options.setter=null]\n         *         settersetter\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n},{\"../core/event\":161,\"../core/util\":166,\"./Animator\":140,\"./requestAnimationFrame\":143}],140:[function(require,module,exports){\n/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = (\n                isValueArray\n                && isArrayLike(firstVal[0])\n            )\n            ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * \n         * @param  {number} time ms\n         * @param  {Object} props key-value\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * \n         * @param  {string|Function} easing\n         *         {@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * \n         * @param  {number} time ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n},{\"../core/util\":166,\"../tool/color\":197,\"./Clip\":141}],141:[function(require,module,exports){\n/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n\n        // \n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            var percent = (globalTime - this._startTime) / this._life;\n\n            // \n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n\n            this._needsRemove = false;\n        },\n\n        fire: function(eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        }\n    };\n\n    module.exports = Clip;\n\n\n},{\"./easing\":142}],142:[function(require,module,exports){\n/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // t^3\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // t^4\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // t^5\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // sin(t)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 2^t\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // sqrt(1-t^2)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n},{}],143:[function(require,module,exports){\n\n\n    module.exports = (typeof window !== 'undefined' &&\n                                    (window.requestAnimationFrame\n                                    || window.msRequestAnimationFrame\n                                    || window.mozRequestAnimationFrame\n                                    || window.webkitRequestAnimationFrame))\n                                || function (func) {\n                                    setTimeout(func, 16);\n                                };\n\n\n},{}],144:[function(require,module,exports){\n\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debugcatchBrushExceptiontrue\n         * 0 : debug\n         * 1 : \n         * 2 : \n         */\n        debugMode: 0,\n\n        // retina \n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n},{}],145:[function(require,module,exports){\n\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n},{\"./util\":151}],146:[function(require,module,exports){\n\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n},{\"../core/curve\":159}],147:[function(require,module,exports){\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n},{}],148:[function(require,module,exports){\n'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // \n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc \n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                //  subpath \n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE  L, C, Q  NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    //  arc \n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // \n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr scale, x\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        //  subpath \n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n},{\"../core/PathProxy\":157,\"../core/curve\":159,\"./arc\":145,\"./cubic\":146,\"./line\":147,\"./quadratic\":149,\"./util\":151,\"./windingLine\":152}],149:[function(require,module,exports){\n\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n},{\"../core/curve\":159}],150:[function(require,module,exports){\n\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText  Canvas \n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME \n        var lineHeight = getTextWidth('', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var halfHeight = height / 2 - textHeight / 2;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n},{\"../core/BoundingRect\":154,\"../core/util\":166}],151:[function(require,module,exports){\n\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n},{}],152:[function(require,module,exports){\n\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n},{}],153:[function(require,module,exports){\n/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * \n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         *  index \n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * \n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         *  nextSibling \n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToMap(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromMap(child.id);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * \n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n},{\"../Element\":134,\"../core/BoundingRect\":154,\"../core/util\":166}],154:[function(require,module,exports){\n'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // \n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n},{\"./matrix\":164,\"./vector\":167}],155:[function(require,module,exports){\n'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = require('./event');\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n},{\"./event\":161}],156:[function(require,module,exports){\n// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function() {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function(val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function(entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function(entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function() {\n        return this._len;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function(val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function(maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     */\n    LRUProto.put = function(key, value) {\n        var list = this._list;\n        var map = this._map;\n        if (map[key] == null) {\n            var len = list.len();\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n            }\n\n            var entry = list.insert(value);\n            entry.key = key;\n            map[key] = entry;\n        }\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function(key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function() {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n},{}],157:[function(require,module,exports){\n'use strict';\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n\n        this._len = 0;\n\n        this._ctx = null;\n\n        this._xi = 0;\n        this._yi = 0;\n\n        this._x0 = 0;\n        this._y0 = 0;\n\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            this._len = 0;\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context  rebuildPath  fill\n         * stroke \n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         *  Path \n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * \n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         *  Path \n         * \n         */\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         *  Float32Array \n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo  subpath, \n                        //  closePath \n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc \n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc \n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n},{\"../config\":144,\"./BoundingRect\":154,\"./bbox\":158,\"./curve\":159,\"./vector\":167}],158:[function(require,module,exports){\n/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n},{\"./curve\":159,\"./vector\":167}],159:[function(require,module,exports){\n'use strict';\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n},{\"./vector\":167}],160:[function(require,module,exports){\n/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // canvas\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n},{}],161:[function(require,module,exports){\n'use strict';\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n    var env = require('./env');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * domtouch.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // \n        Dispatcher: Eventful\n    };\n\n\n},{\"../mixin/Eventful\":195,\"./env\":160}],162:[function(require,module,exports){\n/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n},{}],163:[function(require,module,exports){\n\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n},{\"../config\":144}],164:[function(require,module,exports){\n\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * \n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n},{}],165:[function(require,module,exports){\n// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n},{}],166:[function(require,module,exports){\n/**\n * @module zrender/core/util\n */\n\n\n    // mergeDate\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuildInObject(sourceProp)\n                    && !isBuildInObject(targetProp)\n                ) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuildInObject: isBuildInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        assert: assert,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n},{}],167:[function(require,module,exports){\n\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * \n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} \n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n},{}],168:[function(require,module,exports){\n\n\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null),\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // rootdommouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n},{\"../core/GestureMgr\":155,\"../core/env\":160,\"../core/event\":161,\"../core/util\":166,\"../mixin/Eventful\":195}],169:[function(require,module,exports){\n// CompoundPath to improve performance\n\n\n    var Path = require('./Path');\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n},{\"./Path\":174}],170:[function(require,module,exports){\n/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable Painter \n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * true\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * zlevelcanvas\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * \n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * \n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         *  x, y \n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         *  x, y \n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * \n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * \n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO,  bind \n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n},{\"../Element\":134,\"../core/util\":166,\"./Style\":177,\"./mixin/RectText\":183}],171:[function(require,module,exports){\n\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n},{}],172:[function(require,module,exports){\n/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // \n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var width = style.width || image.width;\n                var height = style.height || image.height;\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // \n                if (!image.width || !image.height) {\n                    return;\n                }\n\n                // transform\n                this.setTransform(ctx);\n\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                // \n                if (style.width == null) {\n                    style.width = width;\n                }\n                if (style.height == null) {\n                    style.height = height;\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n},{\"../core/BoundingRect\":154,\"../core/LRU\":156,\"../core/util\":166,\"./Displayable\":170}],173:[function(require,module,exports){\n'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n},{\"../core/util\":166,\"./Gradient\":171}],174:[function(require,module,exports){\n/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || (\n                lineDash && !ctxLineDash && hasStroke\n            )) {\n                path = this.path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n},{\"../contain/path\":148,\"../core/PathProxy\":157,\"../core/util\":166,\"./Displayable\":170,\"./Pattern\":175}],175:[function(require,module,exports){\n\n\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n\n        return this._canvasPattern\n            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n\n    module.exports = Pattern;\n\n},{}],176:[function(require,module,exports){\n'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n},{\"../core/util\":166,\"./Gradient\":171}],177:[function(require,module,exports){\n/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n},{}],178:[function(require,module,exports){\n/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            if (!this._rect) {\n                var style = this.style;\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                this._rect = rect;\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n},{\"../contain/text\":150,\"../core/util\":166,\"./Displayable\":170}],179:[function(require,module,exports){\n\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n},{\"./smoothBezier\":181,\"./smoothSpline\":182}],180:[function(require,module,exports){\n\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n},{}],181:[function(require,module,exports){\n/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n},{\"../../core/vector\":167}],182:[function(require,module,exports){\n/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n},{\"../../core/vector\":167}],183:[function(require,module,exports){\n/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var textOffset = style.textOffset;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            if (textOffset) {\n                x += textOffset[0];\n                y += textOffset[1];\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n},{\"../../contain/text\":150,\"../../core/BoundingRect\":154}],184:[function(require,module,exports){\n/**\n * \n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n},{\"../Path\":174}],185:[function(require,module,exports){\n'use strict';\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n},{\"../../core/curve\":159,\"../../core/vector\":167,\"../Path\":174}],186:[function(require,module,exports){\n'use strict';\n/**\n * \n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n},{\"../Path\":174}],187:[function(require,module,exports){\n/**\n * \n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n},{\"../Path\":174}],188:[function(require,module,exports){\n/**\n * \n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n},{\"../Path\":174,\"../helper/poly\":179}],189:[function(require,module,exports){\n/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n},{\"../Path\":174,\"../helper/poly\":179}],190:[function(require,module,exports){\n/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // r1r2r3r4\n            // r1          [1, 1, 1, 1]\n            // r[1]        [1, 1, 1, 1]\n            // r[1, 2]     [1, 2, 1, 2]\n            // r[1, 2, 3]  [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n},{\"../Path\":174,\"../helper/roundRect\":180}],191:[function(require,module,exports){\n/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n},{\"../Path\":174}],192:[function(require,module,exports){\n/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var env = require('../../core/env');\n    var Path = require('../Path');\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n            // where exception \"unexpected call to method or property access\"\n            // might be thrown when calling ctx.fill after a path whose area size\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n            // (e.g.,\n            //  ctx.moveTo(10, 10);\n            //  ctx.lineTo(20, 10);\n            //  ctx.closePath();\n            //  ctx.clip();\n            //  ctx.shadowBlur = 10;\n            //  ...\n            //  ctx.fill();\n            // )\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var shape = clipPaths[i] && clipPaths[i].shape;\n                        if (shape && shape.startAngle === shape.endAngle) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                Path.prototype.brush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n            : Path.prototype.brush,\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n},{\"../../core/env\":160,\"../Path\":174}],193:[function(require,module,exports){\n'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * \n         *\n         * @param {string} path a.b.c\n         * @param {boolean} [loop] \n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n},{\"../animation/Animator\":140,\"../core/log\":163,\"../core/util\":166}],194:[function(require,module,exports){\n// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    module.exports = Draggable;\n\n},{}],195:[function(require,module,exports){\n/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * trigger\n         *\n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} [handler] \n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * \n         *\n         * @param {string} type \n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * context, context\n         * @param {string} type \n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n},{}],196:[function(require,module,exports){\n'use strict';\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = this.origin;\n\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n    /**\n     * transformcontext\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n\n    var tmpTransform = [];\n\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    module.exports = Transformable;\n\n\n},{\"../core/matrix\":164,\"../core/vector\":167}],197:[function(require,module,exports){\n/**\n * @module zrender/tool/color\n */\n\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();  // dup.\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                ];\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                ];\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return [\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    ];\n                case 'hsla':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    return hsla2rgba(params);\n                case 'hsl':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return hsla2rgba(params);\n                default:\n                    return;\n            }\n        }\n\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        var rgba = [\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n        ];\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n        out = out || [0, 0, 0, 0];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n},{}],198:[function(require,module,exports){\n\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n},{\"../core/PathProxy\":157,\"../core/matrix\":164,\"../graphic/Path\":174,\"./transformPath\":199}],199:[function(require,module,exports){\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i++] += x;\n                    // cy\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n},{\"../core/PathProxy\":157,\"../core/vector\":167}],200:[function(require,module,exports){\n/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var zrUtil = require('./core/util');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRendermap\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.3.0';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        //  storage.delFromMap, \n        // FIXME ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * \n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, width, height) {\n            var id = guid();\n            return this.painter.pathToImage(id, e, width, height);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n},{\"./Handler\":135,\"./Painter\":137,\"./Storage\":138,\"./animation/Animation\":139,\"./core/env\":160,\"./core/guid\":162,\"./core/util\":166,\"./dom/HandlerProxy\":168}],201:[function(require,module,exports){\n'use strict';\n\nvar echarts = require('echarts/lib/echarts');\nrequire('echarts/lib/chart/bar');\nrequire('echarts/lib/chart/pie');\nrequire('echarts/lib/chart/line');\nrequire('echarts/lib/chart/radar');\nrequire('echarts/lib/chart/gauge');\nrequire('echarts/lib/component/legend');\nrequire('echarts/lib/component/tooltip');\nrequire('echarts/lib/component/title');\nrequire('echarts/lib/component/markLine');\nrequire('echarts/lib/component/markPoint');\nrequire('echarts/lib/component/dataZoomInside');\n\nwindow.echarts = echarts;\nmodule.exports = echarts;\n\n},{\"echarts/lib/chart/bar\":4,\"echarts/lib/chart/gauge\":10,\"echarts/lib/chart/line\":20,\"echarts/lib/chart/pie\":25,\"echarts/lib/chart/radar\":30,\"echarts/lib/component/dataZoomInside\":38,\"echarts/lib/component/legend\":55,\"echarts/lib/component/markLine\":60,\"echarts/lib/component/markPoint\":61,\"echarts/lib/component/title\":71,\"echarts/lib/component/tooltip\":72,\"echarts/lib/echarts\":94}]},{},[201])\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvQ29vcmRpbmF0ZVN5c3RlbS5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9FeHRlbnNpb25BUEkuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvYWN0aW9uL2NyZWF0ZURhdGFTZWxlY3RBY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2Jhci9CYXJTZXJpZXMuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0JhclZpZXcuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL0Jhc2VCYXJTZXJpZXMuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvYmFyL2Jhckl0ZW1TdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9iYXIvaGVscGVyLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dhdWdlLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dhdWdlL0dhdWdlU2VyaWVzLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2dhdWdlL0dhdWdlVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9nYXVnZS9Qb2ludGVyUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZS5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvTGluZURyYXcuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL0xpbmVQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2hlbHBlci9TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL1N5bWJvbERyYXcuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXkuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL0xpbmVTZXJpZXMuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvbGluZS9MaW5lVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9saW5lL2xpbmVBbmltYXRpb25EaWZmLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NoYXJ0L2xpbmUvcG9seS5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9waWUuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvcGllL1BpZVNlcmllcy5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9waWUvUGllVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9waWUvbGFiZWxMYXlvdXQuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvcGllL3BpZUxheW91dC5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9yYWRhci5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9yYWRhci9SYWRhclNlcmllcy5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jaGFydC9yYWRhci9SYWRhclZpZXcuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvcmFkYXIvYmFja3dhcmRDb21wYXQuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY2hhcnQvcmFkYXIvcmFkYXJMYXlvdXQuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQXhpc0J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2F4aXMvQXhpc1ZpZXcuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tSW5zaWRlLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9BeGlzUHJveHkuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWwuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vSW5zaWRlWm9vbU1vZGVsLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9JbnNpZGVab29tVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb20vZGF0YVpvb21BY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL2RhdGFab29tUHJvY2Vzc29yLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS9oZWxwZXIuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2RhdGFab29tL3JvYW1zLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9kYXRhWm9vbS90eXBlRGVmYXVsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9ncmlkLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2hlbHBlci9pbnRlcmFjdGlvbk11dGV4LmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvbGlzdENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL3NlbGVjdGFibGVNaXhpbi5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL3NsaWRlck1vdmUuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL0xlZ2VuZE1vZGVsLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL2xlZ2VuZEFjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL2xlZ2VuZEZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya0xpbmUuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtQb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtMaW5lTW9kZWwuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrTGluZVZpZXcuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrUG9pbnRNb2RlbC5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtQb2ludFZpZXcuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9NYXJrZXJNb2RlbC5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtlclZpZXcuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtlci9tYXJrZXJIZWxwZXIuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3JhZGFyLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC9yYWRhci9SYWRhclZpZXcuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3RpdGxlLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBDb250ZW50LmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBNb2RlbC5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9BeGlzLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2F4aXNIZWxwZXIuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc01vZGVsQ29tbW9uTWl4aW4uanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvYXhpc01vZGVsQ3JlYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vQXhpczJELmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWwuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbi5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuMkQuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0dyaWQuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvY2FydGVzaWFuL0dyaWRNb2RlbC5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9jYXJ0ZXNpYW4vYXhpc0xhYmVsSW50ZXJ2YWwuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29vcmQvcmFkYXIvSW5kaWNhdG9yQXhpcy5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9yYWRhci9SYWRhci5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb29yZC9yYWRhci9SYWRhck1vZGVsLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2RhdGEvRGF0YURpZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9kYXRhL0xpc3QuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2VjaGFydHMuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbGF5b3V0L2JhckdyaWQuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbGF5b3V0L3BvaW50cy5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9sb2FkaW5nL2RlZmF1bHQuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL0dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9Nb2RlbC5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9PcHRpb25NYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL1Nlcmllcy5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9nbG9iYWxEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2FyZWFTdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9ib3hMYXlvdXQuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vY29sb3JQYWxldHRlLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL2l0ZW1TdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9saW5lU3R5bGUuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vbWFrZVN0eWxlTWFwcGVyLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL21vZGVsL21peGluL3RleHRTdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcmVwcm9jZXNzb3IvYmFja3dhcmRDb21wYXQuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvcHJlcHJvY2Vzc29yL2hlbHBlci9jb21wYXRTdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcm9jZXNzb3IvZGF0YUZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9wcm9jZXNzb3IvZGF0YVNhbXBsZS5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9JbnRlcnZhbC5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9Mb2cuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvc2NhbGUvT3JkaW5hbC5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9TY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9zY2FsZS9UaW1lLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvY2xhenouanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9jb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9ncmFwaGljLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvbGF5b3V0LmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3V0aWwvbW9kZWwuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9udW1iZXIuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC9zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdXRpbC90aHJvdHRsZS5qcyIsIm5vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi92aWV3L0NoYXJ0LmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3ZpZXcvQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Zpc3VhbC9kYXRhQ29sb3IuanMiLCJub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvdmlzdWFsL3Nlcmllc0NvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL3Zpc3VhbC9zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvRWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9IYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL0xheWVyLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL1BhaW50ZXIuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvU3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9hbmltYXRpb24vQ2xpcC5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9saW5lLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3RleHQuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vd2luZGluZ0xpbmUuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvR2VzdHVyZU1nci5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL0xSVS5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2Jib3guanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9jdXJ2ZS5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2Vudi5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2xvZy5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9Db21wb3VuZFBhdGguanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudC5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1BhdGguanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9QYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9TdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1RleHQuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aFNwbGluZS5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vQW5pbWF0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzIiwibm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanMiLCJub2RlX21vZHVsZXMvenJlbmRlci9saWIvenJlbmRlci5qcyIsInNyY1xcbGliXFxlY2hhcnRzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2phQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNodkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0bkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3QxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25xQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hhQSxJQUFJLFVBQVUsUUFBUSxxQkFBUixDQUFkO0FBQ0EsUUFBUSx1QkFBUjtBQUNBLFFBQVEsdUJBQVI7QUFDQSxRQUFRLHdCQUFSO0FBQ0EsUUFBUSx5QkFBUjtBQUNBLFFBQVEseUJBQVI7QUFDQSxRQUFRLDhCQUFSO0FBQ0EsUUFBUSwrQkFBUjtBQUNBLFFBQVEsNkJBQVI7QUFDQSxRQUFRLGdDQUFSO0FBQ0EsUUFBUSxpQ0FBUjtBQUNBLFFBQVEsc0NBQVI7O0FBRUEsT0FBTyxPQUFQLEdBQWlCLE9BQWpCO0FBQ0EsT0FBTyxPQUFQLEdBQWlCLE9BQWpCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJmYWNlIG9mIENvb3JkaW5hdGUgU3lzdGVtIENsYXNzXG4gICAgICpcbiAgICAgKiBjcmVhdGU6XG4gICAgICogICAgIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogICAgIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgKiAgICAgQHJldHVybiB7T2JqZWN0fSBjb29yZGluYXRlIHN5c3RlbSBpbnN0YW5jZVxuICAgICAqXG4gICAgICogdXBkYXRlOlxuICAgICAqICAgICBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAqICAgICBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICpcbiAgICAgKiBjb252ZXJ0VG9QaXhlbDpcbiAgICAgKiBjb252ZXJ0RnJvbVBpeGVsOlxuICAgICAqICAgICBUaGVzZSB0d28gbWV0aG9kcyBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBkZXRlcm1pbmUgd2hldGhlciB0aGlzXG4gICAgICogICAgIGNvb2RpbmF0ZSBzeXN0ZW0gaXMgYXBwbGljYWJsZSB0byB0aGUgZ2l2ZW4gYGZpbmRlcmAuXG4gICAgICogICAgIEVhY2ggY29vcmRpbmF0ZSBzeXN0ZW0gd2lsbCBiZSB0cmllZCwgdXRpbCBvbmUgcmV0dXJucyBub25lXG4gICAgICogICAgIG51bGwvdW5kZWZpbmVkIHZhbHVlLlxuICAgICAqICAgICBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAqICAgICBAcGFyYW0ge09iamVjdH0gZmluZGVyXG4gICAgICogICAgIEBwYXJhbSB7QXJyYXl8bnVtYmVyfSB2YWx1ZVxuICAgICAqICAgICBAcmV0dXJuIHtBcnJheXxudW1iZXJ9IGNvbnZlcnQgcmVzdWx0LlxuICAgICAqXG4gICAgICogY29udGFpblBvaW50OlxuICAgICAqICAgICBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludCBJbiBwaXhlbCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiAgICAgQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICAgIHZhciBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyKCkge1xuXG4gICAgICAgIHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zID0gW107XG4gICAgfVxuXG4gICAgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBDb29yZGluYXRlU3lzdGVtTWFuYWdlcixcblxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlU3lzdGVtcyA9IFtdO1xuICAgICAgICAgICAgenJVdGlsLmVhY2goY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3JzLCBmdW5jdGlvbiAoY3JlYXRlciwgdHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gY3JlYXRlci5jcmVhdGUoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlU3lzdGVtcyA9IGNvb3JkaW5hdGVTeXN0ZW1zLmNvbmNhdChsaXN0IHx8IFtdKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLl9jb29yZGluYXRlU3lzdGVtcyA9IGNvb3JkaW5hdGVTeXN0ZW1zO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy5fY29vcmRpbmF0ZVN5c3RlbXMsIGZ1bmN0aW9uIChjb29yZFN5cykge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIE1VU1QgaGF2ZVxuICAgICAgICAgICAgICAgIGNvb3JkU3lzLnVwZGF0ZSAmJiBjb29yZFN5cy51cGRhdGUoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvb3JkaW5hdGVTeXN0ZW1zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZVN5c3RlbXMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDb29yZGluYXRlU3lzdGVtTWFuYWdlci5yZWdpc3RlciA9IGZ1bmN0aW9uICh0eXBlLCBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcikge1xuICAgICAgICBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnNbdHlwZV0gPSBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcjtcbiAgICB9O1xuXG4gICAgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIuZ2V0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9yc1t0eXBlXTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb29yZGluYXRlU3lzdGVtTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIGVjaGFydHNBUElMaXN0ID0gW1xuICAgICAgICAnZ2V0RG9tJywgJ2dldFpyJywgJ2dldFdpZHRoJywgJ2dldEhlaWdodCcsICdkaXNwYXRjaEFjdGlvbicsICdpc0Rpc3Bvc2VkJyxcbiAgICAgICAgJ29uJywgJ29mZicsICdnZXREYXRhVVJMJywgJ2dldENvbm5lY3RlZERhdGFVUkwnLCAnZ2V0TW9kZWwnLCAnZ2V0T3B0aW9uJ1xuICAgIF07XG5cbiAgICBmdW5jdGlvbiBFeHRlbnNpb25BUEkoY2hhcnRJbnN0YW5jZSkge1xuICAgICAgICB6clV0aWwuZWFjaChlY2hhcnRzQVBJTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB6clV0aWwuYmluZChjaGFydEluc3RhbmNlW25hbWVdLCBjaGFydEluc3RhbmNlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFeHRlbnNpb25BUEk7XG4iLCJcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgYWN0aW9uSW5mb3MpIHtcbiAgICAgICAgenJVdGlsLmVhY2goYWN0aW9uSW5mb3MsIGZ1bmN0aW9uIChhY3Rpb25JbmZvKSB7XG4gICAgICAgICAgICBhY3Rpb25JbmZvLnVwZGF0ZSA9ICd1cGRhdGVWaWV3JztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBheWxvYWRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZXJpZXNOYW1lXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKGFjdGlvbkluZm8sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0ge307XG4gICAgICAgICAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICB7bWFpblR5cGU6ICdzZXJpZXMnLCBzdWJUeXBlOiBzZXJpZXNUeXBlLCBxdWVyeTogcGF5bG9hZH0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmllc01vZGVsW2FjdGlvbkluZm8ubWV0aG9kXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsW2FjdGlvbkluZm8ubWV0aG9kXShwYXlsb2FkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgc2VsZWN0ZWQgbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRbbmFtZV0gPSBzZXJpZXNNb2RlbC5pc1NlbGVjdGVkKG5hbWUpIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuIiwiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICByZXF1aXJlKCcuLi9jb29yZC9jYXJ0ZXNpYW4vR3JpZCcpO1xuXG4gICAgcmVxdWlyZSgnLi9iYXIvQmFyU2VyaWVzJyk7XG4gICAgcmVxdWlyZSgnLi9iYXIvQmFyVmlldycpO1xuXG4gICAgdmFyIGJhckxheW91dEdyaWQgPSByZXF1aXJlKCcuLi9sYXlvdXQvYmFyR3JpZCcpO1xuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vZWNoYXJ0cycpO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlckxheW91dCh6clV0aWwuY3VycnkoYmFyTGF5b3V0R3JpZCwgJ2JhcicpKTtcbiAgICAvLyBWaXN1YWwgY29kaW5nIGZvciBsZWdlbmRcbiAgICBlY2hhcnRzLnJlZ2lzdGVyVmlzdWFsKGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgnYmFyJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIGRhdGEuc2V0VmlzdWFsKCdsZWdlbmRTeW1ib2wnLCAncm91bmRSZWN0Jyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gSW4gY2FzZSBkZXZlbG9wZXIgZm9yZ2V0IHRvIGluY2x1ZGUgZ3JpZCBjb21wb25lbnRcbiAgICByZXF1aXJlKCcuLi9jb21wb25lbnQvZ3JpZCcpO1xuIiwiXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vQmFzZUJhclNlcmllcycpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3Nlcmllcy5iYXInLFxuXG4gICAgICAgIGRlcGVuZGVuY2llczogWydncmlkJywgJ3BvbGFyJ10sXG5cbiAgICAgICAgYnJ1c2hTZWxlY3RvcjogJ3JlY3QnXG4gICAgfSk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciBoZWxwZXIgPSByZXF1aXJlKCcuL2hlbHBlcicpO1xuXG4gICAgdmFyIEJBUl9CT1JERVJfV0lEVEhfUVVFUlkgPSBbJ2l0ZW1TdHlsZScsICdub3JtYWwnLCAnYmFyQm9yZGVyV2lkdGgnXTtcblxuICAgIC8vIEZJWE1FXG4gICAgLy8gSnVzdCBmb3IgY29tcGF0aWJsZSB3aXRoIGVjMi5cbiAgICB6clV0aWwuZXh0ZW5kKHJlcXVpcmUoJy4uLy4uL21vZGVsL01vZGVsJykucHJvdG90eXBlLCByZXF1aXJlKCcuL2Jhckl0ZW1TdHlsZScpKTtcblxuICAgIHZhciBCYXJWaWV3ID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENoYXJ0Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ2JhcicsXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVTeXN0ZW1UeXBlID0gc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJyk7XG5cbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlU3lzdGVtVHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlck9uQ2FydGVzaWFuKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncm91cDtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiB6clV0aWwubm9vcCxcblxuICAgICAgICBfcmVuZGVyT25DYXJ0ZXNpYW46IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAgICB2YXIgaXNIb3Jpem9udGFsID0gYmFzZUF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uTW9kZWwgPSBzZXJpZXNNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKSA/IHNlcmllc01vZGVsIDogbnVsbDtcblxuICAgICAgICAgICAgZGF0YS5kaWZmKG9sZERhdGEpXG4gICAgICAgICAgICAgICAgLmFkZChmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5oYXNWYWx1ZShkYXRhSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheW91dCA9IGdldFJlY3RJdGVtTGF5b3V0KGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gY3JlYXRlUmVjdChkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBpc0hvcml6b250YWwsIGFuaW1hdGlvbk1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgZWwpO1xuICAgICAgICAgICAgICAgICAgICBncm91cC5hZGQoZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0eWxlKGVsLCBkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBzZXJpZXNNb2RlbCwgaXNIb3Jpem9udGFsKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC51cGRhdGUoZnVuY3Rpb24gKG5ld0luZGV4LCBvbGRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5oYXNWYWx1ZShuZXdJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwobmV3SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF5b3V0ID0gZ2V0UmVjdEl0ZW1MYXlvdXQoZGF0YSwgbmV3SW5kZXgsIGl0ZW1Nb2RlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCB7c2hhcGU6IGxheW91dH0sIGFuaW1hdGlvbk1vZGVsLCBuZXdJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGNyZWF0ZVJlY3QoZGF0YSwgbmV3SW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBpc0hvcml6b250YWwsIGFuaW1hdGlvbk1vZGVsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJbmRleCwgZWwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYmFja1xuICAgICAgICAgICAgICAgICAgICBncm91cC5hZGQoZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0eWxlKGVsLCBkYXRhLCBuZXdJbmRleCwgaXRlbU1vZGVsLCBsYXlvdXQsIHNlcmllc01vZGVsLCBpc0hvcml6b250YWwpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlbW92ZShmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBlbCAmJiByZW1vdmVSZWN0KGRhdGFJbmRleCwgYW5pbWF0aW9uTW9kZWwsIGVsKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5leGVjdXRlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgICAgIGlmIChlY01vZGVsLmdldCgnYW5pbWF0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUmVjdChlbC5kYXRhSW5kZXgsIGVjTW9kZWwsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3QoZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgaXNIb3Jpem9udGFsLCBhbmltYXRpb25Nb2RlbCwgaXNVcGRhdGUpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtzaGFwZTogenJVdGlsLmV4dGVuZCh7fSwgbGF5b3V0KX0pO1xuXG4gICAgICAgIC8vIEFuaW1hdGlvblxuICAgICAgICBpZiAoYW5pbWF0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciByZWN0U2hhcGUgPSByZWN0LnNoYXBlO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGVQcm9wZXJ0eSA9IGlzSG9yaXpvbnRhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgICAgIHZhciBhbmltYXRlVGFyZ2V0ID0ge307XG4gICAgICAgICAgICByZWN0U2hhcGVbYW5pbWF0ZVByb3BlcnR5XSA9IDA7XG4gICAgICAgICAgICBhbmltYXRlVGFyZ2V0W2FuaW1hdGVQcm9wZXJ0eV0gPSBsYXlvdXRbYW5pbWF0ZVByb3BlcnR5XTtcbiAgICAgICAgICAgIGdyYXBoaWNbaXNVcGRhdGUgPyAndXBkYXRlUHJvcHMnIDogJ2luaXRQcm9wcyddKHJlY3QsIHtcbiAgICAgICAgICAgICAgICBzaGFwZTogYW5pbWF0ZVRhcmdldFxuICAgICAgICAgICAgfSwgYW5pbWF0aW9uTW9kZWwsIGRhdGFJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVSZWN0KGRhdGFJbmRleCwgYW5pbWF0aW9uTW9kZWwsIGVsKSB7XG4gICAgICAgIC8vIE5vdCBzaG93IHRleHQgd2hlbiBhbmltYXRpbmdcbiAgICAgICAgZWwuc3R5bGUudGV4dCA9ICcnO1xuICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCB7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGFuaW1hdGlvbk1vZGVsLCBkYXRhSW5kZXgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsLnBhcmVudCAmJiBlbC5wYXJlbnQucmVtb3ZlKGVsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmVjdEl0ZW1MYXlvdXQoZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwpIHtcbiAgICAgICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChkYXRhSW5kZXgpO1xuICAgICAgICB2YXIgZml4ZWRMaW5lV2lkdGggPSBnZXRMaW5lV2lkdGgoaXRlbU1vZGVsLCBsYXlvdXQpO1xuXG4gICAgICAgIC8vIGZpeCBsYXlvdXQgd2l0aCBsaW5lV2lkdGhcbiAgICAgICAgdmFyIHNpZ25YID0gbGF5b3V0LndpZHRoID4gMCA/IDEgOiAtMTtcbiAgICAgICAgdmFyIHNpZ25ZID0gbGF5b3V0LmhlaWdodCA+IDAgPyAxIDogLTE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBsYXlvdXQueCArIHNpZ25YICogZml4ZWRMaW5lV2lkdGggLyAyLFxuICAgICAgICAgICAgeTogbGF5b3V0LnkgKyBzaWduWSAqIGZpeGVkTGluZVdpZHRoIC8gMixcbiAgICAgICAgICAgIHdpZHRoOiBsYXlvdXQud2lkdGggLSBzaWduWCAqIGZpeGVkTGluZVdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBsYXlvdXQuaGVpZ2h0IC0gc2lnblkgKiBmaXhlZExpbmVXaWR0aFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKGVsLCBkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBzZXJpZXNNb2RlbCwgaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdjb2xvcicpO1xuICAgICAgICB2YXIgb3BhY2l0eSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdvcGFjaXR5Jyk7XG4gICAgICAgIHZhciBpdGVtU3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlLm5vcm1hbCcpO1xuICAgICAgICB2YXIgaG92ZXJTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlLmVtcGhhc2lzJykuZ2V0QmFySXRlbVN0eWxlKCk7XG5cbiAgICAgICAgZWwuc2V0U2hhcGUoJ3InLCBpdGVtU3R5bGVNb2RlbC5nZXQoJ2JhckJvcmRlclJhZGl1cycpIHx8IDApO1xuXG4gICAgICAgIGVsLnVzZVN0eWxlKHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXRlbVN0eWxlTW9kZWwuZ2V0QmFySXRlbVN0eWxlKClcbiAgICAgICAgKSk7XG5cbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb25PdXRzaWRlID0gaXNIb3Jpem9udGFsXG4gICAgICAgICAgICA/IChsYXlvdXQuaGVpZ2h0ID4gMCA/ICdib3R0b20nIDogJ3RvcCcpXG4gICAgICAgICAgICA6IChsYXlvdXQud2lkdGggPiAwID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7XG5cbiAgICAgICAgaGVscGVyLnNldExhYmVsKFxuICAgICAgICAgICAgZWwuc3R5bGUsIGhvdmVyU3R5bGUsIGl0ZW1Nb2RlbCwgY29sb3IsXG4gICAgICAgICAgICBzZXJpZXNNb2RlbCwgZGF0YUluZGV4LCBsYWJlbFBvc2l0aW9uT3V0c2lkZVxuICAgICAgICApO1xuXG4gICAgICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZShlbCwgaG92ZXJTdHlsZSk7XG4gICAgfVxuXG4gICAgLy8gSW4gY2FzZSB3aWR0aCBvciBoZWlnaHQgYXJlIHRvbyBzbWFsbC5cbiAgICBmdW5jdGlvbiBnZXRMaW5lV2lkdGgoaXRlbU1vZGVsLCByYXdMYXlvdXQpIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGl0ZW1Nb2RlbC5nZXQoQkFSX0JPUkRFUl9XSURUSF9RVUVSWSkgfHwgMDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKGxpbmVXaWR0aCwgTWF0aC5hYnMocmF3TGF5b3V0LndpZHRoKSwgTWF0aC5hYnMocmF3TGF5b3V0LmhlaWdodCkpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gQmFyVmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIFNlcmllc01vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvU2VyaWVzJyk7XG4gICAgdmFyIGNyZWF0ZUxpc3RGcm9tQXJyYXkgPSByZXF1aXJlKCcuLi9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTZXJpZXNNb2RlbC5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdzZXJpZXMuX19iYXNlX2Jhcl9fJyxcblxuICAgICAgICBnZXRJbml0aWFsRGF0YTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBvcHRpb24uY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgICAgICBpZiAoY29vcmRTeXMgIT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXIgb25seSBzdXBwb3J0IGNhcnRlc2lhbjJkIGNvb3JkaW5hdGVTeXN0ZW0nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTGlzdEZyb21BcnJheShvcHRpb24uZGF0YSwgdGhpcywgZWNNb2RlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TWFya2VyUG9zaXRpb246IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gdGhpcy5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgaWYgKGNvb3JkU3lzKSB7XG4gICAgICAgICAgICAgICAgLy8gUEVORElORyBpZiBjbGFtcCA/XG4gICAgICAgICAgICAgICAgdmFyIHB0ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQodmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGRhdGEuZ2V0TGF5b3V0KCdvZmZzZXQnKTtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGRhdGEuZ2V0TGF5b3V0KCdzaXplJyk7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldEluZGV4ID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKS5pc0hvcml6b250YWwoKSA/IDAgOiAxO1xuICAgICAgICAgICAgICAgIHB0W29mZnNldEluZGV4XSArPSBvZmZzZXQgKyBzaXplIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW05hTiwgTmFOXTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICB6bGV2ZWw6IDAsICAgICAgICAgICAgICAgICAgLy8g5LiA57qn5bGC5Y+gXG4gICAgICAgICAgICB6OiAyLCAgICAgICAgICAgICAgICAgICAgICAgLy8g5LqM57qn5bGC5Y+gXG4gICAgICAgICAgICBjb29yZGluYXRlU3lzdGVtOiAnY2FydGVzaWFuMmQnLFxuICAgICAgICAgICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgICAgICAgICAgLy8gc3RhY2s6IG51bGxcblxuICAgICAgICAgICAgLy8gQ2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICAgICAgICAvLyB4QXhpc0luZGV4OiAwLFxuICAgICAgICAgICAgLy8geUF4aXNJbmRleDogMCxcblxuICAgICAgICAgICAgLy8g5pyA5bCP6auY5bqm5pS55Li6MFxuICAgICAgICAgICAgYmFyTWluSGVpZ2h0OiAwLFxuXG4gICAgICAgICAgICAvLyBiYXJNYXhXaWR0aDogbnVsbCxcbiAgICAgICAgICAgIC8vIOm7mOiupOiHqumAguW6lFxuICAgICAgICAgICAgLy8gYmFyV2lkdGg6IG51bGwsXG4gICAgICAgICAgICAvLyDmn7Hpl7Tot53nprvvvIzpu5jorqTkuLrmn7HlvaLlrr3luqbnmoQzMCXvvIzlj6/orr7lm7rlrprlgLxcbiAgICAgICAgICAgIC8vIGJhckdhcDogJzMwJScsXG4gICAgICAgICAgICAvLyDnsbvnm67pl7Tmn7HlvaLot53nprvvvIzpu5jorqTkuLrnsbvnm67pl7Tot53nmoQyMCXvvIzlj6/orr7lm7rlrprlgLxcbiAgICAgICAgICAgIC8vIGJhckNhdGVnb3J5R2FwOiAnMjAlJyxcbiAgICAgICAgICAgIC8vIGxhYmVsOiB7XG4gICAgICAgICAgICAvLyAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAvLyAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfSxcbiAgICAgICAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2xvcjogJ+WQhOW8gidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVtcGhhc2lzOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4iLCJcblxuXG4gICAgdmFyIGdldEJhckl0ZW1TdHlsZSA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL21peGluL21ha2VTdHlsZU1hcHBlcicpKFxuICAgICAgICBbXG4gICAgICAgICAgICBbJ2ZpbGwnLCAnY29sb3InXSxcbiAgICAgICAgICAgIFsnc3Ryb2tlJywgJ2JvcmRlckNvbG9yJ10sXG4gICAgICAgICAgICBbJ2xpbmVXaWR0aCcsICdib3JkZXJXaWR0aCddLFxuICAgICAgICAgICAgLy8gQ29tcGF0aXRhYmxlIHdpdGggMlxuICAgICAgICAgICAgWydzdHJva2UnLCAnYmFyQm9yZGVyQ29sb3InXSxcbiAgICAgICAgICAgIFsnbGluZVdpZHRoJywgJ2JhckJvcmRlcldpZHRoJ10sXG4gICAgICAgICAgICBbJ29wYWNpdHknXSxcbiAgICAgICAgICAgIFsnc2hhZG93Qmx1ciddLFxuICAgICAgICAgICAgWydzaGFkb3dPZmZzZXRYJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd09mZnNldFknXSxcbiAgICAgICAgICAgIFsnc2hhZG93Q29sb3InXVxuICAgICAgICBdXG4gICAgKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZ2V0QmFySXRlbVN0eWxlOiBmdW5jdGlvbiAoZXhjbHVkZXMpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldEJhckl0ZW1TdHlsZS5jYWxsKHRoaXMsIGV4Y2x1ZGVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEJvcmRlckxpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5nZXRCb3JkZXJMaW5lRGFzaCgpO1xuICAgICAgICAgICAgICAgIGxpbmVEYXNoICYmIChzdHlsZS5saW5lRGFzaCA9IGxpbmVEYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfVxuICAgIH07XG4iLCJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuXG4gICAgdmFyIGhlbHBlciA9IHt9O1xuXG4gICAgaGVscGVyLnNldExhYmVsID0gZnVuY3Rpb24gKFxuICAgICAgICBub3JtYWxTdHlsZSwgaG92ZXJTdHlsZSwgaXRlbU1vZGVsLCBjb2xvciwgc2VyaWVzTW9kZWwsIGRhdGFJbmRleCwgbGFiZWxQb3NpdGlvbk91dHNpZGVcbiAgICApIHtcbiAgICAgICAgdmFyIGxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLm5vcm1hbCcpO1xuICAgICAgICB2YXIgaG92ZXJMYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5lbXBoYXNpcycpO1xuXG4gICAgICAgIGlmIChsYWJlbE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICBzZXRMYWJlbChcbiAgICAgICAgICAgICAgICBub3JtYWxTdHlsZSwgbGFiZWxNb2RlbCwgY29sb3IsXG4gICAgICAgICAgICAgICAgenJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChkYXRhSW5kZXgsICdub3JtYWwnKSxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0UmF3VmFsdWUoZGF0YUluZGV4KVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbk91dHNpZGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxTdHlsZS50ZXh0ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaG92ZXJMYWJlbE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICBzZXRMYWJlbChcbiAgICAgICAgICAgICAgICBob3ZlclN0eWxlLCBob3ZlckxhYmVsTW9kZWwsIGNvbG9yLFxuICAgICAgICAgICAgICAgIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWwoZGF0YUluZGV4LCAnZW1waGFzaXMnKSxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0UmF3VmFsdWUoZGF0YUluZGV4KVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbk91dHNpZGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBob3ZlclN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRMYWJlbChzdHlsZSwgbW9kZWwsIGNvbG9yLCBsYWJlbFRleHQsIGxhYmVsUG9zaXRpb25PdXRzaWRlKSB7XG4gICAgICAgIGdyYXBoaWMuc2V0VGV4dChzdHlsZSwgbW9kZWwsIGNvbG9yKTtcbiAgICAgICAgc3R5bGUudGV4dCA9IGxhYmVsVGV4dDtcbiAgICAgICAgaWYgKHN0eWxlLnRleHRQb3NpdGlvbiA9PT0gJ291dHNpZGUnKSB7XG4gICAgICAgICAgICBzdHlsZS50ZXh0UG9zaXRpb24gPSBsYWJlbFBvc2l0aW9uT3V0c2lkZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuIiwiXG4gICAgcmVxdWlyZSgnLi9nYXVnZS9HYXVnZVNlcmllcycpO1xuICAgIHJlcXVpcmUoJy4vZ2F1Z2UvR2F1Z2VWaWV3Jyk7XG4iLCJcblxuICAgIHZhciBMaXN0ID0gcmVxdWlyZSgnLi4vLi4vZGF0YS9MaXN0Jyk7XG4gICAgdmFyIFNlcmllc01vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvU2VyaWVzJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIEdhdWdlU2VyaWVzID0gU2VyaWVzTW9kZWwuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnc2VyaWVzLmdhdWdlJyxcblxuICAgICAgICBnZXRJbml0aWFsRGF0YTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBuZXcgTGlzdChbJ3ZhbHVlJ10sIHRoaXMpO1xuICAgICAgICAgICAgdmFyIGRhdGFPcHQgPSBvcHRpb24uZGF0YSB8fCBbXTtcbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoZGF0YU9wdCkpIHtcbiAgICAgICAgICAgICAgICBkYXRhT3B0ID0gW2RhdGFPcHRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSB1c2UgdGhlIGZpcnN0IGRhdGEgaXRlbVxuICAgICAgICAgICAgbGlzdC5pbml0RGF0YShkYXRhT3B0KTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIHpsZXZlbDogMCxcbiAgICAgICAgICAgIHo6IDIsXG4gICAgICAgICAgICAvLyDpu5jorqTlhajlsYDlsYXkuK1cbiAgICAgICAgICAgIGNlbnRlcjogWyc1MCUnLCAnNTAlJ10sXG4gICAgICAgICAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG4gICAgICAgICAgICByYWRpdXM6ICc3NSUnLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogMjI1LFxuICAgICAgICAgICAgZW5kQW5nbGU6IC00NSxcbiAgICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIOacgOWwj+WAvFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgLy8g5pyA5aSn5YC8XG4gICAgICAgICAgICBtYXg6IDEwMCxcbiAgICAgICAgICAgIC8vIOWIhuWJsuauteaVsO+8jOm7mOiupOS4ujEwXG4gICAgICAgICAgICBzcGxpdE51bWJlcjogMTAsXG4gICAgICAgICAgICAvLyDlnZDmoIfovbTnur9cbiAgICAgICAgICAgIGF4aXNMaW5lOiB7XG4gICAgICAgICAgICAgICAgLy8g6buY6K6k5pi+56S677yM5bGe5oCnc2hvd+aOp+WItuaYvuekuuS4juWQplxuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgbGluZVN0eWxlOiB7ICAgICAgIC8vIOWxnuaAp2xpbmVTdHlsZeaOp+WItue6v+adoeagt+W8j1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogW1swLjIsICcjOTFjN2FlJ10sIFswLjgsICcjNjM4NjllJ10sIFsxLCAnI2MyMzUzMSddXSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDMwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIOWIhumalOe6v1xuICAgICAgICAgICAgc3BsaXRMaW5lOiB7XG4gICAgICAgICAgICAgICAgLy8g6buY6K6k5pi+56S677yM5bGe5oCnc2hvd+aOp+WItuaYvuekuuS4juWQplxuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgLy8g5bGe5oCnbGVuZ3Ro5o6n5Yi257q/6ZW/XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiAzMCxcbiAgICAgICAgICAgICAgICAvLyDlsZ7mgKdsaW5lU3R5bGXvvIjor6bop4FsaW5lU3R5bGXvvInmjqfliLbnur/mnaHmoLflvI9cbiAgICAgICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjZWVlJyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8g5Z2Q5qCH6L205bCP5qCH6K6wXG4gICAgICAgICAgICBheGlzVGljazoge1xuICAgICAgICAgICAgICAgIC8vIOWxnuaAp3Nob3fmjqfliLbmmL7npLrkuI7lkKbvvIzpu5jorqTkuI3mmL7npLpcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIOavj+S7vXNwbGl057uG5YiG5aSa5bCR5q61XG4gICAgICAgICAgICAgICAgc3BsaXROdW1iZXI6IDUsXG4gICAgICAgICAgICAgICAgLy8g5bGe5oCnbGVuZ3Ro5o6n5Yi257q/6ZW/XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiA4LFxuICAgICAgICAgICAgICAgIC8vIOWxnuaAp2xpbmVTdHlsZeaOp+WItue6v+adoeagt+W8j1xuICAgICAgICAgICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNlZWUnLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBheGlzTGFiZWw6IHtcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlOiA1LFxuICAgICAgICAgICAgICAgIC8vIGZvcm1hdHRlcjogbnVsbCxcbiAgICAgICAgICAgICAgICB0ZXh0U3R5bGU6IHsgICAgICAgLy8g5YW25L2Z5bGe5oCn6buY6K6k5L2/55So5YWo5bGA5paH5pys5qC35byP77yM6K+m6KeBVEVYVFNUWUxFXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnYXV0bydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9pbnRlcjoge1xuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiAnODAlJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogOFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2F1dG8nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyB4LCB577yM5Y2V5L2NcHhcbiAgICAgICAgICAgICAgICBvZmZzZXRDZW50ZXI6IFswLCAnLTQwJSddLFxuICAgICAgICAgICAgICAgIC8vIOWFtuS9meWxnuaAp+m7mOiupOS9v+eUqOWFqOWxgOaWh+acrOagt+W8j++8jOivpuingVRFWFRTVFlMRVxuICAgICAgICAgICAgICAgIHRleHRTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyMzMzMnLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMTVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJyNjY2MnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA0MCxcbiAgICAgICAgICAgICAgICAvLyB4LCB577yM5Y2V5L2NcHhcbiAgICAgICAgICAgICAgICBvZmZzZXRDZW50ZXI6IFswLCAnNDAlJ10sXG4gICAgICAgICAgICAgICAgLy8gZm9ybWF0dGVyOiBudWxsLFxuICAgICAgICAgICAgICAgIC8vIOWFtuS9meWxnuaAp+m7mOiupOS9v+eUqOWFqOWxgOaWh+acrOagt+W8j++8jOivpuingVRFWFRTVFlMRVxuICAgICAgICAgICAgICAgIHRleHRTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2F1dG8nLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMzBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR2F1Z2VTZXJpZXM7XG4iLCJcblxuICAgIHZhciBQb2ludGVyUGF0aCA9IHJlcXVpcmUoJy4vUG9pbnRlclBhdGgnKTtcblxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpO1xuICAgIHZhciBwYXJzZVBlcmNlbnQgPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudDtcblxuICAgIGZ1bmN0aW9uIHBhcnNlUG9zaXRpb24oc2VyaWVzTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgY2VudGVyID0gc2VyaWVzTW9kZWwuZ2V0KCdjZW50ZXInKTtcbiAgICAgICAgdmFyIHdpZHRoID0gYXBpLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBhcGkuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIHZhciBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHZhciBjeCA9IHBhcnNlUGVyY2VudChjZW50ZXJbMF0sIGFwaS5nZXRXaWR0aCgpKTtcbiAgICAgICAgdmFyIGN5ID0gcGFyc2VQZXJjZW50KGNlbnRlclsxXSwgYXBpLmdldEhlaWdodCgpKTtcbiAgICAgICAgdmFyIHIgPSBwYXJzZVBlcmNlbnQoc2VyaWVzTW9kZWwuZ2V0KCdyYWRpdXMnKSwgc2l6ZSAvIDIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICByOiByXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0TGFiZWwobGFiZWwsIGxhYmVsRm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChsYWJlbEZvcm1hdHRlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYWJlbEZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsRm9ybWF0dGVyLnJlcGxhY2UoJ3t2YWx1ZX0nLCBsYWJlbCAhPSBudWxsID8gbGFiZWwgOiAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbGFiZWxGb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsRm9ybWF0dGVyKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9XG5cbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG5cbiAgICB2YXIgR2F1Z2VWaWV3ID0gcmVxdWlyZSgnLi4vLi4vdmlldy9DaGFydCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2dhdWdlJyxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgICAgIHZhciBjb2xvckxpc3QgPSBzZXJpZXNNb2RlbC5nZXQoJ2F4aXNMaW5lLmxpbmVTdHlsZS5jb2xvcicpO1xuICAgICAgICAgICAgdmFyIHBvc0luZm8gPSBwYXJzZVBvc2l0aW9uKHNlcmllc01vZGVsLCBhcGkpO1xuXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJNYWluKFxuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIGNvbG9yTGlzdCwgcG9zSW5mb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgICAgICBfcmVuZGVyTWFpbjogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIGNvbG9yTGlzdCwgcG9zSW5mbykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcblxuICAgICAgICAgICAgdmFyIGF4aXNMaW5lTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnYXhpc0xpbmUnKTtcbiAgICAgICAgICAgIHZhciBsaW5lU3R5bGVNb2RlbCA9IGF4aXNMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuXG4gICAgICAgICAgICB2YXIgY2xvY2t3aXNlID0gc2VyaWVzTW9kZWwuZ2V0KCdjbG9ja3dpc2UnKTtcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gLXNlcmllc01vZGVsLmdldCgnc3RhcnRBbmdsZScpIC8gMTgwICogTWF0aC5QSTtcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IC1zZXJpZXNNb2RlbC5nZXQoJ2VuZEFuZ2xlJykgLyAxODAgKiBNYXRoLlBJO1xuXG4gICAgICAgICAgICB2YXIgYW5nbGVSYW5nZVNwYW4gPSAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAlIFBJMjtcblxuICAgICAgICAgICAgdmFyIHByZXZFbmRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICB2YXIgYXhpc0xpbmVXaWR0aCA9IGxpbmVTdHlsZU1vZGVsLmdldCgnd2lkdGgnKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBDbGFtcFxuICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gTWF0aC5taW4oTWF0aC5tYXgoY29sb3JMaXN0W2ldWzBdLCAwKSwgMSk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGFuZ2xlUmFuZ2VTcGFuICogcGVyY2VudDtcbiAgICAgICAgICAgICAgICB2YXIgc2VjdG9yID0gbmV3IGdyYXBoaWMuU2VjdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IHByZXZFbmRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4OiBwb3NJbmZvLmN4LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHBvc0luZm8uY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9ja3dpc2U6IGNsb2Nrd2lzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIwOiBwb3NJbmZvLnIgLSBheGlzTGluZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcjogcG9zSW5mby5yXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc2VjdG9yLnNldFN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogY29sb3JMaXN0W2ldWzFdXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzZWN0b3Iuc2V0U3R5bGUobGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKFxuICAgICAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHdlIHVzZSBzZWN0b3IgdG8gc2ltdWxhdGUgYXJjXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHRoZSBwcm9wZXJ0aWVzIGZvciBzdHJva2luZyBhcmUgdXNlbGVzc1xuICAgICAgICAgICAgICAgICAgICBbJ2NvbG9yJywgJ2JvcmRlcldpZHRoJywgJ2JvcmRlckNvbG9yJ11cbiAgICAgICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgICAgIGdyb3VwLmFkZChzZWN0b3IpO1xuXG4gICAgICAgICAgICAgICAgcHJldkVuZEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBnZXRDb2xvciA9IGZ1bmN0aW9uIChwZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gTGVzcyB0aGFuIDBcbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvckxpc3RbMF1bMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvckxpc3RbaV1bMF0gPj0gcGVyY2VudFxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGkgPT09IDAgPyAwIDogY29sb3JMaXN0W2kgLSAxXVswXSkgPCBwZXJjZW50XG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yTGlzdFtpXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBNb3JlIHRoYW4gMVxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvckxpc3RbaSAtIDFdWzFdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFjbG9ja3dpc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRpY2tzKFxuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIGdldENvbG9yLCBwb3NJbmZvLFxuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2VcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclBvaW50ZXIoXG4gICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgZ2V0Q29sb3IsIHBvc0luZm8sXG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGl0bGUoXG4gICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgZ2V0Q29sb3IsIHBvc0luZm9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJEZXRhaWwoXG4gICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgZ2V0Q29sb3IsIHBvc0luZm9cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlbmRlclRpY2tzOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBnZXRDb2xvciwgcG9zSW5mbyxcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICAgICAgdmFyIGN4ID0gcG9zSW5mby5jeDtcbiAgICAgICAgICAgIHZhciBjeSA9IHBvc0luZm8uY3k7XG4gICAgICAgICAgICB2YXIgciA9IHBvc0luZm8ucjtcblxuICAgICAgICAgICAgdmFyIG1pblZhbCA9ICtzZXJpZXNNb2RlbC5nZXQoJ21pbicpO1xuICAgICAgICAgICAgdmFyIG1heFZhbCA9ICtzZXJpZXNNb2RlbC5nZXQoJ21heCcpO1xuXG4gICAgICAgICAgICB2YXIgc3BsaXRMaW5lTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRMaW5lJyk7XG4gICAgICAgICAgICB2YXIgdGlja01vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNUaWNrJyk7XG4gICAgICAgICAgICB2YXIgbGFiZWxNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKTtcblxuICAgICAgICAgICAgdmFyIHNwbGl0TnVtYmVyID0gc2VyaWVzTW9kZWwuZ2V0KCdzcGxpdE51bWJlcicpO1xuICAgICAgICAgICAgdmFyIHN1YlNwbGl0TnVtYmVyID0gdGlja01vZGVsLmdldCgnc3BsaXROdW1iZXInKTtcblxuICAgICAgICAgICAgdmFyIHNwbGl0TGluZUxlbiA9IHBhcnNlUGVyY2VudChcbiAgICAgICAgICAgICAgICBzcGxpdExpbmVNb2RlbC5nZXQoJ2xlbmd0aCcpLCByXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIHRpY2tMZW4gPSBwYXJzZVBlcmNlbnQoXG4gICAgICAgICAgICAgICAgdGlja01vZGVsLmdldCgnbGVuZ3RoJyksIHJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBhbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpIC8gc3BsaXROdW1iZXI7XG4gICAgICAgICAgICB2YXIgc3ViU3RlcCA9IHN0ZXAgLyBzdWJTcGxpdE51bWJlcjtcblxuICAgICAgICAgICAgdmFyIHNwbGl0TGluZVN0eWxlID0gc3BsaXRMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpO1xuICAgICAgICAgICAgdmFyIHRpY2tMaW5lU3R5bGUgPSB0aWNrTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpO1xuICAgICAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHNwbGl0TnVtYmVyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdW5pdFggPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgICAgICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGxpbmVcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRMaW5lTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0TGluZSA9IG5ldyBncmFwaGljLkxpbmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MTogdW5pdFggKiByICsgY3gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTE6IHVuaXRZICogciArIGN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyOiB1bml0WCAqIChyIC0gc3BsaXRMaW5lTGVuKSArIGN4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyOiB1bml0WSAqIChyIC0gc3BsaXRMaW5lTGVuKSArIGN5XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHNwbGl0TGluZVN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXRMaW5lU3R5bGUuc3Ryb2tlID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0TGluZS5zZXRTdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBnZXRDb2xvcihpIC8gc3BsaXROdW1iZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFkZChzcGxpdExpbmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExhYmVsXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gZm9ybWF0TGFiZWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJVdGlsLnJvdW5kKGkgLyBzcGxpdE51bWJlciAqIChtYXhWYWwgLSBtaW5WYWwpICsgbWluVmFsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsTW9kZWwuZ2V0KCdmb3JtYXR0ZXInKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBsYWJlbE1vZGVsLmdldCgnZGlzdGFuY2UnKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB1bml0WCAqIChyIC0gc3BsaXRMaW5lTGVuIC0gZGlzdGFuY2UpICsgY3gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdW5pdFkgKiAociAtIHNwbGl0TGluZUxlbiAtIGRpc3RhbmNlKSArIGN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRGb250OiB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IHVuaXRZIDwgLTAuNCA/ICd0b3AnIDogKHVuaXRZID4gMC40ID8gJ2JvdHRvbScgOiAnbWlkZGxlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB1bml0WCA8IC0wLjQgPyAnbGVmdCcgOiAodW5pdFggPiAwLjQgPyAncmlnaHQnIDogJ2NlbnRlcicpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dC5zdHlsZS5maWxsID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuc2V0U3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGdldENvbG9yKGkgLyBzcGxpdE51bWJlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHRleHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEF4aXMgdGlja1xuICAgICAgICAgICAgICAgIGlmICh0aWNrTW9kZWwuZ2V0KCdzaG93JykgJiYgaSAhPT0gc3BsaXROdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPD0gc3ViU3BsaXROdW1iZXI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuaXRYID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpY2tMaW5lID0gbmV3IGdyYXBoaWMuTGluZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDE6IHVuaXRYICogciArIGN4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MTogdW5pdFkgKiByICsgY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyOiB1bml0WCAqIChyIC0gdGlja0xlbikgKyBjeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTI6IHVuaXRZICogKHIgLSB0aWNrTGVuKSArIGN5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHRpY2tMaW5lU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGlja0xpbmVTdHlsZS5zdHJva2UgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tMaW5lLnNldFN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBnZXRDb2xvcigoaSArIGogLyBzdWJTcGxpdE51bWJlcikgLyBzcGxpdE51bWJlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHRpY2tMaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlICs9IHN1YlN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYW5nbGUgLT0gc3ViU3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlICs9IHN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9yZW5kZXJQb2ludGVyOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBnZXRDb2xvciwgcG9zSW5mbyxcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2VcbiAgICAgICAgKSB7XG5cbiAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgICAgICAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgICAgIGlmICghc2VyaWVzTW9kZWwuZ2V0KCdwb2ludGVyLnNob3cnKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQgZWxlbWVudFxuICAgICAgICAgICAgICAgIG9sZERhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsdWVFeHRlbnQgPSBbK3Nlcmllc01vZGVsLmdldCgnbWluJyksICtzZXJpZXNNb2RlbC5nZXQoJ21heCcpXTtcbiAgICAgICAgICAgIHZhciBhbmdsZUV4dGVudCA9IFtzdGFydEFuZ2xlLCBlbmRBbmdsZV07XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgICAgICAgICBkYXRhLmRpZmYob2xkRGF0YSlcbiAgICAgICAgICAgICAgICAuYWRkKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ZXIgPSBuZXcgUG9pbnRlclBhdGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmdsZTogc3RhcnRBbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvaW50ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGU6IG51bWJlclV0aWwubGluZWFyTWFwKGRhdGEuZ2V0KCd2YWx1ZScsIGlkeCksIHZhbHVlRXh0ZW50LCBhbmdsZUV4dGVudCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFkZChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgcG9pbnRlcik7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRlciA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocG9pbnRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmdsZTogbnVtYmVyVXRpbC5saW5lYXJNYXAoZGF0YS5nZXQoJ3ZhbHVlJywgbmV3SWR4KSwgdmFsdWVFeHRlbnQsIGFuZ2xlRXh0ZW50LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBwb2ludGVyKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRlciA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpO1xuICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZXhlY3V0ZSgpO1xuXG4gICAgICAgICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChwb2ludGVyLCBpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRlck1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdwb2ludGVyJyk7XG5cbiAgICAgICAgICAgICAgICBwb2ludGVyLnNldFNoYXBlKHtcbiAgICAgICAgICAgICAgICAgICAgeDogcG9zSW5mby5jeCxcbiAgICAgICAgICAgICAgICAgICAgeTogcG9zSW5mby5jeSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHBhcnNlUGVyY2VudChcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJNb2RlbC5nZXQoJ3dpZHRoJyksIHBvc0luZm8uclxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICByOiBwYXJzZVBlcmNlbnQocG9pbnRlck1vZGVsLmdldCgnbGVuZ3RoJyksIHBvc0luZm8ucilcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHBvaW50ZXIudXNlU3R5bGUoaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUubm9ybWFsJykuZ2V0SXRlbVN0eWxlKCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvaW50ZXIuc3R5bGUuZmlsbCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuc2V0U3R5bGUoJ2ZpbGwnLCBnZXRDb2xvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIChkYXRhLmdldCgndmFsdWUnLCBpZHgpIC0gdmFsdWVFeHRlbnRbMF0pIC8gKHZhbHVlRXh0ZW50WzFdIC0gdmFsdWVFeHRlbnRbMF0pXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZShcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlciwgaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUuZW1waGFzaXMnKS5nZXRJdGVtU3R5bGUoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlbmRlclRpdGxlOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBnZXRDb2xvciwgcG9zSW5mb1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB0aXRsZU1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ3RpdGxlJyk7XG4gICAgICAgICAgICBpZiAodGl0bGVNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IHRpdGxlTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRDZW50ZXIgPSB0aXRsZU1vZGVsLmdldCgnb2Zmc2V0Q2VudGVyJyk7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBwb3NJbmZvLmN4ICsgcGFyc2VQZXJjZW50KG9mZnNldENlbnRlclswXSwgcG9zSW5mby5yKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHBvc0luZm8uY3kgKyBwYXJzZVBlcmNlbnQob2Zmc2V0Q2VudGVyWzFdLCBwb3NJbmZvLnIpO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIEZpcnN0IGRhdGEgbmFtZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzZXJpZXNNb2RlbC5nZXREYXRhKCkuZ2V0TmFtZSgwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEZvbnQ6IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9yZW5kZXJEZXRhaWw6IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIGdldENvbG9yLCBwb3NJbmZvXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGRldGFpbE1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2RldGFpbCcpO1xuICAgICAgICAgICAgdmFyIG1pblZhbCA9ICtzZXJpZXNNb2RlbC5nZXQoJ21pbicpO1xuICAgICAgICAgICAgdmFyIG1heFZhbCA9ICtzZXJpZXNNb2RlbC5nZXQoJ21heCcpO1xuICAgICAgICAgICAgaWYgKGRldGFpbE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gZGV0YWlsTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRDZW50ZXIgPSBkZXRhaWxNb2RlbC5nZXQoJ29mZnNldENlbnRlcicpO1xuICAgICAgICAgICAgICAgIHZhciB4ID0gcG9zSW5mby5jeCArIHBhcnNlUGVyY2VudChvZmZzZXRDZW50ZXJbMF0sIHBvc0luZm8ucik7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBwb3NJbmZvLmN5ICsgcGFyc2VQZXJjZW50KG9mZnNldENlbnRlclsxXSwgcG9zSW5mby5yKTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBwYXJzZVBlcmNlbnQoZGV0YWlsTW9kZWwuZ2V0KCd3aWR0aCcpLCBwb3NJbmZvLnIpO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwYXJzZVBlcmNlbnQoZGV0YWlsTW9kZWwuZ2V0KCdoZWlnaHQnKSwgcG9zSW5mby5yKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCkuZ2V0KCd2YWx1ZScsIDApO1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4IC0gd2lkdGggLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSAtIGhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZm9ybWF0TGFiZWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgRmlyc3QgZGF0YSBuYW1lID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSwgZGV0YWlsTW9kZWwuZ2V0KCdmb3JtYXR0ZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGRldGFpbE1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5zdHlsZS50ZXh0RmlsbCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Quc2V0U3R5bGUoJ3RleHRGaWxsJywgZ2V0Q29sb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJVdGlsLmxpbmVhck1hcCh2YWx1ZSwgW21pblZhbCwgbWF4VmFsXSwgWzAsIDFdLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjdC5zZXRTdHlsZShkZXRhaWxNb2RlbC5nZXRJdGVtU3R5bGUoWydjb2xvciddKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQocmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR2F1Z2VWaWV3O1xuIiwiXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2VjaGFydHNHYXVnZVBvaW50ZXInLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBhbmdsZTogMCxcblxuICAgICAgICAgICAgd2lkdGg6IDEwLFxuXG4gICAgICAgICAgICByOiAxMCxcblxuICAgICAgICAgICAgeDogMCxcblxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG4gICAgICAgICAgICB2YXIgbWF0aFNpbiA9IE1hdGguc2luO1xuXG4gICAgICAgICAgICB2YXIgciA9IHNoYXBlLnI7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IHNoYXBlLmFuZ2xlO1xuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54IC0gbWF0aENvcyhhbmdsZSkgKiB3aWR0aCAqICh3aWR0aCA+PSByIC8gMyA/IDEgOiAyKTtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueSAtIG1hdGhTaW4oYW5nbGUpICogd2lkdGggKiAod2lkdGggPj0gciAvIDMgPyAxIDogMik7XG5cbiAgICAgICAgICAgIGFuZ2xlID0gc2hhcGUuYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKFxuICAgICAgICAgICAgICAgIHNoYXBlLnggKyBtYXRoQ29zKGFuZ2xlKSAqIHdpZHRoLFxuICAgICAgICAgICAgICAgIHNoYXBlLnkgKyBtYXRoU2luKGFuZ2xlKSAqIHdpZHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgICAgICAgICBzaGFwZS54ICsgbWF0aENvcyhzaGFwZS5hbmdsZSkgKiByLFxuICAgICAgICAgICAgICAgIHNoYXBlLnkgKyBtYXRoU2luKHNoYXBlLmFuZ2xlKSAqIHJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgubGluZVRvKFxuICAgICAgICAgICAgICAgIHNoYXBlLnggLSBtYXRoQ29zKGFuZ2xlKSAqIHdpZHRoLFxuICAgICAgICAgICAgICAgIHNoYXBlLnkgLSBtYXRoU2luKGFuZ2xlKSAqIHdpZHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xuIiwiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY2hhcnQvaGVscGVyL0xpbmVcbiAqL1xuXG5cbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvc3ltYm9sJyk7XG4gICAgdmFyIHZlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XG4gICAgLy8gdmFyIG1hdHJpeCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4Jyk7XG4gICAgdmFyIExpbmVQYXRoID0gcmVxdWlyZSgnLi9MaW5lUGF0aCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udW1iZXInKTtcblxuICAgIHZhciBTWU1CT0xfQ0FURUdPUklFUyA9IFsnZnJvbVN5bWJvbCcsICd0b1N5bWJvbCddO1xuICAgIGZ1bmN0aW9uIG1ha2VTeW1ib2xUeXBlS2V5KHN5bWJvbENhdGVnb3J5KSB7XG4gICAgICAgIHJldHVybiAnXycgKyBzeW1ib2xDYXRlZ29yeSArICdUeXBlJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlU3ltYm9sKG5hbWUsIGxpbmVEYXRhLCBpZHgpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuICAgICAgICB2YXIgc3ltYm9sVHlwZSA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCBuYW1lKTtcbiAgICAgICAgdmFyIHN5bWJvbFNpemUgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgbmFtZSArICdTaXplJyk7XG5cbiAgICAgICAgaWYgKCFzeW1ib2xUeXBlIHx8IHN5bWJvbFR5cGUgPT09ICdub25lJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShzeW1ib2xTaXplKSkge1xuICAgICAgICAgICAgc3ltYm9sU2l6ZSA9IFtzeW1ib2xTaXplLCBzeW1ib2xTaXplXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ltYm9sUGF0aCA9IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sKFxuICAgICAgICAgICAgc3ltYm9sVHlwZSwgLXN5bWJvbFNpemVbMF0gLyAyLCAtc3ltYm9sU2l6ZVsxXSAvIDIsXG4gICAgICAgICAgICBzeW1ib2xTaXplWzBdLCBzeW1ib2xTaXplWzFdLCBjb2xvclxuICAgICAgICApO1xuXG4gICAgICAgIHN5bWJvbFBhdGgubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgcmV0dXJuIHN5bWJvbFBhdGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTGluZShwb2ludHMpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBuZXcgTGluZVBhdGgoe1xuICAgICAgICAgICAgbmFtZTogJ2xpbmUnXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRMaW5lUG9pbnRzKGxpbmUuc2hhcGUsIHBvaW50cyk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldExpbmVQb2ludHModGFyZ2V0U2hhcGUsIHBvaW50cykge1xuICAgICAgICB2YXIgcDEgPSBwb2ludHNbMF07XG4gICAgICAgIHZhciBwMiA9IHBvaW50c1sxXTtcbiAgICAgICAgdmFyIGNwMSA9IHBvaW50c1syXTtcbiAgICAgICAgdGFyZ2V0U2hhcGUueDEgPSBwMVswXTtcbiAgICAgICAgdGFyZ2V0U2hhcGUueTEgPSBwMVsxXTtcbiAgICAgICAgdGFyZ2V0U2hhcGUueDIgPSBwMlswXTtcbiAgICAgICAgdGFyZ2V0U2hhcGUueTIgPSBwMlsxXTtcbiAgICAgICAgdGFyZ2V0U2hhcGUucGVyY2VudCA9IDE7XG5cbiAgICAgICAgaWYgKGNwMSkge1xuICAgICAgICAgICAgdGFyZ2V0U2hhcGUuY3B4MSA9IGNwMVswXTtcbiAgICAgICAgICAgIHRhcmdldFNoYXBlLmNweTEgPSBjcDFbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRTaGFwZS5jcHgxID0gTmFOO1xuICAgICAgICAgICAgdGFyZ2V0U2hhcGUuY3B5MSA9IE5hTjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN5bWJvbEFuZExhYmVsQmVmb3JlTGluZVVwZGF0ZSAoKSB7XG4gICAgICAgIHZhciBsaW5lR3JvdXAgPSB0aGlzO1xuICAgICAgICB2YXIgc3ltYm9sRnJvbSA9IGxpbmVHcm91cC5jaGlsZE9mTmFtZSgnZnJvbVN5bWJvbCcpO1xuICAgICAgICB2YXIgc3ltYm9sVG8gPSBsaW5lR3JvdXAuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XG4gICAgICAgIHZhciBsYWJlbCA9IGxpbmVHcm91cC5jaGlsZE9mTmFtZSgnbGFiZWwnKTtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIGlmICghc3ltYm9sRnJvbSAmJiAhc3ltYm9sVG8gJiYgbGFiZWwuaWdub3JlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW52U2NhbGUgPSAxO1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50O1xuICAgICAgICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUuc2NhbGUpIHtcbiAgICAgICAgICAgICAgICBpbnZTY2FsZSAvPSBwYXJlbnROb2RlLnNjYWxlWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lR3JvdXAuY2hpbGRPZk5hbWUoJ2xpbmUnKTtcbiAgICAgICAgLy8gSWYgbGluZSBub3QgY2hhbmdlZFxuICAgICAgICAvLyBGSVhNRSBQYXJlbnQgc2NhbGUgY2hhbmdlZFxuICAgICAgICBpZiAoIXRoaXMuX19kaXJ0eSAmJiAhbGluZS5fX2RpcnR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGVyY2VudCA9IGxpbmUuc2hhcGUucGVyY2VudDtcbiAgICAgICAgdmFyIGZyb21Qb3MgPSBsaW5lLnBvaW50QXQoMCk7XG4gICAgICAgIHZhciB0b1BvcyA9IGxpbmUucG9pbnRBdChwZXJjZW50KTtcblxuICAgICAgICB2YXIgZCA9IHZlY3Rvci5zdWIoW10sIHRvUG9zLCBmcm9tUG9zKTtcbiAgICAgICAgdmVjdG9yLm5vcm1hbGl6ZShkLCBkKTtcblxuICAgICAgICBpZiAoc3ltYm9sRnJvbSkge1xuICAgICAgICAgICAgc3ltYm9sRnJvbS5hdHRyKCdwb3NpdGlvbicsIGZyb21Qb3MpO1xuICAgICAgICAgICAgdmFyIHRhbmdlbnQgPSBsaW5lLnRhbmdlbnRBdCgwKTtcbiAgICAgICAgICAgIHN5bWJvbEZyb20uYXR0cigncm90YXRpb24nLCBNYXRoLlBJIC8gMiAtIE1hdGguYXRhbjIoXG4gICAgICAgICAgICAgICAgdGFuZ2VudFsxXSwgdGFuZ2VudFswXVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBzeW1ib2xGcm9tLmF0dHIoJ3NjYWxlJywgW2ludlNjYWxlICogcGVyY2VudCwgaW52U2NhbGUgKiBwZXJjZW50XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN5bWJvbFRvKSB7XG4gICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdwb3NpdGlvbicsIHRvUG9zKTtcbiAgICAgICAgICAgIHZhciB0YW5nZW50ID0gbGluZS50YW5nZW50QXQoMSk7XG4gICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdyb3RhdGlvbicsIC1NYXRoLlBJIC8gMiAtIE1hdGguYXRhbjIoXG4gICAgICAgICAgICAgICAgdGFuZ2VudFsxXSwgdGFuZ2VudFswXVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdzY2FsZScsIFtpbnZTY2FsZSAqIHBlcmNlbnQsIGludlNjYWxlICogcGVyY2VudF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsYWJlbC5pZ25vcmUpIHtcbiAgICAgICAgICAgIGxhYmVsLmF0dHIoJ3Bvc2l0aW9uJywgdG9Qb3MpO1xuXG4gICAgICAgICAgICB2YXIgdGV4dFBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHRleHRBbGlnbjtcbiAgICAgICAgICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbjtcblxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gNSAqIGludlNjYWxlO1xuICAgICAgICAgICAgLy8gRW5kXG4gICAgICAgICAgICBpZiAobGFiZWwuX19wb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb24gPSBbZFswXSAqIGRpc3RhbmNlICsgdG9Qb3NbMF0sIGRbMV0gKiBkaXN0YW5jZSArIHRvUG9zWzFdXTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBkWzBdID4gMC44ID8gJ2xlZnQnIDogKGRbMF0gPCAtMC44ID8gJ3JpZ2h0JyA6ICdjZW50ZXInKTtcbiAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IGRbMV0gPiAwLjggPyAndG9wJyA6IChkWzFdIDwgLTAuOCA/ICdib3R0b20nIDogJ21pZGRsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWlkZGxlXG4gICAgICAgICAgICBlbHNlIGlmIChsYWJlbC5fX3Bvc2l0aW9uID09PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgICAgIHZhciBoYWxmUGVyY2VudCA9IHBlcmNlbnQgLyAyO1xuICAgICAgICAgICAgICAgIHZhciB0YW5nZW50ID0gbGluZS50YW5nZW50QXQoaGFsZlBlcmNlbnQpO1xuICAgICAgICAgICAgICAgIHZhciBuID0gW3RhbmdlbnRbMV0sIC10YW5nZW50WzBdXTtcbiAgICAgICAgICAgICAgICB2YXIgY3AgPSBsaW5lLnBvaW50QXQoaGFsZlBlcmNlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChuWzFdID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBuWzBdID0gLW5bMF07XG4gICAgICAgICAgICAgICAgICAgIG5bMV0gPSAtblsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uID0gW2NwWzBdICsgblswXSAqIGRpc3RhbmNlLCBjcFsxXSArIG5bMV0gKiBkaXN0YW5jZV07XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSAtTWF0aC5hdGFuMih0YW5nZW50WzFdLCB0YW5nZW50WzBdKTtcbiAgICAgICAgICAgICAgICBpZiAodG9Qb3NbMF0gPCBmcm9tUG9zWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gTWF0aC5QSSArIHJvdGF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYWJlbC5hdHRyKCdyb3RhdGlvbicsIHJvdGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb24gPSBbLWRbMF0gKiBkaXN0YW5jZSArIGZyb21Qb3NbMF0sIC1kWzFdICogZGlzdGFuY2UgKyBmcm9tUG9zWzFdXTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBkWzBdID4gMC44ID8gJ3JpZ2h0JyA6IChkWzBdIDwgLTAuOCA/ICdsZWZ0JyA6ICdjZW50ZXInKTtcbiAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IGRbMV0gPiAwLjggPyAnYm90dG9tJyA6IChkWzFdIDwgLTAuOCA/ICd0b3AnIDogJ21pZGRsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFiZWwuYXR0cih7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSB1c2VyIHNwZWNpZmllZCB0ZXh0IGFsaWduIGFuZCBiYXNlbGluZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogbGFiZWwuX192ZXJ0aWNhbEFsaWduIHx8IHRleHRWZXJ0aWNhbEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IGxhYmVsLl9fdGV4dEFsaWduIHx8IHRleHRBbGlnblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHRleHRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICBzY2FsZTogW2ludlNjYWxlLCBpbnZTY2FsZV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXB9XG4gICAgICogQGFsaWFzIHttb2R1bGU6ZWNoYXJ0cy9jaGFydC9oZWxwZXIvTGluZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaW5lKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgICAgIGdyYXBoaWMuR3JvdXAuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVMaW5lKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbiAgICB9XG5cbiAgICB2YXIgbGluZVByb3RvID0gTGluZS5wcm90b3R5cGU7XG5cbiAgICAvLyBVcGRhdGUgc3ltYm9sIHBvc2l0aW9uIGFuZCByb3RhdGlvblxuICAgIGxpbmVQcm90by5iZWZvcmVVcGRhdGUgPSB1cGRhdGVTeW1ib2xBbmRMYWJlbEJlZm9yZUxpbmVVcGRhdGU7XG5cbiAgICBsaW5lUHJvdG8uX2NyZWF0ZUxpbmUgPSBmdW5jdGlvbiAobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuICAgICAgICB2YXIgbGluZVBvaW50cyA9IGxpbmVEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcblxuICAgICAgICB2YXIgbGluZSA9IGNyZWF0ZUxpbmUobGluZVBvaW50cyk7XG4gICAgICAgIGxpbmUuc2hhcGUucGVyY2VudCA9IDA7XG4gICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKGxpbmUsIHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcblxuICAgICAgICB0aGlzLmFkZChsaW5lKTtcblxuICAgICAgICB2YXIgbGFiZWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgICAgIG5hbWU6ICdsYWJlbCdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkKGxhYmVsKTtcblxuICAgICAgICB6clV0aWwuZWFjaChTWU1CT0xfQ0FURUdPUklFUywgZnVuY3Rpb24gKHN5bWJvbENhdGVnb3J5KSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sID0gY3JlYXRlU3ltYm9sKHN5bWJvbENhdGVnb3J5LCBsaW5lRGF0YSwgaWR4KTtcbiAgICAgICAgICAgIC8vIHN5bWJvbHMgbXVzdCBhZGRlZCBhZnRlciBsaW5lIHRvIG1ha2Ugc3VyZVxuICAgICAgICAgICAgLy8gaXQgd2lsbCBiZSB1cGRhdGVkIGFmdGVyIGxpbmUjdXBkYXRlLlxuICAgICAgICAgICAgLy8gT3Igc3ltYm9sIHBvc2l0aW9uIGFuZCByb3RhdGlvbiB1cGRhdGUgaW4gbGluZSNiZWZvcmVVcGRhdGUgd2lsbCBiZSBvbmUgZnJhbWUgc2xvd1xuICAgICAgICAgICAgdGhpcy5hZGQoc3ltYm9sKTtcbiAgICAgICAgICAgIHRoaXNbbWFrZVN5bWJvbFR5cGVLZXkoc3ltYm9sQ2F0ZWdvcnkpXSA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCBzeW1ib2xDYXRlZ29yeSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbW1vblN0bChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG4gICAgfTtcblxuICAgIGxpbmVQcm90by51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGxpbmVEYXRhLmhvc3RNb2RlbDtcblxuICAgICAgICB2YXIgbGluZSA9IHRoaXMuY2hpbGRPZk5hbWUoJ2xpbmUnKTtcbiAgICAgICAgdmFyIGxpbmVQb2ludHMgPSBsaW5lRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICAgICAgICBzaGFwZToge31cbiAgICAgICAgfTtcbiAgICAgICAgc2V0TGluZVBvaW50cyh0YXJnZXQuc2hhcGUsIGxpbmVQb2ludHMpO1xuICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGxpbmUsIHRhcmdldCwgc2VyaWVzTW9kZWwsIGlkeCk7XG5cbiAgICAgICAgenJVdGlsLmVhY2goU1lNQk9MX0NBVEVHT1JJRVMsIGZ1bmN0aW9uIChzeW1ib2xDYXRlZ29yeSkge1xuICAgICAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgc3ltYm9sQ2F0ZWdvcnkpO1xuICAgICAgICAgICAgdmFyIGtleSA9IG1ha2VTeW1ib2xUeXBlS2V5KHN5bWJvbENhdGVnb3J5KTtcbiAgICAgICAgICAgIC8vIFN5bWJvbCBjaGFuZ2VkXG4gICAgICAgICAgICBpZiAodGhpc1trZXldICE9PSBzeW1ib2xUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhpcy5jaGlsZE9mTmFtZShzeW1ib2xDYXRlZ29yeSkpO1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSBjcmVhdGVTeW1ib2woc3ltYm9sQ2F0ZWdvcnksIGxpbmVEYXRhLCBpZHgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBzeW1ib2xUeXBlO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVDb21tb25TdGwobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpO1xuICAgIH07XG5cbiAgICBsaW5lUHJvdG8uX3VwZGF0ZUNvbW1vblN0bCA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBsaW5lRGF0YS5ob3N0TW9kZWw7XG5cbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmNoaWxkT2ZOYW1lKCdsaW5lJyk7XG5cbiAgICAgICAgdmFyIGxpbmVTdHlsZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmxpbmVTdHlsZTtcbiAgICAgICAgdmFyIGhvdmVyTGluZVN0eWxlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuaG92ZXJMaW5lU3R5bGU7XG4gICAgICAgIHZhciBsYWJlbE1vZGVsID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUubGFiZWxNb2RlbDtcbiAgICAgICAgdmFyIGhvdmVyTGFiZWxNb2RlbCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmhvdmVyTGFiZWxNb2RlbDtcblxuICAgICAgICAvLyBPcHRpbWl6YXRpb24gZm9yIGxhcmdlIGRhdGFzZXRcbiAgICAgICAgaWYgKCFzZXJpZXNTY29wZSB8fCBsaW5lRGF0YS5oYXNJdGVtT3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gbGluZURhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG5cbiAgICAgICAgICAgIGxpbmVTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlLm5vcm1hbCcpLmdldExpbmVTdHlsZSgpO1xuICAgICAgICAgICAgaG92ZXJMaW5lU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZS5lbXBoYXNpcycpLmdldExpbmVTdHlsZSgpO1xuXG4gICAgICAgICAgICBsYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5ub3JtYWwnKTtcbiAgICAgICAgICAgIGhvdmVyTGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwuZW1waGFzaXMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2aXN1YWxDb2xvciA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKTtcbiAgICAgICAgdmFyIHZpc3VhbE9wYWNpdHkgPSB6clV0aWwucmV0cmlldmUoXG4gICAgICAgICAgICBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ29wYWNpdHknKSxcbiAgICAgICAgICAgIGxpbmVTdHlsZS5vcGFjaXR5LFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuXG4gICAgICAgIGxpbmUudXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0cm9rZU5vU2NhbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogdmlzdWFsQ29sb3IsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogdmlzdWFsT3BhY2l0eVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVTdHlsZVxuICAgICAgICApKTtcbiAgICAgICAgbGluZS5ob3ZlclN0eWxlID0gaG92ZXJMaW5lU3R5bGU7XG5cbiAgICAgICAgLy8gVXBkYXRlIHN5bWJvbFxuICAgICAgICB6clV0aWwuZWFjaChTWU1CT0xfQ0FURUdPUklFUywgZnVuY3Rpb24gKHN5bWJvbENhdGVnb3J5KSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sID0gdGhpcy5jaGlsZE9mTmFtZShzeW1ib2xDYXRlZ29yeSk7XG4gICAgICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sLnNldENvbG9yKHZpc3VhbENvbG9yKTtcbiAgICAgICAgICAgICAgICBzeW1ib2wuc2V0U3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiB2aXN1YWxPcGFjaXR5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHZhciBzaG93TGFiZWwgPSBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKTtcbiAgICAgICAgdmFyIGhvdmVyU2hvd0xhYmVsID0gaG92ZXJMYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKTtcblxuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLmNoaWxkT2ZOYW1lKCdsYWJlbCcpO1xuICAgICAgICB2YXIgZGVmYXVsdExhYmVsQ29sb3I7XG4gICAgICAgIHZhciBkZWZhdWx0VGV4dDtcblxuICAgICAgICBpZiAoc2hvd0xhYmVsIHx8IGhvdmVyU2hvd0xhYmVsKSB7XG4gICAgICAgICAgICB2YXIgcmF3VmFsID0gc2VyaWVzTW9kZWwuZ2V0UmF3VmFsdWUoaWR4KTtcbiAgICAgICAgICAgIGRlZmF1bHRUZXh0ID0gcmF3VmFsID09IG51bGxcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRUZXh0ID0gbGluZURhdGEuZ2V0TmFtZShpZHgpXG4gICAgICAgICAgICAgICAgOiBpc0Zpbml0ZShyYXdWYWwpXG4gICAgICAgICAgICAgICAgPyBudW1iZXJVdGlsLnJvdW5kKHJhd1ZhbClcbiAgICAgICAgICAgICAgICA6IHJhd1ZhbDtcbiAgICAgICAgICAgIGRlZmF1bHRMYWJlbENvbG9yID0gdmlzdWFsQ29sb3IgfHwgJyMwMDAnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGFiZWwuYWZ0ZXJVcGRhdGUgPSBsaW5lQWZ0ZXJVcGRhdGU7XG4gICAgICAgIGlmIChzaG93TGFiZWwpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGxhYmVsTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgICAgICAgICAgbGFiZWwuc2V0U3R5bGUoe1xuICAgICAgICAgICAgICAgIHRleHQ6IHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWwoaWR4LCAnbm9ybWFsJywgbGluZURhdGEuZGF0YVR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VGV4dFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgICAgICAgICBmaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBkZWZhdWx0TGFiZWxDb2xvclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxhYmVsLl9fdGV4dEFsaWduID0gdGV4dFN0eWxlTW9kZWwuZ2V0KCdhbGlnbicpO1xuICAgICAgICAgICAgbGFiZWwuX192ZXJ0aWNhbEFsaWduID0gdGV4dFN0eWxlTW9kZWwuZ2V0KCdiYXNlbGluZScpO1xuICAgICAgICAgICAgbGFiZWwuX19wb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFiZWwuc2V0U3R5bGUoJ3RleHQnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvdmVyU2hvd0xhYmVsKSB7XG4gICAgICAgICAgICB2YXIgdGV4dFN0eWxlSG92ZXJNb2RlbCA9IGhvdmVyTGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG5cbiAgICAgICAgICAgIGxhYmVsLmhvdmVyU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogenJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChpZHgsICdlbXBoYXNpcycsIGxpbmVEYXRhLmRhdGFUeXBlKSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFRleHRcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHRleHRGb250OiB0ZXh0U3R5bGVIb3Zlck1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgICAgICAgICBmaWxsOiB0ZXh0U3R5bGVIb3Zlck1vZGVsLmdldFRleHRDb2xvcigpIHx8IGRlZmF1bHRMYWJlbENvbG9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFiZWwuaG92ZXJTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhYmVsLmlnbm9yZSA9ICFzaG93TGFiZWwgJiYgIWhvdmVyU2hvd0xhYmVsO1xuXG4gICAgICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgbGluZVByb3RvLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4KSB7XG4gICAgICAgIHRoaXMuc2V0TGluZVBvaW50cyhsaW5lRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCkpO1xuICAgIH07XG5cbiAgICBsaW5lUHJvdG8uc2V0TGluZVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgICAgdmFyIGxpbmVQYXRoID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZScpO1xuICAgICAgICBzZXRMaW5lUG9pbnRzKGxpbmVQYXRoLnNoYXBlLCBwb2ludHMpO1xuICAgICAgICBsaW5lUGF0aC5kaXJ0eSgpO1xuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoTGluZSwgZ3JhcGhpYy5Hcm91cCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpbmU7XG4iLCIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jaGFydC9oZWxwZXIvTGluZURyYXdcbiAqL1xuXG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciBMaW5lR3JvdXAgPSByZXF1aXJlKCcuL0xpbmUnKTtcblxuXG4gICAgZnVuY3Rpb24gaXNQb2ludE5hTihwdCkge1xuICAgICAgICByZXR1cm4gaXNOYU4ocHRbMF0pIHx8IGlzTmFOKHB0WzFdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZU5lZWRzRHJhdyhwdHMpIHtcbiAgICAgICAgcmV0dXJuICFpc1BvaW50TmFOKHB0c1swXSkgJiYgIWlzUG9pbnROYU4ocHRzWzFdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9tYXJrZXIvTGluZURyYXdcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaW5lRHJhdyhjdG9yKSB7XG4gICAgICAgIHRoaXMuX2N0b3IgPSBjdG9yIHx8IExpbmVHcm91cDtcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgfVxuXG4gICAgdmFyIGxpbmVEcmF3UHJvdG8gPSBMaW5lRHJhdy5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gbGluZURhdGFcbiAgICAgKi9cbiAgICBsaW5lRHJhd1Byb3RvLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAobGluZURhdGEpIHtcblxuICAgICAgICB2YXIgb2xkTGluZURhdGEgPSB0aGlzLl9saW5lRGF0YTtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgdmFyIExpbmVDdG9yID0gdGhpcy5fY3RvcjtcblxuICAgICAgICB2YXIgaG9zdE1vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuXG4gICAgICAgIHZhciBzZXJpZXNTY29wZSA9IHtcbiAgICAgICAgICAgIGxpbmVTdHlsZTogaG9zdE1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUubm9ybWFsJykuZ2V0TGluZVN0eWxlKCksXG4gICAgICAgICAgICBob3ZlckxpbmVTdHlsZTogaG9zdE1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUuZW1waGFzaXMnKS5nZXRMaW5lU3R5bGUoKSxcbiAgICAgICAgICAgIGxhYmVsTW9kZWw6IGhvc3RNb2RlbC5nZXRNb2RlbCgnbGFiZWwubm9ybWFsJyksXG4gICAgICAgICAgICBob3ZlckxhYmVsTW9kZWw6IGhvc3RNb2RlbC5nZXRNb2RlbCgnbGFiZWwuZW1waGFzaXMnKVxuICAgICAgICB9O1xuXG4gICAgICAgIGxpbmVEYXRhLmRpZmYob2xkTGluZURhdGEpXG4gICAgICAgICAgICAuYWRkKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmVOZWVkc0RyYXcobGluZURhdGEuZ2V0SXRlbUxheW91dChpZHgpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsaW5lR3JvdXAgPSBuZXcgTGluZUN0b3IobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpO1xuXG4gICAgICAgICAgICAgICAgbGluZURhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIGxpbmVHcm91cCk7XG5cbiAgICAgICAgICAgICAgICBncm91cC5hZGQobGluZUdyb3VwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lR3JvdXAgPSBvbGRMaW5lRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5lTmVlZHNEcmF3KGxpbmVEYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKGxpbmVHcm91cCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWxpbmVHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lR3JvdXAgPSBuZXcgTGluZUN0b3IobGluZURhdGEsIG5ld0lkeCwgc2VyaWVzU2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZUdyb3VwLnVwZGF0ZURhdGEobGluZURhdGEsIG5ld0lkeCwgc2VyaWVzU2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpbmVEYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBsaW5lR3JvdXApO1xuXG4gICAgICAgICAgICAgICAgZ3JvdXAuYWRkKGxpbmVHcm91cCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlbW92ZShmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKG9sZExpbmVEYXRhLmdldEl0ZW1HcmFwaGljRWwoaWR4KSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmV4ZWN1dGUoKTtcblxuICAgICAgICB0aGlzLl9saW5lRGF0YSA9IGxpbmVEYXRhO1xuICAgIH07XG5cbiAgICBsaW5lRHJhd1Byb3RvLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpbmVEYXRhID0gdGhpcy5fbGluZURhdGE7XG4gICAgICAgIGxpbmVEYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICAgICAgICBlbC51cGRhdGVMYXlvdXQobGluZURhdGEsIGlkeCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICBsaW5lRHJhd1Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lRHJhdztcbiIsIi8qKlxuICogTGluZSBwYXRoIGZvciBiZXppZXIgYW5kIHN0cmFpZ2h0IGxpbmUgZHJhd1xuICovXG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcblxuICAgIHZhciBzdHJhaWdodExpbmVQcm90byA9IGdyYXBoaWMuTGluZS5wcm90b3R5cGU7XG4gICAgdmFyIGJlemllckN1cnZlUHJvdG8gPSBncmFwaGljLkJlemllckN1cnZlLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGlzTGluZShzaGFwZSkge1xuICAgICAgICByZXR1cm4gaXNOYU4oK3NoYXBlLmNweDEpIHx8IGlzTmFOKCtzaGFwZS5jcHkxKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuXG4gICAgICAgIHR5cGU6ICdlYy1saW5lJyxcblxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgeTE6IDAsXG4gICAgICAgICAgICB4MjogMCxcbiAgICAgICAgICAgIHkyOiAwLFxuICAgICAgICAgICAgcGVyY2VudDogMSxcbiAgICAgICAgICAgIGNweDE6IG51bGwsXG4gICAgICAgICAgICBjcHkxOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgKGlzTGluZShzaGFwZSkgPyBzdHJhaWdodExpbmVQcm90byA6IGJlemllckN1cnZlUHJvdG8pLmJ1aWxkUGF0aChjdHgsIHNoYXBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludEF0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTGluZSh0aGlzLnNoYXBlKVxuICAgICAgICAgICAgICAgID8gc3RyYWlnaHRMaW5lUHJvdG8ucG9pbnRBdC5jYWxsKHRoaXMsIHQpXG4gICAgICAgICAgICAgICAgOiBiZXppZXJDdXJ2ZVByb3RvLnBvaW50QXQuY2FsbCh0aGlzLCB0KTtcbiAgICAgICAgfSxcblxuICAgICAgICB0YW5nZW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgdmFyIHAgPSBpc0xpbmUoc2hhcGUpXG4gICAgICAgICAgICAgICAgPyBbc2hhcGUueDIgLSBzaGFwZS54MSwgc2hhcGUueTIgLSBzaGFwZS55MV1cbiAgICAgICAgICAgICAgICA6IGJlemllckN1cnZlUHJvdG8udGFuZ2VudEF0LmNhbGwodGhpcywgdCk7XG4gICAgICAgICAgICByZXR1cm4gdmVjMi5ub3JtYWxpemUocCwgcCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiIsIi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NoYXJ0L2hlbHBlci9TeW1ib2xcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIHN5bWJvbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3N5bWJvbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpO1xuXG4gICAgZnVuY3Rpb24gZ2V0U3ltYm9sU2l6ZShkYXRhLCBpZHgpIHtcbiAgICAgICAgdmFyIHN5bWJvbFNpemUgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScpO1xuICAgICAgICByZXR1cm4gc3ltYm9sU2l6ZSBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgICA/IHN5bWJvbFNpemUuc2xpY2UoKVxuICAgICAgICAgICAgOiBbK3N5bWJvbFNpemUsICtzeW1ib2xTaXplXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTY2FsZShzeW1ib2xTaXplKSB7XG4gICAgICAgIHJldHVybiBbc3ltYm9sU2l6ZVswXSAvIDIsIHN5bWJvbFNpemVbMV0gLyAyXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMge21vZHVsZTplY2hhcnRzL2NoYXJ0L2hlbHBlci9TeW1ib2x9XG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gU3ltYm9sKGRhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgICAgICAgZ3JhcGhpYy5Hcm91cC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRGF0YShkYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbiAgICB9XG5cbiAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wucHJvdG90eXBlO1xuXG4gICAgZnVuY3Rpb24gZHJpZnRTeW1ib2woZHgsIGR5KSB7XG4gICAgICAgIHRoaXMucGFyZW50LmRyaWZ0KGR4LCBkeSk7XG4gICAgfVxuXG4gICAgc3ltYm9sUHJvdG8uX2NyZWF0ZVN5bWJvbCA9IGZ1bmN0aW9uIChzeW1ib2xUeXBlLCBkYXRhLCBpZHgsIHN5bWJvbFNpemUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHBhdGhzIGNyZWF0ZWQgYmVmb3JlXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgIC8vIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woXG4gICAgICAgIC8vICAgICBzeW1ib2xUeXBlLCAtMC41LCAtMC41LCAxLCAxLCBjb2xvclxuICAgICAgICAvLyApO1xuICAgICAgICAvLyBJZiB3aWR0aC9oZWlnaHQgYXJlIHNldCB0b28gc21hbGwgKGUuZy4sIHNldCB0byAxKSBvbiBpb3MxMFxuICAgICAgICAvLyBhbmQgbWFjT1MgU2llcnJhLCBhIGNpcmNsZSBzdHJva2UgYmVjb21lIGEgcmVjdCwgbm8gbWF0dGVyIHdoYXRcbiAgICAgICAgLy8gdGhlIHNjYWxlIGlzIHNldC4gU28gd2Ugc2V0IHdpZHRoL2hlaWdodCBhcyAyLiBTZWUgIzQxNTAuXG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woXG4gICAgICAgICAgICBzeW1ib2xUeXBlLCAtMSwgLTEsIDIsIDIsIGNvbG9yXG4gICAgICAgICk7XG5cbiAgICAgICAgc3ltYm9sUGF0aC5hdHRyKHtcbiAgICAgICAgICAgIHoyOiAxMDAsXG4gICAgICAgICAgICBjdWxsaW5nOiB0cnVlLFxuICAgICAgICAgICAgc2NhbGU6IFswLCAwXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmV3cml0ZSBkcmlmdCBtZXRob2RcbiAgICAgICAgc3ltYm9sUGF0aC5kcmlmdCA9IGRyaWZ0U3ltYm9sO1xuXG4gICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKHN5bWJvbFBhdGgsIHtcbiAgICAgICAgICAgIHNjYWxlOiBnZXRTY2FsZShzeW1ib2xTaXplKVxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgICAgdGhpcy5fc3ltYm9sVHlwZSA9IHN5bWJvbFR5cGU7XG5cbiAgICAgICAgdGhpcy5hZGQoc3ltYm9sUGF0aCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3AgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSB0b0xhc3RGcmFtZVxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLnN0b3BTeW1ib2xBbmltYXRpb24gPSBmdW5jdGlvbiAodG9MYXN0RnJhbWUpIHtcbiAgICAgICAgdGhpcy5jaGlsZEF0KDApLnN0b3BBbmltYXRpb24odG9MYXN0RnJhbWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3ltYm9sIHBhdGggZWxlbWVudFxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLmdldFN5bWJvbFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQXQoMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBzY2FsZShha2EsIGN1cnJlbnQgc3ltYm9sIHNpemUpLlxuICAgICAqIEluY2x1ZGluZyB0aGUgY2hhbmdlIGNhdXNlZCBieSBhbmltYXRpb25cbiAgICAgKi9cbiAgICBzeW1ib2xQcm90by5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRBdCgwKS5zY2FsZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGlnaGxpZ2h0IHN5bWJvbFxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGlsZEF0KDApLnRyaWdnZXIoJ2VtcGhhc2lzJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERvd25wbGF5IHN5bWJvbFxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLmRvd25wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoaWxkQXQoMCkudHJpZ2dlcignbm9ybWFsJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gelxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLnNldFogPSBmdW5jdGlvbiAoemxldmVsLCB6KSB7XG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICAgICAgICBzeW1ib2xQYXRoLnpsZXZlbCA9IHpsZXZlbDtcbiAgICAgICAgc3ltYm9sUGF0aC56ID0gejtcbiAgICB9O1xuXG4gICAgc3ltYm9sUHJvdG8uc2V0RHJhZ2dhYmxlID0gZnVuY3Rpb24gKGRyYWdnYWJsZSkge1xuICAgICAgICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICAgICAgc3ltYm9sUGF0aC5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XG4gICAgICAgIHN5bWJvbFBhdGguY3Vyc29yID0gZHJhZ2dhYmxlID8gJ21vdmUnIDogJ3BvaW50ZXInO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc3ltYm9sIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlkeFxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgICAgICB0aGlzLnNpbGVudCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBzeW1ib2xUeXBlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbCcpIHx8ICdjaXJjbGUnO1xuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICAgICAgdmFyIHN5bWJvbFNpemUgPSBnZXRTeW1ib2xTaXplKGRhdGEsIGlkeCk7XG5cbiAgICAgICAgaWYgKHN5bWJvbFR5cGUgIT09IHRoaXMuX3N5bWJvbFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVN5bWJvbChzeW1ib2xUeXBlLCBkYXRhLCBpZHgsIHN5bWJvbFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gICAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHN5bWJvbFBhdGgsIHtcbiAgICAgICAgICAgICAgICBzY2FsZTogZ2V0U2NhbGUoc3ltYm9sU2l6ZSlcbiAgICAgICAgICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbW1vbihkYXRhLCBpZHgsIHN5bWJvbFNpemUsIHNlcmllc1Njb3BlKTtcbiAgICAgICAgdGhpcy5fc2VyaWVzTW9kZWwgPSBzZXJpZXNNb2RlbDtcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIGNvbW1vbiBwcm9wZXJ0aWVzXG4gICAgdmFyIG5vcm1hbFN0eWxlQWNjZXNzUGF0aCA9IFsnaXRlbVN0eWxlJywgJ25vcm1hbCddO1xuICAgIHZhciBlbXBoYXNpc1N0eWxlQWNjZXNzUGF0aCA9IFsnaXRlbVN0eWxlJywgJ2VtcGhhc2lzJ107XG4gICAgdmFyIG5vcm1hbExhYmVsQWNjZXNzUGF0aCA9IFsnbGFiZWwnLCAnbm9ybWFsJ107XG4gICAgdmFyIGVtcGhhc2lzTGFiZWxBY2Nlc3NQYXRoID0gWydsYWJlbCcsICdlbXBoYXNpcyddO1xuXG4gICAgc3ltYm9sUHJvdG8uX3VwZGF0ZUNvbW1vbiA9IGZ1bmN0aW9uIChkYXRhLCBpZHgsIHN5bWJvbFNpemUsIHNlcmllc1Njb3BlKSB7XG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICAgICAgdmFyIGNvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJyk7XG5cbiAgICAgICAgLy8gUmVzZXQgc3R5bGVcbiAgICAgICAgaWYgKHN5bWJvbFBhdGgudHlwZSAhPT0gJ2ltYWdlJykge1xuICAgICAgICAgICAgc3ltYm9sUGF0aC51c2VTdHlsZSh7XG4gICAgICAgICAgICAgICAgc3Ryb2tlTm9TY2FsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpZXNTY29wZSA9IHNlcmllc1Njb3BlIHx8IG51bGw7XG5cbiAgICAgICAgdmFyIGl0ZW1TdHlsZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLml0ZW1TdHlsZTtcbiAgICAgICAgdmFyIGhvdmVySXRlbVN0eWxlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuaG92ZXJJdGVtU3R5bGU7XG4gICAgICAgIHZhciBzeW1ib2xSb3RhdGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5zeW1ib2xSb3RhdGU7XG4gICAgICAgIHZhciBzeW1ib2xPZmZzZXQgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5zeW1ib2xPZmZzZXQ7XG4gICAgICAgIHZhciBsYWJlbE1vZGVsID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUubGFiZWxNb2RlbDtcbiAgICAgICAgdmFyIGhvdmVyTGFiZWxNb2RlbCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmhvdmVyTGFiZWxNb2RlbDtcbiAgICAgICAgdmFyIGhvdmVyQW5pbWF0aW9uID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuaG92ZXJBbmltYXRpb247XG5cbiAgICAgICAgaWYgKCFzZXJpZXNTY29wZSB8fCBkYXRhLmhhc0l0ZW1PcHRpb24pIHtcbiAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuXG4gICAgICAgICAgICAvLyBDb2xvciBtdXN0IGJlIGV4Y2x1ZGVkLlxuICAgICAgICAgICAgLy8gQmVjYXVzZSBzeW1ib2wgcHJvdmlkZSBzZXRDb2xvciBpbmRpdmlkdWFsbHkgdG8gc2V0IGZpbGwgYW5kIHN0cm9rZVxuICAgICAgICAgICAgaXRlbVN0eWxlID0gaXRlbU1vZGVsLmdldE1vZGVsKG5vcm1hbFN0eWxlQWNjZXNzUGF0aCkuZ2V0SXRlbVN0eWxlKFsnY29sb3InXSk7XG4gICAgICAgICAgICBob3Zlckl0ZW1TdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChlbXBoYXNpc1N0eWxlQWNjZXNzUGF0aCkuZ2V0SXRlbVN0eWxlKCk7XG5cbiAgICAgICAgICAgIHN5bWJvbFJvdGF0ZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xSb3RhdGUnKTtcbiAgICAgICAgICAgIHN5bWJvbE9mZnNldCA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2xPZmZzZXQnKTtcblxuICAgICAgICAgICAgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChub3JtYWxMYWJlbEFjY2Vzc1BhdGgpO1xuICAgICAgICAgICAgaG92ZXJMYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKGVtcGhhc2lzTGFiZWxBY2Nlc3NQYXRoKTtcbiAgICAgICAgICAgIGhvdmVyQW5pbWF0aW9uID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ2hvdmVyQW5pbWF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBob3Zlckl0ZW1TdHlsZSA9IHpyVXRpbC5leHRlbmQoe30sIGhvdmVySXRlbVN0eWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbFN0eWxlID0gc3ltYm9sUGF0aC5zdHlsZTtcblxuICAgICAgICBzeW1ib2xQYXRoLmF0dHIoJ3JvdGF0aW9uJywgKHN5bWJvbFJvdGF0ZSB8fCAwKSAqIE1hdGguUEkgLyAxODAgfHwgMCk7XG5cbiAgICAgICAgaWYgKHN5bWJvbE9mZnNldCkge1xuICAgICAgICAgICAgc3ltYm9sUGF0aC5hdHRyKCdwb3NpdGlvbicsIFtcbiAgICAgICAgICAgICAgICBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChzeW1ib2xPZmZzZXRbMF0sIHN5bWJvbFNpemVbMF0pLFxuICAgICAgICAgICAgICAgIG51bWJlclV0aWwucGFyc2VQZXJjZW50KHN5bWJvbE9mZnNldFsxXSwgc3ltYm9sU2l6ZVsxXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUEVORElORyBzZXRDb2xvciBiZWZvcmUgc2V0U3R5bGUhISFcbiAgICAgICAgc3ltYm9sUGF0aC5zZXRDb2xvcihjb2xvcik7XG5cbiAgICAgICAgc3ltYm9sUGF0aC5zZXRTdHlsZShpdGVtU3R5bGUpO1xuXG4gICAgICAgIHZhciBvcGFjaXR5ID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ29wYWNpdHknKTtcbiAgICAgICAgaWYgKG9wYWNpdHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgZWxTdHlsZS5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBsYXN0IHZhbHVlIGRpbVxuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGRhdGEuZGltZW5zaW9ucy5zbGljZSgpO1xuICAgICAgICB2YXIgdmFsdWVEaW07XG4gICAgICAgIHZhciBkYXRhVHlwZTtcbiAgICAgICAgd2hpbGUgKGRpbWVuc2lvbnMubGVuZ3RoICYmIChcbiAgICAgICAgICAgIHZhbHVlRGltID0gZGltZW5zaW9ucy5wb3AoKSxcbiAgICAgICAgICAgIGRhdGFUeXBlID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKHZhbHVlRGltKS50eXBlLFxuICAgICAgICAgICAgZGF0YVR5cGUgPT09ICdvcmRpbmFsJyB8fCBkYXRhVHlwZSA9PT0gJ3RpbWUnXG4gICAgICAgICkpIHt9IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgICAgIGlmICh2YWx1ZURpbSAhPSBudWxsICYmIGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnc2hvdycpKSB7XG4gICAgICAgICAgICBncmFwaGljLnNldFRleHQoZWxTdHlsZSwgbGFiZWxNb2RlbCwgY29sb3IpO1xuICAgICAgICAgICAgZWxTdHlsZS50ZXh0ID0genJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldEZvcm1hdHRlZExhYmVsKGlkeCwgJ25vcm1hbCcpLFxuICAgICAgICAgICAgICAgIGRhdGEuZ2V0KHZhbHVlRGltLCBpZHgpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxTdHlsZS50ZXh0ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVEaW0gIT0gbnVsbCAmJiBob3ZlckxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnc2hvdycpKSB7XG4gICAgICAgICAgICBncmFwaGljLnNldFRleHQoaG92ZXJJdGVtU3R5bGUsIGhvdmVyTGFiZWxNb2RlbCwgY29sb3IpO1xuICAgICAgICAgICAgaG92ZXJJdGVtU3R5bGUudGV4dCA9IHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChpZHgsICdlbXBoYXNpcycpLFxuICAgICAgICAgICAgICAgIGRhdGEuZ2V0KHZhbHVlRGltLCBpZHgpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG92ZXJJdGVtU3R5bGUudGV4dCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ltYm9sUGF0aC5vZmYoJ21vdXNlb3ZlcicpXG4gICAgICAgICAgICAub2ZmKCdtb3VzZW91dCcpXG4gICAgICAgICAgICAub2ZmKCdlbXBoYXNpcycpXG4gICAgICAgICAgICAub2ZmKCdub3JtYWwnKTtcblxuICAgICAgICBzeW1ib2xQYXRoLmhvdmVyU3R5bGUgPSBob3Zlckl0ZW1TdHlsZTtcblxuICAgICAgICBncmFwaGljLnNldEhvdmVyU3R5bGUoc3ltYm9sUGF0aCk7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gZ2V0U2NhbGUoc3ltYm9sU2l6ZSk7XG5cbiAgICAgICAgaWYgKGhvdmVyQW5pbWF0aW9uICYmIHNlcmllc01vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB2YXIgb25FbXBoYXNpcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IHNjYWxlWzFdIC8gc2NhbGVbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlVG8oe1xuICAgICAgICAgICAgICAgICAgICBzY2FsZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoc2NhbGVbMF0gKiAxLjEsIHNjYWxlWzBdICsgMyksXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChzY2FsZVsxXSAqIDEuMSwgc2NhbGVbMV0gKyAzICogcmF0aW8pXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LCA0MDAsICdlbGFzdGljT3V0Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9uTm9ybWFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlVG8oe1xuICAgICAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGVcbiAgICAgICAgICAgICAgICB9LCA0MDAsICdlbGFzdGljT3V0Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3ltYm9sUGF0aC5vbignbW91c2VvdmVyJywgb25FbXBoYXNpcylcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0Jywgb25Ob3JtYWwpXG4gICAgICAgICAgICAgICAgLm9uKCdlbXBoYXNpcycsIG9uRW1waGFzaXMpXG4gICAgICAgICAgICAgICAgLm9uKCdub3JtYWwnLCBvbk5vcm1hbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc3ltYm9sUHJvdG8uZmFkZU91dCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICAgICAgLy8gQXZvaWQgbWlzdGFrZW4gaG92ZXIgd2hlbiBmYWRpbmcgb3V0XG4gICAgICAgIHRoaXMuc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgLy8gTm90IHNob3cgdGV4dCB3aGVuIGFuaW1hdGluZ1xuICAgICAgICBzeW1ib2xQYXRoLnN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhzeW1ib2xQYXRoLCB7XG4gICAgICAgICAgICBzY2FsZTogWzAsIDBdXG4gICAgICAgIH0sIHRoaXMuX3Nlcmllc01vZGVsLCB0aGlzLmRhdGFJbmRleCwgY2IpO1xuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoU3ltYm9sLCBncmFwaGljLkdyb3VwKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY2hhcnQvaGVscGVyL1N5bWJvbERyYXdcbiAqL1xuXG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciBTeW1ib2wgPSByZXF1aXJlKCcuL1N5bWJvbCcpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NoYXJ0L2hlbHBlci9TeW1ib2xEcmF3XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwfSBbc3ltYm9sQ3Rvcl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTeW1ib2xEcmF3KHN5bWJvbEN0b3IpIHtcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgdGhpcy5fc3ltYm9sQ3RvciA9IHN5bWJvbEN0b3IgfHwgU3ltYm9sO1xuICAgIH1cblxuICAgIHZhciBzeW1ib2xEcmF3UHJvdG8gPSBTeW1ib2xEcmF3LnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIHN5bWJvbE5lZWRzRHJhdyhkYXRhLCBpZHgsIGlzSWdub3JlKSB7XG4gICAgICAgIHZhciBwb2ludCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgICAvLyBJcyBhbiBvYmplY3RcbiAgICAgICAgLy8gaWYgKHBvaW50ICYmIHBvaW50Lmhhc093blByb3BlcnR5KCdwb2ludCcpKSB7XG4gICAgICAgIC8vICAgICBwb2ludCA9IHBvaW50LnBvaW50O1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBwb2ludCAmJiAhaXNOYU4ocG9pbnRbMF0pICYmICFpc05hTihwb2ludFsxXSkgJiYgIShpc0lnbm9yZSAmJiBpc0lnbm9yZShpZHgpKVxuICAgICAgICAgICAgICAgICAgICAmJiBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJykgIT09ICdub25lJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHN5bWJvbHMgZHJhdyBieSBuZXcgZGF0YVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheS48Ym9vbGVhbj59IFtpc0lnbm9yZV1cbiAgICAgKi9cbiAgICBzeW1ib2xEcmF3UHJvdG8udXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBpc0lnbm9yZSkge1xuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHZhciBTeW1ib2xDdG9yID0gdGhpcy5fc3ltYm9sQ3RvcjtcblxuICAgICAgICB2YXIgc2VyaWVzU2NvcGUgPSB7XG4gICAgICAgICAgICBpdGVtU3R5bGU6IHNlcmllc01vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUubm9ybWFsJykuZ2V0SXRlbVN0eWxlKFsnY29sb3InXSksXG4gICAgICAgICAgICBob3Zlckl0ZW1TdHlsZTogc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5lbXBoYXNpcycpLmdldEl0ZW1TdHlsZSgpLFxuICAgICAgICAgICAgc3ltYm9sUm90YXRlOiBzZXJpZXNNb2RlbC5nZXQoJ3N5bWJvbFJvdGF0ZScpLFxuICAgICAgICAgICAgc3ltYm9sT2Zmc2V0OiBzZXJpZXNNb2RlbC5nZXQoJ3N5bWJvbE9mZnNldCcpLFxuICAgICAgICAgICAgaG92ZXJBbmltYXRpb246IHNlcmllc01vZGVsLmdldCgnaG92ZXJBbmltYXRpb24nKSxcblxuICAgICAgICAgICAgbGFiZWxNb2RlbDogc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLm5vcm1hbCcpLFxuICAgICAgICAgICAgaG92ZXJMYWJlbE1vZGVsOiBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnbGFiZWwuZW1waGFzaXMnKVxuICAgICAgICB9O1xuXG4gICAgICAgIGRhdGEuZGlmZihvbGREYXRhKVxuICAgICAgICAgICAgLmFkZChmdW5jdGlvbiAobmV3SWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gZGF0YS5nZXRJdGVtTGF5b3V0KG5ld0lkeCk7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbE5lZWRzRHJhdyhkYXRhLCBuZXdJZHgsIGlzSWdub3JlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9sRWwgPSBuZXcgU3ltYm9sQ3RvcihkYXRhLCBuZXdJZHgsIHNlcmllc1Njb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sRWwuYXR0cigncG9zaXRpb24nLCBwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIHN5bWJvbEVsKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHN5bWJvbEVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sRWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBkYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXN5bWJvbE5lZWRzRHJhdyhkYXRhLCBuZXdJZHgsIGlzSWdub3JlKSkge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUoc3ltYm9sRWwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc3ltYm9sRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sRWwgPSBuZXcgU3ltYm9sQ3RvcihkYXRhLCBuZXdJZHgpO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xFbC5hdHRyKCdwb3NpdGlvbicsIHBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbEVsLnVwZGF0ZURhdGEoZGF0YSwgbmV3SWR4LCBzZXJpZXNTY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoc3ltYm9sRWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb2ludFxuICAgICAgICAgICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGJhY2tcbiAgICAgICAgICAgICAgICBncm91cC5hZGQoc3ltYm9sRWwpO1xuXG4gICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgc3ltYm9sRWwpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZW1vdmUoZnVuY3Rpb24gKG9sZElkeCkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuICAgICAgICAgICAgICAgIGVsICYmIGVsLmZhZGVPdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5leGVjdXRlKCk7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfTtcblxuICAgIHN5bWJvbERyYXdQcm90by51cGRhdGVMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIE5vdCB1c2UgYW5pbWF0aW9uXG4gICAgICAgICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgICAgICAgICAgZWwuYXR0cigncG9zaXRpb24nLCBwb2ludCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzeW1ib2xEcmF3UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKGVuYWJsZUFuaW1hdGlvbikge1xuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuZmFkZU91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU3ltYm9sRHJhdztcbiIsIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIExpc3QgPSByZXF1aXJlKCcuLi8uLi9kYXRhL0xpc3QnKTtcbiAgICB2YXIgY29tcGxldGVEaW1lbnNpb25zID0gcmVxdWlyZSgnLi4vLi4vZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIENvb3JkaW5hdGVTeXN0ZW0gPSByZXF1aXJlKCcuLi8uLi9Db29yZGluYXRlU3lzdGVtJyk7XG4gICAgdmFyIGdldERhdGFJdGVtVmFsdWUgPSBtb2RlbFV0aWwuZ2V0RGF0YUl0ZW1WYWx1ZTtcbiAgICB2YXIgY29udmVyRGF0YVZhbHVlID0gbW9kZWxVdGlsLmNvbnZlckRhdGFWYWx1ZTtcblxuICAgIGZ1bmN0aW9uIGZpcnN0RGF0YU5vdE51bGwoZGF0YSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgZGF0YS5sZW5ndGggJiYgZGF0YVtpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFbaV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlmTmVlZENvbXBsZXRlT3JkaW5hbERhdGEoZGF0YSkge1xuICAgICAgICB2YXIgc2FtcGxlSXRlbSA9IGZpcnN0RGF0YU5vdE51bGwoZGF0YSk7XG4gICAgICAgIHJldHVybiBzYW1wbGVJdGVtICE9IG51bGxcbiAgICAgICAgICAgICYmICF6clV0aWwuaXNBcnJheShnZXREYXRhSXRlbVZhbHVlKHNhbXBsZUl0ZW0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbGlzdCBmcm9tIG9wdGlvbiBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTGlzdEZyb21BcnJheShkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgICAgICAvLyBJZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICBkYXRhID0gZGF0YSB8fCBbXTtcblxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvb3JkU3lzTmFtZSA9IHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpO1xuICAgICAgICB2YXIgY3JlYXRvciA9IGNyZWF0b3JzW2Nvb3JkU3lzTmFtZV07XG4gICAgICAgIHZhciByZWdpc3RlcmVkQ29vcmRTeXMgPSBDb29yZGluYXRlU3lzdGVtLmdldChjb29yZFN5c05hbWUpO1xuICAgICAgICAvLyBGSVhNRVxuICAgICAgICB2YXIgYXhlc0luZm8gPSBjcmVhdG9yICYmIGNyZWF0b3IoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwpO1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGF4ZXNJbmZvICYmIGF4ZXNJbmZvLmRpbWVuc2lvbnM7XG4gICAgICAgIGlmICghZGltZW5zaW9ucykge1xuICAgICAgICAgICAgLy8gR2V0IGRpbWVuc2lvbnMgZnJvbSByZWdpc3RlcmVkIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICAgICAgICBkaW1lbnNpb25zID0gKHJlZ2lzdGVyZWRDb29yZFN5cyAmJiByZWdpc3RlcmVkQ29vcmRTeXMuZGltZW5zaW9ucykgfHwgWyd4JywgJ3knXTtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwgZGltZW5zaW9ucy5jb25jYXQoWyd2YWx1ZSddKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhdGVnb3J5SW5kZXggPSBheGVzSW5mbyA/IGF4ZXNJbmZvLmNhdGVnb3J5SW5kZXggOiAtMTtcblxuICAgICAgICB2YXIgbGlzdCA9IG5ldyBMaXN0KGRpbWVuc2lvbnMsIHNlcmllc01vZGVsKTtcblxuICAgICAgICB2YXIgbmFtZUxpc3QgPSBjcmVhdGVOYW1lTGlzdChheGVzSW5mbywgZGF0YSk7XG5cbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSB7fTtcbiAgICAgICAgdmFyIGRpbVZhbHVlR2V0dGVyID0gKGNhdGVnb3J5SW5kZXggPj0gMCAmJiBpZk5lZWRDb21wbGV0ZU9yZGluYWxEYXRhKGRhdGEpKVxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoaXRlbU9wdCwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGFueSBkYXRhSXRlbSBpcyBsaWtlIHsgdmFsdWU6IDEwIH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZWxVdGlsLmlzRGF0YUl0ZW1PcHRpb24oaXRlbU9wdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgZGF0YUluZGV4IGFzIG9yZGluYWwgdmFsdWUgaW4gY2F0ZWdvcnlBeGlzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpbUluZGV4ID09PSBjYXRlZ29yeUluZGV4XG4gICAgICAgICAgICAgICAgICAgID8gZGF0YUluZGV4XG4gICAgICAgICAgICAgICAgICAgIDogY29udmVyRGF0YVZhbHVlKGdldERhdGFJdGVtVmFsdWUoaXRlbU9wdCksIGRpbWVuc2lvbnNbZGltSW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGl0ZW1PcHQsIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXREYXRhSXRlbVZhbHVlKGl0ZW1PcHQpO1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBjb252ZXJEYXRhVmFsdWUodmFsdWUgJiYgdmFsdWVbZGltSW5kZXhdLCBkaW1lbnNpb25zW2RpbUluZGV4XSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW55IGRhdGFJdGVtIGlzIGxpa2UgeyB2YWx1ZTogMTAgfVxuICAgICAgICAgICAgICAgIGlmIChtb2RlbFV0aWwuaXNEYXRhSXRlbU9wdGlvbihpdGVtT3B0KSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0Lmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjYXRlZ29yeUF4ZXNNb2RlbHMgPSBheGVzSW5mbyAmJiBheGVzSW5mby5jYXRlZ29yeUF4ZXNNb2RlbHM7XG4gICAgICAgICAgICAgICAgaWYgKGNhdGVnb3J5QXhlc01vZGVscyAmJiBjYXRlZ29yeUF4ZXNNb2RlbHNbZGltTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZ2l2ZW4gdmFsdWUgaXMgYSBjYXRlZ29yeSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMYXp5IGdldCBjYXRlZ29yaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzW2RpbU5hbWVdID0gY2F0ZWdvcmllc1tkaW1OYW1lXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNhdGVnb3J5QXhlc01vZGVsc1tkaW1OYW1lXS5nZXRDYXRlZ29yaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB6clV0aWwuaW5kZXhPZihjYXRlZ29yaWVzW2RpbU5hbWVdLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA8IDAgJiYgIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHNvbWUgb25lIHdyaXRlICcxJywgJzInIGlzdGVhZCBvZiAxLCAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gK3ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBsaXN0Lmhhc0l0ZW1PcHRpb24gPSBmYWxzZTtcbiAgICAgICAgbGlzdC5pbml0RGF0YShkYXRhLCBuYW1lTGlzdCwgZGltVmFsdWVHZXR0ZXIpO1xuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RhY2thYmxlKGF4aXNUeXBlKSB7XG4gICAgICAgIHJldHVybiBheGlzVHlwZSAhPT0gJ2NhdGVnb3J5JyAmJiBheGlzVHlwZSAhPT0gJ3RpbWUnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERpbVR5cGVCeUF4aXMoYXhpc1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIGF4aXNUeXBlID09PSAnY2F0ZWdvcnknXG4gICAgICAgICAgICA/ICdvcmRpbmFsJ1xuICAgICAgICAgICAgOiBheGlzVHlwZSA9PT0gJ3RpbWUnXG4gICAgICAgICAgICA/ICd0aW1lJ1xuICAgICAgICAgICAgOiAnZmxvYXQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXJzIGZvciBlYWNoIGNvb3JkIHN5c3RlbS5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRvcnMgPSB7XG5cbiAgICAgICAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuXG4gICAgICAgICAgICB2YXIgYXhlc01vZGVscyA9IHpyVXRpbC5tYXAoWyd4QXhpcycsICd5QXhpcyddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgICAgICAgICAgIG1haW5UeXBlOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KG5hbWUgKyAnSW5kZXgnKSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNlcmllc01vZGVsLmdldChuYW1lICsgJ0lkJylcbiAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHhBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzBdO1xuICAgICAgICAgICAgdmFyIHlBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzFdO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGlmICgheEF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3hBeGlzIFwiJyArIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgneEF4aXNJbmRleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCd4QXhpc0lkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICkgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgheUF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3lBeGlzIFwiJyArIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgneEF4aXNJbmRleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCd5QXhpc0lkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICkgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgeEF4aXNUeXBlID0geEF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgICAgIHZhciB5QXhpc1R5cGUgPSB5QXhpc01vZGVsLmdldCgndHlwZScpO1xuXG4gICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0RGltVHlwZUJ5QXhpcyh4QXhpc1R5cGUpLFxuICAgICAgICAgICAgICAgICAgICBzdGFja2FibGU6IGlzU3RhY2thYmxlKHhBeGlzVHlwZSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3knLFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0d28gY2F0ZWdvcnkgYXhlc1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKHlBeGlzVHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoeUF4aXNUeXBlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHZhciBpc1hBeGlzQ2F0ZW9ncnkgPSB4QXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgICAgICAgICB2YXIgaXNZQXhpc0NhdGVnb3J5ID0geUF4aXNUeXBlID09PSAnY2F0ZWdvcnknO1xuXG4gICAgICAgICAgICBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwgWyd4JywgJ3knLCAneiddKTtcblxuICAgICAgICAgICAgdmFyIGNhdGVnb3J5QXhlc01vZGVscyA9IHt9O1xuICAgICAgICAgICAgaWYgKGlzWEF4aXNDYXRlb2dyeSkge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5QXhlc01vZGVscy54ID0geEF4aXNNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1lBeGlzQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMueSA9IHlBeGlzTW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlJbmRleDogaXNYQXhpc0NhdGVvZ3J5ID8gMCA6IChpc1lBeGlzQ2F0ZWdvcnkgPyAxIDogLTEpLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5QXhlc01vZGVsczogY2F0ZWdvcnlBeGVzTW9kZWxzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpbmdsZUF4aXM6IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuXG4gICAgICAgICAgICB2YXIgc2luZ2xlQXhpc01vZGVsID0gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICAgICAgICAgIG1haW5UeXBlOiAnc2luZ2xlQXhpcycsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHNlcmllc01vZGVsLmdldCgnc2luZ2xlQXhpc0luZGV4JyksXG4gICAgICAgICAgICAgICAgaWQ6IHNlcmllc01vZGVsLmdldCgnc2luZ2xlQXhpc0lkJylcbiAgICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGlmICghc2luZ2xlQXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2luZ2xlQXhpcyBzaG91bGQgYmUgc3BlY2lmaWVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNpbmdsZUF4aXNUeXBlID0gc2luZ2xlQXhpc01vZGVsLmdldCgndHlwZScpO1xuICAgICAgICAgICAgdmFyIGlzQ2F0ZWdvcnkgPSBzaW5nbGVBeGlzVHlwZSA9PT0gJ2NhdGVnb3J5JztcblxuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzaW5nbGUnLFxuICAgICAgICAgICAgICAgIHR5cGU6IGdldERpbVR5cGVCeUF4aXMoc2luZ2xlQXhpc1R5cGUpLFxuICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoc2luZ2xlQXhpc1R5cGUpXG4gICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgY29tcGxldGVEaW1lbnNpb25zKGRpbWVuc2lvbnMsIGRhdGEpO1xuXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcnlBeGVzTW9kZWxzID0ge307XG4gICAgICAgICAgICBpZiAoaXNDYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5QXhlc01vZGVscy5zaW5nbGUgPSBzaW5nbGVBeGlzTW9kZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUluZGV4OiBpc0NhdGVnb3J5ID8gMCA6IC0xLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5QXhlc01vZGVsczogY2F0ZWdvcnlBeGVzTW9kZWxzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvbGFyOiBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBwb2xhck1vZGVsID0gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICAgICAgICAgIG1haW5UeXBlOiAncG9sYXInLFxuICAgICAgICAgICAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQoJ3BvbGFySW5kZXgnKSxcbiAgICAgICAgICAgICAgICBpZDogc2VyaWVzTW9kZWwuZ2V0KCdwb2xhcklkJylcbiAgICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAgICAgICB2YXIgYW5nbGVBeGlzTW9kZWwgPSBwb2xhck1vZGVsLmZpbmRBeGlzTW9kZWwoJ2FuZ2xlQXhpcycpO1xuICAgICAgICAgICAgdmFyIHJhZGl1c0F4aXNNb2RlbCA9IHBvbGFyTW9kZWwuZmluZEF4aXNNb2RlbCgncmFkaXVzQXhpcycpO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGlmICghYW5nbGVBeGlzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbmdsZUF4aXMgb3B0aW9uIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJhZGl1c0F4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl1c0F4aXMgb3B0aW9uIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJhZGl1c0F4aXNUeXBlID0gcmFkaXVzQXhpc01vZGVsLmdldCgndHlwZScpO1xuICAgICAgICAgICAgdmFyIGFuZ2xlQXhpc1R5cGUgPSBhbmdsZUF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcblxuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmFkaXVzJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0RGltVHlwZUJ5QXhpcyhyYWRpdXNBeGlzVHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUocmFkaXVzQXhpc1R5cGUpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhbmdsZScsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGdldERpbVR5cGVCeUF4aXMoYW5nbGVBeGlzVHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoYW5nbGVBeGlzVHlwZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIGlzQW5nbGVBeGlzQ2F0ZW9ncnkgPSBhbmdsZUF4aXNUeXBlID09PSAnY2F0ZWdvcnknO1xuICAgICAgICAgICAgdmFyIGlzUmFkaXVzQXhpc0NhdGVvZ3J5ID0gcmFkaXVzQXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG5cbiAgICAgICAgICAgIGNvbXBsZXRlRGltZW5zaW9ucyhkaW1lbnNpb25zLCBkYXRhLCBbJ3JhZGl1cycsICdhbmdsZScsICd2YWx1ZSddKTtcblxuICAgICAgICAgICAgdmFyIGNhdGVnb3J5QXhlc01vZGVscyA9IHt9O1xuICAgICAgICAgICAgaWYgKGlzUmFkaXVzQXhpc0NhdGVvZ3J5KSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzLnJhZGl1cyA9IHJhZGl1c0F4aXNNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FuZ2xlQXhpc0NhdGVvZ3J5KSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzLmFuZ2xlID0gYW5nbGVBeGlzTW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlJbmRleDogaXNBbmdsZUF4aXNDYXRlb2dyeSA/IDEgOiAoaXNSYWRpdXNBeGlzQ2F0ZW9ncnkgPyAwIDogLTEpLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5QXhlc01vZGVsczogY2F0ZWdvcnlBeGVzTW9kZWxzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdlbzogZnVuY3Rpb24gKGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgICAgICAvLyBUT0RPIFJlZ2lvblxuICAgICAgICAgICAgLy8g5aSa5Liq5pWj54K55Zu+57O75YiX5Zyo5ZCM5LiA5Liq5Zyw5Yy655qE5pe25YCZXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IGNvbXBsZXRlRGltZW5zaW9ucyhbXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbG5nJ30sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbGF0J31cbiAgICAgICAgICAgICAgICBdLCBkYXRhLCBbJ2xuZycsICdsYXQnLCAndmFsdWUnXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlTmFtZUxpc3QocmVzdWx0LCBkYXRhKSB7XG4gICAgICAgIHZhciBuYW1lTGlzdCA9IFtdO1xuXG4gICAgICAgIHZhciBjYXRlZ29yeURpbSA9IHJlc3VsdCAmJiByZXN1bHQuZGltZW5zaW9uc1tyZXN1bHQuY2F0ZWdvcnlJbmRleF07XG4gICAgICAgIHZhciBjYXRlZ29yeUF4aXNNb2RlbDtcbiAgICAgICAgaWYgKGNhdGVnb3J5RGltKSB7XG4gICAgICAgICAgICBjYXRlZ29yeUF4aXNNb2RlbCA9IHJlc3VsdC5jYXRlZ29yeUF4ZXNNb2RlbHNbY2F0ZWdvcnlEaW0ubmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2F0ZWdvcnlBeGlzTW9kZWwpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIFR3byBjYXRlZ29yeSBheGlzXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IGNhdGVnb3J5QXhpc01vZGVsLmdldENhdGVnb3JpZXMoKTtcbiAgICAgICAgICAgIGlmIChjYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBPcmRlcmVkIGRhdGEgaXMgZ2l2ZW4gZXhwbGljaXRseSBsaWtlXG4gICAgICAgICAgICAgICAgLy8gW1szLCAwLjJdLCBbMSwgMC4zXSwgWzIsIDAuMTVdXVxuICAgICAgICAgICAgICAgIC8vIG9yIGdpdmVuIHNjYXR0ZXIgZGF0YSxcbiAgICAgICAgICAgICAgICAvLyBwaWNrIHRoZSBjYXRlZ29yeVxuICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaXNBcnJheShkYXRhWzBdKSAmJiBkYXRhWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVMaXN0W2ldID0gY2F0ZWdvcmllc1tkYXRhW2ldW3Jlc3VsdC5jYXRlZ29yeUluZGV4IHx8IDBdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUxpc3QgPSBjYXRlZ29yaWVzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lTGlzdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUxpc3RGcm9tQXJyYXk7XG5cbiIsIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vZWNoYXJ0cycpO1xuICAgIHZhciBQUklPUklUWSA9IGVjaGFydHMuUFJJT1JJVFk7XG5cbiAgICByZXF1aXJlKCcuL2xpbmUvTGluZVNlcmllcycpO1xuICAgIHJlcXVpcmUoJy4vbGluZS9MaW5lVmlldycpO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclZpc3VhbCh6clV0aWwuY3VycnkoXG4gICAgICAgIHJlcXVpcmUoJy4uL3Zpc3VhbC9zeW1ib2wnKSwgJ2xpbmUnLCAnY2lyY2xlJywgJ2xpbmUnXG4gICAgKSk7XG4gICAgZWNoYXJ0cy5yZWdpc3RlckxheW91dCh6clV0aWwuY3VycnkoXG4gICAgICAgIHJlcXVpcmUoJy4uL2xheW91dC9wb2ludHMnKSwgJ2xpbmUnXG4gICAgKSk7XG5cbiAgICAvLyBEb3duIHNhbXBsZSBhZnRlciBmaWx0ZXJcbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKFBSSU9SSVRZLlBST0NFU1NPUi5TVEFUSVNUSUMsIHpyVXRpbC5jdXJyeShcbiAgICAgICAgcmVxdWlyZSgnLi4vcHJvY2Vzc29yL2RhdGFTYW1wbGUnKSwgJ2xpbmUnXG4gICAgKSk7XG5cbiAgICAvLyBJbiBjYXNlIGRldmVsb3BlciBmb3JnZXQgdG8gaW5jbHVkZSBncmlkIGNvbXBvbmVudFxuICAgIHJlcXVpcmUoJy4uL2NvbXBvbmVudC9ncmlkJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBjcmVhdGVMaXN0RnJvbUFycmF5ID0gcmVxdWlyZSgnLi4vaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXknKTtcbiAgICB2YXIgU2VyaWVzTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9TZXJpZXMnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU2VyaWVzTW9kZWwuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnc2VyaWVzLmxpbmUnLFxuXG4gICAgICAgIGRlcGVuZGVuY2llczogWydncmlkJywgJ3BvbGFyJ10sXG5cbiAgICAgICAgZ2V0SW5pdGlhbERhdGE6IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gb3B0aW9uLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICAgICAgaWYgKGNvb3JkU3lzICE9PSAncG9sYXInICYmIGNvb3JkU3lzICE9PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGluZSBub3Qgc3VwcG9ydCBjb29yZGluYXRlU3lzdGVtIGJlc2lkZXMgY2FydGVzaWFuIGFuZCBwb2xhcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMaXN0RnJvbUFycmF5KG9wdGlvbi5kYXRhLCB0aGlzLCBlY01vZGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICB6bGV2ZWw6IDAsICAgICAgICAgICAgICAgICAgLy8g5LiA57qn5bGC5Y+gXG4gICAgICAgICAgICB6OiAyLCAgICAgICAgICAgICAgICAgICAgICAgLy8g5LqM57qn5bGC5Y+gXG4gICAgICAgICAgICBjb29yZGluYXRlU3lzdGVtOiAnY2FydGVzaWFuMmQnLFxuICAgICAgICAgICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuXG4gICAgICAgICAgICBob3ZlckFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIC8vIHN0YWNrOiBudWxsXG4gICAgICAgICAgICAvLyB4QXhpc0luZGV4OiAwLFxuICAgICAgICAgICAgLy8geUF4aXNJbmRleDogMCxcblxuICAgICAgICAgICAgLy8gcG9sYXJJbmRleDogMCxcblxuICAgICAgICAgICAgLy8gSWYgY2xpcCB0aGUgb3ZlcmZsb3cgdmFsdWVcbiAgICAgICAgICAgIGNsaXBPdmVyZmxvdzogdHJ1ZSxcblxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICd0b3AnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGl0ZW1TdHlsZToge1xuICAgICAgICAgICAgLy8gICAgIG5vcm1hbDoge30sXG4gICAgICAgICAgICAvLyAgICAgZW1waGFzaXM6IHt9XG4gICAgICAgICAgICAvLyB9LFxuICAgICAgICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc29saWQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGFyZWFTdHlsZToge30sXG4gICAgICAgICAgICAvLyBmYWxzZSwgJ3N0YXJ0JywgJ2VuZCcsICdtaWRkbGUnXG4gICAgICAgICAgICBzdGVwOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gRGlzYWJsZWQgaWYgc3RlcCBpcyB0cnVlXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxuICAgICAgICAgICAgc21vb3RoTW9ub3RvbmU6IG51bGwsXG4gICAgICAgICAgICAvLyDmi5Dngrnlm77lvaLnsbvlnotcbiAgICAgICAgICAgIHN5bWJvbDogJ2VtcHR5Q2lyY2xlJyxcbiAgICAgICAgICAgIC8vIOaLkOeCueWbvuW9ouWkp+Wwj1xuICAgICAgICAgICAgc3ltYm9sU2l6ZTogNCxcbiAgICAgICAgICAgIC8vIOaLkOeCueWbvuW9ouaXi+i9rOaOp+WItlxuICAgICAgICAgICAgc3ltYm9sUm90YXRlOiBudWxsLFxuXG4gICAgICAgICAgICAvLyDmmK/lkKbmmL7npLogc3ltYm9sLCDlj6rmnInlnKggdG9vbHRpcCBob3ZlciDnmoTml7blgJnmmL7npLpcbiAgICAgICAgICAgIHNob3dTeW1ib2w6IHRydWUsXG4gICAgICAgICAgICAvLyDmoIflv5flm77lvaLpu5jorqTlj6rmnInkuLvovbTmmL7npLrvvIjpmo/kuLvovbTmoIfnrb7pl7TpmpTpmpDol4/nrZbnlaXvvIlcbiAgICAgICAgICAgIHNob3dBbGxTeW1ib2w6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyDmmK/lkKbov57mjqXmlq3ngrlcbiAgICAgICAgICAgIGNvbm5lY3ROdWxsczogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIOaVsOaNrui/h+a7pO+8jCdhdmVyYWdlJywgJ21heCcsICdtaW4nLCAnc3VtJ1xuICAgICAgICAgICAgc2FtcGxpbmc6ICdub25lJyxcblxuICAgICAgICAgICAgYW5pbWF0aW9uRWFzaW5nOiAnbGluZWFyJyxcblxuICAgICAgICAgICAgLy8gRGlzYWJsZSBwcm9ncmVzc2l2ZVxuICAgICAgICAgICAgcHJvZ3Jlc3NpdmU6IDAsXG4gICAgICAgICAgICBob3ZlckxheWVyVGhyZXNob2xkOiBJbmZpbml0eVxuICAgICAgICB9XG4gICAgfSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBGSVhNRSBzdGVwIG5vdCBzdXBwb3J0IHBvbGFyXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgU3ltYm9sRHJhdyA9IHJlcXVpcmUoJy4uL2hlbHBlci9TeW1ib2xEcmF3Jyk7XG4gICAgdmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4uL2hlbHBlci9TeW1ib2wnKTtcbiAgICB2YXIgbGluZUFuaW1hdGlvbkRpZmYgPSByZXF1aXJlKCcuL2xpbmVBbmltYXRpb25EaWZmJyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBwb2x5SGVscGVyID0gcmVxdWlyZSgnLi9wb2x5Jyk7XG4gICAgdmFyIENoYXJ0VmlldyA9IHJlcXVpcmUoJy4uLy4uL3ZpZXcvQ2hhcnQnKTtcblxuICAgIGZ1bmN0aW9uIGlzUG9pbnRzU2FtZShwb2ludHMxLCBwb2ludHMyKSB7XG4gICAgICAgIGlmIChwb2ludHMxLmxlbmd0aCAhPT0gcG9pbnRzMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwMSA9IHBvaW50czFbaV07XG4gICAgICAgICAgICB2YXIgcDIgPSBwb2ludHMyW2ldO1xuICAgICAgICAgICAgaWYgKHAxWzBdICE9PSBwMlswXSB8fCBwMVsxXSAhPT0gcDJbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U21vb3RoKHNtb290aCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIChzbW9vdGgpID09PSAnbnVtYmVyJyA/IHNtb290aCA6IChzbW9vdGggPyAwLjMgOiAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBeGlzRXh0ZW50V2l0aEdhcChheGlzKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSBheGlzLmdldEdsb2JhbEV4dGVudCgpO1xuICAgICAgICBpZiAoYXhpcy5vbkJhbmQpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBleHRyYSAxcHggdG8gYXZvaWQgbGluZSBtaXRlciBpbiBjbGlwcGVkIGVkZ2VcbiAgICAgICAgICAgIHZhciBoYWxmQmFuZFdpZHRoID0gYXhpcy5nZXRCYW5kV2lkdGgoKSAvIDIgLSAxO1xuICAgICAgICAgICAgdmFyIGRpciA9IGV4dGVudFsxXSA+IGV4dGVudFswXSA/IDEgOiAtMTtcbiAgICAgICAgICAgIGV4dGVudFswXSArPSBkaXIgKiBoYWxmQmFuZFdpZHRoO1xuICAgICAgICAgICAgZXh0ZW50WzFdIC09IGRpciAqIGhhbGZCYW5kV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dGVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaWduKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID49IDAgPyAxIDogLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbjJEfG1vZHVsZTplY2hhcnRzL2Nvb3JkL3BvbGFyL1BvbGFyfSBjb29yZFN5c1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwb2ludHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFN0YWNrZWRPblBvaW50cyhjb29yZFN5cywgZGF0YSkge1xuICAgICAgICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICB2YXIgdmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKTtcbiAgICAgICAgdmFyIHZhbHVlU3RhcnQgPSBiYXNlQXhpcy5vblplcm9cbiAgICAgICAgICAgID8gMCA6IHZhbHVlQXhpcy5zY2FsZS5nZXRFeHRlbnQoKVswXTtcblxuICAgICAgICB2YXIgdmFsdWVEaW0gPSB2YWx1ZUF4aXMuZGltO1xuXG4gICAgICAgIHZhciBiYXNlRGF0YU9mZnNldCA9IHZhbHVlRGltID09PSAneCcgfHwgdmFsdWVEaW0gPT09ICdyYWRpdXMnID8gMSA6IDA7XG5cbiAgICAgICAgcmV0dXJuIGRhdGEubWFwQXJyYXkoW3ZhbHVlRGltXSwgZnVuY3Rpb24gKHZhbCwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgc3RhY2tlZE9uU2FtZVNpZ247XG4gICAgICAgICAgICB2YXIgc3RhY2tlZE9uID0gZGF0YS5zdGFja2VkT247XG4gICAgICAgICAgICAvLyBGaW5kIGZpcnN0IHN0YWNrZWQgdmFsdWUgd2l0aCBzYW1lIHNpZ25cbiAgICAgICAgICAgIHdoaWxlIChzdGFja2VkT24gJiZcbiAgICAgICAgICAgICAgICBzaWduKHN0YWNrZWRPbi5nZXQodmFsdWVEaW0sIGlkeCkpID09PSBzaWduKHZhbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHN0YWNrZWRPblNhbWVTaWduID0gc3RhY2tlZE9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YWNrZWREYXRhID0gW107XG4gICAgICAgICAgICBzdGFja2VkRGF0YVtiYXNlRGF0YU9mZnNldF0gPSBkYXRhLmdldChiYXNlQXhpcy5kaW0sIGlkeCk7XG4gICAgICAgICAgICBzdGFja2VkRGF0YVsxIC0gYmFzZURhdGFPZmZzZXRdID0gc3RhY2tlZE9uU2FtZVNpZ25cbiAgICAgICAgICAgICAgICA/IHN0YWNrZWRPblNhbWVTaWduLmdldCh2YWx1ZURpbSwgaWR4LCB0cnVlKSA6IHZhbHVlU3RhcnQ7XG5cbiAgICAgICAgICAgIHJldHVybiBjb29yZFN5cy5kYXRhVG9Qb2ludChzdGFja2VkRGF0YSk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUdyaWRDbGlwU2hhcGUoY2FydGVzaWFuLCBoYXNBbmltYXRpb24sIHNlcmllc01vZGVsKSB7XG4gICAgICAgIHZhciB4RXh0ZW50ID0gZ2V0QXhpc0V4dGVudFdpdGhHYXAoY2FydGVzaWFuLmdldEF4aXMoJ3gnKSk7XG4gICAgICAgIHZhciB5RXh0ZW50ID0gZ2V0QXhpc0V4dGVudFdpdGhHYXAoY2FydGVzaWFuLmdldEF4aXMoJ3knKSk7XG4gICAgICAgIHZhciBpc0hvcml6b250YWwgPSBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKS5pc0hvcml6b250YWwoKTtcblxuICAgICAgICB2YXIgeCA9IE1hdGgubWluKHhFeHRlbnRbMF0sIHhFeHRlbnRbMV0pO1xuICAgICAgICB2YXIgeSA9IE1hdGgubWluKHlFeHRlbnRbMF0sIHlFeHRlbnRbMV0pO1xuICAgICAgICB2YXIgd2lkdGggPSBNYXRoLm1heCh4RXh0ZW50WzBdLCB4RXh0ZW50WzFdKSAtIHg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLm1heCh5RXh0ZW50WzBdLCB5RXh0ZW50WzFdKSAtIHk7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBzZXJpZXNNb2RlbC5nZXQoJ2xpbmVTdHlsZS5ub3JtYWwud2lkdGgnKSB8fCAyO1xuICAgICAgICAvLyBFeHBhbmQgY2xpcCBzaGFwZSB0byBhdm9pZCBjbGlwcGluZyB3aGVuIGxpbmUgdmFsdWUgZXhjZWVkcyBheGlzXG4gICAgICAgIHZhciBleHBhbmRTaXplID0gc2VyaWVzTW9kZWwuZ2V0KCdjbGlwT3ZlcmZsb3cnKSA/IGxpbmVXaWR0aCAvIDIgOiBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgeSAtPSBleHBhbmRTaXplO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IGV4cGFuZFNpemUgKiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeCAtPSBleHBhbmRTaXplO1xuICAgICAgICAgICAgd2lkdGggKz0gZXhwYW5kU2l6ZSAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2xpcFBhdGggPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaGFzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBjbGlwUGF0aC5zaGFwZVtpc0hvcml6b250YWwgPyAnd2lkdGgnIDogJ2hlaWdodCddID0gMDtcbiAgICAgICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKGNsaXBQYXRoLCB7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGlwUGF0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQb2xhckNsaXBTaGFwZShwb2xhciwgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCkge1xuICAgICAgICB2YXIgYW5nbGVBeGlzID0gcG9sYXIuZ2V0QW5nbGVBeGlzKCk7XG4gICAgICAgIHZhciByYWRpdXNBeGlzID0gcG9sYXIuZ2V0UmFkaXVzQXhpcygpO1xuXG4gICAgICAgIHZhciByYWRpdXNFeHRlbnQgPSByYWRpdXNBeGlzLmdldEV4dGVudCgpO1xuICAgICAgICB2YXIgYW5nbGVFeHRlbnQgPSBhbmdsZUF4aXMuZ2V0RXh0ZW50KCk7XG5cbiAgICAgICAgdmFyIFJBRElBTiA9IE1hdGguUEkgLyAxODA7XG5cbiAgICAgICAgdmFyIGNsaXBQYXRoID0gbmV3IGdyYXBoaWMuU2VjdG9yKHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgY3g6IHBvbGFyLmN4LFxuICAgICAgICAgICAgICAgIGN5OiBwb2xhci5jeSxcbiAgICAgICAgICAgICAgICByMDogcmFkaXVzRXh0ZW50WzBdLFxuICAgICAgICAgICAgICAgIHI6IHJhZGl1c0V4dGVudFsxXSxcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiAtYW5nbGVFeHRlbnRbMF0gKiBSQURJQU4sXG4gICAgICAgICAgICAgICAgZW5kQW5nbGU6IC1hbmdsZUV4dGVudFsxXSAqIFJBRElBTixcbiAgICAgICAgICAgICAgICBjbG9ja3dpc2U6IGFuZ2xlQXhpcy5pbnZlcnNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChoYXNBbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNsaXBQYXRoLnNoYXBlLmVuZEFuZ2xlID0gLWFuZ2xlRXh0ZW50WzBdICogUkFESUFOO1xuICAgICAgICAgICAgZ3JhcGhpYy5pbml0UHJvcHMoY2xpcFBhdGgsIHtcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogLWFuZ2xlRXh0ZW50WzFdICogUkFESUFOXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsaXBQYXRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNsaXBTaGFwZShjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCkge1xuICAgICAgICByZXR1cm4gY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJ1xuICAgICAgICAgICAgPyBjcmVhdGVQb2xhckNsaXBTaGFwZShjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbClcbiAgICAgICAgICAgIDogY3JlYXRlR3JpZENsaXBTaGFwZShjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHVyblBvaW50c0ludG9TdGVwKHBvaW50cywgY29vcmRTeXMsIHN0ZXBUdXJuQXQpIHtcbiAgICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgdmFyIGJhc2VJbmRleCA9IGJhc2VBeGlzLmRpbSA9PT0gJ3gnIHx8IGJhc2VBeGlzLmRpbSA9PT0gJ3JhZGl1cycgPyAwIDogMTtcblxuICAgICAgICB2YXIgc3RlcFBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuZXh0UHQgPSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgc3RlcFBvaW50cy5wdXNoKHB0KTtcblxuICAgICAgICAgICAgdmFyIHN0ZXBQdCA9IFtdO1xuICAgICAgICAgICAgc3dpdGNoIChzdGVwVHVybkF0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgc3RlcFB0W2Jhc2VJbmRleF0gPSBuZXh0UHRbYmFzZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgc3RlcFB0WzEgLSBiYXNlSW5kZXhdID0gcHRbMSAtIGJhc2VJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgaXMgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgaXMgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pZGRsZSA9IChwdFtiYXNlSW5kZXhdICsgbmV4dFB0W2Jhc2VJbmRleF0pIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ZXBQdDIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgc3RlcFB0W2Jhc2VJbmRleF0gPSBzdGVwUHQyW2Jhc2VJbmRleF0gPSBtaWRkbGU7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBQdFsxIC0gYmFzZUluZGV4XSA9IHB0WzEgLSBiYXNlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBzdGVwUHQyWzEgLSBiYXNlSW5kZXhdID0gbmV4dFB0WzEgLSBiYXNlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBzdGVwUG9pbnRzLnB1c2goc3RlcFB0KTtcbiAgICAgICAgICAgICAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdDIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBzdGVwUHRbYmFzZUluZGV4XSA9IHB0W2Jhc2VJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBQdFsxIC0gYmFzZUluZGV4XSA9IG5leHRQdFsxIC0gYmFzZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBpcyBzdGFydFxuICAgICAgICAgICAgICAgICAgICBzdGVwUG9pbnRzLnB1c2goc3RlcFB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMYXN0IHBvaW50c1xuICAgICAgICBwb2ludHNbaV0gJiYgc3RlcFBvaW50cy5wdXNoKHBvaW50c1tpXSk7XG4gICAgICAgIHJldHVybiBzdGVwUG9pbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZpc3VhbEdyYWRpZW50KGRhdGEsIGNvb3JkU3lzKSB7XG4gICAgICAgIHZhciB2aXN1YWxNZXRhTGlzdCA9IGRhdGEuZ2V0VmlzdWFsKCd2aXN1YWxNZXRhJyk7XG4gICAgICAgIGlmICghdmlzdWFsTWV0YUxpc3QgfHwgIXZpc3VhbE1ldGFMaXN0Lmxlbmd0aCB8fCAhZGF0YS5jb3VudCgpKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGRhdGEuY291bnQoKSBpcyAwLCBncmFkaWVudCByYW5nZSBjYW4gbm90IGJlIGNhbGN1bGF0ZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmlzdWFsTWV0YTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHZpc3VhbE1ldGFMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAvLyBDYW4gb25seSBiZSB4IG9yIHlcbiAgICAgICAgICAgIGlmICh2aXN1YWxNZXRhTGlzdFtpXS5kaW1lbnNpb24gPCAyKSB7XG4gICAgICAgICAgICAgICAgdmlzdWFsTWV0YSA9IHZpc3VhbE1ldGFMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdmlzdWFsTWV0YSB8fCBjb29yZFN5cy50eXBlICE9PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVmlzdWFsIG1hcCBvbiBsaW5lIHN0eWxlIG9ubHkgc3VwcG9ydCB4IG9yIHkgZGltZW5zaW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGFyZWEgdG8gYmUgcmVuZGVyZWQgaXMgYmlnZ2VyIHRoYW4gYXJlYSBkZWZpbmVkIGJ5IExpbmVhckdyYWRpZW50LFxuICAgICAgICAvLyB0aGUgY2FudmFzIHNwZWMgcHJlc2NyaWJlcyB0aGF0IHRoZSBjb2xvciBvZiB0aGUgZmlyc3Qgc3RvcCBhbmQgdGhlIGxhc3RcbiAgICAgICAgLy8gc3RvcCBzaG91bGQgYmUgdXNlZC4gQnV0IGlmIHR3byBzdG9wcyBhcmUgYWRkZWQgYXQgb2Zmc2V0IDAsIGluIGVmZmVjdFxuICAgICAgICAvLyBicm93c2VycyB1c2UgdGhlIGNvbG9yIG9mIHRoZSBzZWNvbmQgc3RvcCB0byByZW5kZXIgYXJlYSBvdXRzaWRlXG4gICAgICAgIC8vIExpbmVhckdyYWRpZW50LiBTbyB3ZSBjYW4gb25seSBpbmZpbml0ZXNpbWFsbHkgZXh0ZW5kIGFyZWEgZGVmaW5lZCBpblxuICAgICAgICAvLyBMaW5lYXJHcmFkaWVudCB0byByZW5kZXIgYG91dGVyQ29sb3JzYC5cblxuICAgICAgICB2YXIgZGltZW5zaW9uID0gdmlzdWFsTWV0YS5kaW1lbnNpb247XG4gICAgICAgIHZhciBkaW1OYW1lID0gZGF0YS5kaW1lbnNpb25zW2RpbWVuc2lvbl07XG4gICAgICAgIHZhciBheGlzID0gY29vcmRTeXMuZ2V0QXhpcyhkaW1OYW1lKTtcblxuICAgICAgICAvLyBkYXRhVG9Db29yIG1hcHBpbmcgbWF5IG5vdCBiZSBsaW5lYXIsIGJ1dCBtdXN0IGJlIG1vbm90b25pYy5cbiAgICAgICAgdmFyIGNvbG9yU3RvcHMgPSB6clV0aWwubWFwKHZpc3VhbE1ldGEuc3RvcHMsIGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvb3JkOiBheGlzLnRvR2xvYmFsQ29vcmQoYXhpcy5kYXRhVG9Db29yZChzdG9wLnZhbHVlKSksXG4gICAgICAgICAgICAgICAgY29sb3I6IHN0b3AuY29sb3JcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc3RvcExlbiA9IGNvbG9yU3RvcHMubGVuZ3RoO1xuICAgICAgICB2YXIgb3V0ZXJDb2xvcnMgPSB2aXN1YWxNZXRhLm91dGVyQ29sb3JzLnNsaWNlKCk7XG5cbiAgICAgICAgaWYgKHN0b3BMZW4gJiYgY29sb3JTdG9wc1swXS5jb29yZCA+IGNvbG9yU3RvcHNbc3RvcExlbiAtIDFdLmNvb3JkKSB7XG4gICAgICAgICAgICBjb2xvclN0b3BzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIG91dGVyQ29sb3JzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aW55RXh0ZW50ID0gMTA7IC8vIEFyYml0cmFyeSB2YWx1ZTogMTBweFxuICAgICAgICB2YXIgbWluQ29vcmQgPSBjb2xvclN0b3BzWzBdLmNvb3JkIC0gdGlueUV4dGVudDtcbiAgICAgICAgdmFyIG1heENvb3JkID0gY29sb3JTdG9wc1tzdG9wTGVuIC0gMV0uY29vcmQgKyB0aW55RXh0ZW50O1xuICAgICAgICB2YXIgY29vcmRTcGFuID0gbWF4Q29vcmQgLSBtaW5Db29yZDtcblxuICAgICAgICBpZiAoY29vcmRTcGFuIDwgMWUtMykge1xuICAgICAgICAgICAgcmV0dXJuICd0cmFuc3BhcmVudCc7XG4gICAgICAgIH1cblxuICAgICAgICB6clV0aWwuZWFjaChjb2xvclN0b3BzLCBmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICAgICAgc3RvcC5vZmZzZXQgPSAoc3RvcC5jb29yZCAtIG1pbkNvb3JkKSAvIGNvb3JkU3BhbjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbG9yU3RvcHMucHVzaCh7XG4gICAgICAgICAgICBvZmZzZXQ6IHN0b3BMZW4gPyBjb2xvclN0b3BzW3N0b3BMZW4gLSAxXS5vZmZzZXQgOiAwLjUsXG4gICAgICAgICAgICBjb2xvcjogb3V0ZXJDb2xvcnNbMV0gfHwgJ3RyYW5zcGFyZW50J1xuICAgICAgICB9KTtcbiAgICAgICAgY29sb3JTdG9wcy51bnNoaWZ0KHsgLy8gbm90aWNlIGNvbG9yU3RvcHMubGVuZ3RoIGhhdmUgYmVlbiBjaGFuZ2VkLlxuICAgICAgICAgICAgb2Zmc2V0OiBzdG9wTGVuID8gY29sb3JTdG9wc1swXS5vZmZzZXQgOiAwLjUsXG4gICAgICAgICAgICBjb2xvcjogb3V0ZXJDb2xvcnNbMF0gfHwgJ3RyYW5zcGFyZW50J1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB6clV0aWwuZWFjaChjb2xvclN0b3BzLCBmdW5jdGlvbiAoY29sb3JTdG9wKSB7XG4gICAgICAgIC8vICAgICAvLyBNYWtlIHN1cmUgZWFjaCBvZmZzZXQgaGFzIHJvdW5kZWQgcHggdG8gYXZvaWQgbm90IHNoYXJwIGVkZ2VcbiAgICAgICAgLy8gICAgIGNvbG9yU3RvcC5vZmZzZXQgPSAoTWF0aC5yb3VuZChjb2xvclN0b3Aub2Zmc2V0ICogKGVuZCAtIHN0YXJ0KSArIHN0YXJ0KSAtIHN0YXJ0KSAvIChlbmQgLSBzdGFydCk7XG4gICAgICAgIC8vIH0pO1xuXG4gICAgICAgIHZhciBncmFkaWVudCA9IG5ldyBncmFwaGljLkxpbmVhckdyYWRpZW50KDAsIDAsIDAsIDAsIGNvbG9yU3RvcHMsIHRydWUpO1xuICAgICAgICBncmFkaWVudFtkaW1OYW1lXSA9IG1pbkNvb3JkO1xuICAgICAgICBncmFkaWVudFtkaW1OYW1lICsgJzInXSA9IG1heENvb3JkO1xuXG4gICAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENoYXJ0Vmlldy5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdsaW5lJyxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGluZUdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgICAgICAgICAgdmFyIHN5bWJvbERyYXcgPSBuZXcgU3ltYm9sRHJhdygpO1xuICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoc3ltYm9sRHJhdy5ncm91cCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3N5bWJvbERyYXcgPSBzeW1ib2xEcmF3O1xuICAgICAgICAgICAgdGhpcy5fbGluZUdyb3VwID0gbGluZUdyb3VwO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlLm5vcm1hbCcpO1xuICAgICAgICAgICAgdmFyIGFyZWFTdHlsZU1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZS5ub3JtYWwnKTtcblxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IGRhdGEubWFwQXJyYXkoZGF0YS5nZXRJdGVtTGF5b3V0LCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIGlzQ29vcmRTeXNQb2xhciA9IGNvb3JkU3lzLnR5cGUgPT09ICdwb2xhcic7XG4gICAgICAgICAgICB2YXIgcHJldkNvb3JkU3lzID0gdGhpcy5fY29vcmRTeXM7XG5cbiAgICAgICAgICAgIHZhciBzeW1ib2xEcmF3ID0gdGhpcy5fc3ltYm9sRHJhdztcbiAgICAgICAgICAgIHZhciBwb2x5bGluZSA9IHRoaXMuX3BvbHlsaW5lO1xuICAgICAgICAgICAgdmFyIHBvbHlnb24gPSB0aGlzLl9wb2x5Z29uO1xuXG4gICAgICAgICAgICB2YXIgbGluZUdyb3VwID0gdGhpcy5fbGluZUdyb3VwO1xuXG4gICAgICAgICAgICB2YXIgaGFzQW5pbWF0aW9uID0gc2VyaWVzTW9kZWwuZ2V0KCdhbmltYXRpb24nKTtcblxuICAgICAgICAgICAgdmFyIGlzQXJlYUNoYXJ0ID0gIWFyZWFTdHlsZU1vZGVsLmlzRW1wdHkoKTtcbiAgICAgICAgICAgIHZhciBzdGFja2VkT25Qb2ludHMgPSBnZXRTdGFja2VkT25Qb2ludHMoY29vcmRTeXMsIGRhdGEpO1xuXG4gICAgICAgICAgICB2YXIgc2hvd1N5bWJvbCA9IHNlcmllc01vZGVsLmdldCgnc2hvd1N5bWJvbCcpO1xuXG4gICAgICAgICAgICB2YXIgaXNTeW1ib2xJZ25vcmUgPSBzaG93U3ltYm9sICYmICFpc0Nvb3JkU3lzUG9sYXIgJiYgIXNlcmllc01vZGVsLmdldCgnc2hvd0FsbFN5bWJvbCcpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5fZ2V0U3ltYm9sSWdub3JlRnVuYyhkYXRhLCBjb29yZFN5cyk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0ZW1wb3Jhcnkgc3ltYm9sc1xuICAgICAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICAgICAgb2xkRGF0YSAmJiBvbGREYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLl9fdGVtcCkge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICAgICAgICAgICAgICBvbGREYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGNyZWF0ZWQgc3ltYm9scyBpZiBzaG93U3ltYm9sIGNoYW5nZWQgdG8gZmFsc2VcbiAgICAgICAgICAgIGlmICghc2hvd1N5bWJvbCkge1xuICAgICAgICAgICAgICAgIHN5bWJvbERyYXcucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLmFkZChsaW5lR3JvdXApO1xuXG4gICAgICAgICAgICAvLyBGSVhNRSBzdGVwIG5vdCBzdXBwb3J0IHBvbGFyXG4gICAgICAgICAgICB2YXIgc3RlcCA9ICFpc0Nvb3JkU3lzUG9sYXIgJiYgc2VyaWVzTW9kZWwuZ2V0KCdzdGVwJyk7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBhbmltYXRpb24gb3IgY29vcmRpbmF0ZSBzeXN0ZW0gY2hhbmdlZFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEocG9seWxpbmUgJiYgcHJldkNvb3JkU3lzLnR5cGUgPT09IGNvb3JkU3lzLnR5cGUgJiYgc3RlcCA9PT0gdGhpcy5fc3RlcClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNob3dTeW1ib2wgJiYgc3ltYm9sRHJhdy51cGRhdGVEYXRhKGRhdGEsIGlzU3ltYm9sSWdub3JlKTtcblxuICAgICAgICAgICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gSWYgc3RhY2tlZCBzZXJpZXMgaXMgbm90IHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgICAgICAgICBzdGFja2VkT25Qb2ludHMgPSB0dXJuUG9pbnRzSW50b1N0ZXAoc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgc3RlcCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9seWxpbmUgPSB0aGlzLl9uZXdQb2x5bGluZShwb2ludHMsIGNvb3JkU3lzLCBoYXNBbmltYXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChpc0FyZWFDaGFydCkge1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uID0gdGhpcy5fbmV3UG9seWdvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cywgc3RhY2tlZE9uUG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRTeXMsIGhhc0FuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lR3JvdXAuc2V0Q2xpcFBhdGgoY3JlYXRlQ2xpcFNoYXBlKGNvb3JkU3lzLCB0cnVlLCBzZXJpZXNNb2RlbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJlYUNoYXJ0ICYmICFwb2x5Z29uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGFyZWFTdHlsZSBpcyBhZGRlZFxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uID0gdGhpcy5fbmV3UG9seWdvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cywgc3RhY2tlZE9uUG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRTeXMsIGhhc0FuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwb2x5Z29uICYmICFpc0FyZWFDaGFydCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhcmVhU3R5bGUgaXMgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICBsaW5lR3JvdXAucmVtb3ZlKHBvbHlnb24pO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uID0gdGhpcy5fcG9seWdvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNsaXBQYXRoXG4gICAgICAgICAgICAgICAgbGluZUdyb3VwLnNldENsaXBQYXRoKGNyZWF0ZUNsaXBTaGFwZShjb29yZFN5cywgZmFsc2UsIHNlcmllc01vZGVsKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgdXBkYXRlLCBvciBpdCBpcyB3cm9uZyBpbiB0aGUgY2FzZSB0dXJuaW5nIG9uIGxlZ2VuZFxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgcG9pbnRzIGFyZSBub3QgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHNob3dTeW1ib2wgJiYgc3ltYm9sRHJhdy51cGRhdGVEYXRhKGRhdGEsIGlzU3ltYm9sSWdub3JlKTtcblxuICAgICAgICAgICAgICAgIC8vIFN0b3Agc3ltYm9sIGFuaW1hdGlvbiBhbmQgc3luYyB3aXRoIGxpbmUgcG9pbnRzXG4gICAgICAgICAgICAgICAgLy8gRklYTUUgcGVyZm9ybWFuY2U/XG4gICAgICAgICAgICAgICAgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc3RvcEFuaW1hdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIGRhdGEgem9vbSB0cmlnZ2VycmVkIHJlZnJlc2hpbmcgZnJlcXVlbnRseVxuICAgICAgICAgICAgICAgIC8vIERhdGEgbWF5IG5vdCBjaGFuZ2UgaWYgbGluZSBoYXMgYSBjYXRlZ29yeSBheGlzLiBTbyBpdCBzaG91bGQgYW5pbWF0ZSBub3RoaW5nXG4gICAgICAgICAgICAgICAgaWYgKCFpc1BvaW50c1NhbWUodGhpcy5fc3RhY2tlZE9uUG9pbnRzLCBzdGFja2VkT25Qb2ludHMpXG4gICAgICAgICAgICAgICAgICAgIHx8ICFpc1BvaW50c1NhbWUodGhpcy5fcG9pbnRzLCBwb2ludHMpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUFuaW1hdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLCBzdGFja2VkT25Qb2ludHMsIGNvb3JkU3lzLCBhcGksIHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgZG8gaXQgaW4gdXBkYXRlIHdpdGggYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gSWYgc3RhY2tlZCBzZXJpZXMgaXMgbm90IHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSB0dXJuUG9pbnRzSW50b1N0ZXAocG9pbnRzLCBjb29yZFN5cywgc3RlcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5bGluZS5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbiAmJiBwb2x5Z29uLnNldFNoYXBlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPblBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2aXN1YWxDb2xvciA9IGdldFZpc3VhbEdyYWRpZW50KGRhdGEsIGNvb3JkU3lzKSB8fCBkYXRhLmdldFZpc3VhbCgnY29sb3InKTtcblxuICAgICAgICAgICAgcG9seWxpbmUudXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgICAgIC8vIFVzZSBjb2xvciBpbiBsaW5lU3R5bGUgZmlyc3RcbiAgICAgICAgICAgICAgICBsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiB2aXN1YWxDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgbGluZUpvaW46ICdiZXZlbCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgdmFyIHNtb290aCA9IHNlcmllc01vZGVsLmdldCgnc21vb3RoJyk7XG4gICAgICAgICAgICBzbW9vdGggPSBnZXRTbW9vdGgoc2VyaWVzTW9kZWwuZ2V0KCdzbW9vdGgnKSk7XG4gICAgICAgICAgICBwb2x5bGluZS5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgc21vb3RoOiBzbW9vdGgsXG4gICAgICAgICAgICAgICAgc21vb3RoTW9ub3RvbmU6IHNlcmllc01vZGVsLmdldCgnc21vb3RoTW9ub3RvbmUnKSxcbiAgICAgICAgICAgICAgICBjb25uZWN0TnVsbHM6IHNlcmllc01vZGVsLmdldCgnY29ubmVjdE51bGxzJylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocG9seWdvbikge1xuICAgICAgICAgICAgICAgIHZhciBzdGFja2VkT24gPSBkYXRhLnN0YWNrZWRPbjtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uU21vb3RoID0gMDtcblxuICAgICAgICAgICAgICAgIHBvbHlnb24udXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgICAgICAgICBhcmVhU3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdmlzdWFsQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lSm9pbjogJ2JldmVsJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhY2tlZE9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFja2VkT25TZXJpZXMgPSBzdGFja2VkT24uaG9zdE1vZGVsO1xuICAgICAgICAgICAgICAgICAgICBzdGFja2VkT25TbW9vdGggPSBnZXRTbW9vdGgoc3RhY2tlZE9uU2VyaWVzLmdldCgnc21vb3RoJykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvbHlnb24uc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgICAgICBzbW9vdGg6IHNtb290aCxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uU21vb3RoOiBzdGFja2VkT25TbW9vdGgsXG4gICAgICAgICAgICAgICAgICAgIHNtb290aE1vbm90b25lOiBzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aE1vbm90b25lJyksXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3ROdWxsczogc2VyaWVzTW9kZWwuZ2V0KCdjb25uZWN0TnVsbHMnKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIGZvciB0cmFuc2l0aW9uIGFuaW1hdGlvbiB3aGVuIGRhdGEgY2hhbmdlZFxuICAgICAgICAgICAgdGhpcy5fY29vcmRTeXMgPSBjb29yZFN5cztcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrZWRPblBvaW50cyA9IHN0YWNrZWRPblBvaW50cztcbiAgICAgICAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIGhpZ2hsaWdodDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleChkYXRhLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgaWYgKCEoZGF0YUluZGV4IGluc3RhbmNlb2YgQXJyYXkpICYmIGRhdGFJbmRleCAhPSBudWxsICYmIGRhdGFJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBzeW1ib2wgaWYgaXQgaXMgbm90IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTnVsbCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbChkYXRhLCBkYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wucG9zaXRpb24gPSBwdDtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnNldFooXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXQoJ3psZXZlbCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCd6JylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmlnbm9yZSA9IGlzTmFOKHB0WzBdKSB8fCBpc05hTihwdFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5fX3RlbXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4LCBzeW1ib2wpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3Agc2NhbGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5zdG9wU3ltYm9sQW5pbWF0aW9uKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN5bWJvbC5oaWdobGlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEhpZ2hsaWdodCB3aG9sZSBzZXJpZXNcbiAgICAgICAgICAgICAgICBDaGFydFZpZXcucHJvdG90eXBlLmhpZ2hsaWdodC5jYWxsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkb3ducGxheTogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleChkYXRhLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIGlmIChkYXRhSW5kZXggIT0gbnVsbCAmJiBkYXRhSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW1ib2wuX190ZW1wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4LCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZG93bnBsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERvd25wbGF5IHdob2xlIHNlcmllc1xuICAgICAgICAgICAgICAgIENoYXJ0Vmlldy5wcm90b3R5cGUuZG93bnBsYXkuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgdGhpcywgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfSBncm91cFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHBvaW50c1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX25ld1BvbHlsaW5lOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICAgICAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjcmVhdGVkIHBvbHlsaW5lXG4gICAgICAgICAgICBpZiAocG9seWxpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lR3JvdXAucmVtb3ZlKHBvbHlsaW5lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9seWxpbmUgPSBuZXcgcG9seUhlbHBlci5Qb2x5bGluZSh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB6MjogMTBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLl9saW5lR3JvdXAuYWRkKHBvbHlsaW5lKTtcblxuICAgICAgICAgICAgdGhpcy5fcG9seWxpbmUgPSBwb2x5bGluZTtcblxuICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBzdGFja2VkT25Qb2ludHNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwb2ludHNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9uZXdQb2x5Z29uOiBmdW5jdGlvbiAocG9pbnRzLCBzdGFja2VkT25Qb2ludHMpIHtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0gdGhpcy5fcG9seWdvbjtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjcmVhdGVkIHBvbHlnb25cbiAgICAgICAgICAgIGlmIChwb2x5Z29uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZUdyb3VwLnJlbW92ZShwb2x5Z29uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9seWdvbiA9IG5ldyBwb2x5SGVscGVyLlBvbHlnb24oe1xuICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPblBvaW50c1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fbGluZUdyb3VwLmFkZChwb2x5Z29uKTtcblxuICAgICAgICAgICAgdGhpcy5fcG9seWdvbiA9IHBvbHlnb247XG4gICAgICAgICAgICByZXR1cm4gcG9seWdvbjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0U3ltYm9sSWdub3JlRnVuYzogZnVuY3Rpb24gKGRhdGEsIGNvb3JkU3lzKSB7XG4gICAgICAgICAgICB2YXIgY2F0ZWdvcnlBeGlzID0gY29vcmRTeXMuZ2V0QXhlc0J5U2NhbGUoJ29yZGluYWwnKVswXTtcbiAgICAgICAgICAgIC8vIGBnZXRMYWJlbEludGVydmFsYCBpcyBwcm92aWRlZCBieSBlY2hhcnRzL2NvbXBvbmVudC9heGlzXG4gICAgICAgICAgICBpZiAoY2F0ZWdvcnlBeGlzICYmIGNhdGVnb3J5QXhpcy5pc0xhYmVsSWdub3JlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6clV0aWwuYmluZChjYXRlZ29yeUF4aXMuaXNMYWJlbElnbm9yZWQsIGNhdGVnb3J5QXhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICAvLyBGSVhNRSBUd28gdmFsdWUgYXhpc1xuICAgICAgICBfdXBkYXRlQW5pbWF0aW9uOiBmdW5jdGlvbiAoZGF0YSwgc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgYXBpLCBzdGVwKSB7XG4gICAgICAgICAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0gdGhpcy5fcG9seWdvbjtcbiAgICAgICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuXG4gICAgICAgICAgICB2YXIgZGlmZiA9IGxpbmVBbmltYXRpb25EaWZmKFxuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEsIGRhdGEsXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tlZE9uUG9pbnRzLCBzdGFja2VkT25Qb2ludHMsXG4gICAgICAgICAgICAgICAgdGhpcy5fY29vcmRTeXMsIGNvb3JkU3lzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IGRpZmYuY3VycmVudDtcbiAgICAgICAgICAgIHZhciBzdGFja2VkT25DdXJyZW50ID0gZGlmZi5zdGFja2VkT25DdXJyZW50O1xuICAgICAgICAgICAgdmFyIG5leHQgPSBkaWZmLm5leHQ7XG4gICAgICAgICAgICB2YXIgc3RhY2tlZE9uTmV4dCA9IGRpZmYuc3RhY2tlZE9uTmV4dDtcbiAgICAgICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBJZiBzdGFja2VkIHNlcmllcyBpcyBub3Qgc3RlcFxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5jdXJyZW50LCBjb29yZFN5cywgc3RlcCk7XG4gICAgICAgICAgICAgICAgc3RhY2tlZE9uQ3VycmVudCA9IHR1cm5Qb2ludHNJbnRvU3RlcChkaWZmLnN0YWNrZWRPbkN1cnJlbnQsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgICAgICAgICAgICBuZXh0ID0gdHVyblBvaW50c0ludG9TdGVwKGRpZmYubmV4dCwgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgICAgIHN0YWNrZWRPbk5leHQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5zdGFja2VkT25OZXh0LCBjb29yZFN5cywgc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBgZGlmZi5jdXJyZW50YCBpcyBzdWJzZXQgb2YgYGN1cnJlbnRgICh3aGljaCBzaG91bGQgYmUgZW5zdXJlZCBieVxuICAgICAgICAgICAgLy8gdHVyblBvaW50c0ludG9TdGVwKSwgc28gcG9pbnRzIGluIGBfX3BvaW50c2AgY2FuIGJlIHVwZGF0ZWQgd2hlblxuICAgICAgICAgICAgLy8gcG9pbnRzIGluIGBjdXJyZW50YCBhcmUgdXBkYXRlIGR1cmluZyBhbmltYXRpb24uXG4gICAgICAgICAgICBwb2x5bGluZS5zaGFwZS5fX3BvaW50cyA9IGRpZmYuY3VycmVudDtcbiAgICAgICAgICAgIHBvbHlsaW5lLnNoYXBlLnBvaW50cyA9IGN1cnJlbnQ7XG5cbiAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocG9seWxpbmUsIHtcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IG5leHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCk7XG5cbiAgICAgICAgICAgIGlmIChwb2x5Z29uKSB7XG4gICAgICAgICAgICAgICAgcG9seWdvbi5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25DdXJyZW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2x5Z29uLCB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IG5leHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPbk5leHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHVwZGF0ZWREYXRhSW5mbyA9IFtdO1xuICAgICAgICAgICAgdmFyIGRpZmZTdGF0dXMgPSBkaWZmLnN0YXR1cztcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmU3RhdHVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNtZCA9IGRpZmZTdGF0dXNbaV0uY21kO1xuICAgICAgICAgICAgICAgIGlmIChjbWQgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGlmZlN0YXR1c1tpXS5pZHgxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkRGF0YUluZm8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWw6IGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB0SWR4OiBpICAgIC8vIEluZGV4IG9mIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb2x5bGluZS5hbmltYXRvcnMgJiYgcG9seWxpbmUuYW5pbWF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBvbHlsaW5lLmFuaW1hdG9yc1swXS5kdXJpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZWREYXRhSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdXBkYXRlZERhdGFJbmZvW2ldLmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuYXR0cigncG9zaXRpb24nLCBwb2x5bGluZS5zaGFwZS5fX3BvaW50c1t1cGRhdGVkRGF0YUluZm9baV0ucHRJZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgICAgICAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgICAgICB0aGlzLl9saW5lR3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICB0aGlzLl9zeW1ib2xEcmF3LnJlbW92ZSh0cnVlKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0ZW1wb3JhcnkgY3JlYXRlZCBlbGVtZW50cyB3aGVuIGhpZ2hsaWdodGluZ1xuICAgICAgICAgICAgb2xkRGF0YSAmJiBvbGREYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLl9fdGVtcCkge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICAgICAgICAgICAgICBvbGREYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fcG9seWxpbmUgPVxuICAgICAgICAgICAgdGhpcy5fcG9seWdvbiA9XG4gICAgICAgICAgICB0aGlzLl9jb29yZFN5cyA9XG4gICAgICAgICAgICB0aGlzLl9wb2ludHMgPVxuICAgICAgICAgICAgdGhpcy5fc3RhY2tlZE9uUG9pbnRzID1cbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSk7XG4iLCJcblxuICAgIC8vIHZhciBhcnJheURpZmYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2FycmF5RGlmZicpO1xuICAgIC8vICd6cmVuZGVyL2NvcmUvYXJyYXlEaWZmJyBoYXMgYmVlbiB1c2VkIGJlZm9yZSwgYnV0IGl0IGRpZFxuICAgIC8vIG5vdCBkbyB3ZWxsIGluIHBlcmZvcm1hbmNlIHdoZW4gcm9hbSB3aXRoIGZpeGVkIGRhdGFab29tIHdpbmRvdy5cblxuICAgIGZ1bmN0aW9uIHNpZ24odmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPj0gMCA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdGFja2VkT25Qb2ludChjb29yZFN5cywgZGF0YSwgaWR4KSB7XG4gICAgICAgIHZhciBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAgICAgIHZhciB2YWx1ZUF4aXMgPSBjb29yZFN5cy5nZXRPdGhlckF4aXMoYmFzZUF4aXMpO1xuICAgICAgICB2YXIgdmFsdWVTdGFydCA9IGJhc2VBeGlzLm9uWmVyb1xuICAgICAgICAgICAgPyAwIDogdmFsdWVBeGlzLnNjYWxlLmdldEV4dGVudCgpWzBdO1xuXG4gICAgICAgIHZhciB2YWx1ZURpbSA9IHZhbHVlQXhpcy5kaW07XG4gICAgICAgIHZhciBiYXNlRGF0YU9mZnNldCA9IHZhbHVlRGltID09PSAneCcgfHwgdmFsdWVEaW0gPT09ICdyYWRpdXMnID8gMSA6IDA7XG5cbiAgICAgICAgdmFyIHN0YWNrZWRPblNhbWVTaWduO1xuICAgICAgICB2YXIgc3RhY2tlZE9uID0gZGF0YS5zdGFja2VkT247XG4gICAgICAgIHZhciB2YWwgPSBkYXRhLmdldCh2YWx1ZURpbSwgaWR4KTtcbiAgICAgICAgLy8gRmluZCBmaXJzdCBzdGFja2VkIHZhbHVlIHdpdGggc2FtZSBzaWduXG4gICAgICAgIHdoaWxlIChzdGFja2VkT24gJiZcbiAgICAgICAgICAgIHNpZ24oc3RhY2tlZE9uLmdldCh2YWx1ZURpbSwgaWR4KSkgPT09IHNpZ24odmFsKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHN0YWNrZWRPblNhbWVTaWduID0gc3RhY2tlZE9uO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YWNrZWREYXRhID0gW107XG4gICAgICAgIHN0YWNrZWREYXRhW2Jhc2VEYXRhT2Zmc2V0XSA9IGRhdGEuZ2V0KGJhc2VBeGlzLmRpbSwgaWR4KTtcbiAgICAgICAgc3RhY2tlZERhdGFbMSAtIGJhc2VEYXRhT2Zmc2V0XSA9IHN0YWNrZWRPblNhbWVTaWduXG4gICAgICAgICAgICA/IHN0YWNrZWRPblNhbWVTaWduLmdldCh2YWx1ZURpbSwgaWR4LCB0cnVlKSA6IHZhbHVlU3RhcnQ7XG5cbiAgICAgICAgcmV0dXJuIGNvb3JkU3lzLmRhdGFUb1BvaW50KHN0YWNrZWREYXRhKTtcbiAgICB9XG5cbiAgICAvLyBmdW5jdGlvbiBjb252ZXJ0VG9JbnRJZChuZXdJZExpc3QsIG9sZElkTGlzdCkge1xuICAgIC8vICAgICAvLyBHZW5lcmF0ZSBpbnQgaWQgaW5zdGVhZCBvZiBzdHJpbmcgaWQuXG4gICAgLy8gICAgIC8vIENvbXBhcmUgc3RyaW5nIG1heWJlIHNsb3cgaW4gc2NvcmUgZnVuY3Rpb24gb2YgYXJyRGlmZlxuXG4gICAgLy8gICAgIC8vIEFzc3VtZSBpZCBpbiBpZExpc3QgYXJlIGFsbCB1bmlxdWVcbiAgICAvLyAgICAgdmFyIGlkSW5kaWNlc01hcCA9IHt9O1xuICAgIC8vICAgICB2YXIgaWR4ID0gMDtcbiAgICAvLyAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJZExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgICAgIGlkSW5kaWNlc01hcFtuZXdJZExpc3RbaV1dID0gaWR4O1xuICAgIC8vICAgICAgICAgbmV3SWRMaXN0W2ldID0gaWR4Kys7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRJZExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgICAgIHZhciBvbGRJZCA9IG9sZElkTGlzdFtpXTtcbiAgICAvLyAgICAgICAgIC8vIFNhbWUgd2l0aCBuZXdJZExpc3RcbiAgICAvLyAgICAgICAgIGlmIChpZEluZGljZXNNYXBbb2xkSWRdKSB7XG4gICAgLy8gICAgICAgICAgICAgb2xkSWRMaXN0W2ldID0gaWRJbmRpY2VzTWFwW29sZElkXTtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgICAgIGVsc2Uge1xuICAgIC8vICAgICAgICAgICAgIG9sZElkTGlzdFtpXSA9IGlkeCsrO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgZnVuY3Rpb24gZGlmZkRhdGEob2xkRGF0YSwgbmV3RGF0YSkge1xuICAgICAgICB2YXIgZGlmZlJlc3VsdCA9IFtdO1xuXG4gICAgICAgIG5ld0RhdGEuZGlmZihvbGREYXRhKVxuICAgICAgICAgICAgLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgZGlmZlJlc3VsdC5wdXNoKHtjbWQ6ICcrJywgaWR4OiBpZHh9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgICAgICAgICAgIGRpZmZSZXN1bHQucHVzaCh7Y21kOiAnPScsIGlkeDogb2xkSWR4LCBpZHgxOiBuZXdJZHh9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVtb3ZlKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICBkaWZmUmVzdWx0LnB1c2goe2NtZDogJy0nLCBpZHg6IGlkeH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5leGVjdXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIGRpZmZSZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoXG4gICAgICAgIG9sZERhdGEsIG5ld0RhdGEsXG4gICAgICAgIG9sZFN0YWNrZWRPblBvaW50cywgbmV3U3RhY2tlZE9uUG9pbnRzLFxuICAgICAgICBvbGRDb29yZFN5cywgbmV3Q29vcmRTeXNcbiAgICApIHtcbiAgICAgICAgdmFyIGRpZmYgPSBkaWZmRGF0YShvbGREYXRhLCBuZXdEYXRhKTtcblxuICAgICAgICAvLyB2YXIgbmV3SWRMaXN0ID0gbmV3RGF0YS5tYXBBcnJheShuZXdEYXRhLmdldElkKTtcbiAgICAgICAgLy8gdmFyIG9sZElkTGlzdCA9IG9sZERhdGEubWFwQXJyYXkob2xkRGF0YS5nZXRJZCk7XG5cbiAgICAgICAgLy8gY29udmVydFRvSW50SWQobmV3SWRMaXN0LCBvbGRJZExpc3QpO1xuXG4gICAgICAgIC8vIC8vIEZJWE1FIE9uZSBkYXRhID9cbiAgICAgICAgLy8gZGlmZiA9IGFycmF5RGlmZihvbGRJZExpc3QsIG5ld0lkTGlzdCk7XG5cbiAgICAgICAgdmFyIGN1cnJQb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIG5leHRQb2ludHMgPSBbXTtcbiAgICAgICAgLy8gUG9pbnRzIGZvciBzdGFja2luZyBiYXNlIGxpbmVcbiAgICAgICAgdmFyIGN1cnJTdGFja2VkUG9pbnRzID0gW107XG4gICAgICAgIHZhciBuZXh0U3RhY2tlZFBvaW50cyA9IFtdO1xuXG4gICAgICAgIHZhciBzdGF0dXMgPSBbXTtcbiAgICAgICAgdmFyIHNvcnRlZEluZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIHJhd0luZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIGRpbXMgPSBuZXdDb29yZFN5cy5kaW1lbnNpb25zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaWZmSXRlbSA9IGRpZmZbaV07XG4gICAgICAgICAgICB2YXIgcG9pbnRBZGRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FLCBhbmltYXRpb24gaXMgbm90IHNvIHBlcmZlY3Qgd2hlbiBkYXRhWm9vbSB3aW5kb3cgbW92ZXMgZmFzdFxuICAgICAgICAgICAgLy8gV2hpY2ggaXMgaW4gY2FzZSByZW12b2luZyBvciBhZGQgbW9yZSB0aGFuIG9uZSBkYXRhIGluIHRoZSB0YWlsIG9yIGhlYWRcbiAgICAgICAgICAgIHN3aXRjaCAoZGlmZkl0ZW0uY21kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UHQgPSBvbGREYXRhLmdldEl0ZW1MYXlvdXQoZGlmZkl0ZW0uaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRQdCA9IG5ld0RhdGEuZ2V0SXRlbUxheW91dChkaWZmSXRlbS5pZHgxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJldmlvdXMgZGF0YSBpcyBOYU4sIHVzZSBuZXh0IHBvaW50IGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihjdXJyZW50UHRbMF0pIHx8IGlzTmFOKGN1cnJlbnRQdFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQdCA9IG5leHRQdC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJQb2ludHMucHVzaChjdXJyZW50UHQpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9pbnRzLnB1c2gobmV4dFB0KTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyU3RhY2tlZFBvaW50cy5wdXNoKG9sZFN0YWNrZWRPblBvaW50c1tkaWZmSXRlbS5pZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YWNrZWRQb2ludHMucHVzaChuZXdTdGFja2VkT25Qb2ludHNbZGlmZkl0ZW0uaWR4MV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJhd0luZGljZXMucHVzaChuZXdEYXRhLmdldFJhd0luZGV4KGRpZmZJdGVtLmlkeDEpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBkaWZmSXRlbS5pZHg7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJQb2ludHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZENvb3JkU3lzLmRhdGFUb1BvaW50KFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhLmdldChkaW1zWzBdLCBpZHgsIHRydWUpLCBuZXdEYXRhLmdldChkaW1zWzFdLCBpZHgsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIG5leHRQb2ludHMucHVzaChuZXdEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KS5zbGljZSgpKTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyU3RhY2tlZFBvaW50cy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RhY2tlZE9uUG9pbnQob2xkQ29vcmRTeXMsIG5ld0RhdGEsIGlkeClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YWNrZWRQb2ludHMucHVzaChuZXdTdGFja2VkT25Qb2ludHNbaWR4XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmF3SW5kaWNlcy5wdXNoKG5ld0RhdGEuZ2V0UmF3SW5kZXgoaWR4KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gZGlmZkl0ZW0uaWR4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SW5kZXggPSBvbGREYXRhLmdldFJhd0luZGV4KGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERhdGEgaXMgcmVwbGFjZWQuIEluIHRoZSBjYXNlIG9mIGR5bmFtaWMgZGF0YSBxdWV1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBGSVhNRSBGSVhNRVxuICAgICAgICAgICAgICAgICAgICBpZiAocmF3SW5kZXggIT09IGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyclBvaW50cy5wdXNoKG9sZERhdGEuZ2V0SXRlbUxheW91dChpZHgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb2ludHMucHVzaChuZXdDb29yZFN5cy5kYXRhVG9Qb2ludChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkRGF0YS5nZXQoZGltc1swXSwgaWR4LCB0cnVlKSwgb2xkRGF0YS5nZXQoZGltc1sxXSwgaWR4LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyU3RhY2tlZFBvaW50cy5wdXNoKG9sZFN0YWNrZWRPblBvaW50c1tpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGFja2VkUG9pbnRzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RhY2tlZE9uUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Nvb3JkU3lzLCBvbGREYXRhLCBpZHhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdJbmRpY2VzLnB1c2gocmF3SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRBZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGluZGljZXNcbiAgICAgICAgICAgIGlmIChwb2ludEFkZGVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnB1c2goZGlmZkl0ZW0pO1xuICAgICAgICAgICAgICAgIHNvcnRlZEluZGljZXMucHVzaChzb3J0ZWRJbmRpY2VzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaWZmIHJlc3VsdCBtYXkgYmUgY3Jvc3NlZCBpZiBhbGwgaXRlbXMgYXJlIGNoYW5nZWRcbiAgICAgICAgLy8gU29ydCBieSBkYXRhIGluZGV4XG4gICAgICAgIHNvcnRlZEluZGljZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHJhd0luZGljZXNbYV0gLSByYXdJbmRpY2VzW2JdO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc29ydGVkQ3VyclBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgc29ydGVkTmV4dFBvaW50cyA9IFtdO1xuXG4gICAgICAgIHZhciBzb3J0ZWRDdXJyU3RhY2tlZFBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgc29ydGVkTmV4dFN0YWNrZWRQb2ludHMgPSBbXTtcblxuICAgICAgICB2YXIgc29ydGVkU3RhdHVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc29ydGVkSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHNvcnRlZEluZGljZXNbaV07XG4gICAgICAgICAgICBzb3J0ZWRDdXJyUG9pbnRzW2ldID0gY3VyclBvaW50c1tpZHhdO1xuICAgICAgICAgICAgc29ydGVkTmV4dFBvaW50c1tpXSA9IG5leHRQb2ludHNbaWR4XTtcblxuICAgICAgICAgICAgc29ydGVkQ3VyclN0YWNrZWRQb2ludHNbaV0gPSBjdXJyU3RhY2tlZFBvaW50c1tpZHhdO1xuICAgICAgICAgICAgc29ydGVkTmV4dFN0YWNrZWRQb2ludHNbaV0gPSBuZXh0U3RhY2tlZFBvaW50c1tpZHhdO1xuXG4gICAgICAgICAgICBzb3J0ZWRTdGF0dXNbaV0gPSBzdGF0dXNbaWR4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50OiBzb3J0ZWRDdXJyUG9pbnRzLFxuICAgICAgICAgICAgbmV4dDogc29ydGVkTmV4dFBvaW50cyxcblxuICAgICAgICAgICAgc3RhY2tlZE9uQ3VycmVudDogc29ydGVkQ3VyclN0YWNrZWRQb2ludHMsXG4gICAgICAgICAgICBzdGFja2VkT25OZXh0OiBzb3J0ZWROZXh0U3RhY2tlZFBvaW50cyxcblxuICAgICAgICAgICAgc3RhdHVzOiBzb3J0ZWRTdGF0dXNcbiAgICAgICAgfTtcbiAgICB9O1xuIiwiLy8gUG9seSBwYXRoIHN1cHBvcnQgTmFOIHBvaW50XG5cblxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xuXG4gICAgdmFyIHZlYzJNaW4gPSB2ZWMyLm1pbjtcbiAgICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuXG4gICAgdmFyIHNjYWxlQW5kQWRkID0gdmVjMi5zY2FsZUFuZEFkZDtcbiAgICB2YXIgdjJDb3B5ID0gdmVjMi5jb3B5O1xuXG4gICAgLy8gVGVtcG9yYXJ5IHZhcmlhYmxlXG4gICAgdmFyIHYgPSBbXTtcbiAgICB2YXIgY3AwID0gW107XG4gICAgdmFyIGNwMSA9IFtdO1xuXG4gICAgZnVuY3Rpb24gaXNQb2ludE51bGwocCkge1xuICAgICAgICByZXR1cm4gaXNOYU4ocFswXSkgfHwgaXNOYU4ocFsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1NlZ21lbnQoXG4gICAgICAgIGN0eCwgcG9pbnRzLCBzdGFydCwgc2VnTGVuLCBhbGxMZW4sXG4gICAgICAgIGRpciwgc21vb3RoTWluLCBzbW9vdGhNYXgsIHNtb290aCwgc21vb3RoTW9ub3RvbmUsIGNvbm5lY3ROdWxsc1xuICAgICkge1xuICAgICAgICB2YXIgcHJldklkeCA9IDA7XG4gICAgICAgIHZhciBpZHggPSBzdGFydDtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzZWdMZW47IGsrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNbaWR4XTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gYWxsTGVuIHx8IGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1BvaW50TnVsbChwKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWR4ICs9IGRpcjtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaWR4ID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIGN0eFtkaXIgPiAwID8gJ21vdmVUbycgOiAnbGluZVRvJ10ocFswXSwgcFsxXSk7XG4gICAgICAgICAgICAgICAgdjJDb3B5KGNwMCwgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dElkeCA9IGlkeCArIGRpcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRQID0gcG9pbnRzW25leHRJZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIG5leHQgcG9pbnQgbm90IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0UCAmJiBpc1BvaW50TnVsbChwb2ludHNbbmV4dElkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dElkeCArPSBkaXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFAgPSBwb2ludHNbbmV4dElkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW9OZXh0U2VnID0gMC41O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlAgPSBwb2ludHNbcHJldklkeF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0UCA9IHBvaW50c1tuZXh0SWR4XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGFzdCBwb2ludFxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHRQIHx8IGlzUG9pbnROdWxsKG5leHRQKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdjJDb3B5KGNwMSwgcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuZXh0IGRhdGEgaXMgbnVsbCBpbiBub3QgY29ubmVjdCBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQb2ludE51bGwobmV4dFApICYmICFjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0UCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuc3ViKHYsIG5leHRQLCBwcmV2UCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5QcmV2U2VnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbk5leHRTZWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc21vb3RoTW9ub3RvbmUgPT09ICd4JyB8fCBzbW9vdGhNb25vdG9uZSA9PT0gJ3knKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpbSA9IHNtb290aE1vbm90b25lID09PSAneCcgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5QcmV2U2VnID0gTWF0aC5hYnMocFtkaW1dIC0gcHJldlBbZGltXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuTmV4dFNlZyA9IE1hdGguYWJzKHBbZGltXSAtIG5leHRQW2RpbV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuUHJldlNlZyA9IHZlYzIuZGlzdChwLCBwcmV2UCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuTmV4dFNlZyA9IHZlYzIuZGlzdChwLCBuZXh0UCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSByYXRpbyBvZiBzZWcgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICByYXRpb05leHRTZWcgPSBsZW5OZXh0U2VnIC8gKGxlbk5leHRTZWcgKyBsZW5QcmV2U2VnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVBbmRBZGQoY3AxLCBwLCB2LCAtc21vb3RoICogKDEgLSByYXRpb05leHRTZWcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTbW9vdGggY29uc3RyYWludFxuICAgICAgICAgICAgICAgICAgICB2ZWMyTWluKGNwMCwgY3AwLCBzbW9vdGhNYXgpO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyTWF4KGNwMCwgY3AwLCBzbW9vdGhNaW4pO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyTWluKGNwMSwgY3AxLCBzbW9vdGhNYXgpO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyTWF4KGNwMSwgY3AxLCBzbW9vdGhNaW4pO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3AwWzBdLCBjcDBbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcDFbMF0sIGNwMVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBbMF0sIHBbMV1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3AwIG9mIG5leHQgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICBzY2FsZUFuZEFkZChjcDAsIHAsIHYsIHNtb290aCAqIHJhdGlvTmV4dFNlZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBbMF0sIHBbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldklkeCA9IGlkeDtcbiAgICAgICAgICAgIGlkeCArPSBkaXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveChwb2ludHMsIHNtb290aENvbnN0cmFpbnQpIHtcbiAgICAgICAgdmFyIHB0TWluID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gICAgICAgIHZhciBwdE1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIGlmIChzbW9vdGhDb25zdHJhaW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocHRbMF0gPCBwdE1pblswXSkgeyBwdE1pblswXSA9IHB0WzBdOyB9XG4gICAgICAgICAgICAgICAgaWYgKHB0WzFdIDwgcHRNaW5bMV0pIHsgcHRNaW5bMV0gPSBwdFsxXTsgfVxuICAgICAgICAgICAgICAgIGlmIChwdFswXSA+IHB0TWF4WzBdKSB7IHB0TWF4WzBdID0gcHRbMF07IH1cbiAgICAgICAgICAgICAgICBpZiAocHRbMV0gPiBwdE1heFsxXSkgeyBwdE1heFsxXSA9IHB0WzFdOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbjogc21vb3RoQ29uc3RyYWludCA/IHB0TWluIDogcHRNYXgsXG4gICAgICAgICAgICBtYXg6IHNtb290aENvbnN0cmFpbnQgPyBwdE1heCA6IHB0TWluXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgUG9seWxpbmU6IFBhdGguZXh0ZW5kKHtcblxuICAgICAgICAgICAgdHlwZTogJ2VjLXBvbHlsaW5lJyxcblxuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICBwb2ludHM6IFtdLFxuXG4gICAgICAgICAgICAgICAgc21vb3RoOiAwLFxuXG4gICAgICAgICAgICAgICAgc21vb3RoQ29uc3RyYWludDogdHJ1ZSxcblxuICAgICAgICAgICAgICAgIHNtb290aE1vbm90b25lOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgY29ubmVjdE51bGxzOiBmYWxzZVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmaWxsOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGdldEJvdW5kaW5nQm94KHBvaW50cywgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11c3QgcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IG51bGwgdmFsdWVzIGF2b2lkIGRyYXcgZXJyb3IgaW4gcG9seWdvblxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2xlbiAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gZHJhd1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsIHBvaW50cywgaSwgbGVuLCBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAxLCByZXN1bHQubWluLCByZXN1bHQubWF4LCBzaGFwZS5zbW9vdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5zbW9vdGhNb25vdG9uZSwgc2hhcGUuY29ubmVjdE51bGxzXG4gICAgICAgICAgICAgICAgICAgICkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG5cbiAgICAgICAgUG9seWdvbjogUGF0aC5leHRlbmQoe1xuXG4gICAgICAgICAgICB0eXBlOiAnZWMtcG9seWdvbicsXG5cbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXSxcblxuICAgICAgICAgICAgICAgIC8vIE9mZnNldCBiZXR3ZWVuIHN0YWNrZWQgYmFzZSBwb2ludHMgYW5kIHBvaW50c1xuICAgICAgICAgICAgICAgIHN0YWNrZWRPblBvaW50czogW10sXG5cbiAgICAgICAgICAgICAgICBzbW9vdGg6IDAsXG5cbiAgICAgICAgICAgICAgICBzdGFja2VkT25TbW9vdGg6IDAsXG5cbiAgICAgICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiB0cnVlLFxuXG4gICAgICAgICAgICAgICAgc21vb3RoTW9ub3RvbmU6IG51bGwsXG5cbiAgICAgICAgICAgICAgICBjb25uZWN0TnVsbHM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uUG9pbnRzID0gc2hhcGUuc3RhY2tlZE9uUG9pbnRzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBzbW9vdGhNb25vdG9uZSA9IHNoYXBlLnNtb290aE1vbm90b25lO1xuICAgICAgICAgICAgICAgIHZhciBiYm94ID0gZ2V0Qm91bmRpbmdCb3gocG9pbnRzLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50KTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uQkJveCA9IGdldEJvdW5kaW5nQm94KHN0YWNrZWRPblBvaW50cywgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11c3QgcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IG51bGwgdmFsdWVzIGF2b2lkIGRyYXcgZXJyb3IgaW4gcG9seWdvblxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2xlbiAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gZHJhd1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsIHBvaW50cywgaSwgbGVuLCBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAxLCBiYm94Lm1pbiwgYmJveC5tYXgsIHNoYXBlLnNtb290aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aE1vbm90b25lLCBzaGFwZS5jb25uZWN0TnVsbHNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZHJhd1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsIHN0YWNrZWRPblBvaW50cywgaSArIGsgLSAxLCBrLCBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAtMSwgc3RhY2tlZE9uQkJveC5taW4sIHN0YWNrZWRPbkJCb3gubWF4LCBzaGFwZS5zdGFja2VkT25TbW9vdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhNb25vdG9uZSwgc2hhcGUuY29ubmVjdE51bGxzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gayArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9O1xuIiwiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGVjaGFydHMgPSByZXF1aXJlKCcuLi9lY2hhcnRzJyk7XG5cbiAgICByZXF1aXJlKCcuL3BpZS9QaWVTZXJpZXMnKTtcbiAgICByZXF1aXJlKCcuL3BpZS9QaWVWaWV3Jyk7XG5cbiAgICByZXF1aXJlKCcuLi9hY3Rpb24vY3JlYXRlRGF0YVNlbGVjdEFjdGlvbicpKCdwaWUnLCBbe1xuICAgICAgICB0eXBlOiAncGllVG9nZ2xlU2VsZWN0JyxcbiAgICAgICAgZXZlbnQ6ICdwaWVzZWxlY3RjaGFuZ2VkJyxcbiAgICAgICAgbWV0aG9kOiAndG9nZ2xlU2VsZWN0ZWQnXG4gICAgfSwge1xuICAgICAgICB0eXBlOiAncGllU2VsZWN0JyxcbiAgICAgICAgZXZlbnQ6ICdwaWVzZWxlY3RlZCcsXG4gICAgICAgIG1ldGhvZDogJ3NlbGVjdCdcbiAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdwaWVVblNlbGVjdCcsXG4gICAgICAgIGV2ZW50OiAncGlldW5zZWxlY3RlZCcsXG4gICAgICAgIG1ldGhvZDogJ3VuU2VsZWN0J1xuICAgIH1dKTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJWaXN1YWwoenJVdGlsLmN1cnJ5KHJlcXVpcmUoJy4uL3Zpc3VhbC9kYXRhQ29sb3InKSwgJ3BpZScpKTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJMYXlvdXQoenJVdGlsLmN1cnJ5KFxuICAgICAgICByZXF1aXJlKCcuL3BpZS9waWVMYXlvdXQnKSwgJ3BpZSdcbiAgICApKTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJQcm9jZXNzb3IoenJVdGlsLmN1cnJ5KHJlcXVpcmUoJy4uL3Byb2Nlc3Nvci9kYXRhRmlsdGVyJyksICdwaWUnKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBMaXN0ID0gcmVxdWlyZSgnLi4vLi4vZGF0YS9MaXN0Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIGNvbXBsZXRlRGltZW5zaW9ucyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9ucycpO1xuXG4gICAgdmFyIGRhdGFTZWxlY3RhYmxlTWl4aW4gPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnQvaGVscGVyL3NlbGVjdGFibGVNaXhpbicpO1xuXG4gICAgdmFyIFBpZVNlcmllcyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRTZXJpZXNNb2RlbCh7XG5cbiAgICAgICAgdHlwZTogJ3Nlcmllcy5waWUnLFxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZVxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICBQaWVTZXJpZXMuc3VwZXJBcHBseSh0aGlzLCAnaW5pdCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIC8vIEVuYWJsZSBsZWdlbmQgc2VsZWN0aW9uIGZvciBlYWNoIGRhdGEgaXRlbVxuICAgICAgICAgICAgLy8gVXNlIGEgZnVuY3Rpb24gaW5zdGVhZCBvZiBkaXJlY3QgYWNjZXNzIGJlY2F1c2UgZGF0YSByZWZlcmVuY2UgbWF5IGNoYW5nZWRcbiAgICAgICAgICAgIHRoaXMubGVnZW5kRGF0YVByb3ZpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhd0RhdGEoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRNYXAob3B0aW9uLmRhdGEpO1xuXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0TGFiZWxMaW5lKG9wdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gT3ZlcndyaXRlXG4gICAgICAgIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAobmV3T3B0aW9uKSB7XG4gICAgICAgICAgICBQaWVTZXJpZXMuc3VwZXJDYWxsKHRoaXMsICdtZXJnZU9wdGlvbicsIG5ld09wdGlvbik7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkTWFwKHRoaXMub3B0aW9uLmRhdGEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEluaXRpYWxEYXRhOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGNvbXBsZXRlRGltZW5zaW9ucyhbJ3ZhbHVlJ10sIG9wdGlvbi5kYXRhKTtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gbmV3IExpc3QoZGltZW5zaW9ucywgdGhpcyk7XG4gICAgICAgICAgICBsaXN0LmluaXREYXRhKG9wdGlvbi5kYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZVxuICAgICAgICBnZXREYXRhUGFyYW1zOiBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFBpZVNlcmllcy5zdXBlckNhbGwodGhpcywgJ2dldERhdGFQYXJhbXMnLCBkYXRhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIHN1bSA9IGRhdGEuZ2V0U3VtKCd2YWx1ZScpO1xuICAgICAgICAgICAgLy8gRklYTUUgdG9GaXhlZD9cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBQZXJjZW50IGlzIDAgaWYgc3VtIGlzIDBcbiAgICAgICAgICAgIHBhcmFtcy5wZXJjZW50ID0gIXN1bSA/IDAgOiArKGRhdGEuZ2V0KCd2YWx1ZScsIGRhdGFJbmRleCkgLyBzdW0gKiAxMDApLnRvRml4ZWQoMik7XG5cbiAgICAgICAgICAgIHBhcmFtcy4kdmFycy5wdXNoKCdwZXJjZW50Jyk7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kZWZhdWx0TGFiZWxMaW5lOiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICAvLyBFeHRlbmQgbGFiZWxMaW5lIGVtcGhhc2lzXG4gICAgICAgICAgICBtb2RlbFV0aWwuZGVmYXVsdEVtcGhhc2lzKG9wdGlvbi5sYWJlbExpbmUsIFsnc2hvdyddKTtcblxuICAgICAgICAgICAgdmFyIGxhYmVsTGluZU5vcm1hbE9wdCA9IG9wdGlvbi5sYWJlbExpbmUubm9ybWFsO1xuICAgICAgICAgICAgdmFyIGxhYmVsTGluZUVtcGhhc2lzT3B0ID0gb3B0aW9uLmxhYmVsTGluZS5lbXBoYXNpcztcbiAgICAgICAgICAgIC8vIE5vdCBzaG93IGxhYmVsIGxpbmUgaWYgYGxhYmVsLm5vcm1hbC5zaG93ID0gZmFsc2VgXG4gICAgICAgICAgICBsYWJlbExpbmVOb3JtYWxPcHQuc2hvdyA9IGxhYmVsTGluZU5vcm1hbE9wdC5zaG93XG4gICAgICAgICAgICAgICAgJiYgb3B0aW9uLmxhYmVsLm5vcm1hbC5zaG93O1xuICAgICAgICAgICAgbGFiZWxMaW5lRW1waGFzaXNPcHQuc2hvdyA9IGxhYmVsTGluZUVtcGhhc2lzT3B0LnNob3dcbiAgICAgICAgICAgICAgICAmJiBvcHRpb24ubGFiZWwuZW1waGFzaXMuc2hvdztcbiAgICAgICAgfSxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICB6bGV2ZWw6IDAsXG4gICAgICAgICAgICB6OiAyLFxuICAgICAgICAgICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuXG4gICAgICAgICAgICBob3ZlckFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIC8vIOm7mOiupOWFqOWxgOWxheS4rVxuICAgICAgICAgICAgY2VudGVyOiBbJzUwJScsICc1MCUnXSxcbiAgICAgICAgICAgIHJhZGl1czogWzAsICc3NSUnXSxcbiAgICAgICAgICAgIC8vIOm7mOiupOmhuuaXtumSiFxuICAgICAgICAgICAgY2xvY2t3aXNlOiB0cnVlLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogOTAsXG4gICAgICAgICAgICAvLyDmnIDlsI/op5LluqbmlLnkuLowXG4gICAgICAgICAgICBtaW5BbmdsZTogMCxcbiAgICAgICAgICAgIC8vIOmAieS4reaYr+aJh+WMuuWBj+enu+mHj1xuICAgICAgICAgICAgc2VsZWN0ZWRPZmZzZXQ6IDEwLFxuXG4gICAgICAgICAgICAvLyBJZiB1c2Ugc3RyYXRlZ3kgdG8gYXZvaWQgbGFiZWwgb3ZlcmxhcHBpbmdcbiAgICAgICAgICAgIGF2b2lkTGFiZWxPdmVybGFwOiB0cnVlLFxuICAgICAgICAgICAgLy8g6YCJ5oup5qih5byP77yM6buY6K6k5YWz6Zet77yM5Y+v6YCJc2luZ2xl77yMbXVsdGlwbGVcbiAgICAgICAgICAgIC8vIHNlbGVjdGVkTW9kZTogZmFsc2UsXG4gICAgICAgICAgICAvLyDljZfkuIHmoLzlsJTnjqvnkbDlm77mqKHlvI/vvIwncmFkaXVzJ++8iOWNiuW+hO+8iSB8ICdhcmVhJ++8iOmdouenr++8iVxuICAgICAgICAgICAgLy8gcm9zZVR5cGU6IG51bGwsXG5cbiAgICAgICAgICAgIC8vIElmIHN0aWxsIHNob3cgd2hlbiBhbGwgZGF0YSB6ZXJvLlxuICAgICAgICAgICAgc3RpbGxTaG93WmVyb1N1bTogdHJ1ZSxcblxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgcm90YXRlIGFyb3VuZCBjaXJjbGVcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gJ291dGVyJywgJ2luc2lkZScsICdjZW50ZXInXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnb3V0ZXInXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcm1hdHRlcjog5qCH562+5paH5pys5qC85byP5Zmo77yM5ZCMVG9vbHRpcC5mb3JtYXR0ZXLvvIzkuI3mlK/mjIHlvILmraXlm57osINcbiAgICAgICAgICAgICAgICAgICAgLy8gdGV4dFN0eWxlOiBudWxsICAgICAgLy8g6buY6K6k5L2/55So5YWo5bGA5paH5pys5qC35byP77yM6K+m6KeBVEVYVFNUWUxFXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc3RhbmNlOiDlvZNwb3NpdGlvbuS4umlubmVy5pe25pyJ5pWI77yM5Li6bGFiZWzkvY3nva7liLDlnIblv4PnmoTot53nprvkuI7lnIbljYrlvoQo546v54q25Zu+5Li65YaF5aSW5Y2K5b6E5ZKMKeeahOavlOS+i+ezu+aVsFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW1waGFzaXM6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gRW5hYmxlZCB3aGVuIGxhYmVsLm5vcm1hbC5wb3NpdGlvbiBpcyAnb3V0ZXInXG4gICAgICAgICAgICBsYWJlbExpbmU6IHtcbiAgICAgICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8g5byV5a+857q/5Lik5q615Lit55qE56ys5LiA5q616ZW/5bqmXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogMTUsXG4gICAgICAgICAgICAgICAgICAgIC8vIOW8leWvvOe6v+S4pOauteS4reeahOesrOS6jOautemVv+W6plxuICAgICAgICAgICAgICAgICAgICBsZW5ndGgyOiAxNSxcbiAgICAgICAgICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb2xvcjog5ZCE5byCLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc29saWQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbXBoYXNpczoge31cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbiB0eXBlIGNhbmJlIGV4cGFuc2lvbiwgc2NhbGVcbiAgICAgICAgICAgIGFuaW1hdGlvblR5cGU6ICdleHBhbnNpb24nLFxuXG4gICAgICAgICAgICBhbmltYXRpb25FYXNpbmc6ICdjdWJpY091dCcsXG5cbiAgICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHpyVXRpbC5taXhpbihQaWVTZXJpZXMsIGRhdGFTZWxlY3RhYmxlTWl4aW4pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQaWVTZXJpZXM7XG4iLCJcblxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBoYXNBbmltYXRpb25cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVEYXRhU2VsZWN0ZWQodWlkLCBzZXJpZXNNb2RlbCwgaGFzQW5pbWF0aW9uLCBhcGkpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSB0aGlzLmRhdGFJbmRleDtcbiAgICAgICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4KTtcbiAgICAgICAgdmFyIHNlbGVjdGVkT2Zmc2V0ID0gc2VyaWVzTW9kZWwuZ2V0KCdzZWxlY3RlZE9mZnNldCcpO1xuXG4gICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAncGllVG9nZ2xlU2VsZWN0JyxcbiAgICAgICAgICAgIGZyb206IHVpZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBzZXJpZXNJZDogc2VyaWVzTW9kZWwuaWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIHRvZ2dsZUl0ZW1TZWxlY3RlZChcbiAgICAgICAgICAgICAgICBkYXRhLmdldEl0ZW1HcmFwaGljRWwoaWR4KSxcbiAgICAgICAgICAgICAgICBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSxcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5pc1NlbGVjdGVkKGRhdGEuZ2V0TmFtZShpZHgpKSxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZE9mZnNldCxcbiAgICAgICAgICAgICAgICBoYXNBbmltYXRpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TZWN0b3J9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxheW91dFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZWxlY3RlZE9mZnNldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzQW5pbWF0aW9uXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9nZ2xlSXRlbVNlbGVjdGVkKGVsLCBsYXlvdXQsIGlzU2VsZWN0ZWQsIHNlbGVjdGVkT2Zmc2V0LCBoYXNBbmltYXRpb24pIHtcbiAgICAgICAgdmFyIG1pZEFuZ2xlID0gKGxheW91dC5zdGFydEFuZ2xlICsgbGF5b3V0LmVuZEFuZ2xlKSAvIDI7XG5cbiAgICAgICAgdmFyIGR4ID0gTWF0aC5jb3MobWlkQW5nbGUpO1xuICAgICAgICB2YXIgZHkgPSBNYXRoLnNpbihtaWRBbmdsZSk7XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IGlzU2VsZWN0ZWQgPyBzZWxlY3RlZE9mZnNldCA6IDA7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IFtkeCAqIG9mZnNldCwgZHkgKiBvZmZzZXRdO1xuXG4gICAgICAgIGhhc0FuaW1hdGlvblxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvIHdpbGwgc3RvcCByZXZpb3VzIGFuaW1hdGlvbiBsaWtlIHVwZGF0ZSB0cmFuc2l0aW9uXG4gICAgICAgICAgICA/IGVsLmFuaW1hdGUoKVxuICAgICAgICAgICAgICAgIC53aGVuKDIwMCwge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5zdGFydCgnYm91bmNlT3V0JylcbiAgICAgICAgICAgIDogZWwuYXR0cigncG9zaXRpb24nLCBwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGllY2Ugb2YgcGllIGluY2x1ZGluZyBTZWN0b3IsIExhYmVsLCBMYWJlbExpbmVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9Hcm91cH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQaWVQaWVjZShkYXRhLCBpZHgpIHtcblxuICAgICAgICBncmFwaGljLkdyb3VwLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdmFyIHNlY3RvciA9IG5ldyBncmFwaGljLlNlY3Rvcih7XG4gICAgICAgICAgICB6MjogMlxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBvbHlsaW5lID0gbmV3IGdyYXBoaWMuUG9seWxpbmUoKTtcbiAgICAgICAgdmFyIHRleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KCk7XG4gICAgICAgIHRoaXMuYWRkKHNlY3Rvcik7XG4gICAgICAgIHRoaXMuYWRkKHBvbHlsaW5lKTtcbiAgICAgICAgdGhpcy5hZGQodGV4dCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKGRhdGEsIGlkeCwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gSG92ZXIgdG8gY2hhbmdlIGxhYmVsIGFuZCBsYWJlbExpbmVcbiAgICAgICAgZnVuY3Rpb24gb25FbXBoYXNpcygpIHtcbiAgICAgICAgICAgIHBvbHlsaW5lLmlnbm9yZSA9IHBvbHlsaW5lLmhvdmVySWdub3JlO1xuICAgICAgICAgICAgdGV4dC5pZ25vcmUgPSB0ZXh0LmhvdmVySWdub3JlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uTm9ybWFsKCkge1xuICAgICAgICAgICAgcG9seWxpbmUuaWdub3JlID0gcG9seWxpbmUubm9ybWFsSWdub3JlO1xuICAgICAgICAgICAgdGV4dC5pZ25vcmUgPSB0ZXh0Lm5vcm1hbElnbm9yZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uKCdlbXBoYXNpcycsIG9uRW1waGFzaXMpXG4gICAgICAgICAgICAub24oJ25vcm1hbCcsIG9uTm9ybWFsKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBvbkVtcGhhc2lzKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIG9uTm9ybWFsKTtcbiAgICB9XG5cbiAgICB2YXIgcGllUGllY2VQcm90byA9IFBpZVBpZWNlLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGdldExhYmVsU3R5bGUoZGF0YSwgaWR4LCBzdGF0ZSwgbGFiZWxNb2RlbCwgbGFiZWxQb3NpdGlvbikge1xuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICAgICAgdmFyIGlzTGFiZWxJbnNpZGUgPSBsYWJlbFBvc2l0aW9uID09PSAnaW5zaWRlJyB8fCBsYWJlbFBvc2l0aW9uID09PSAnaW5uZXInO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKClcbiAgICAgICAgICAgICAgICB8fCAoaXNMYWJlbEluc2lkZSA/ICcjZmZmJyA6IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpKSxcbiAgICAgICAgICAgIG9wYWNpdHk6IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdvcGFjaXR5JyksXG4gICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgdGV4dDogenJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgIGRhdGEuaG9zdE1vZGVsLmdldEZvcm1hdHRlZExhYmVsKGlkeCwgc3RhdGUpLCBkYXRhLmdldE5hbWUoaWR4KVxuICAgICAgICAgICAgKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBpZVBpZWNlUHJvdG8udXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBpZHgsIGZpcnN0Q3JlYXRlKSB7XG5cbiAgICAgICAgdmFyIHNlY3RvciA9IHRoaXMuY2hpbGRBdCgwKTtcblxuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICAgICAgdmFyIHNlY3RvclNoYXBlID0genJVdGlsLmV4dGVuZCh7fSwgbGF5b3V0KTtcbiAgICAgICAgc2VjdG9yU2hhcGUubGFiZWwgPSBudWxsO1xuXG4gICAgICAgIGlmIChmaXJzdENyZWF0ZSkge1xuICAgICAgICAgICAgc2VjdG9yLnNldFNoYXBlKHNlY3RvclNoYXBlKTtcblxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvblR5cGUgPSBzZXJpZXNNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25UeXBlJyk7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gJ3NjYWxlJykge1xuICAgICAgICAgICAgICAgIHNlY3Rvci5zaGFwZS5yID0gbGF5b3V0LnIwO1xuICAgICAgICAgICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKHNlY3Rvciwge1xuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcjogbGF5b3V0LnJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXhwYW5zaW9uXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWN0b3Iuc2hhcGUuZW5kQW5nbGUgPSBsYXlvdXQuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHNlY3Rvciwge1xuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQW5nbGU6IGxheW91dC5lbmRBbmdsZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoc2VjdG9yLCB7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHNlY3RvclNoYXBlXG4gICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBjb21tb24gc3R5bGVcbiAgICAgICAgdmFyIGl0ZW1TdHlsZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKTtcbiAgICAgICAgdmFyIHZpc3VhbENvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJyk7XG5cbiAgICAgICAgc2VjdG9yLnVzZVN0eWxlKFxuICAgICAgICAgICAgenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZUpvaW46ICdiZXZlbCcsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IHZpc3VhbENvbG9yXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpdGVtU3R5bGVNb2RlbC5nZXRNb2RlbCgnbm9ybWFsJykuZ2V0SXRlbVN0eWxlKClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgc2VjdG9yLmhvdmVyU3R5bGUgPSBpdGVtU3R5bGVNb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKS5nZXRJdGVtU3R5bGUoKTtcblxuICAgICAgICAvLyBUb2dnbGUgc2VsZWN0ZWRcbiAgICAgICAgdG9nZ2xlSXRlbVNlbGVjdGVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGRhdGEuZ2V0SXRlbUxheW91dChpZHgpLFxuICAgICAgICAgICAgaXRlbU1vZGVsLmdldCgnc2VsZWN0ZWQnKSxcbiAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgnc2VsZWN0ZWRPZmZzZXQnKSxcbiAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgnYW5pbWF0aW9uJylcbiAgICAgICAgKTtcblxuICAgICAgICBmdW5jdGlvbiBvbkVtcGhhc2lzKCkge1xuICAgICAgICAgICAgLy8gU2VjdG9yIG1heSBoYXMgYW5pbWF0aW9uIG9mIHVwZGF0aW5nIGRhdGEuIEZvcmNlIHRvIG1vdmUgdG8gdGhlIGxhc3QgZnJhbWVcbiAgICAgICAgICAgIC8vIE9yIGl0IG1heSBzdG9wcGVkIG9uIHRoZSB3cm9uZyBzaGFwZVxuICAgICAgICAgICAgc2VjdG9yLnN0b3BBbmltYXRpb24odHJ1ZSk7XG4gICAgICAgICAgICBzZWN0b3IuYW5pbWF0ZVRvKHtcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICByOiBsYXlvdXQuciArIDEwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMzAwLCAnZWxhc3RpY091dCcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uTm9ybWFsKCkge1xuICAgICAgICAgICAgc2VjdG9yLnN0b3BBbmltYXRpb24odHJ1ZSk7XG4gICAgICAgICAgICBzZWN0b3IuYW5pbWF0ZVRvKHtcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICByOiBsYXlvdXQuclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDMwMCwgJ2VsYXN0aWNPdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0b3Iub2ZmKCdtb3VzZW92ZXInKS5vZmYoJ21vdXNlb3V0Jykub2ZmKCdlbXBoYXNpcycpLm9mZignbm9ybWFsJyk7XG4gICAgICAgIGlmIChpdGVtTW9kZWwuZ2V0KCdob3ZlckFuaW1hdGlvbicpICYmIHNlcmllc01vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBzZWN0b3JcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIG9uRW1waGFzaXMpXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIG9uTm9ybWFsKVxuICAgICAgICAgICAgICAgIC5vbignZW1waGFzaXMnLCBvbkVtcGhhc2lzKVxuICAgICAgICAgICAgICAgIC5vbignbm9ybWFsJywgb25Ob3JtYWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlTGFiZWwoZGF0YSwgaWR4KTtcblxuICAgICAgICBncmFwaGljLnNldEhvdmVyU3R5bGUodGhpcyk7XG4gICAgfTtcblxuICAgIHBpZVBpZWNlUHJvdG8uX3VwZGF0ZUxhYmVsID0gZnVuY3Rpb24gKGRhdGEsIGlkeCkge1xuXG4gICAgICAgIHZhciBsYWJlbExpbmUgPSB0aGlzLmNoaWxkQXQoMSk7XG4gICAgICAgIHZhciBsYWJlbFRleHQgPSB0aGlzLmNoaWxkQXQoMik7XG5cbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgIHZhciBsYWJlbExheW91dCA9IGxheW91dC5sYWJlbDtcbiAgICAgICAgdmFyIHZpc3VhbENvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJyk7XG5cbiAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhsYWJlbExpbmUsIHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgcG9pbnRzOiBsYWJlbExheW91dC5saW5lUG9pbnRzIHx8IFtcbiAgICAgICAgICAgICAgICAgICAgW2xhYmVsTGF5b3V0LngsIGxhYmVsTGF5b3V0LnldLCBbbGFiZWxMYXlvdXQueCwgbGFiZWxMYXlvdXQueV0sIFtsYWJlbExheW91dC54LCBsYWJlbExheW91dC55XVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG5cbiAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhsYWJlbFRleHQsIHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgeDogbGFiZWxMYXlvdXQueCxcbiAgICAgICAgICAgICAgICB5OiBsYWJlbExheW91dC55XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICAgICAgICBsYWJlbFRleHQuYXR0cih7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiBsYWJlbExheW91dC52ZXJ0aWNhbEFsaWduLFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogbGFiZWxMYXlvdXQudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgIHRleHRGb250OiBsYWJlbExheW91dC5mb250XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm90YXRpb246IGxhYmVsTGF5b3V0LnJvdGF0aW9uLFxuICAgICAgICAgICAgb3JpZ2luOiBbbGFiZWxMYXlvdXQueCwgbGFiZWxMYXlvdXQueV0sXG4gICAgICAgICAgICB6MjogMTBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLm5vcm1hbCcpO1xuICAgICAgICB2YXIgbGFiZWxIb3Zlck1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5lbXBoYXNpcycpO1xuICAgICAgICB2YXIgbGFiZWxMaW5lTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsTGluZS5ub3JtYWwnKTtcbiAgICAgICAgdmFyIGxhYmVsTGluZUhvdmVyTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsTGluZS5lbXBoYXNpcycpO1xuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0KCdwb3NpdGlvbicpIHx8IGxhYmVsSG92ZXJNb2RlbC5nZXQoJ3Bvc2l0aW9uJyk7XG5cbiAgICAgICAgbGFiZWxUZXh0LnNldFN0eWxlKGdldExhYmVsU3R5bGUoZGF0YSwgaWR4LCAnbm9ybWFsJywgbGFiZWxNb2RlbCwgbGFiZWxQb3NpdGlvbikpO1xuXG4gICAgICAgIGxhYmVsVGV4dC5pZ25vcmUgPSBsYWJlbFRleHQubm9ybWFsSWdub3JlID0gIWxhYmVsTW9kZWwuZ2V0KCdzaG93Jyk7XG4gICAgICAgIGxhYmVsVGV4dC5ob3Zlcklnbm9yZSA9ICFsYWJlbEhvdmVyTW9kZWwuZ2V0KCdzaG93Jyk7XG5cbiAgICAgICAgbGFiZWxMaW5lLmlnbm9yZSA9IGxhYmVsTGluZS5ub3JtYWxJZ25vcmUgPSAhbGFiZWxMaW5lTW9kZWwuZ2V0KCdzaG93Jyk7XG4gICAgICAgIGxhYmVsTGluZS5ob3Zlcklnbm9yZSA9ICFsYWJlbExpbmVIb3Zlck1vZGVsLmdldCgnc2hvdycpO1xuXG4gICAgICAgIC8vIERlZmF1bHQgdXNlIGl0ZW0gdmlzdWFsIGNvbG9yXG4gICAgICAgIGxhYmVsTGluZS5zZXRTdHlsZSh7XG4gICAgICAgICAgICBzdHJva2U6IHZpc3VhbENvbG9yLFxuICAgICAgICAgICAgb3BhY2l0eTogZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ29wYWNpdHknKVxuICAgICAgICB9KTtcbiAgICAgICAgbGFiZWxMaW5lLnNldFN0eWxlKGxhYmVsTGluZU1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKSk7XG5cbiAgICAgICAgbGFiZWxUZXh0LmhvdmVyU3R5bGUgPSBnZXRMYWJlbFN0eWxlKGRhdGEsIGlkeCwgJ2VtcGhhc2lzJywgbGFiZWxIb3Zlck1vZGVsLCBsYWJlbFBvc2l0aW9uKTtcbiAgICAgICAgbGFiZWxMaW5lLmhvdmVyU3R5bGUgPSBsYWJlbExpbmVIb3Zlck1vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKTtcblxuICAgICAgICB2YXIgc21vb3RoID0gbGFiZWxMaW5lTW9kZWwuZ2V0KCdzbW9vdGgnKTtcbiAgICAgICAgaWYgKHNtb290aCAmJiBzbW9vdGggPT09IHRydWUpIHtcbiAgICAgICAgICAgIHNtb290aCA9IDAuNDtcbiAgICAgICAgfVxuICAgICAgICBsYWJlbExpbmUuc2V0U2hhcGUoe1xuICAgICAgICAgICAgc21vb3RoOiBzbW9vdGhcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhQaWVQaWVjZSwgZ3JhcGhpYy5Hcm91cCk7XG5cblxuICAgIC8vIFBpZSB2aWV3XG4gICAgdmFyIFBpZSA9IHJlcXVpcmUoJy4uLy4uL3ZpZXcvQ2hhcnQnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdwaWUnLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWN0b3JHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgICAgICAgICB0aGlzLl9zZWN0b3JHcm91cCA9IHNlY3Rvckdyb3VwO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkICYmIChwYXlsb2FkLmZyb20gPT09IHRoaXMudWlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuXG4gICAgICAgICAgICB2YXIgaGFzQW5pbWF0aW9uID0gZWNNb2RlbC5nZXQoJ2FuaW1hdGlvbicpO1xuICAgICAgICAgICAgdmFyIGlzRmlyc3RSZW5kZXIgPSAhb2xkRGF0YTtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25UeXBlID0gc2VyaWVzTW9kZWwuZ2V0KCdhbmltYXRpb25UeXBlJyk7XG5cbiAgICAgICAgICAgIHZhciBvblNlY3RvckNsaWNrID0genJVdGlsLmN1cnJ5KFxuICAgICAgICAgICAgICAgIHVwZGF0ZURhdGFTZWxlY3RlZCwgdGhpcy51aWQsIHNlcmllc01vZGVsLCBoYXNBbmltYXRpb24sIGFwaVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkTW9kZSA9IHNlcmllc01vZGVsLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG5cbiAgICAgICAgICAgIGRhdGEuZGlmZihvbGREYXRhKVxuICAgICAgICAgICAgICAgIC5hZGQoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGllUGllY2UgPSBuZXcgUGllUGllY2UoZGF0YSwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBleHBhbnNpb24gYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0UmVuZGVyICYmIGFuaW1hdGlvblR5cGUgIT09ICdzY2FsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpZVBpZWNlLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE1vZGUgJiYgcGllUGllY2Uub24oJ2NsaWNrJywgb25TZWN0b3JDbGljayk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgcGllUGllY2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFkZChwaWVQaWVjZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGllUGllY2UgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcblxuICAgICAgICAgICAgICAgICAgICBwaWVQaWVjZS51cGRhdGVEYXRhKGRhdGEsIG5ld0lkeCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGllUGllY2Uub2ZmKCdjbGljaycpO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE1vZGUgJiYgcGllUGllY2Uub24oJ2NsaWNrJywgb25TZWN0b3JDbGljayk7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFkZChwaWVQaWVjZSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIHBpZVBpZWNlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGllUGllY2UgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKHBpZVBpZWNlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5leGVjdXRlKCk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNBbmltYXRpb24gJiYgaXNGaXJzdFJlbmRlciAmJiBkYXRhLmNvdW50KCkgPiAwXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBleHBhbnNpb24gYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgJiYgYW5pbWF0aW9uVHlwZSAhPT0gJ3NjYWxlJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gZGF0YS5nZXRJdGVtTGF5b3V0KDApO1xuICAgICAgICAgICAgICAgIHZhciByID0gTWF0aC5tYXgoYXBpLmdldFdpZHRoKCksIGFwaS5nZXRIZWlnaHQoKSkgLyAyO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZUNsaXBQYXRoID0genJVdGlsLmJpbmQoZ3JvdXAucmVtb3ZlQ2xpcFBhdGgsIGdyb3VwKTtcbiAgICAgICAgICAgICAgICBncm91cC5zZXRDbGlwUGF0aCh0aGlzLl9jcmVhdGVDbGlwUGF0aChcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUuY3gsIHNoYXBlLmN5LCByLCBzaGFwZS5zdGFydEFuZ2xlLCBzaGFwZS5jbG9ja3dpc2UsIHJlbW92ZUNsaXBQYXRoLCBzZXJpZXNNb2RlbFxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgICAgICBfY3JlYXRlQ2xpcFBhdGg6IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgY2xvY2t3aXNlLCBjYiwgc2VyaWVzTW9kZWxcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgY2xpcFBhdGggPSBuZXcgZ3JhcGhpYy5TZWN0b3Ioe1xuICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgICAgICByMDogMCxcbiAgICAgICAgICAgICAgICAgICAgcjogcixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kQW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgICAgICAgICAgIGNsb2Nrd2lzZTogY2xvY2t3aXNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKGNsaXBQYXRoLCB7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZW5kQW5nbGU6IHN0YXJ0QW5nbGUgKyAoY2xvY2t3aXNlID8gMSA6IC0xKSAqIE1hdGguUEkgKiAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGNiKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNsaXBQYXRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW1wbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCwgc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIGl0ZW1MYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoMCk7XG4gICAgICAgICAgICBpZiAoaXRlbUxheW91dCkge1xuICAgICAgICAgICAgICAgIHZhciBkeCA9IHBvaW50WzBdIC0gaXRlbUxheW91dC5jeDtcbiAgICAgICAgICAgICAgICB2YXIgZHkgPSBwb2ludFsxXSAtIGl0ZW1MYXlvdXQuY3k7XG4gICAgICAgICAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhZGl1cyA8PSBpdGVtTGF5b3V0LnIgJiYgcmFkaXVzID49IGl0ZW1MYXlvdXQucjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQaWU7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBGSVhNRSBlbXBoYXNpcyBsYWJlbCBwb3NpdGlvbiBpcyBub3Qgc2FtZSB3aXRoIG5vcm1hbCBsYWJlbCBwb3NpdGlvblxuXG5cbiAgICB2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluL3RleHQnKTtcblxuICAgIGZ1bmN0aW9uIGFkanVzdFNpbmdsZVNpZGUobGlzdCwgY3gsIGN5LCByLCBkaXIsIHZpZXdXaWR0aCwgdmlld0hlaWdodCkge1xuICAgICAgICBsaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnkgLSBiLnk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIOWOi1xuICAgICAgICBmdW5jdGlvbiBzaGlmdERvd24oc3RhcnQsIGVuZCwgZGVsdGEsIGRpcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDwgZW5kOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsaXN0W2pdLnkgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgaWYgKGogPiBzdGFydFxuICAgICAgICAgICAgICAgICAgICAmJiBqICsgMSA8IGVuZFxuICAgICAgICAgICAgICAgICAgICAmJiBsaXN0W2ogKyAxXS55ID4gbGlzdFtqXS55ICsgbGlzdFtqXS5oZWlnaHRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnRVcChqLCBkZWx0YSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaGlmdFVwKGVuZCAtIDEsIGRlbHRhIC8gMik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDlvLlcbiAgICAgICAgZnVuY3Rpb24gc2hpZnRVcChlbmQsIGRlbHRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gZW5kOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGxpc3Rbal0ueSAtPSBkZWx0YTtcbiAgICAgICAgICAgICAgICBpZiAoaiA+IDBcbiAgICAgICAgICAgICAgICAgICAgJiYgbGlzdFtqXS55ID4gbGlzdFtqIC0gMV0ueSArIGxpc3RbaiAtIDFdLmhlaWdodFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGFuZ2VYKGxpc3QsIGlzRG93bkxpc3QsIGN4LCBjeSwgciwgZGlyKSB7XG4gICAgICAgICAgICB2YXIgbGFzdERlbHRhWCA9IGRpciA+IDBcbiAgICAgICAgICAgICAgICA/IGlzRG93bkxpc3QgICAgICAgICAgICAgICAgLy8g5Y+z5L6nXG4gICAgICAgICAgICAgICAgICAgID8gTnVtYmVyLk1BWF9WQUxVRSAgICAgIC8vIOS4i1xuICAgICAgICAgICAgICAgICAgICA6IDAgICAgICAgICAgICAgICAgICAgICAvLyDkuIpcbiAgICAgICAgICAgICAgICA6IGlzRG93bkxpc3QgICAgICAgICAgICAgICAgLy8g5bem5L6nXG4gICAgICAgICAgICAgICAgICAgID8gTnVtYmVyLk1BWF9WQUxVRSAgICAgIC8vIOS4i1xuICAgICAgICAgICAgICAgICAgICA6IDA7ICAgICAgICAgICAgICAgICAgICAvLyDkuIpcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBjaGFuZ2UgeCBmb3IgY2VudGVyIGxhYmVsXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RbaV0ucG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFZID0gTWF0aC5hYnMobGlzdFtpXS55IC0gY3kpO1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBsaXN0W2ldLmxlbjtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoMiA9IGxpc3RbaV0ubGVuMjtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFYID0gKGRlbHRhWSA8IHIgKyBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAociArIGxlbmd0aCArIGxlbmd0aDIpICogKHIgKyBsZW5ndGggKyBsZW5ndGgyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAtIGRlbHRhWSAqIGRlbHRhWVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLmFicyhsaXN0W2ldLnggLSBjeCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRG93bkxpc3QgJiYgZGVsdGFYID49IGxhc3REZWx0YVgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5Y+z5LiL77yM5bem5LiLXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWCA9IGxhc3REZWx0YVggLSAxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Rvd25MaXN0ICYmIGRlbHRhWCA8PSBsYXN0RGVsdGFYKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWPs+S4iu+8jOW3puS4ilxuICAgICAgICAgICAgICAgICAgICBkZWx0YVggPSBsYXN0RGVsdGFYICsgMTA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGlzdFtpXS54ID0gY3ggKyBkZWx0YVggKiBkaXI7XG4gICAgICAgICAgICAgICAgbGFzdERlbHRhWCA9IGRlbHRhWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0WSA9IDA7XG4gICAgICAgIHZhciBkZWx0YTtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgdXBMaXN0ID0gW107XG4gICAgICAgIHZhciBkb3duTGlzdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBkZWx0YSA9IGxpc3RbaV0ueSAtIGxhc3RZO1xuICAgICAgICAgICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgICAgIHNoaWZ0RG93bihpLCBsZW4sIC1kZWx0YSwgZGlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RZID0gbGlzdFtpXS55ICsgbGlzdFtpXS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZXdIZWlnaHQgLSBsYXN0WSA8IDApIHtcbiAgICAgICAgICAgIHNoaWZ0VXAobGVuIC0gMSwgbGFzdFkgLSB2aWV3SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGlzdFtpXS55ID49IGN5KSB7XG4gICAgICAgICAgICAgICAgZG93bkxpc3QucHVzaChsaXN0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwTGlzdC5wdXNoKGxpc3RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoYW5nZVgodXBMaXN0LCBmYWxzZSwgY3gsIGN5LCByLCBkaXIpO1xuICAgICAgICBjaGFuZ2VYKGRvd25MaXN0LCB0cnVlLCBjeCwgY3ksIHIsIGRpcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXZvaWRPdmVybGFwKGxhYmVsTGF5b3V0TGlzdCwgY3gsIGN5LCByLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpIHtcbiAgICAgICAgdmFyIGxlZnRMaXN0ID0gW107XG4gICAgICAgIHZhciByaWdodExpc3QgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbExheW91dExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsYWJlbExheW91dExpc3RbaV0ueCA8IGN4KSB7XG4gICAgICAgICAgICAgICAgbGVmdExpc3QucHVzaChsYWJlbExheW91dExpc3RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmlnaHRMaXN0LnB1c2gobGFiZWxMYXlvdXRMaXN0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFkanVzdFNpbmdsZVNpZGUocmlnaHRMaXN0LCBjeCwgY3ksIHIsIDEsIHZpZXdXaWR0aCwgdmlld0hlaWdodCk7XG4gICAgICAgIGFkanVzdFNpbmdsZVNpZGUobGVmdExpc3QsIGN4LCBjeSwgciwgLTEsIHZpZXdXaWR0aCwgdmlld0hlaWdodCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbExheW91dExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5lUG9pbnRzID0gbGFiZWxMYXlvdXRMaXN0W2ldLmxpbmVQb2ludHM7XG4gICAgICAgICAgICBpZiAobGluZVBvaW50cykge1xuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gbGluZVBvaW50c1sxXVswXSAtIGxpbmVQb2ludHNbMl1bMF07XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsTGF5b3V0TGlzdFtpXS54IDwgY3gpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZVBvaW50c1syXVswXSA9IGxhYmVsTGF5b3V0TGlzdFtpXS54ICsgMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVQb2ludHNbMl1bMF0gPSBsYWJlbExheW91dExpc3RbaV0ueCAtIDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmVQb2ludHNbMV1bMV0gPSBsaW5lUG9pbnRzWzJdWzFdID0gbGFiZWxMYXlvdXRMaXN0W2ldLnk7XG4gICAgICAgICAgICAgICAgbGluZVBvaW50c1sxXVswXSA9IGxpbmVQb2ludHNbMl1bMF0gKyBkaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIHIsIHZpZXdXaWR0aCwgdmlld0hlaWdodCkge1xuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgdmFyIGxhYmVsTGF5b3V0TGlzdCA9IFtdO1xuICAgICAgICB2YXIgY3g7XG4gICAgICAgIHZhciBjeTtcbiAgICAgICAgdmFyIGhhc0xhYmVsUm90YXRlID0gZmFsc2U7XG5cbiAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcblxuICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgICAgICB2YXIgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwubm9ybWFsJyk7XG4gICAgICAgICAgICAvLyBVc2UgcG9zaXRpb24gaW4gbm9ybWFsIG9yIGVtcGhhc2lzXG4gICAgICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0KCdwb3NpdGlvbicpIHx8IGl0ZW1Nb2RlbC5nZXQoJ2xhYmVsLmVtcGhhc2lzLnBvc2l0aW9uJyk7XG5cbiAgICAgICAgICAgIHZhciBsYWJlbExpbmVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWxMaW5lLm5vcm1hbCcpO1xuICAgICAgICAgICAgdmFyIGxhYmVsTGluZUxlbiA9IGxhYmVsTGluZU1vZGVsLmdldCgnbGVuZ3RoJyk7XG4gICAgICAgICAgICB2YXIgbGFiZWxMaW5lTGVuMiA9IGxhYmVsTGluZU1vZGVsLmdldCgnbGVuZ3RoMicpO1xuXG4gICAgICAgICAgICB2YXIgbWlkQW5nbGUgPSAobGF5b3V0LnN0YXJ0QW5nbGUgKyBsYXlvdXQuZW5kQW5nbGUpIC8gMjtcbiAgICAgICAgICAgIHZhciBkeCA9IE1hdGguY29zKG1pZEFuZ2xlKTtcbiAgICAgICAgICAgIHZhciBkeSA9IE1hdGguc2luKG1pZEFuZ2xlKTtcblxuICAgICAgICAgICAgdmFyIHRleHRYO1xuICAgICAgICAgICAgdmFyIHRleHRZO1xuICAgICAgICAgICAgdmFyIGxpbmVQb2ludHM7XG4gICAgICAgICAgICB2YXIgdGV4dEFsaWduO1xuXG4gICAgICAgICAgICBjeCA9IGxheW91dC5jeDtcbiAgICAgICAgICAgIGN5ID0gbGF5b3V0LmN5O1xuXG4gICAgICAgICAgICB2YXIgaXNMYWJlbEluc2lkZSA9IGxhYmVsUG9zaXRpb24gPT09ICdpbnNpZGUnIHx8IGxhYmVsUG9zaXRpb24gPT09ICdpbm5lcic7XG4gICAgICAgICAgICBpZiAobGFiZWxQb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICB0ZXh0WCA9IGxheW91dC5jeDtcbiAgICAgICAgICAgICAgICB0ZXh0WSA9IGxheW91dC5jeTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB4MSA9IChpc0xhYmVsSW5zaWRlID8gKGxheW91dC5yICsgbGF5b3V0LnIwKSAvIDIgKiBkeCA6IGxheW91dC5yICogZHgpICsgY3g7XG4gICAgICAgICAgICAgICAgdmFyIHkxID0gKGlzTGFiZWxJbnNpZGUgPyAobGF5b3V0LnIgKyBsYXlvdXQucjApIC8gMiAqIGR5IDogbGF5b3V0LnIgKiBkeSkgKyBjeTtcblxuICAgICAgICAgICAgICAgIHRleHRYID0geDEgKyBkeCAqIDM7XG4gICAgICAgICAgICAgICAgdGV4dFkgPSB5MSArIGR5ICogMztcblxuICAgICAgICAgICAgICAgIGlmICghaXNMYWJlbEluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3Igcm9zZVR5cGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgyID0geDEgKyBkeCAqIChsYWJlbExpbmVMZW4gKyByIC0gbGF5b3V0LnIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTIgPSB5MSArIGR5ICogKGxhYmVsTGluZUxlbiArIHIgLSBsYXlvdXQucik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MyA9IHgyICsgKChkeCA8IDAgPyAtMSA6IDEpICogbGFiZWxMaW5lTGVuMik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MyA9IHkyO1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHRYID0geDMgKyAoZHggPCAwID8gLTUgOiA1KTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dFkgPSB5MztcbiAgICAgICAgICAgICAgICAgICAgbGluZVBvaW50cyA9IFtbeDEsIHkxXSwgW3gyLCB5Ml0sIFt4MywgeTNdXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBpc0xhYmVsSW5zaWRlID8gJ2NlbnRlcicgOiAoZHggPiAwID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm9udCA9IGxhYmVsTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpLmdldEZvbnQoKTtcblxuICAgICAgICAgICAgdmFyIGxhYmVsUm90YXRlID0gbGFiZWxNb2RlbC5nZXQoJ3JvdGF0ZScpXG4gICAgICAgICAgICAgICAgPyAoZHggPCAwID8gLW1pZEFuZ2xlICsgTWF0aC5QSSA6IC1taWRBbmdsZSkgOiAwO1xuICAgICAgICAgICAgdmFyIHRleHQgPSBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChpZHgsICdub3JtYWwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgZGF0YS5nZXROYW1lKGlkeCk7XG4gICAgICAgICAgICB2YXIgdGV4dFJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgdGV4dCwgZm9udCwgdGV4dEFsaWduLCAndG9wJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGhhc0xhYmVsUm90YXRlID0gISFsYWJlbFJvdGF0ZTtcbiAgICAgICAgICAgIGxheW91dC5sYWJlbCA9IHtcbiAgICAgICAgICAgICAgICB4OiB0ZXh0WCxcbiAgICAgICAgICAgICAgICB5OiB0ZXh0WSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogbGFiZWxQb3NpdGlvbixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRleHRSZWN0LmhlaWdodCxcbiAgICAgICAgICAgICAgICBsZW46IGxhYmVsTGluZUxlbixcbiAgICAgICAgICAgICAgICBsZW4yOiBsYWJlbExpbmVMZW4yLFxuICAgICAgICAgICAgICAgIGxpbmVQb2ludHM6IGxpbmVQb2ludHMsXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogbGFiZWxSb3RhdGVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIE5vdCBsYXlvdXQgdGhlIGluc2lkZSBsYWJlbFxuICAgICAgICAgICAgaWYgKCFpc0xhYmVsSW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxMYXlvdXRMaXN0LnB1c2gobGF5b3V0LmxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaGFzTGFiZWxSb3RhdGUgJiYgc2VyaWVzTW9kZWwuZ2V0KCdhdm9pZExhYmVsT3ZlcmxhcCcpKSB7XG4gICAgICAgICAgICBhdm9pZE92ZXJsYXAobGFiZWxMYXlvdXRMaXN0LCBjeCwgY3ksIHIsIHZpZXdXaWR0aCwgdmlld0hlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuIiwiLy8gVE9ETyBtaW5BbmdsZVxuXG5cblxuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgcGFyc2VQZXJjZW50ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQ7XG4gICAgdmFyIGxhYmVsTGF5b3V0ID0gcmVxdWlyZSgnLi9sYWJlbExheW91dCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICB2YXIgUkFESUFOID0gTWF0aC5QSSAvIDE4MDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlcmllc1R5cGUsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoc2VyaWVzVHlwZSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gc2VyaWVzTW9kZWwuZ2V0KCdjZW50ZXInKTtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBzZXJpZXNNb2RlbC5nZXQoJ3JhZGl1cycpO1xuXG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHJhZGl1cykpIHtcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBbMCwgcmFkaXVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoY2VudGVyKSkge1xuICAgICAgICAgICAgICAgIGNlbnRlciA9IFtjZW50ZXIsIGNlbnRlcl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGFwaS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGFwaS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB2YXIgY3ggPSBwYXJzZVBlcmNlbnQoY2VudGVyWzBdLCB3aWR0aCk7XG4gICAgICAgICAgICB2YXIgY3kgPSBwYXJzZVBlcmNlbnQoY2VudGVyWzFdLCBoZWlnaHQpO1xuICAgICAgICAgICAgdmFyIHIwID0gcGFyc2VQZXJjZW50KHJhZGl1c1swXSwgc2l6ZSAvIDIpO1xuICAgICAgICAgICAgdmFyIHIgPSBwYXJzZVBlcmNlbnQocmFkaXVzWzFdLCBzaXplIC8gMik7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IC1zZXJpZXNNb2RlbC5nZXQoJ3N0YXJ0QW5nbGUnKSAqIFJBRElBTjtcblxuICAgICAgICAgICAgdmFyIG1pbkFuZ2xlID0gc2VyaWVzTW9kZWwuZ2V0KCdtaW5BbmdsZScpICogUkFESUFOO1xuXG4gICAgICAgICAgICB2YXIgc3VtID0gZGF0YS5nZXRTdW0oJ3ZhbHVlJyk7XG4gICAgICAgICAgICAvLyBTdW0gbWF5IGJlIDBcbiAgICAgICAgICAgIHZhciB1bml0UmFkaWFuID0gTWF0aC5QSSAvIChzdW0gfHwgZGF0YS5jb3VudCgpKSAqIDI7XG5cbiAgICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBzZXJpZXNNb2RlbC5nZXQoJ2Nsb2Nrd2lzZScpO1xuXG4gICAgICAgICAgICB2YXIgcm9zZVR5cGUgPSBzZXJpZXNNb2RlbC5nZXQoJ3Jvc2VUeXBlJyk7XG4gICAgICAgICAgICB2YXIgc3RpbGxTaG93WmVyb1N1bSA9IHNlcmllc01vZGVsLmdldCgnc3RpbGxTaG93WmVyb1N1bScpO1xuXG4gICAgICAgICAgICAvLyBbMC4uLm1heF1cbiAgICAgICAgICAgIHZhciBleHRlbnQgPSBkYXRhLmdldERhdGFFeHRlbnQoJ3ZhbHVlJyk7XG4gICAgICAgICAgICBleHRlbnRbMF0gPSAwO1xuXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBzb21lIHNlY3RvciBhbmdsZSBpcyBzbWFsbGVyIHRoYW4gbWluQW5nbGVcbiAgICAgICAgICAgIHZhciByZXN0QW5nbGUgPSBQSTI7XG4gICAgICAgICAgICB2YXIgdmFsdWVTdW1MYXJnZXJUaGFuTWluQW5nbGUgPSAwO1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudEFuZ2xlID0gc3RhcnRBbmdsZTtcblxuICAgICAgICAgICAgdmFyIGRpciA9IGNsb2Nrd2lzZSA/IDEgOiAtMTtcbiAgICAgICAgICAgIGRhdGEuZWFjaCgndmFsdWUnLCBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBhbmdsZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlOiBOYU4sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBOYU4sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogTmFOLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvY2t3aXNlOiBjbG9ja3dpc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICByMDogcjAsXG4gICAgICAgICAgICAgICAgICAgICAgICByOiByb3NlVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gTmFOXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRklYTUUg5YW85a65IDIuMCDkvYbmmK8gcm9zZVR5cGUg5pivIGFyZWEg55qE5pe25YCZ5omN5piv6L+Z5qC377yfXG4gICAgICAgICAgICAgICAgaWYgKHJvc2VUeXBlICE9PSAnYXJlYScpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSAoc3VtID09PSAwICYmIHN0aWxsU2hvd1plcm9TdW0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHVuaXRSYWRpYW4gOiAodmFsdWUgKiB1bml0UmFkaWFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gUEkyIC8gKGRhdGEuY291bnQoKSB8fCAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPCBtaW5BbmdsZSkge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IG1pbkFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICByZXN0QW5nbGUgLT0gbWluQW5nbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVN1bUxhcmdlclRoYW5NaW5BbmdsZSArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBjdXJyZW50QW5nbGUgKyBkaXIgKiBhbmdsZTtcbiAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogY3VycmVudEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgICAgICAgICAgIGNsb2Nrd2lzZTogY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICAgICAgcjA6IHIwLFxuICAgICAgICAgICAgICAgICAgICByOiByb3NlVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBudW1iZXJVdGlsLmxpbmVhck1hcCh2YWx1ZSwgZXh0ZW50LCBbcjAsIHJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiByXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50QW5nbGUgPSBlbmRBbmdsZTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBTb21lIHNlY3RvciBpcyBjb25zdHJhaW5lZCBieSBtaW5BbmdsZVxuICAgICAgICAgICAgLy8gUmVzdCBzZWN0b3JzIG5lZWRzIHJlY2FsY3VsYXRlIGFuZ2xlXG4gICAgICAgICAgICBpZiAocmVzdEFuZ2xlIDwgUEkyKSB7XG4gICAgICAgICAgICAgICAgLy8gQXZlcmFnZSB0aGUgYW5nbGUgaWYgcmVzdCBhbmdsZSBpcyBub3QgZW5vdWdoIGFmdGVyIGFsbCBhbmdsZXMgaXNcbiAgICAgICAgICAgICAgICAvLyBDb25zdHJhaW5lZCBieSBtaW5BbmdsZVxuICAgICAgICAgICAgICAgIGlmIChyZXN0QW5nbGUgPD0gMWUtMykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBQSTIgLyBkYXRhLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQuc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBkaXIgKiBpZHggKiBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dC5lbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBkaXIgKiAoaWR4ICsgMSkgKiBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1bml0UmFkaWFuID0gcmVzdEFuZ2xlIC8gdmFsdWVTdW1MYXJnZXJUaGFuTWluQW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZWFjaCgndmFsdWUnLCBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gbGF5b3V0LmFuZ2xlID09PSBtaW5BbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbWluQW5nbGUgOiB2YWx1ZSAqIHVuaXRSYWRpYW47XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQuc3RhcnRBbmdsZSA9IGN1cnJlbnRBbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dC5lbmRBbmdsZSA9IGN1cnJlbnRBbmdsZSArIGRpciAqIGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFuZ2xlICs9IGRpciAqIGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhYmVsTGF5b3V0KHNlcmllc01vZGVsLCByLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiIsIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vZWNoYXJ0cycpO1xuXG4gICAgLy8gTXVzdCB1c2UgcmFkYXIgY29tcG9uZW50XG4gICAgcmVxdWlyZSgnLi4vY29tcG9uZW50L3JhZGFyJyk7XG5cbiAgICByZXF1aXJlKCcuL3JhZGFyL1JhZGFyU2VyaWVzJyk7XG4gICAgcmVxdWlyZSgnLi9yYWRhci9SYWRhclZpZXcnKTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJWaXN1YWwoenJVdGlsLmN1cnJ5KHJlcXVpcmUoJy4uL3Zpc3VhbC9kYXRhQ29sb3InKSwgJ3JhZGFyJykpO1xuICAgIGVjaGFydHMucmVnaXN0ZXJWaXN1YWwoenJVdGlsLmN1cnJ5KFxuICAgICAgICByZXF1aXJlKCcuLi92aXN1YWwvc3ltYm9sJyksICdyYWRhcicsICdjaXJjbGUnLCBudWxsXG4gICAgKSk7XG4gICAgZWNoYXJ0cy5yZWdpc3RlckxheW91dChyZXF1aXJlKCcuL3JhZGFyL3JhZGFyTGF5b3V0JykpO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3NvcihcbiAgICAgICAgenJVdGlsLmN1cnJ5KHJlcXVpcmUoJy4uL3Byb2Nlc3Nvci9kYXRhRmlsdGVyJyksICdyYWRhcicpXG4gICAgKTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJQcmVwcm9jZXNzb3IocmVxdWlyZSgnLi9yYWRhci9iYWNrd2FyZENvbXBhdCcpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIFNlcmllc01vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvU2VyaWVzJyk7XG4gICAgdmFyIExpc3QgPSByZXF1aXJlKCcuLi8uLi9kYXRhL0xpc3QnKTtcbiAgICB2YXIgY29tcGxldGVEaW1lbnNpb25zID0gcmVxdWlyZSgnLi4vLi4vZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBlbmNvZGVIVE1MID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9mb3JtYXQnKS5lbmNvZGVIVE1MO1xuXG4gICAgdmFyIFJhZGFyU2VyaWVzID0gU2VyaWVzTW9kZWwuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnc2VyaWVzLnJhZGFyJyxcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IFsncmFkYXInXSxcblxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZVxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICBSYWRhclNlcmllcy5zdXBlckFwcGx5KHRoaXMsICdpbml0JywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gRW5hYmxlIGxlZ2VuZCBzZWxlY3Rpb24gZm9yIGVhY2ggZGF0YSBpdGVtXG4gICAgICAgICAgICAvLyBVc2UgYSBmdW5jdGlvbiBpbnN0ZWFkIG9mIGRpcmVjdCBhY2Nlc3MgYmVjYXVzZSBkYXRhIHJlZmVyZW5jZSBtYXkgY2hhbmdlZFxuICAgICAgICAgICAgdGhpcy5sZWdlbmREYXRhUHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmF3RGF0YSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRJbml0aWFsRGF0YTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBvcHRpb24uZGF0YSB8fCBbXTtcbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gY29tcGxldGVEaW1lbnNpb25zKFxuICAgICAgICAgICAgICAgIFtdLCBkYXRhLCBbXSwgJ2luZGljYXRvcl8nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBuZXcgTGlzdChkaW1lbnNpb25zLCB0aGlzKTtcbiAgICAgICAgICAgIGxpc3QuaW5pdERhdGEoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfSxcblxuICAgICAgICBmb3JtYXRUb29sdGlwOiBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFJhd1ZhbHVlKGRhdGFJbmRleCk7XG4gICAgICAgICAgICB2YXIgY29vcmRTeXMgPSB0aGlzLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICB2YXIgaW5kaWNhdG9yQXhlcyA9IGNvb3JkU3lzLmdldEluZGljYXRvckF4ZXMoKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXREYXRhKCkuZ2V0TmFtZShkYXRhSW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZUhUTUwobmFtZSA9PT0gJycgPyB0aGlzLm5hbWUgOiBuYW1lKSArICc8YnIvPidcbiAgICAgICAgICAgICAgICArIHpyVXRpbC5tYXAoaW5kaWNhdG9yQXhlcywgZnVuY3Rpb24gKGF4aXMsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlSFRNTChheGlzLm5hbWUgKyAnIDogJyArIHZhbHVlW2lkeF0pO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJzxiciAvPicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIHpsZXZlbDogMCxcbiAgICAgICAgICAgIHo6IDIsXG4gICAgICAgICAgICBjb29yZGluYXRlU3lzdGVtOiAncmFkYXInLFxuICAgICAgICAgICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuICAgICAgICAgICAgcmFkYXJJbmRleDogMCxcbiAgICAgICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3RvcCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gYXJlYVN0eWxlOiB7XG4gICAgICAgICAgICAvLyB9LFxuICAgICAgICAgICAgLy8gaXRlbVN0eWxlOiB7fVxuICAgICAgICAgICAgc3ltYm9sOiAnZW1wdHlDaXJjbGUnLFxuICAgICAgICAgICAgc3ltYm9sU2l6ZTogNFxuICAgICAgICAgICAgLy8gc3ltYm9sUm90YXRlOiBudWxsXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUmFkYXJTZXJpZXM7XG4iLCJcblxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBzeW1ib2xVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9zeW1ib2wnKTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVN5bWJvbFNpemUoc3ltYm9sU2l6ZSkge1xuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHN5bWJvbFNpemUpKSB7XG4gICAgICAgICAgICBzeW1ib2xTaXplID0gWytzeW1ib2xTaXplLCArc3ltYm9sU2l6ZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN5bWJvbFNpemU7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENoYXJ0Vmlldyh7XG4gICAgICAgIHR5cGU6ICdyYWRhcicsXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIHBvbGFyID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVTeW1ib2woZGF0YSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJykgfHwgJ2NpcmNsZSc7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJyk7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGUsIC0wLjUsIC0wLjUsIDEsIDEsIGNvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBzeW1ib2xQYXRoLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTm9TY2FsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB6MjogMTAwLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZTogbm9ybWFsaXplU3ltYm9sU2l6ZShkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2xQYXRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVTeW1ib2xzKG9sZFBvaW50cywgbmV3UG9pbnRzLCBzeW1ib2xHcm91cCwgZGF0YSwgaWR4LCBpc0luaXQpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbHkgcmVyZW5kZXIgYWxsXG4gICAgICAgICAgICAgICAgc3ltYm9sR3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdQb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xQYXRoID0gY3JlYXRlU3ltYm9sKGRhdGEsIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW1ib2xQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xQYXRoLl9fZGltSWR4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRQb2ludHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xQYXRoLmF0dHIoJ3Bvc2l0aW9uJywgb2xkUG9pbnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljW2lzSW5pdCA/ICdpbml0UHJvcHMnIDogJ3VwZGF0ZVByb3BzJ10oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbFBhdGgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBuZXdQb2ludHNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGlkeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xQYXRoLmF0dHIoJ3Bvc2l0aW9uJywgbmV3UG9pbnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbEdyb3VwLmFkZChzeW1ib2xQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFBvaW50cyhwb2ludHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4genJVdGlsLm1hcChwb2ludHMsIGZ1bmN0aW9uIChwdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3BvbGFyLmN4LCBwb2xhci5jeV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmRpZmYob2xkRGF0YSlcbiAgICAgICAgICAgICAgICAuYWRkKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBvaW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2x5Z29uID0gbmV3IGdyYXBoaWMuUG9seWdvbigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9seWxpbmUgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnNoYXBlLnBvaW50cyA9IGdldEluaXRpYWxQb2ludHMocG9pbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWxpbmUuc2hhcGUucG9pbnRzID0gZ2V0SW5pdGlhbFBvaW50cyhwb2ludHMpO1xuICAgICAgICAgICAgICAgICAgICBncmFwaGljLmluaXRQcm9wcyhwb2x5Z29uLCB0YXJnZXQsIHNlcmllc01vZGVsLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICBncmFwaGljLmluaXRQcm9wcyhwb2x5bGluZSwgdGFyZ2V0LCBzZXJpZXNNb2RlbCwgaWR4KTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbEdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUdyb3VwLmFkZChwb2x5bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Hcm91cC5hZGQocG9seWdvbik7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Hcm91cC5hZGQoc3ltYm9sR3JvdXApO1xuXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN5bWJvbHMoXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5bGluZS5zaGFwZS5wb2ludHMsIHBvaW50cywgc3ltYm9sR3JvdXAsIGRhdGEsIGlkeCwgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIGl0ZW1Hcm91cCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUdyb3VwID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2x5bGluZSA9IGl0ZW1Hcm91cC5jaGlsZEF0KDApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9seWdvbiA9IGl0ZW1Hcm91cC5jaGlsZEF0KDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9sR3JvdXAgPSBpdGVtR3JvdXAuY2hpbGRBdCgyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBkYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5zaGFwZS5wb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTeW1ib2xzKFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWxpbmUuc2hhcGUucG9pbnRzLCB0YXJnZXQuc2hhcGUucG9pbnRzLCBzeW1ib2xHcm91cCwgZGF0YSwgbmV3SWR4LCBmYWxzZVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocG9seWxpbmUsIHRhcmdldCwgc2VyaWVzTW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHBvbHlnb24sIHRhcmdldCwgc2VyaWVzTW9kZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIGl0ZW1Hcm91cCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVtb3ZlKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5leGVjdXRlKCk7XG5cbiAgICAgICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGl0ZW1Hcm91cCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgICAgICAgICAgdmFyIHBvbHlsaW5lID0gaXRlbUdyb3VwLmNoaWxkQXQoMCk7XG4gICAgICAgICAgICAgICAgdmFyIHBvbHlnb24gPSBpdGVtR3JvdXAuY2hpbGRBdCgxKTtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sR3JvdXAgPSBpdGVtR3JvdXAuY2hpbGRBdCgyKTtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKTtcblxuICAgICAgICAgICAgICAgIGdyb3VwLmFkZChpdGVtR3JvdXApO1xuXG4gICAgICAgICAgICAgICAgcG9seWxpbmUudXNlU3R5bGUoXG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlLm5vcm1hbCcpLmdldExpbmVTdHlsZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHBvbHlsaW5lLmhvdmVyU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZS5lbXBoYXNpcycpLmdldExpbmVTdHlsZSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFyZWFTdHlsZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdhcmVhU3R5bGUubm9ybWFsJyk7XG4gICAgICAgICAgICAgICAgdmFyIGhvdmVyQXJlYVN0eWxlTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZS5lbXBoYXNpcycpO1xuICAgICAgICAgICAgICAgIHZhciBwb2x5Z29uSWdub3JlID0gYXJlYVN0eWxlTW9kZWwuaXNFbXB0eSgpICYmIGFyZWFTdHlsZU1vZGVsLnBhcmVudE1vZGVsLmlzRW1wdHkoKTtcbiAgICAgICAgICAgICAgICB2YXIgaG92ZXJQb2x5Z29uSWdub3JlID0gaG92ZXJBcmVhU3R5bGVNb2RlbC5pc0VtcHR5KCkgJiYgaG92ZXJBcmVhU3R5bGVNb2RlbC5wYXJlbnRNb2RlbC5pc0VtcHR5KCk7XG5cbiAgICAgICAgICAgICAgICBob3ZlclBvbHlnb25JZ25vcmUgPSBob3ZlclBvbHlnb25JZ25vcmUgJiYgcG9seWdvbklnbm9yZTtcbiAgICAgICAgICAgICAgICBwb2x5Z29uLmlnbm9yZSA9IHBvbHlnb25JZ25vcmU7XG5cbiAgICAgICAgICAgICAgICBwb2x5Z29uLnVzZVN0eWxlKFxuICAgICAgICAgICAgICAgICAgICB6clV0aWwuZGVmYXVsdHMoXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhU3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcG9seWdvbi5ob3ZlclN0eWxlID0gaG92ZXJBcmVhU3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKTtcblxuICAgICAgICAgICAgICAgIHZhciBpdGVtU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5ub3JtYWwnKS5nZXRJdGVtU3R5bGUoWydjb2xvciddKTtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUhvdmVyU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5lbXBoYXNpcycpLmdldEl0ZW1TdHlsZSgpO1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5ub3JtYWwnKTtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxIb3Zlck1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5lbXBoYXNpcycpO1xuICAgICAgICAgICAgICAgIHN5bWJvbEdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoc3ltYm9sUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xQYXRoLnNldFN0eWxlKGl0ZW1TdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFBhdGguaG92ZXJTdHlsZSA9IHpyVXRpbC5jbG9uZShpdGVtSG92ZXJTdHlsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRUZXh0ID0gZGF0YS5nZXQoZGF0YS5kaW1lbnNpb25zW3N5bWJvbFBhdGguX19kaW1JZHhdLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICBncmFwaGljLnNldFRleHQoc3ltYm9sUGF0aC5zdHlsZSwgbGFiZWxNb2RlbCwgY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xQYXRoLnNldFN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsTW9kZWwuZ2V0KCdzaG93JykgPyB6clV0aWwucmV0cmlldmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCwgJ25vcm1hbCcsIG51bGwsIHN5bWJvbFBhdGguX19kaW1JZHhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICApIDogJydcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5zZXRUZXh0KHN5bWJvbFBhdGguaG92ZXJTdHlsZSwgbGFiZWxIb3Zlck1vZGVsLCBjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFBhdGguaG92ZXJTdHlsZS50ZXh0ID0gbGFiZWxIb3Zlck1vZGVsLmdldCgnc2hvdycpID8genJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4LCAnZW1waGFzaXMnLCBudWxsLCBzeW1ib2xQYXRoLl9fZGltSWR4XG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFRleHRcbiAgICAgICAgICAgICAgICAgICAgKSA6ICcnO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gb25FbXBoYXNpcygpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5hdHRyKCdpZ25vcmUnLCBob3ZlclBvbHlnb25JZ25vcmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uTm9ybWFsKCkge1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLmF0dHIoJ2lnbm9yZScsIHBvbHlnb25JZ25vcmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW1Hcm91cC5vZmYoJ21vdXNlb3ZlcicpLm9mZignbW91c2VvdXQnKS5vZmYoJ25vcm1hbCcpLm9mZignZW1waGFzaXMnKTtcbiAgICAgICAgICAgICAgICBpdGVtR3JvdXAub24oJ2VtcGhhc2lzJywgb25FbXBoYXNpcylcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBvbkVtcGhhc2lzKVxuICAgICAgICAgICAgICAgICAgICAub24oJ25vcm1hbCcsIG9uTm9ybWFsKVxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0Jywgb25Ob3JtYWwpO1xuXG4gICAgICAgICAgICAgICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKGl0ZW1Hcm91cCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge31cbiAgICB9KTtcbiIsIi8vIEJhY2t3YXJkIGNvbXBhdCBmb3IgcmFkYXIgY2hhcnQgaW4gMlxuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdmFyIHBvbGFyT3B0QXJyID0gb3B0aW9uLnBvbGFyO1xuICAgICAgICBpZiAocG9sYXJPcHRBcnIpIHtcbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkocG9sYXJPcHRBcnIpKSB7XG4gICAgICAgICAgICAgICAgcG9sYXJPcHRBcnIgPSBbcG9sYXJPcHRBcnJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBvbGFyTm90UmFkYXIgPSBbXTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHBvbGFyT3B0QXJyLCBmdW5jdGlvbiAocG9sYXJPcHQsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChwb2xhck9wdC5pbmRpY2F0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbGFyT3B0LnR5cGUgJiYgIXBvbGFyT3B0LnNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2xhck9wdC5zaGFwZSA9IHBvbGFyT3B0LnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnJhZGFyID0gb3B0aW9uLnJhZGFyIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KG9wdGlvbi5yYWRhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5yYWRhciA9IFtvcHRpb24ucmFkYXJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbi5yYWRhci5wdXNoKHBvbGFyT3B0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvbGFyTm90UmFkYXIucHVzaChwb2xhck9wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvcHRpb24ucG9sYXIgPSBwb2xhck5vdFJhZGFyO1xuICAgICAgICB9XG4gICAgICAgIHpyVXRpbC5lYWNoKG9wdGlvbi5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNPcHQpIHtcbiAgICAgICAgICAgIGlmIChzZXJpZXNPcHQudHlwZSA9PT0gJ3JhZGFyJyAmJiBzZXJpZXNPcHQucG9sYXJJbmRleCkge1xuICAgICAgICAgICAgICAgIHNlcmllc09wdC5yYWRhckluZGV4ID0gc2VyaWVzT3B0LnBvbGFySW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4iLCJcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKCdyYWRhcicsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgaWYgKCFjb29yZFN5cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcG9pbnRzQ29udmVydGVyKHZhbCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzW2lkeF0gPSBwb2ludHNbaWR4XSB8fCBbXTtcbiAgICAgICAgICAgICAgICBwb2ludHNbaWR4XVtpXSA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KHZhbCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkU3lzLmdldEluZGljYXRvckF4ZXMoKS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBkaW0gPSBkYXRhLmRpbWVuc2lvbnNbaV07XG4gICAgICAgICAgICAgICAgZGF0YS5lYWNoKGRpbSwgcG9pbnRzQ29udmVydGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwb2x5Z29uXG4gICAgICAgICAgICAgICAgcG9pbnRzW2lkeF1bMF0gJiYgcG9pbnRzW2lkeF0ucHVzaChwb2ludHNbaWR4XVswXS5zbGljZSgpKTtcbiAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBwb2ludHNbaWR4XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE8gYm91bmRhcnlHYXBcblxuXG4gICAgcmVxdWlyZSgnLi4vY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbCcpO1xuXG4gICAgcmVxdWlyZSgnLi9heGlzL0F4aXNWaWV3Jyk7XG4iLCJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZm9ybWF0Jyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9Nb2RlbCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgcmVtUmFkaWFuID0gbnVtYmVyVXRpbC5yZW1SYWRpYW47XG4gICAgdmFyIGlzUmFkaWFuQXJvdW5kWmVybyA9IG51bWJlclV0aWwuaXNSYWRpYW5Bcm91bmRaZXJvO1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcbiAgICB2YXIgdjJBcHBseVRyYW5zZm9ybSA9IHZlYzIuYXBwbHlUcmFuc2Zvcm07XG4gICAgdmFyIHJldHJpZXZlID0genJVdGlsLnJldHJpZXZlO1xuXG4gICAgdmFyIFBJID0gTWF0aC5QSTtcblxuICAgIGZ1bmN0aW9uIG1ha2VBeGlzRXZlbnREYXRhQmFzZShheGlzTW9kZWwpIHtcbiAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IGF4aXNNb2RlbC5tYWluVHlwZVxuICAgICAgICB9O1xuICAgICAgICBldmVudERhdGFbYXhpc01vZGVsLm1haW5UeXBlICsgJ0luZGV4J10gPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG4gICAgICAgIHJldHVybiBldmVudERhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBmaW5hbCBheGlzIGlzIHRyYW5zbGF0ZWQgYW5kIHJvdGF0ZWQgZnJvbSBhIFwic3RhbmRhcmQgYXhpc1wiLlxuICAgICAqIFNvIG9wdC5wb3NpdGlvbiBhbmQgb3B0LnJvdGF0aW9uIGlzIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogQSBzdGFuZGFyZCBheGlzIGlzIGFuZCBheGlzIGZyb20gWzAsIDBdIHRvIFswLCBheGlzRXh0ZW50WzFdXSxcbiAgICAgKiBmb3IgZXhhbXBsZTogKDAsIDApIC0tLS0tLS0tLS0tLT4gKDAsIDUwKVxuICAgICAqXG4gICAgICogbmFtZURpcmVjdGlvbiBvciB0aWNrRGlyZWN0aW9uIG9yIGxhYmVsRGlyZWN0aW9uIGlzIDEgbWVhbnMgdGlja1xuICAgICAqIG9yIGxhYmVsIGlzIGJlbG93IHRoZSBzdGFuZGFyZCBheGlzLCB3aGVyZWFzIGlzIC0xIG1lYW5zIGFib3ZlXG4gICAgICogdGhlIHN0YW5kYXJkIGF4aXMuIGxhYmVsT2Zmc2V0IG1lYW5zIG9mZnNldCBiZXR3ZWVuIGxhYmVsIGFuZCBheGlzLFxuICAgICAqIHdoaWNoIGlzIHVzZWZ1bCB3aGVuICdvblplcm8nLCB3aGVyZSBheGlzTGFiZWwgaXMgaW4gdGhlIGdyaWQgYW5kXG4gICAgICogbGFiZWwgaW4gb3V0c2lkZSBncmlkLlxuICAgICAqXG4gICAgICogVGlwczogbGlrZSBhbHdheXMsXG4gICAgICogcG9zaXRpdmUgcm90YXRpb24gcmVwcmVzZW50cyBhbnRpY2xvY2t3aXNlLCBhbmQgbmVnYXRpdmUgcm90YXRpb25cbiAgICAgKiByZXByZXNlbnRzIGNsb2Nrd2lzZS5cbiAgICAgKiBUaGUgZGlyZWN0aW9uIG9mIHBvc2l0aW9uIGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgdGhlIGRpcmVjdGlvblxuICAgICAqIG9mIHNjcmVlbiBjb29yZGluYXRlLlxuICAgICAqXG4gICAgICogRG8gbm90IG5lZWQgdG8gY29uc2lkZXIgYXhpcyAnaW52ZXJzZScsIHdoaWNoIGlzIGF1dG8gcHJvY2Vzc2VkIGJ5XG4gICAgICogYXhpcyBleHRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXhpc01vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdCBTdGFuZGFyZCBheGlzIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3B0LnBvc2l0aW9uIFt4LCB5XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHQucm90YXRpb24gYnkgcmFkaWFuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubmFtZURpcmVjdGlvbj0xXSAxIG9yIC0xIFVzZWQgd2hlbiBuYW1lTG9jYXRpb24gaXMgJ21pZGRsZScuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQudGlja0RpcmVjdGlvbj0xXSAxIG9yIC0xXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubGFiZWxEaXJlY3Rpb249MV0gMSBvciAtMVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmxhYmVsT2Zmc2V0PTBdIFVzZWZ1bGwgd2hlbiBvblplcm8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuYXhpc0xhYmVsU2hvd10gZGVmYXVsdCBnZXQgZnJvbSBheGlzTW9kZWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuYXhpc05hbWVdIGRlZmF1bHQgZ2V0IGZyb20gYXhpc01vZGVsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmF4aXNOYW1lQXZhaWxhYmxlV2lkdGhdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubGFiZWxSb3RhdGlvbl0gYnkgZGVncmVlLCBkZWZhdWx0IGdldCBmcm9tIGF4aXNNb2RlbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5sYWJlbEludGVydmFsXSBEZWZhdWx0IGxhYmVsIGludGVydmFsIHdoZW4gbGFiZWxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCBmcm9tIG1vZGVsIGlzIG51bGwgb3IgJ2F1dG8nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LnN0cm9rZUNvbnRhaW5UaHJlc2hvbGRdIERlZmF1bHQgbGFiZWwgaW50ZXJ2YWwgd2hlbiBsYWJlbFxuICAgICAqL1xuICAgIHZhciBBeGlzQnVpbGRlciA9IGZ1bmN0aW9uIChheGlzTW9kZWwsIG9wdCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0ID0gb3B0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXhpc01vZGVsID0gYXhpc01vZGVsO1xuXG4gICAgICAgIC8vIERlZmF1bHQgdmFsdWVcbiAgICAgICAgenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgb3B0LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIG5hbWVEaXJlY3Rpb246IDEsXG4gICAgICAgICAgICAgICAgdGlja0RpcmVjdGlvbjogMSxcbiAgICAgICAgICAgICAgICBsYWJlbERpcmVjdGlvbjogMSxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgICAgICAvLyBGSVhNRSBOb3QgdXNlIGEgc2VwZXJhdGUgdGV4dCBncm91cD9cbiAgICAgICAgdmFyIGR1bWJHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBvcHQucG9zaXRpb24uc2xpY2UoKSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBvcHQucm90YXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhpcy5ncm91cC5hZGQoZHVtYkdyb3VwKTtcbiAgICAgICAgLy8gdGhpcy5fZHVtYkdyb3VwID0gZHVtYkdyb3VwO1xuXG4gICAgICAgIGR1bWJHcm91cC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gZHVtYkdyb3VwLnRyYW5zZm9ybTtcblxuICAgICAgICB0aGlzLl9kdW1iR3JvdXAgPSBkdW1iR3JvdXA7XG4gICAgfTtcblxuICAgIEF4aXNCdWlsZGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQXhpc0J1aWxkZXIsXG5cbiAgICAgICAgaGFzQnVpbGRlcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWJ1aWxkZXJzW25hbWVdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGJ1aWxkZXJzW25hbWVdLmNhbGwodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0R3JvdXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyb3VwO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdmFyIGJ1aWxkZXJzID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXhpc0xpbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdDtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmF4aXNNb2RlbDtcblxuICAgICAgICAgICAgaWYgKCFheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5zaG93JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLmF4aXNNb2RlbC5heGlzLmdldEV4dGVudCgpO1xuXG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5fdHJhbnNmb3JtO1xuICAgICAgICAgICAgdmFyIHB0MSA9IFtleHRlbnRbMF0sIDBdO1xuICAgICAgICAgICAgdmFyIHB0MiA9IFtleHRlbnRbMV0sIDBdO1xuICAgICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQxLCBwdDEsIG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwdDIsIHB0MiwgbWF0cml4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQobmV3IGdyYXBoaWMuTGluZShncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lKHtcblxuICAgICAgICAgICAgICAgIC8vIElkIGZvciBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBhbmlkOiAnbGluZScsXG5cbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICB4MTogcHQxWzBdLFxuICAgICAgICAgICAgICAgICAgICB5MTogcHQxWzFdLFxuICAgICAgICAgICAgICAgICAgICB4MjogcHQyWzBdLFxuICAgICAgICAgICAgICAgICAgICB5MjogcHQyWzFdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZTogenJVdGlsLmV4dGVuZChcbiAgICAgICAgICAgICAgICAgICAge2xpbmVDYXA6ICdyb3VuZCd9LFxuICAgICAgICAgICAgICAgICAgICBheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNMaW5lLmxpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzdHJva2VDb250YWluVGhyZXNob2xkOiBvcHQuc3Ryb2tlQ29udGFpblRocmVzaG9sZCB8fCA1LFxuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB6MjogMVxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGF4aXNUaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5heGlzTW9kZWw7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuXG4gICAgICAgICAgICBpZiAoIWF4aXNNb2RlbC5nZXQoJ2F4aXNUaWNrLnNob3cnKSB8fCBheGlzLmlzQmxhbmsoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRpY2tNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc1RpY2snKTtcbiAgICAgICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdDtcblxuICAgICAgICAgICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gdGlja01vZGVsLmdldE1vZGVsKCdsaW5lU3R5bGUnKTtcbiAgICAgICAgICAgIHZhciB0aWNrTGVuID0gdGlja01vZGVsLmdldCgnbGVuZ3RoJyk7XG5cbiAgICAgICAgICAgIHZhciB0aWNrSW50ZXJ2YWwgPSBnZXRJbnRlcnZhbCh0aWNrTW9kZWwsIG9wdC5sYWJlbEludGVydmFsKTtcbiAgICAgICAgICAgIHZhciB0aWNrc0Nvb3JkcyA9IGF4aXMuZ2V0VGlja3NDb29yZHModGlja01vZGVsLmdldCgnYWxpZ25XaXRoTGFiZWwnKSk7XG4gICAgICAgICAgICB2YXIgdGlja3MgPSBheGlzLnNjYWxlLmdldFRpY2tzKCk7XG5cbiAgICAgICAgICAgIHZhciBwdDEgPSBbXTtcbiAgICAgICAgICAgIHZhciBwdDIgPSBbXTtcbiAgICAgICAgICAgIHZhciBtYXRyaXggPSB0aGlzLl90cmFuc2Zvcm07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3NDb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IG9yZGluYWwgc2NhbGUgc3VwcG9ydCB0aWNrIGludGVydmFsXG4gICAgICAgICAgICAgICAgaWYgKGlmSWdub3JlT25UaWNrKGF4aXMsIGksIHRpY2tJbnRlcnZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0aWNrQ29vcmQgPSB0aWNrc0Nvb3Jkc1tpXTtcblxuICAgICAgICAgICAgICAgIHB0MVswXSA9IHRpY2tDb29yZDtcbiAgICAgICAgICAgICAgICBwdDFbMV0gPSAwO1xuICAgICAgICAgICAgICAgIHB0MlswXSA9IHRpY2tDb29yZDtcbiAgICAgICAgICAgICAgICBwdDJbMV0gPSBvcHQudGlja0RpcmVjdGlvbiAqIHRpY2tMZW47XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQxLCBwdDEsIG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQyLCBwdDIsIG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRpY2sgbGluZSwgTm90IHVzZSBncm91cCB0cmFuc2Zvcm0gdG8gaGF2ZSBiZXR0ZXIgbGluZSBkcmF3XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQobmV3IGdyYXBoaWMuTGluZShncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lKHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZCBmb3IgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGFuaWQ6ICd0aWNrXycgKyB0aWNrc1tpXSxcblxuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDE6IHB0MVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxOiBwdDFbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB4MjogcHQyWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTI6IHB0MlsxXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5saW5lU3R5bGUuY29sb3InKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICB6MjogMixcbiAgICAgICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsfSBheGlzTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZE1vZGVsfSBncmlkTW9kZWxcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGF4aXNMYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0O1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuYXhpc01vZGVsO1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICAgICAgICAgIHZhciBzaG93ID0gcmV0cmlldmUob3B0LmF4aXNMYWJlbFNob3csIGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93JykpO1xuXG4gICAgICAgICAgICBpZiAoIXNob3cgfHwgYXhpcy5pc0JsYW5rKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYWJlbE1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKTtcbiAgICAgICAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGxhYmVsTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgICAgICAgICAgdmFyIGxhYmVsTWFyZ2luID0gbGFiZWxNb2RlbC5nZXQoJ21hcmdpbicpO1xuICAgICAgICAgICAgdmFyIHRpY2tzID0gYXhpcy5zY2FsZS5nZXRUaWNrcygpO1xuICAgICAgICAgICAgdmFyIGxhYmVscyA9IGF4aXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbHMoKTtcblxuICAgICAgICAgICAgLy8gU3BlY2lhbCBsYWJlbCByb3RhdGUuXG4gICAgICAgICAgICB2YXIgbGFiZWxSb3RhdGlvbiA9IHJldHJpZXZlKG9wdC5sYWJlbFJvdGF0aW9uLCBsYWJlbE1vZGVsLmdldCgncm90YXRlJykpIHx8IDA7XG4gICAgICAgICAgICAvLyBUbyByYWRpYW4uXG4gICAgICAgICAgICBsYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbiAqIFBJIC8gMTgwO1xuXG4gICAgICAgICAgICB2YXIgbGFiZWxMYXlvdXQgPSBpbm5lclRleHRMYXlvdXQob3B0LCBsYWJlbFJvdGF0aW9uLCBvcHQubGFiZWxEaXJlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5RGF0YSA9IGF4aXNNb2RlbC5nZXQoJ2RhdGEnKTtcblxuICAgICAgICAgICAgdmFyIHRleHRFbHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBzaWxlbnQgPSBpc1NpbGVudChheGlzTW9kZWwpO1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJFdmVudCA9IGF4aXNNb2RlbC5nZXQoJ3RyaWdnZXJFdmVudCcpO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaCh0aWNrcywgZnVuY3Rpb24gKHRpY2tWYWwsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlmSWdub3JlT25UaWNrKGF4aXMsIGluZGV4LCBvcHQubGFiZWxJbnRlcnZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaXRlbVRleHRTdHlsZU1vZGVsID0gdGV4dFN0eWxlTW9kZWw7XG4gICAgICAgICAgICAgICAgaWYgKGNhdGVnb3J5RGF0YSAmJiBjYXRlZ29yeURhdGFbdGlja1ZhbF0gJiYgY2F0ZWdvcnlEYXRhW3RpY2tWYWxdLnRleHRTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtVGV4dFN0eWxlTW9kZWwgPSBuZXcgTW9kZWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeURhdGFbdGlja1ZhbF0udGV4dFN0eWxlLCB0ZXh0U3R5bGVNb2RlbCwgYXhpc01vZGVsLmVjTW9kZWxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRleHRDb2xvciA9IGl0ZW1UZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKVxuICAgICAgICAgICAgICAgICAgICB8fCBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5saW5lU3R5bGUuY29sb3InKTtcblxuICAgICAgICAgICAgICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLmRhdGFUb0Nvb3JkKHRpY2tWYWwpO1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIHRpY2tDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgb3B0LmxhYmVsT2Zmc2V0ICsgb3B0LmxhYmVsRGlyZWN0aW9uICogbGFiZWxNYXJnaW5cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbEJlZm9yZUZvcm1hdCA9IGF4aXMuc2NhbGUuZ2V0TGFiZWwodGlja1ZhbCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dEVsID0gbmV3IGdyYXBoaWMuVGV4dCh7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWQgZm9yIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICBhbmlkOiAnbGFiZWxfJyArIHRpY2tWYWwsXG5cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IGl0ZW1UZXh0U3R5bGVNb2RlbC5nZXQoJ2FsaWduJywgdHJ1ZSkgfHwgbGFiZWxMYXlvdXQudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IGl0ZW1UZXh0U3R5bGVNb2RlbC5nZXQoJ2Jhc2VsaW5lJywgdHJ1ZSkgfHwgbGFiZWxMYXlvdXQudmVydGljYWxBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRGb250OiBpdGVtVGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdHlwZW9mIHRleHRDb2xvciA9PT0gJ2Z1bmN0aW9uJyA/IHRleHRDb2xvcihsYWJlbEJlZm9yZUZvcm1hdCkgOiB0ZXh0Q29sb3JcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb246IGxhYmVsTGF5b3V0LnJvdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHNpbGVudCxcbiAgICAgICAgICAgICAgICAgICAgejI6IDEwXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBQYWNrIGRhdGEgZm9yIG1vdXNlIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RWwuZXZlbnREYXRhID0gbWFrZUF4aXNFdmVudERhdGFCYXNlKGF4aXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIHRleHRFbC5ldmVudERhdGEudGFyZ2V0VHlwZSA9ICdheGlzTGFiZWwnO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RWwuZXZlbnREYXRhLnZhbHVlID0gbGFiZWxCZWZvcmVGb3JtYXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICB0aGlzLl9kdW1iR3JvdXAuYWRkKHRleHRFbCk7XG4gICAgICAgICAgICAgICAgdGV4dEVsLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICAgICAgdGV4dEVscy5wdXNoKHRleHRFbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQodGV4dEVsKTtcblxuICAgICAgICAgICAgICAgIHRleHRFbC5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzVHdvTGFiZWxPdmVybGFwcGVkKGN1cnJlbnQsIG5leHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RSZWN0ID0gY3VycmVudCAmJiBjdXJyZW50LmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRSZWN0ID0gbmV4dCAmJiBuZXh0LmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0UmVjdCAmJiBuZXh0UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlY3QuYXBwbHlUcmFuc2Zvcm0oY3VycmVudC5nZXRMb2NhbFRyYW5zZm9ybSgpKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlY3QuYXBwbHlUcmFuc2Zvcm0obmV4dC5nZXRMb2NhbFRyYW5zZm9ybSgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0UmVjdC5pbnRlcnNlY3QobmV4dFJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbWluIG9yIG1heCBhcmUgdXNlciBzZXQsIHdlIG5lZWQgdG8gY2hlY2tcbiAgICAgICAgICAgIC8vIElmIHRoZSB0aWNrIG9uIG1pbihtYXgpIGFyZSBvdmVybGFwIG9uIHRoZWlyIG5laWdoYm91ciB0aWNrXG4gICAgICAgICAgICAvLyBJZiB0aGV5IGFyZSBvdmVybGFwcGVkLCB3ZSBuZWVkIHRvIGhpZGUgdGhlIG1pbihtYXgpIHRpY2sgbGFiZWxcbiAgICAgICAgICAgIGlmIChheGlzTW9kZWwuZ2V0TWluKCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdExhYmVsID0gdGV4dEVsc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dExhYmVsID0gdGV4dEVsc1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUd29MYWJlbE92ZXJsYXBwZWQoZmlyc3RMYWJlbCwgbmV4dExhYmVsKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdExhYmVsLmlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF4aXNNb2RlbC5nZXRNYXgoKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RMYWJlbCA9IHRleHRFbHNbdGV4dEVscy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldkxhYmVsID0gdGV4dEVsc1t0ZXh0RWxzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgIGlmIChpc1R3b0xhYmVsT3ZlcmxhcHBlZChwcmV2TGFiZWwsIGxhc3RMYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExhYmVsLmlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXhpc05hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdDtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmF4aXNNb2RlbDtcbiAgICAgICAgICAgIHZhciBuYW1lID0gcmV0cmlldmUob3B0LmF4aXNOYW1lLCBheGlzTW9kZWwuZ2V0KCduYW1lJykpO1xuXG4gICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuYW1lTG9jYXRpb24gPSBheGlzTW9kZWwuZ2V0KCduYW1lTG9jYXRpb24nKTtcbiAgICAgICAgICAgIHZhciBuYW1lRGlyZWN0aW9uID0gb3B0Lm5hbWVEaXJlY3Rpb247XG4gICAgICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ25hbWVUZXh0U3R5bGUnKTtcbiAgICAgICAgICAgIHZhciBnYXAgPSBheGlzTW9kZWwuZ2V0KCduYW1lR2FwJykgfHwgMDtcblxuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuYXhpc01vZGVsLmF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICB2YXIgZ2FwU2lnbmFsID0gZXh0ZW50WzBdID4gZXh0ZW50WzFdID8gLTEgOiAxO1xuICAgICAgICAgICAgdmFyIHBvcyA9IFtcbiAgICAgICAgICAgICAgICBuYW1lTG9jYXRpb24gPT09ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgPyBleHRlbnRbMF0gLSBnYXBTaWduYWwgKiBnYXBcbiAgICAgICAgICAgICAgICAgICAgOiBuYW1lTG9jYXRpb24gPT09ICdlbmQnXG4gICAgICAgICAgICAgICAgICAgID8gZXh0ZW50WzFdICsgZ2FwU2lnbmFsICogZ2FwXG4gICAgICAgICAgICAgICAgICAgIDogKGV4dGVudFswXSArIGV4dGVudFsxXSkgLyAyLCAvLyAnbWlkZGxlJ1xuICAgICAgICAgICAgICAgIC8vIFJldXNlIGxhYmVsT2Zmc2V0LlxuICAgICAgICAgICAgICAgIG5hbWVMb2NhdGlvbiA9PT0gJ21pZGRsZScgPyBvcHQubGFiZWxPZmZzZXQgKyBuYW1lRGlyZWN0aW9uICogZ2FwIDogMFxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgdmFyIGxhYmVsTGF5b3V0O1xuXG4gICAgICAgICAgICB2YXIgbmFtZVJvdGF0aW9uID0gYXhpc01vZGVsLmdldCgnbmFtZVJvdGF0ZScpO1xuICAgICAgICAgICAgaWYgKG5hbWVSb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmFtZVJvdGF0aW9uID0gbmFtZVJvdGF0aW9uICogUEkgLyAxODA7IC8vIFRvIHJhZGlhbi5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF4aXNOYW1lQXZhaWxhYmxlV2lkdGg7XG5cbiAgICAgICAgICAgIGlmIChuYW1lTG9jYXRpb24gPT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxMYXlvdXQgPSBpbm5lclRleHRMYXlvdXQoXG4gICAgICAgICAgICAgICAgICAgIG9wdCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZVJvdGF0aW9uICE9IG51bGwgPyBuYW1lUm90YXRpb24gOiBvcHQucm90YXRpb24sIC8vIEFkYXB0IHRvIGF4aXMuXG4gICAgICAgICAgICAgICAgICAgIG5hbWVEaXJlY3Rpb25cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWxMYXlvdXQgPSBlbmRUZXh0TGF5b3V0KFxuICAgICAgICAgICAgICAgICAgICBvcHQsIG5hbWVMb2NhdGlvbiwgbmFtZVJvdGF0aW9uIHx8IDAsIGV4dGVudFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoID0gb3B0LmF4aXNOYW1lQXZhaWxhYmxlV2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoID0gTWF0aC5hYnMoXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoIC8gTWF0aC5zaW4obGFiZWxMYXlvdXQucm90YXRpb24pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICFpc0Zpbml0ZShheGlzTmFtZUF2YWlsYWJsZVdpZHRoKSAmJiAoYXhpc05hbWVBdmFpbGFibGVXaWR0aCA9IG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRleHRGb250ID0gdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpO1xuXG4gICAgICAgICAgICB2YXIgdHJ1bmNhdGVPcHQgPSBheGlzTW9kZWwuZ2V0KCduYW1lVHJ1bmNhdGUnLCB0cnVlKSB8fCB7fTtcbiAgICAgICAgICAgIHZhciBlbGxpcHNpcyA9IHRydW5jYXRlT3B0LmVsbGlwc2lzO1xuICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gcmV0cmlldmUodHJ1bmNhdGVPcHQubWF4V2lkdGgsIGF4aXNOYW1lQXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICAgICAgdmFyIHRydW5jYXRlZFRleHQgPSAoZWxsaXBzaXMgIT0gbnVsbCAmJiBtYXhXaWR0aCAhPSBudWxsKVxuICAgICAgICAgICAgICAgID8gZm9ybWF0VXRpbC50cnVuY2F0ZVRleHQoXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsIG1heFdpZHRoLCB0ZXh0Rm9udCwgZWxsaXBzaXMsXG4gICAgICAgICAgICAgICAgICAgIHttaW5DaGFyOiAyLCBwbGFjZWhvbGRlcjogdHJ1bmNhdGVPcHQucGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogbmFtZTtcblxuICAgICAgICAgICAgdmFyIHRvb2x0aXBPcHQgPSBheGlzTW9kZWwuZ2V0KCd0b29sdGlwJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBtYWluVHlwZSA9IGF4aXNNb2RlbC5tYWluVHlwZTtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZXJQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZTogbWFpblR5cGUsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAkdmFyczogWyduYW1lJ11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3JtYXR0ZXJQYXJhbXNbbWFpblR5cGUgKyAnSW5kZXgnXSA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcblxuICAgICAgICAgICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuXG4gICAgICAgICAgICAgICAgLy8gSWQgZm9yIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGFuaWQ6ICduYW1lJyxcblxuICAgICAgICAgICAgICAgIF9fZnVsbFRleHQ6IG5hbWUsXG4gICAgICAgICAgICAgICAgX190cnVuY2F0ZWRUZXh0OiB0cnVuY2F0ZWRUZXh0LFxuXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdHJ1bmNhdGVkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZvbnQ6IHRleHRGb250LFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgYXhpc01vZGVsLmdldCgnYXhpc0xpbmUubGluZVN0eWxlLmNvbG9yJyksXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogbGFiZWxMYXlvdXQudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogbGFiZWxMYXlvdXQudmVydGljYWxBbGlnblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogbGFiZWxMYXlvdXQucm90YXRpb24sXG4gICAgICAgICAgICAgICAgc2lsZW50OiBpc1NpbGVudChheGlzTW9kZWwpLFxuICAgICAgICAgICAgICAgIHoyOiAxLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6ICh0b29sdGlwT3B0ICYmIHRvb2x0aXBPcHQuc2hvdylcbiAgICAgICAgICAgICAgICAgICAgPyB6clV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXJQYXJhbXM6IGZvcm1hdHRlclBhcmFtc1xuICAgICAgICAgICAgICAgICAgICB9LCB0b29sdGlwT3B0KVxuICAgICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoYXhpc01vZGVsLmdldCgndHJpZ2dlckV2ZW50JykpIHtcbiAgICAgICAgICAgICAgICB0ZXh0RWwuZXZlbnREYXRhID0gbWFrZUF4aXNFdmVudERhdGFCYXNlKGF4aXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgdGV4dEVsLmV2ZW50RGF0YS50YXJnZXRUeXBlID0gJ2F4aXNOYW1lJztcbiAgICAgICAgICAgICAgICB0ZXh0RWwuZXZlbnREYXRhLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgdGhpcy5fZHVtYkdyb3VwLmFkZCh0ZXh0RWwpO1xuICAgICAgICAgICAgdGV4dEVsLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZCh0ZXh0RWwpO1xuXG4gICAgICAgICAgICB0ZXh0RWwuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbm5lclRleHRMYXlvdXQob3B0LCB0ZXh0Um90YXRpb24sIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgcm90YXRpb25EaWZmID0gcmVtUmFkaWFuKHRleHRSb3RhdGlvbiAtIG9wdC5yb3RhdGlvbik7XG4gICAgICAgIHZhciB0ZXh0QWxpZ247XG4gICAgICAgIHZhciB2ZXJ0aWNhbEFsaWduO1xuXG4gICAgICAgIGlmIChpc1JhZGlhbkFyb3VuZFplcm8ocm90YXRpb25EaWZmKSkgeyAvLyBMYWJlbCBpcyBwYXJhbGxlbCB3aXRoIGF4aXMgbGluZS5cbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmFkaWFuQXJvdW5kWmVybyhyb3RhdGlvbkRpZmYgLSBQSSkpIHsgLy8gTGFiZWwgaXMgaW52ZXJzZSBwYXJhbGxlbCB3aXRoIGF4aXMgbGluZS5cbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuXG4gICAgICAgICAgICBpZiAocm90YXRpb25EaWZmID4gMCAmJiByb3RhdGlvbkRpZmYgPCBQSSkge1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IGRpcmVjdGlvbiA+IDAgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gZGlyZWN0aW9uID4gMCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uRGlmZixcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogdmVydGljYWxBbGlnblxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZFRleHRMYXlvdXQob3B0LCB0ZXh0UG9zaXRpb24sIHRleHRSb3RhdGUsIGV4dGVudCkge1xuICAgICAgICB2YXIgcm90YXRpb25EaWZmID0gcmVtUmFkaWFuKHRleHRSb3RhdGUgLSBvcHQucm90YXRpb24pO1xuICAgICAgICB2YXIgdGV4dEFsaWduO1xuICAgICAgICB2YXIgdmVydGljYWxBbGlnbjtcbiAgICAgICAgdmFyIGludmVyc2UgPSBleHRlbnRbMF0gPiBleHRlbnRbMV07XG4gICAgICAgIHZhciBvbkxlZnQgPSAodGV4dFBvc2l0aW9uID09PSAnc3RhcnQnICYmICFpbnZlcnNlKVxuICAgICAgICAgICAgfHwgKHRleHRQb3NpdGlvbiAhPT0gJ3N0YXJ0JyAmJiBpbnZlcnNlKTtcblxuICAgICAgICBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZiAtIFBJIC8gMikpIHtcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ24gPSBvbkxlZnQgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZiAtIFBJICogMS41KSkge1xuICAgICAgICAgICAgdmVydGljYWxBbGlnbiA9IG9uTGVmdCA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGlmIChyb3RhdGlvbkRpZmYgPCBQSSAqIDEuNSAmJiByb3RhdGlvbkRpZmYgPiBQSSAvIDIpIHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBvbkxlZnQgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gb25MZWZ0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb25EaWZmLFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiB2ZXJ0aWNhbEFsaWduXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTaWxlbnQoYXhpc01vZGVsKSB7XG4gICAgICAgIHZhciB0b29sdGlwT3B0ID0gYXhpc01vZGVsLmdldCgndG9vbHRpcCcpO1xuICAgICAgICByZXR1cm4gYXhpc01vZGVsLmdldCgnc2lsZW50JylcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIG1vdXNlIGN1cnNvciwgYWRkIHRoZXNlIHJlc3RyaWN0aW9ucy5cbiAgICAgICAgICAgIHx8ICEoXG4gICAgICAgICAgICAgICAgYXhpc01vZGVsLmdldCgndHJpZ2dlckV2ZW50JykgfHwgKHRvb2x0aXBPcHQgJiYgdG9vbHRpcE9wdC5zaG93KVxuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdmFyIGlmSWdub3JlT25UaWNrID0gQXhpc0J1aWxkZXIuaWZJZ25vcmVPblRpY2sgPSBmdW5jdGlvbiAoYXhpcywgaSwgaW50ZXJ2YWwpIHtcbiAgICAgICAgdmFyIHJhd1RpY2s7XG4gICAgICAgIHZhciBzY2FsZSA9IGF4aXMuc2NhbGU7XG4gICAgICAgIHJldHVybiBzY2FsZS50eXBlID09PSAnb3JkaW5hbCdcbiAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICB0eXBlb2YgaW50ZXJ2YWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdUaWNrID0gc2NhbGUuZ2V0VGlja3MoKVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICFpbnRlcnZhbChyYXdUaWNrLCBzY2FsZS5nZXRMYWJlbChyYXdUaWNrKSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IGkgJSAoaW50ZXJ2YWwgKyAxKVxuICAgICAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhciBnZXRJbnRlcnZhbCA9IEF4aXNCdWlsZGVyLmdldEludGVydmFsID0gZnVuY3Rpb24gKG1vZGVsLCBsYWJlbEludGVydmFsKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IG1vZGVsLmdldCgnaW50ZXJ2YWwnKTtcbiAgICAgICAgaWYgKGludGVydmFsID09IG51bGwgfHwgaW50ZXJ2YWwgPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCA9IGxhYmVsSW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVydmFsO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEF4aXNCdWlsZGVyO1xuXG4iLCJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciBBeGlzQnVpbGRlciA9IHJlcXVpcmUoJy4vQXhpc0J1aWxkZXInKTtcbiAgICB2YXIgaWZJZ25vcmVPblRpY2sgPSBBeGlzQnVpbGRlci5pZklnbm9yZU9uVGljaztcbiAgICB2YXIgZ2V0SW50ZXJ2YWwgPSBBeGlzQnVpbGRlci5nZXRJbnRlcnZhbDtcblxuICAgIHZhciBheGlzQnVpbGRlckF0dHJzID0gW1xuICAgICAgICAnYXhpc0xpbmUnLCAnYXhpc0xhYmVsJywgJ2F4aXNUaWNrJywgJ2F4aXNOYW1lJ1xuICAgIF07XG4gICAgdmFyIHNlbGZCdWlsZGVyQXR0cnMgPSBbXG4gICAgICAgICdzcGxpdEFyZWEnLCAnc3BsaXRMaW5lJ1xuICAgIF07XG5cbiAgICAvLyBmdW5jdGlvbiBnZXRBbGlnbldpdGhMYWJlbChtb2RlbCwgYXhpc01vZGVsKSB7XG4gICAgLy8gICAgIHZhciBhbGlnbldpdGhMYWJlbCA9IG1vZGVsLmdldCgnYWxpZ25XaXRoTGFiZWwnKTtcbiAgICAvLyAgICAgaWYgKGFsaWduV2l0aExhYmVsID09PSAnYXV0bycpIHtcbiAgICAvLyAgICAgICAgIGFsaWduV2l0aExhYmVsID0gYXhpc01vZGVsLmdldCgnYXhpc1RpY2suYWxpZ25XaXRoTGFiZWwnKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICByZXR1cm4gYWxpZ25XaXRoTGFiZWw7XG4gICAgLy8gfVxuXG4gICAgdmFyIEF4aXNWaWV3ID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuXG4gICAgICAgIHR5cGU6ICdheGlzJyxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGVjTW9kZWwpIHtcblxuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcblxuICAgICAgICAgICAgdmFyIG9sZEF4aXNHcm91cCA9IHRoaXMuX2F4aXNHcm91cDtcbiAgICAgICAgICAgIHRoaXMuX2F4aXNHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2F4aXNHcm91cCk7XG5cbiAgICAgICAgICAgIGlmICghYXhpc01vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ3JpZE1vZGVsID0gYXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKTtcblxuICAgICAgICAgICAgdmFyIGxheW91dCA9IGxheW91dEF4aXMoZ3JpZE1vZGVsLCBheGlzTW9kZWwpO1xuXG4gICAgICAgICAgICB2YXIgYXhpc0J1aWxkZXIgPSBuZXcgQXhpc0J1aWxkZXIoYXhpc01vZGVsLCBsYXlvdXQpO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChheGlzQnVpbGRlckF0dHJzLCBheGlzQnVpbGRlci5hZGQsIGF4aXNCdWlsZGVyKTtcblxuICAgICAgICAgICAgdGhpcy5fYXhpc0dyb3VwLmFkZChheGlzQnVpbGRlci5nZXRHcm91cCgpKTtcblxuICAgICAgICAgICAgenJVdGlsLmVhY2goc2VsZkJ1aWxkZXJBdHRycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpc01vZGVsLmdldChuYW1lICsgJy5zaG93JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1snXycgKyBuYW1lXShheGlzTW9kZWwsIGdyaWRNb2RlbCwgbGF5b3V0LmxhYmVsSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBncmFwaGljLmdyb3VwVHJhbnNpdGlvbihvbGRBeGlzR3JvdXAsIHRoaXMuX2F4aXNHcm91cCwgYXhpc01vZGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsfSBheGlzTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZE1vZGVsfSBncmlkTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8RnVuY3Rpb259IGxhYmVsSW50ZXJ2YWxcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zcGxpdExpbmU6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGdyaWRNb2RlbCwgbGFiZWxJbnRlcnZhbCkge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcblxuICAgICAgICAgICAgaWYgKGF4aXMuaXNCbGFuaygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3BsaXRMaW5lTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ3NwbGl0TGluZScpO1xuICAgICAgICAgICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gc3BsaXRMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgICAgICAgICAgdmFyIGxpbmVDb2xvcnMgPSBsaW5lU3R5bGVNb2RlbC5nZXQoJ2NvbG9yJyk7XG5cbiAgICAgICAgICAgIHZhciBsaW5lSW50ZXJ2YWwgPSBnZXRJbnRlcnZhbChzcGxpdExpbmVNb2RlbCwgbGFiZWxJbnRlcnZhbCk7XG5cbiAgICAgICAgICAgIGxpbmVDb2xvcnMgPSB6clV0aWwuaXNBcnJheShsaW5lQ29sb3JzKSA/IGxpbmVDb2xvcnMgOiBbbGluZUNvbG9yc107XG5cbiAgICAgICAgICAgIHZhciBncmlkUmVjdCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFJlY3QoKTtcbiAgICAgICAgICAgIHZhciBpc0hvcml6b250YWwgPSBheGlzLmlzSG9yaXpvbnRhbCgpO1xuXG4gICAgICAgICAgICB2YXIgbGluZUNvdW50ID0gMDtcblxuICAgICAgICAgICAgdmFyIHRpY2tzQ29vcmRzID0gYXhpcy5nZXRUaWNrc0Nvb3JkcyhcbiAgICAgICAgICAgICAgICAvLyBzcGxpdExpbmVNb2RlbC5nZXQoJ2FsaWduV2l0aExhYmVsJylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgdGlja3MgPSBheGlzLnNjYWxlLmdldFRpY2tzKCk7XG5cbiAgICAgICAgICAgIHZhciBwMSA9IFtdO1xuICAgICAgICAgICAgdmFyIHAyID0gW107XG4gICAgICAgICAgICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG4gICAgICAgICAgICAvLyBCYXRjaGluZyB0aGUgbGluZXMgaWYgY29sb3IgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICB2YXIgbGluZVN0eWxlID0gbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzQ29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlmSWdub3JlT25UaWNrKGF4aXMsIGksIGxpbmVJbnRlcnZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRpY2tDb29yZCA9IGF4aXMudG9HbG9iYWxDb29yZCh0aWNrc0Nvb3Jkc1tpXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHAxWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICAgICAgICAgICAgICBwMVsxXSA9IGdyaWRSZWN0Lnk7XG4gICAgICAgICAgICAgICAgICAgIHAyWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICAgICAgICAgICAgICBwMlsxXSA9IGdyaWRSZWN0LnkgKyBncmlkUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwMVswXSA9IGdyaWRSZWN0Lng7XG4gICAgICAgICAgICAgICAgICAgIHAxWzFdID0gdGlja0Nvb3JkO1xuICAgICAgICAgICAgICAgICAgICBwMlswXSA9IGdyaWRSZWN0LnggKyBncmlkUmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcDJbMV0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9ySW5kZXggPSAobGluZUNvdW50KyspICUgbGluZUNvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXhpc0dyb3VwLmFkZChuZXcgZ3JhcGhpYy5MaW5lKGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUoe1xuICAgICAgICAgICAgICAgICAgICBhbmlkOiAnbGluZV8nICsgdGlja3NbaV0sXG5cbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxOiBwMVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxOiBwMVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyOiBwMlswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyOiBwMlsxXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogbGluZUNvbG9yc1tjb2xvckluZGV4XVxuICAgICAgICAgICAgICAgICAgICB9LCBsaW5lU3R5bGUpLFxuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWx9IGF4aXNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWx9IGdyaWRNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxGdW5jdGlvbn0gbGFiZWxJbnRlcnZhbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3NwbGl0QXJlYTogZnVuY3Rpb24gKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBsYWJlbEludGVydmFsKSB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuXG4gICAgICAgICAgICBpZiAoYXhpcy5pc0JsYW5rKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzcGxpdEFyZWFNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRBcmVhJyk7XG4gICAgICAgICAgICB2YXIgYXJlYVN0eWxlTW9kZWwgPSBzcGxpdEFyZWFNb2RlbC5nZXRNb2RlbCgnYXJlYVN0eWxlJyk7XG4gICAgICAgICAgICB2YXIgYXJlYUNvbG9ycyA9IGFyZWFTdHlsZU1vZGVsLmdldCgnY29sb3InKTtcblxuICAgICAgICAgICAgdmFyIGdyaWRSZWN0ID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpO1xuXG4gICAgICAgICAgICB2YXIgdGlja3NDb29yZHMgPSBheGlzLmdldFRpY2tzQ29vcmRzKFxuICAgICAgICAgICAgICAgIC8vIHNwbGl0QXJlYU1vZGVsLmdldCgnYWxpZ25XaXRoTGFiZWwnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IGF4aXMuc2NhbGUuZ2V0VGlja3MoKTtcblxuICAgICAgICAgICAgdmFyIHByZXZYID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzWzBdKTtcbiAgICAgICAgICAgIHZhciBwcmV2WSA9IGF4aXMudG9HbG9iYWxDb29yZCh0aWNrc0Nvb3Jkc1swXSk7XG5cbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBhcmVhSW50ZXJ2YWwgPSBnZXRJbnRlcnZhbChzcGxpdEFyZWFNb2RlbCwgbGFiZWxJbnRlcnZhbCk7XG5cbiAgICAgICAgICAgIHZhciBhcmVhU3R5bGUgPSBhcmVhU3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKTtcbiAgICAgICAgICAgIGFyZWFDb2xvcnMgPSB6clV0aWwuaXNBcnJheShhcmVhQ29sb3JzKSA/IGFyZWFDb2xvcnMgOiBbYXJlYUNvbG9yc107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGlja3NDb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaWZJZ25vcmVPblRpY2soYXhpcywgaSwgYXJlYUludGVydmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGlja0Nvb3JkID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzW2ldKTtcblxuICAgICAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgICAgIHZhciB5O1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChheGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBwcmV2WDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGdyaWRSZWN0Lnk7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gdGlja0Nvb3JkIC0geDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gZ3JpZFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGdyaWRSZWN0Lng7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBwcmV2WTtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBncmlkUmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGlja0Nvb3JkIC0geTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IChjb3VudCsrKSAlIGFyZWFDb2xvcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F4aXNHcm91cC5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGFuaWQ6ICdhcmVhXycgKyB0aWNrc1tpXSxcblxuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGFyZWFDb2xvcnNbY29sb3JJbmRleF1cbiAgICAgICAgICAgICAgICAgICAgfSwgYXJlYVN0eWxlKSxcbiAgICAgICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgcHJldlggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgcHJldlkgPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBBeGlzVmlldy5leHRlbmQoe1xuICAgICAgICB0eXBlOiAneEF4aXMnXG4gICAgfSk7XG4gICAgQXhpc1ZpZXcuZXh0ZW5kKHtcbiAgICAgICAgdHlwZTogJ3lBeGlzJ1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF5b3V0QXhpcyhncmlkTW9kZWwsIGF4aXNNb2RlbCkge1xuICAgICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgICAgICB2YXIgbGF5b3V0ID0ge307XG5cbiAgICAgICAgdmFyIHJhd0F4aXNQb3NpdGlvbiA9IGF4aXMucG9zaXRpb247XG4gICAgICAgIHZhciBheGlzUG9zaXRpb24gPSBheGlzLm9uWmVybyA/ICdvblplcm8nIDogcmF3QXhpc1Bvc2l0aW9uO1xuICAgICAgICB2YXIgYXhpc0RpbSA9IGF4aXMuZGltO1xuXG4gICAgICAgIC8vIFtsZWZ0LCByaWdodCwgdG9wLCBib3R0b21dXG4gICAgICAgIHZhciByZWN0ID0gZ3JpZC5nZXRSZWN0KCk7XG4gICAgICAgIHZhciByZWN0Qm91bmQgPSBbcmVjdC54LCByZWN0LnggKyByZWN0LndpZHRoLCByZWN0LnksIHJlY3QueSArIHJlY3QuaGVpZ2h0XTtcblxuICAgICAgICB2YXIgYXhpc09mZnNldCA9IGF4aXNNb2RlbC5nZXQoJ29mZnNldCcpIHx8IDA7XG5cbiAgICAgICAgdmFyIHBvc01hcCA9IHtcbiAgICAgICAgICAgIHg6IHsgdG9wOiByZWN0Qm91bmRbMl0gLSBheGlzT2Zmc2V0LCBib3R0b206IHJlY3RCb3VuZFszXSArIGF4aXNPZmZzZXQgfSxcbiAgICAgICAgICAgIHk6IHsgbGVmdDogcmVjdEJvdW5kWzBdIC0gYXhpc09mZnNldCwgcmlnaHQ6IHJlY3RCb3VuZFsxXSArIGF4aXNPZmZzZXQgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHBvc01hcC54Lm9uWmVybyA9IE1hdGgubWF4KE1hdGgubWluKGdldFplcm8oJ3knKSwgcG9zTWFwLnguYm90dG9tKSwgcG9zTWFwLngudG9wKTtcbiAgICAgICAgcG9zTWFwLnkub25aZXJvID0gTWF0aC5tYXgoTWF0aC5taW4oZ2V0WmVybygneCcpLCBwb3NNYXAueS5yaWdodCksIHBvc01hcC55LmxlZnQpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFplcm8oZGltLCB2YWwpIHtcbiAgICAgICAgICAgIHZhciB0aGVBeGlzID0gZ3JpZC5nZXRBeGlzKGRpbSk7XG4gICAgICAgICAgICByZXR1cm4gdGhlQXhpcy50b0dsb2JhbENvb3JkKHRoZUF4aXMuZGF0YVRvQ29vcmQoMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXhpcyBwb3NpdGlvblxuICAgICAgICBsYXlvdXQucG9zaXRpb24gPSBbXG4gICAgICAgICAgICBheGlzRGltID09PSAneScgPyBwb3NNYXAueVtheGlzUG9zaXRpb25dIDogcmVjdEJvdW5kWzBdLFxuICAgICAgICAgICAgYXhpc0RpbSA9PT0gJ3gnID8gcG9zTWFwLnhbYXhpc1Bvc2l0aW9uXSA6IHJlY3RCb3VuZFszXVxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIEF4aXMgcm90YXRpb25cbiAgICAgICAgbGF5b3V0LnJvdGF0aW9uID0gTWF0aC5QSSAvIDIgKiAoYXhpc0RpbSA9PT0gJ3gnID8gMCA6IDEpO1xuXG4gICAgICAgIC8vIFRpY2sgYW5kIGxhYmVsIGRpcmVjdGlvbiwgeCB5IGlzIGF4aXNEaW1cbiAgICAgICAgdmFyIGRpck1hcCA9IHt0b3A6IC0xLCBib3R0b206IDEsIGxlZnQ6IC0xLCByaWdodDogMX07XG5cbiAgICAgICAgbGF5b3V0LmxhYmVsRGlyZWN0aW9uID0gbGF5b3V0LnRpY2tEaXJlY3Rpb24gPSBsYXlvdXQubmFtZURpcmVjdGlvbiA9IGRpck1hcFtyYXdBeGlzUG9zaXRpb25dO1xuICAgICAgICBpZiAoYXhpcy5vblplcm8pIHtcbiAgICAgICAgICAgIGxheW91dC5sYWJlbE9mZnNldCA9IHBvc01hcFtheGlzRGltXVtyYXdBeGlzUG9zaXRpb25dIC0gcG9zTWFwW2F4aXNEaW1dLm9uWmVybztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNUaWNrJykuZ2V0KCdpbnNpZGUnKSkge1xuICAgICAgICAgICAgbGF5b3V0LnRpY2tEaXJlY3Rpb24gPSAtbGF5b3V0LnRpY2tEaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc0xhYmVsJykuZ2V0KCdpbnNpZGUnKSkge1xuICAgICAgICAgICAgbGF5b3V0LmxhYmVsRGlyZWN0aW9uID0gLWxheW91dC5sYWJlbERpcmVjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNwZWNpYWwgbGFiZWwgcm90YXRpb25cbiAgICAgICAgdmFyIGxhYmVsUm90YXRpb24gPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNMYWJlbCcpLmdldCgncm90YXRlJyk7XG4gICAgICAgIGxheW91dC5sYWJlbFJvdGF0aW9uID0gYXhpc1Bvc2l0aW9uID09PSAndG9wJyA/IC1sYWJlbFJvdGF0aW9uIDogbGFiZWxSb3RhdGlvbjtcblxuICAgICAgICAvLyBsYWJlbCBpbnRlcnZhbCB3aGVuIGF1dG8gbW9kZS5cbiAgICAgICAgbGF5b3V0LmxhYmVsSW50ZXJ2YWwgPSBheGlzLmdldExhYmVsSW50ZXJ2YWwoKTtcblxuICAgICAgICAvLyBPdmVyIHNwbGl0TGluZSBhbmQgc3BsaXRBcmVhXG4gICAgICAgIGxheW91dC56MiA9IDE7XG5cbiAgICAgICAgcmV0dXJuIGxheW91dDtcbiAgICB9XG4iLCIvKipcbiAqIERhdGFab29tIGNvbXBvbmVudCBlbnRyeVxuICovXG5cblxuICAgIHJlcXVpcmUoJy4vZGF0YVpvb20vdHlwZURlZmF1bHRlcicpO1xuXG4gICAgcmVxdWlyZSgnLi9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsJyk7XG4gICAgcmVxdWlyZSgnLi9kYXRhWm9vbS9EYXRhWm9vbVZpZXcnKTtcblxuICAgIHJlcXVpcmUoJy4vZGF0YVpvb20vSW5zaWRlWm9vbU1vZGVsJyk7XG4gICAgcmVxdWlyZSgnLi9kYXRhWm9vbS9JbnNpZGVab29tVmlldycpO1xuXG4gICAgcmVxdWlyZSgnLi9kYXRhWm9vbS9kYXRhWm9vbVByb2Nlc3NvcicpO1xuICAgIHJlcXVpcmUoJy4vZGF0YVpvb20vZGF0YVpvb21BY3Rpb24nKTtcblxuIiwiLyoqXG4gKiBAZmlsZSBBeGlzIG9wZXJhdG9yXG4gKi9cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgaGVscGVyID0gcmVxdWlyZSgnLi9oZWxwZXInKTtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBhc2MgPSBudW1iZXJVdGlsLmFzYztcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGUgc2luZ2xlIGF4aXMuXG4gICAgICogT25lIGF4aXMgY2FuIG9ubHkgb3BlcmF0ZWQgYnkgb25lIGF4aXMgb3BlcmF0b3IuXG4gICAgICogRGlmZmVyZW50IGRhdGFab29tTW9kZWxzIG1heSBiZSBkZWZpbmVkIHRvIG9wZXJhdGUgdGhlIHNhbWUgYXhpcy5cbiAgICAgKiAoaS5lLiAnaW5zaWRlJyBkYXRhIHpvb20gYW5kICdzbGlkZXInIGRhdGEgem9vbSBjb21wb25lbnRzKVxuICAgICAqIFNvIGRhdGFab29tTW9kZWxzIHNoYXJlIG9uZSBheGlzUHJveHkgaW4gdGhhdCBjYXNlLlxuICAgICAqXG4gICAgICogQGNsYXNzXG4gICAgICovXG4gICAgdmFyIEF4aXNQcm94eSA9IGZ1bmN0aW9uIChkaW1OYW1lLCBheGlzSW5kZXgsIGRhdGFab29tTW9kZWwsIGVjTW9kZWwpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RpbU5hbWUgPSBkaW1OYW1lO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXhpc0luZGV4ID0gYXhpc0luZGV4O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl92YWx1ZVdpbmRvdztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcGVyY2VudFdpbmRvdztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGF0YUV4dGVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6IGVjaGFydHMvbW9kZWwvR2xvYmFsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge21vZHVsZTogZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RhdGFab29tTW9kZWwgPSBkYXRhWm9vbU1vZGVsO1xuICAgIH07XG5cbiAgICBBeGlzUHJveHkucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBBeGlzUHJveHksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGF4aXNQcm94eSBpcyBob3N0ZWQgYnkgZGF0YVpvb21Nb2RlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTogZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbH0gZGF0YVpvb21Nb2RlbFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaG9zdGVkQnk6IGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVpvb21Nb2RlbCA9PT0gZGF0YVpvb21Nb2RlbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFZhbHVlIGNhbiBvbmx5IGJlIE5hTiBvciBmaW5pdGUgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXREYXRhVmFsdWVXaW5kb3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZVdpbmRvdy5zbGljZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldERhdGFQZXJjZW50V2luZG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVyY2VudFdpbmRvdy5zbGljZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBheGlzSW5kZXhcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IHNlcmllc01vZGVsc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGFyZ2V0U2VyaWVzTW9kZWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzTW9kZWxzID0gW107XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcblxuICAgICAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIGlmIChoZWxwZXIuaXNDb29yZFN1cHBvcnRlZChzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpbU5hbWUgPSB0aGlzLl9kaW1OYW1lO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpblR5cGU6IGRpbU5hbWUgKyAnQXhpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KGRpbU5hbWUgKyAnQXhpc0luZGV4JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogc2VyaWVzTW9kZWwuZ2V0KGRpbU5hbWUgKyAnQXhpc0lkJylcbiAgICAgICAgICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9heGlzSW5kZXggPT09IChheGlzTW9kZWwgJiYgYXhpc01vZGVsLmNvbXBvbmVudEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWxzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZXJpZXNNb2RlbHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QXhpc01vZGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lY01vZGVsLmdldENvbXBvbmVudCh0aGlzLl9kaW1OYW1lICsgJ0F4aXMnLCB0aGlzLl9heGlzSW5kZXgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldE90aGVyQXhpc01vZGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXhpc0RpbSA9IHRoaXMuX2RpbU5hbWU7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmdldEF4aXNNb2RlbCgpO1xuICAgICAgICAgICAgdmFyIGlzQ2FydGVzaWFuID0gYXhpc0RpbSA9PT0gJ3gnIHx8IGF4aXNEaW0gPT09ICd5JztcbiAgICAgICAgICAgIHZhciBvdGhlckF4aXNEaW07XG4gICAgICAgICAgICB2YXIgY29vcmRTeXNJbmRleE5hbWU7XG4gICAgICAgICAgICBpZiAoaXNDYXJ0ZXNpYW4pIHtcbiAgICAgICAgICAgICAgICBjb29yZFN5c0luZGV4TmFtZSA9ICdncmlkSW5kZXgnO1xuICAgICAgICAgICAgICAgIG90aGVyQXhpc0RpbSA9IGF4aXNEaW0gPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvb3JkU3lzSW5kZXhOYW1lID0gJ3BvbGFySW5kZXgnO1xuICAgICAgICAgICAgICAgIG90aGVyQXhpc0RpbSA9IGF4aXNEaW0gPT09ICdhbmdsZScgPyAncmFkaXVzJyA6ICdhbmdsZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm91bmRPdGhlckF4aXNNb2RlbDtcbiAgICAgICAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudChvdGhlckF4aXNEaW0gKyAnQXhpcycsIGZ1bmN0aW9uIChvdGhlckF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIGlmICgob3RoZXJBeGlzTW9kZWwuZ2V0KGNvb3JkU3lzSW5kZXhOYW1lKSB8fCAwKVxuICAgICAgICAgICAgICAgICAgICA9PT0gKGF4aXNNb2RlbC5nZXQoY29vcmRTeXNJbmRleE5hbWUpIHx8IDApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kT3RoZXJBeGlzTW9kZWwgPSBvdGhlckF4aXNNb2RlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZE90aGVyQXhpc01vZGVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IGNhbGN1bGF0ZSBieSBnaXZlbiByYW5nZSBhbmQgdGhpcy5fZGF0YUV4dGVudCwgZG8gbm90IGNoYW5nZSBhbnl0aGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5zdGFydF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuZW5kXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5zdGFydFZhbHVlXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5lbmRWYWx1ZV1cbiAgICAgICAgICovXG4gICAgICAgIGNhbGN1bGF0ZURhdGFXaW5kb3c6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhRXh0ZW50ID0gdGhpcy5fZGF0YUV4dGVudDtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmdldEF4aXNNb2RlbCgpO1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gYXhpc01vZGVsLmF4aXMuc2NhbGU7XG4gICAgICAgICAgICB2YXIgcGVyY2VudEV4dGVudCA9IFswLCAxMDBdO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnRXaW5kb3cgPSBbXG4gICAgICAgICAgICAgICAgb3B0LnN0YXJ0LFxuICAgICAgICAgICAgICAgIG9wdC5lbmRcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgdmFsdWVXaW5kb3cgPSBbXTtcblxuICAgICAgICAgICAgLy8gSW4gcGVyY2VudCByYW5nZSBpcyB1c2VkIGFuZCBheGlzIG1pbi9tYXgvc2NhbGUgaXMgc2V0LFxuICAgICAgICAgICAgLy8gd2luZG93IHNob3VsZCBiZSBiYXNlZCBvbiBtaW4vbWF4LzAsIGJ1dCBzaG91bGQgbm90IGJlXG4gICAgICAgICAgICAvLyBiYXNlZCBvbiB0aGUgZXh0ZW50IG9mIGZpbHRlcmVkIGRhdGEuXG4gICAgICAgICAgICBkYXRhRXh0ZW50ID0gZGF0YUV4dGVudC5zbGljZSgpO1xuICAgICAgICAgICAgZml4RXh0ZW50QnlBeGlzKGRhdGFFeHRlbnQsIGF4aXNNb2RlbCk7XG5cbiAgICAgICAgICAgIGVhY2goWydzdGFydFZhbHVlJywgJ2VuZFZhbHVlJ10sIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVXaW5kb3cucHVzaChvcHRbcHJvcF0gIT0gbnVsbCA/IHNjYWxlLnBhcnNlKG9wdFtwcm9wXSkgOiBudWxsKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYm91bmQuXG4gICAgICAgICAgICBlYWNoKFswLCAxXSwgZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBib3VuZFZhbHVlID0gdmFsdWVXaW5kb3dbaWR4XTtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRQZXJjZW50ID0gcGVyY2VudFdpbmRvd1tpZHhdO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQvZW5kIGhhcyBoaWdoZXIgcHJpb3JpdHkgb3ZlciBzdGFydFZhbHVlL2VuZFZhbHVlLFxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugc3RhcnQvZW5kIGNhbiBiZSBjb25zaXN0ZW50IGFtb25nIGRpZmZlcmVudCB0eXBlXG4gICAgICAgICAgICAgICAgLy8gb2YgYXhpcyBidXQgc3RhcnRWYWx1ZS9lbmRWYWx1ZSBub3QuXG5cbiAgICAgICAgICAgICAgICBpZiAoYm91bmRQZXJjZW50ICE9IG51bGwgfHwgYm91bmRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChib3VuZFBlcmNlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRQZXJjZW50ID0gcGVyY2VudEV4dGVudFtpZHhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBzY2FsZS5wYXJzZSB0byBtYXRoIHJvdW5kIGZvciBjYXRlZ29yeSBvciB0aW1lIGF4aXMuXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kVmFsdWUgPSBzY2FsZS5wYXJzZShudW1iZXJVdGlsLmxpbmVhck1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUGVyY2VudCwgcGVyY2VudEV4dGVudCwgZGF0YUV4dGVudCwgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIGJvdW5kUGVyY2VudCA9PSBudWxsICYmIGJvdW5kVmFsdWUgIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICBib3VuZFBlcmNlbnQgPSBudW1iZXJVdGlsLmxpbmVhck1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kVmFsdWUsIGRhdGFFeHRlbnQsIHBlcmNlbnRFeHRlbnQsIHRydWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdmFsdWVXaW5kb3dbaWR4XSA9IHJvdW5kKGJvdW5kVmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIHBlcmNlbnRXaW5kb3dbaWR4XSA9IHJvdW5kKGJvdW5kUGVyY2VudCk7XG4gICAgICAgICAgICAgICAgdmFsdWVXaW5kb3dbaWR4XSA9IGJvdW5kVmFsdWU7XG4gICAgICAgICAgICAgICAgcGVyY2VudFdpbmRvd1tpZHhdID0gYm91bmRQZXJjZW50O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWVXaW5kb3c6IGFzYyh2YWx1ZVdpbmRvdyksXG4gICAgICAgICAgICAgICAgcGVyY2VudFdpbmRvdzogYXNjKHBlcmNlbnRXaW5kb3cpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3RpY2U6IHJlc2V0IHNob3VsZCBub3QgYmUgY2FsbGVkIGJlZm9yZSBzZXJpZXMucmVzdG9yZURhdGEoKSBjYWxsZWQsXG4gICAgICAgICAqIHNvIGl0IGlzIHJlY29tbWFuZGVkIHRvIGJlIGNhbGxlZCBpbiBcInByb2Nlc3Mgc3RhZ2VcIiBidXQgbm90IFwibW9kZWwgaW5pdFxuICAgICAgICAgKiBzdGFnZVwiLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTogZWNoYXJ0cy9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbH0gZGF0YVpvb21Nb2RlbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVpvb21Nb2RlbCAhPT0gdGhpcy5fZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3VsY3VsYXRlIGRhdGEgd2luZG93IGFuZCBkYXRhIGV4dGVudCwgYW5kIHJlY29yZCB0aGVtLlxuICAgICAgICAgICAgdGhpcy5fZGF0YUV4dGVudCA9IGNhbGN1bGF0ZURhdGFFeHRlbnQoXG4gICAgICAgICAgICAgICAgdGhpcy5fZGltTmFtZSwgdGhpcy5nZXRUYXJnZXRTZXJpZXNNb2RlbHMoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBkYXRhV2luZG93ID0gdGhpcy5jYWxjdWxhdGVEYXRhV2luZG93KGRhdGFab29tTW9kZWwub3B0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlV2luZG93ID0gZGF0YVdpbmRvdy52YWx1ZVdpbmRvdztcbiAgICAgICAgICAgIHRoaXMuX3BlcmNlbnRXaW5kb3cgPSBkYXRhV2luZG93LnBlcmNlbnRXaW5kb3c7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBheGlzIHNldHRpbmcgdGhlbi5cbiAgICAgICAgICAgIHNldEF4aXNNb2RlbCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9IGRhdGFab29tTW9kZWxcbiAgICAgICAgICovXG4gICAgICAgIHJlc3RvcmU6IGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVpvb21Nb2RlbCAhPT0gdGhpcy5fZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWVXaW5kb3cgPSB0aGlzLl9wZXJjZW50V2luZG93ID0gbnVsbDtcbiAgICAgICAgICAgIHNldEF4aXNNb2RlbCh0aGlzLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9IGRhdGFab29tTW9kZWxcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlckRhdGE6IGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVpvb21Nb2RlbCAhPT0gdGhpcy5fZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF4aXNEaW0gPSB0aGlzLl9kaW1OYW1lO1xuICAgICAgICAgICAgdmFyIHNlcmllc01vZGVscyA9IHRoaXMuZ2V0VGFyZ2V0U2VyaWVzTW9kZWxzKCk7XG4gICAgICAgICAgICB2YXIgZmlsdGVyTW9kZSA9IGRhdGFab29tTW9kZWwuZ2V0KCdmaWx0ZXJNb2RlJyk7XG4gICAgICAgICAgICB2YXIgdmFsdWVXaW5kb3cgPSB0aGlzLl92YWx1ZVdpbmRvdztcblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIC8vIFRvb2xib3ggbWF5IGhhcyBkYXRhWm9vbSBpbmplY3RlZC4gQW5kIGlmIHRoZXJlIGFyZSBzdGFja2VkIGJhciBjaGFydFxuICAgICAgICAgICAgLy8gd2l0aCBOYU4gZGF0YSwgTmFOIHdpbGwgYmUgZmlsdGVyZWQgYW5kIHN0YWNrIHdpbGwgYmUgd3JvbmcuXG4gICAgICAgICAgICAvLyBTbyB3ZSBuZWVkIHRvIGZvcmNlIHRoZSBtb2RlIHRvIGJlIHNldCBlbXB0eS5cbiAgICAgICAgICAgIC8vIEluIGZlY3QsIGl0IGlzIG5vdCBhIGJpZyBkZWFsIHRoYXQgZG8gbm90IHN1cHBvcnQgZmlsdGVyTW9kZS0nZmlsdGVyJ1xuICAgICAgICAgICAgLy8gd2hlbiB1c2luZyB0b29sYm94I2RhdGFab29tLCB1dGlsbCB0b29sdGlwI2RhdGFab29tIHN1cHBvcnQgXCJzaW5nbGUgYXhpc1xuICAgICAgICAgICAgLy8gc2VsZWN0aW9uXCIgc29tZSBkYXksIHdoaWNoIG1pZ2h0IG5lZWQgXCJhZGFwdCB0byBkYXRhIGV4dGVudCBvbiB0aGVcbiAgICAgICAgICAgIC8vIG90aGVyQXhpc1wiLCB3aGljaCBpcyBkaXNhYmxlZCBieSBmaWx0ZXJNb2RlLSdlbXB0eScuXG4gICAgICAgICAgICB2YXIgb3RoZXJBeGlzTW9kZWwgPSB0aGlzLmdldE90aGVyQXhpc01vZGVsKCk7XG4gICAgICAgICAgICBpZiAoZGF0YVpvb21Nb2RlbC5nZXQoJyRmcm9tVG9vbGJveCcpXG4gICAgICAgICAgICAgICAgJiYgb3RoZXJBeGlzTW9kZWxcbiAgICAgICAgICAgICAgICAmJiBvdGhlckF4aXNNb2RlbC5nZXQoJ3R5cGUnKSA9PT0gJ2NhdGVnb3J5J1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyTW9kZSA9ICdlbXB0eSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3Mgc2VyaWVzIGRhdGFcbiAgICAgICAgICAgIGVhY2goc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcblxuICAgICAgICAgICAgICAgIHNlcmllc0RhdGEgJiYgZWFjaChzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShheGlzRGltKSwgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuc2V0RGF0YShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNEYXRhLm1hcChkaW0sIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzSW5XaW5kb3codmFsdWUpID8gTmFOIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNEYXRhLmZpbHRlclNlbGYoZGltLCBpc0luV2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzSW5XaW5kb3codmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPj0gdmFsdWVXaW5kb3dbMF0gJiYgdmFsdWUgPD0gdmFsdWVXaW5kb3dbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlRGF0YUV4dGVudChheGlzRGltLCBzZXJpZXNNb2RlbHMpIHtcbiAgICAgICAgdmFyIGRhdGFFeHRlbnQgPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG5cbiAgICAgICAgZWFjaChzZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIHNlcmllc0RhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICBpZiAoc2VyaWVzRGF0YSkge1xuICAgICAgICAgICAgICAgIGVhY2goc2VyaWVzTW9kZWwuY29vcmREaW1Ub0RhdGFEaW0oYXhpc0RpbSksIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllc0V4dGVudCA9IHNlcmllc0RhdGEuZ2V0RGF0YUV4dGVudChkaW0pO1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNFeHRlbnRbMF0gPCBkYXRhRXh0ZW50WzBdICYmIChkYXRhRXh0ZW50WzBdID0gc2VyaWVzRXh0ZW50WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzRXh0ZW50WzFdID4gZGF0YUV4dGVudFsxXSAmJiAoZGF0YUV4dGVudFsxXSA9IHNlcmllc0V4dGVudFsxXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmIChkYXRhRXh0ZW50WzFdIDwgZGF0YUV4dGVudFswXSkge1xuICAgICAgICAgICAgZGF0YUV4dGVudCA9IFtOYU4sIE5hTl07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YUV4dGVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhFeHRlbnRCeUF4aXMoZGF0YUV4dGVudCwgYXhpc01vZGVsKSB7XG4gICAgICAgIHZhciBtaW4gPSBheGlzTW9kZWwuZ2V0TWluKHRydWUpO1xuICAgICAgICBpZiAobWluICE9IG51bGwgJiYgbWluICE9PSAnZGF0YU1pbicpIHtcbiAgICAgICAgICAgIGRhdGFFeHRlbnRbMF0gPSBtaW47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heCA9IGF4aXNNb2RlbC5nZXRNYXgodHJ1ZSk7XG4gICAgICAgIGlmIChtYXggIT0gbnVsbCAmJiBtYXggIT09ICdkYXRhTWF4Jykge1xuICAgICAgICAgICAgZGF0YUV4dGVudFsxXSA9IG1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYXhpc01vZGVsLmdldCgnc2NhbGUnLCB0cnVlKSkge1xuICAgICAgICAgICAgZGF0YUV4dGVudFswXSA+IDAgJiYgKGRhdGFFeHRlbnRbMF0gPSAwKTtcbiAgICAgICAgICAgIGRhdGFFeHRlbnRbMV0gPCAwICYmIChkYXRhRXh0ZW50WzFdID0gMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YUV4dGVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRBeGlzTW9kZWwoYXhpc1Byb3h5LCBpc1Jlc3RvcmUpIHtcbiAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGF4aXNQcm94eS5nZXRBeGlzTW9kZWwoKTtcblxuICAgICAgICB2YXIgcGVyY2VudFdpbmRvdyA9IGF4aXNQcm94eS5fcGVyY2VudFdpbmRvdztcbiAgICAgICAgdmFyIHZhbHVlV2luZG93ID0gYXhpc1Byb3h5Ll92YWx1ZVdpbmRvdztcblxuICAgICAgICBpZiAoIXBlcmNlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFswLCA1MDBdOiBhcmJpdHJhcnkgdmFsdWUsIGd1ZXNzIGF4aXMgZXh0ZW50LlxuICAgICAgICB2YXIgcHJlY2lzaW9uID0gbnVtYmVyVXRpbC5nZXRQaXhlbFByZWNpc2lvbih2YWx1ZVdpbmRvdywgWzAsIDUwMF0pO1xuICAgICAgICAvLyBpc1Jlc3RvcmUgb3IgaXNGdWxsXG4gICAgICAgIHZhciB1c2VPcmlnaW4gPSBpc1Jlc3RvcmUgfHwgKHBlcmNlbnRXaW5kb3dbMF0gPT09IDAgJiYgcGVyY2VudFdpbmRvd1sxXSA9PT0gMTAwKTtcblxuICAgICAgICBheGlzTW9kZWwuc2V0UmFuZ2UoXG4gICAgICAgICAgICB1c2VPcmlnaW4gPyBudWxsIDogK3ZhbHVlV2luZG93WzBdLnRvRml4ZWQocHJlY2lzaW9uKSxcbiAgICAgICAgICAgIHVzZU9yaWdpbiA/IG51bGwgOiArdmFsdWVXaW5kb3dbMV0udG9GaXhlZChwcmVjaXNpb24pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBeGlzUHJveHk7XG5cbiIsIi8qKlxuICogQGZpbGUgRGF0YSB6b29tIG1vZGVsXG4gKi9cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIGhlbHBlciA9IHJlcXVpcmUoJy4vaGVscGVyJyk7XG4gICAgdmFyIEF4aXNQcm94eSA9IHJlcXVpcmUoJy4vQXhpc1Byb3h5Jyk7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgZWFjaEF4aXNEaW0gPSBoZWxwZXIuZWFjaEF4aXNEaW07XG5cbiAgICB2YXIgRGF0YVpvb21Nb2RlbCA9IGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50TW9kZWwoe1xuXG4gICAgICAgIHR5cGU6ICdkYXRhWm9vbScsXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbXG4gICAgICAgICAgICAneEF4aXMnLCAneUF4aXMnLCAnekF4aXMnLCAncmFkaXVzQXhpcycsICdhbmdsZUF4aXMnLCAnc2luZ2xlQXhpcycsICdzZXJpZXMnXG4gICAgICAgIF0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIHpsZXZlbDogMCxcbiAgICAgICAgICAgIHo6IDQsICAgICAgICAgICAgICAgICAgIC8vIEhpZ2hlciB0aGFuIG5vcm1hbCBjb21wb25lbnQgKHo6IDIpLlxuICAgICAgICAgICAgb3JpZW50OiBudWxsLCAgICAgICAgICAgLy8gRGVmYXVsdCBhdXRvIGJ5IGF4aXNJbmRleC4gUG9zc2libGUgdmFsdWU6ICdob3Jpem9udGFsJywgJ3ZlcnRpY2FsJy5cbiAgICAgICAgICAgIHhBeGlzSW5kZXg6IG51bGwsICAgICAgIC8vIERlZmF1bHQgdGhlIGZpcnN0IGhvcml6b250YWwgY2F0ZWdvcnkgYXhpcy5cbiAgICAgICAgICAgIHlBeGlzSW5kZXg6IG51bGwsICAgICAgIC8vIERlZmF1bHQgdGhlIGZpcnN0IHZlcnRpY2FsIGNhdGVnb3J5IGF4aXMuXG5cbiAgICAgICAgICAgIGZpbHRlck1vZGU6ICdmaWx0ZXInLCAgIC8vIFBvc3NpYmxlIHZhbHVlczogJ2ZpbHRlcicgb3IgJ2VtcHR5Jy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdmaWx0ZXInOiBkYXRhIGl0ZW1zIHdoaWNoIGFyZSBvdXQgb2Ygd2luZG93IHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICBUaGlzIG9wdGlvbiBpcyBhcHBsaWNhYmxlIHdoZW4gZmlsdGVyaW5nIG91dGxpZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ2VtcHR5JzogZGF0YSBpdGVtcyB3aGljaCBhcmUgb3V0IG9mIHdpbmRvdyB3aWxsIGJlIHNldCB0byBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgIFRoaXMgb3B0aW9uIGlzIGFwcGxpY2FibGUgd2hlbiB1c2VyIHNob3VsZCBub3QgbmVnbGVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgdGhhdCB0aGVyZSBhcmUgc29tZSBkYXRhIGl0ZW1zIG91dCBvZiB3aW5kb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUYWtpbmcgbGluZSBjaGFydCBhcyBhbiBleGFtcGxlLCBsaW5lIHdpbGwgYmUgYnJva2VuIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmlsdGVyZWQgcG9pbnRzIHdoZW4gZmlsdGVyTW9kZWwgaXMgc2V0IHRvICdlbXB0eScsIGJ1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgY29ubmVjdGVkIHdoZW4gc2V0IHRvICdmaWx0ZXInLlxuXG4gICAgICAgICAgICB0aHJvdHRsZTogbnVsbCwgICAgICAgICAvLyBEaXNwYXRjaCBhY3Rpb24gYnkgdGhlIGZpeGVkIHJhdGUsIGF2b2lkIGZyZXF1ZW5jeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgMTAwLiBEbyBub3QgdGhyb3R0bGUgd2hlbiB1c2UgbnVsbC91bmRlZmluZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhbmltYXRpb24gPT09IHRydWUgYW5kIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlID4gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUgaXMgMTAwLCBvdGhlcndpc2UgMjAuXG4gICAgICAgICAgICBzdGFydDogMCwgICAgICAgICAgICAgICAvLyBTdGFydCBwZXJjZW50LiAwIH4gMTAwXG4gICAgICAgICAgICBlbmQ6IDEwMCwgICAgICAgICAgICAgICAvLyBFbmQgcGVyY2VudC4gMCB+IDEwMFxuICAgICAgICAgICAgc3RhcnRWYWx1ZTogbnVsbCwgICAgICAgLy8gU3RhcnQgdmFsdWUuIElmIHN0YXJ0VmFsdWUgc3BlY2lmaWVkLCBzdGFydCBpcyBpZ25vcmVkLlxuICAgICAgICAgICAgZW5kVmFsdWU6IG51bGwgICAgICAgICAgLy8gRW5kIHZhbHVlLiBJZiBlbmRWYWx1ZSBzcGVjaWZpZWQsIGVuZCBpcyBpZ25vcmVkLlxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICoga2V5IGxpa2UgeF8wLCB5XzFcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9kYXRhSW50ZXJ2YWxCeUF4aXMgPSB7fTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9kYXRhSW5mbyA9IHt9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGtleSBsaWtlIHhfMCwgeV8xXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9heGlzUHJveGllcyA9IHt9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnRleHRTdHlsZU1vZGVsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2F1dG9UaHJvdHRsZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciByYXdPcHRpb24gPSByZXRyaWV2ZVJhdyhvcHRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLm1lcmdlRGVmYXVsdEFuZFRoZW1lKG9wdGlvbiwgZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIHRoaXMuZG9Jbml0KHJhd09wdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHRpb24pIHtcbiAgICAgICAgICAgIHZhciByYXdPcHRpb24gPSByZXRyaWV2ZVJhdyhuZXdPcHRpb24pO1xuXG4gICAgICAgICAgICAvL0ZJWCAjMjU5MVxuICAgICAgICAgICAgenJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBuZXdPcHRpb24sIHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLmRvSW5pdChyYXdPcHRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkb0luaXQ6IGZ1bmN0aW9uIChyYXdPcHRpb24pIHtcbiAgICAgICAgICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247XG5cbiAgICAgICAgICAgIC8vIERpc2FibGUgcmVhbHRpbWUgdmlldyB1cGRhdGUgaWYgY2FudmFzIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgICAgICBpZiAoIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzT3B0aW9uLnJlYWx0aW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldERlZmF1bHRUaHJvdHRsZShyYXdPcHRpb24pO1xuXG4gICAgICAgICAgICBwcm9jZXNzUmFuZ2VQcm9wKCdzdGFydCcsICdzdGFydFZhbHVlJywgcmF3T3B0aW9uLCB0aGlzT3B0aW9uKTtcbiAgICAgICAgICAgIHByb2Nlc3NSYW5nZVByb3AoJ2VuZCcsICdlbmRWYWx1ZScsIHJhd09wdGlvbiwgdGhpc09wdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMudGV4dFN0eWxlTW9kZWwgPSB0aGlzLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcblxuICAgICAgICAgICAgdGhpcy5fcmVzZXRUYXJnZXQoKTtcblxuICAgICAgICAgICAgdGhpcy5fZ2l2ZUF4aXNQcm94aWVzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZ2l2ZUF4aXNQcm94aWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXhpc1Byb3hpZXMgPSB0aGlzLl9heGlzUHJveGllcztcblxuICAgICAgICAgICAgdGhpcy5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoZGltTmFtZXMsIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmRlcGVuZGVudE1vZGVsc1tkaW1OYW1lcy5heGlzXVtheGlzSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgZXhpc3RzLCBzaGFyZSBheGlzUHJveHkgd2l0aCBvdGhlciBkYXRhWm9vbU1vZGVscy5cbiAgICAgICAgICAgICAgICB2YXIgYXhpc1Byb3h5ID0gYXhpc01vZGVsLl9fZHpBeGlzUHJveHkgfHwgKFxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IGRhdGFab29tTW9kZWwgYXMgdGhlIG1haW4gbW9kZWwgb2YgYXhpc1Byb3h5LlxuICAgICAgICAgICAgICAgICAgICBheGlzTW9kZWwuX19kekF4aXNQcm94eSA9IG5ldyBBeGlzUHJveHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1OYW1lcy5uYW1lLCBheGlzSW5kZXgsIHRoaXMsIGVjTW9kZWxcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAvLyBkaXNwb3NlIF9fZHpBeGlzUHJveHlcblxuICAgICAgICAgICAgICAgIGF4aXNQcm94aWVzW2RpbU5hbWVzLm5hbWUgKyAnXycgKyBheGlzSW5kZXhdID0gYXhpc1Byb3h5O1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfcmVzZXRUYXJnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247XG5cbiAgICAgICAgICAgIHZhciBhdXRvTW9kZSA9IHRoaXMuX2p1ZGdlQXV0b01vZGUoKTtcblxuICAgICAgICAgICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNJbmRleE5hbWUgPSBkaW1OYW1lcy5heGlzSW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpc09wdGlvbltheGlzSW5kZXhOYW1lXSA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzT3B0aW9uW2F4aXNJbmRleE5hbWVdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoYXV0b01vZGUgPT09ICdheGlzSW5kZXgnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXV0b1NldEF4aXNJbmRleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXV0b01vZGUgPT09ICdvcmllbnQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXV0b1NldE9yaWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2p1ZGdlQXV0b01vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEF1dG8gc2V0IG9ubHkgd29ya3MgZm9yIHNldE9wdGlvbiBhdCB0aGUgZmlyc3QgdGltZS5cbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgdXNlcidzIHJlcG9uc2liaWxpdHkuIFNvIHVzaW5nIG1lcmdlZFxuICAgICAgICAgICAgLy8gb3B0aW9uIGlzIE9LLlxuICAgICAgICAgICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcblxuICAgICAgICAgICAgdmFyIGhhc0luZGV4U3BlY2lmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHVzZXIgc2V0IGF4aXNJbmRleCBhcyBhIGVtcHR5IGFycmF5LCB3ZSB0aGluayB0aGF0IHVzZXIgc3BlY2lmeSBheGlzSW5kZXhcbiAgICAgICAgICAgICAgICAvLyBidXQgZG8gbm90IHdhbnQgdXNlIGF1dG8gbW9kZS4gQmVjYXVzZSBlbXB0eSBhcnJheSBtYXkgYmUgZW5jb3VudGVyZWQgd2hlblxuICAgICAgICAgICAgICAgIC8vIHNvbWUgZXJyb3Igb2NjdXJlZC5cbiAgICAgICAgICAgICAgICBpZiAodGhpc09wdGlvbltkaW1OYW1lcy5heGlzSW5kZXhdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzSW5kZXhTcGVjaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgb3JpZW50ID0gdGhpc09wdGlvbi5vcmllbnQ7XG5cbiAgICAgICAgICAgIGlmIChvcmllbnQgPT0gbnVsbCAmJiBoYXNJbmRleFNwZWNpZmllZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnb3JpZW50JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFoYXNJbmRleFNwZWNpZmllZCkge1xuICAgICAgICAgICAgICAgIGlmIChvcmllbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzT3B0aW9uLm9yaWVudCA9ICdob3Jpem9udGFsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICdheGlzSW5kZXgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2F1dG9TZXRBeGlzSW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhdXRvQXhpc0luZGV4ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvcmllbnQgPSB0aGlzLmdldCgnb3JpZW50JywgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgICAgICAgICAgdmFyIGRlcGVuZGVudE1vZGVscyA9IHRoaXMuZGVwZW5kZW50TW9kZWxzO1xuXG4gICAgICAgICAgICBpZiAoYXV0b0F4aXNJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgYXhpcyB0aGF0IHBhcmFsbGVsIHRvIGRhdGFab29tIGFzIGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgdmFyIGRpbU5hbWUgPSBvcmllbnQgPT09ICd2ZXJ0aWNhbCcgPyAneScgOiAneCc7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW50TW9kZWxzW2RpbU5hbWUgKyAnQXhpcyddLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzT3B0aW9uW2RpbU5hbWUgKyAnQXhpc0luZGV4J10gPSBbMF07XG4gICAgICAgICAgICAgICAgICAgIGF1dG9BeGlzSW5kZXggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVhY2goZGVwZW5kZW50TW9kZWxzLnNpbmdsZUF4aXMsIGZ1bmN0aW9uIChzaW5nbGVBeGlzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdXRvQXhpc0luZGV4ICYmIHNpbmdsZUF4aXNNb2RlbC5nZXQoJ29yaWVudCcsIHRydWUpID09PSBvcmllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzT3B0aW9uLnNpbmdsZUF4aXNJbmRleCA9IFtzaW5nbGVBeGlzTW9kZWwuY29tcG9uZW50SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9BeGlzSW5kZXggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXV0b0F4aXNJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGNhdGVnb3J5IGF4aXMgYXMgZGVmYXVsdC4gKGNvbnNpZGVyIHBvbGFyKVxuICAgICAgICAgICAgICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWF1dG9BeGlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYXhpc0luZGljZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNNb2RlbHMgPSB0aGlzLmRlcGVuZGVudE1vZGVsc1tkaW1OYW1lcy5heGlzXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXNNb2RlbHMubGVuZ3RoICYmICFheGlzSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBheGlzTW9kZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXNNb2RlbHNbaV0uZ2V0KCd0eXBlJykgPT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0luZGljZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpc09wdGlvbltkaW1OYW1lcy5heGlzSW5kZXhdID0gYXhpc0luZGljZXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9BeGlzSW5kZXggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXV0b0F4aXNJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgLy8g6L+Z6YeM5piv5YW85a65ZWMy55qE5YaZ5rOV77yI5rKh5oyH5a6aeEF4aXNJbmRleOWSjHlBeGlzSW5kZXjml7bmiopzY2F0dGVy5ZKM5Y+M5pWw5YC86L205oqY5p+x57qz5YWlZGF0YVpvb23mjqfliLbvvInvvIxcbiAgICAgICAgICAgICAgICAvLyDkvYbmmK/lrp7pmYXmmK/lkKbpnIDopoFHcmlkLmpzI2dldFNjYWxlQnlPcHRpb27mnaXliKTmlq3vvIjogIPomZF0aW1l77yMbG9n562JYXhpcyB0eXBl77yJ77yfXG5cbiAgICAgICAgICAgICAgICAvLyBJZiBib3RoIGRhdGFab29tLnhBeGlzSW5kZXggYW5kIGRhdGFab29tLnlBeGlzSW5kZXggaXMgbm90IHNwZWNpZmllZCxcbiAgICAgICAgICAgICAgICAvLyBkYXRhWm9vbSBjb21wb25lbnQgYXV0byBhZG9wdHMgc2VyaWVzIHRoYXQgcmVmZXJlbmNlIHRvXG4gICAgICAgICAgICAgICAgLy8gYm90aCB4QXhpcyBhbmQgeUF4aXMgd2hpY2ggdHlwZSBpcyAndmFsdWUnLlxuICAgICAgICAgICAgICAgIHRoaXMuZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNTZXJpZXNIYXNBbGxBeGVzVHlwZU9mKHNlcmllc01vZGVsLCAndmFsdWUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNJbmRpY2VzID0gdGhpc09wdGlvbltkaW1OYW1lcy5heGlzSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNJbmRleCA9IHNlcmllc01vZGVsLmdldChkaW1OYW1lcy5heGlzSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGlzSWQgPSBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZXMuYXhpc0lkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBzZXJpZXNNb2RlbC5lY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5UeXBlOiBkaW1OYW1lcy5heGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogYXhpc0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogYXhpc0lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlbMF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbU5hbWVzLmF4aXMgKyAnIFwiJyArIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApICsgJ1wiIG5vdCBmb3VuZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0luZGV4ID0gYXhpc01vZGVsLmNvbXBvbmVudEluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKGF4aXNJbmRpY2VzLCBheGlzSW5kZXgpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzSW5kaWNlcy5wdXNoKGF4aXNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9hdXRvU2V0T3JpZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGltO1xuXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBheGlzXG4gICAgICAgICAgICB0aGlzLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgICAgICAgICAgICFkaW0gJiYgKGRpbSA9IGRpbU5hbWVzLm5hbWUpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXMub3B0aW9uLm9yaWVudCA9IGRpbSA9PT0gJ3knID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9pc1Nlcmllc0hhc0FsbEF4ZXNUeXBlT2Y6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgYXhpc1R5cGUpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyDpnIDopoFzZXJpZXPnmoR4QXhpc0luZGV45ZKMeUF4aXNJbmRleOmDvemmluWFiOiHquWKqOiuvue9ruS4iuOAglxuICAgICAgICAgICAgLy8g5L6L5aaCc2VyaWVzLnR5cGUgPT09IHNjYXR0ZXLml7bjgIJcblxuICAgICAgICAgICAgdmFyIGlzID0gdHJ1ZTtcbiAgICAgICAgICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXNBeGlzSW5kZXggPSBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZXMuYXhpc0luZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5kZXBlbmRlbnRNb2RlbHNbZGltTmFtZXMuYXhpc11bc2VyaWVzQXhpc0luZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmICghYXhpc01vZGVsIHx8IGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSAhPT0gYXhpc1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zZXREZWZhdWx0VGhyb3R0bGU6IGZ1bmN0aW9uIChyYXdPcHRpb24pIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZmlyc3QgdGltZSB1c2VyIHNldCB0aHJvdHRsZSwgYXV0byB0aHJvdHRsZSBlbmRzLlxuICAgICAgICAgICAgaWYgKHJhd09wdGlvbi5oYXNPd25Qcm9wZXJ0eSgndGhyb3R0bGUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9UaHJvdHRsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2F1dG9UaHJvdHRsZSkge1xuICAgICAgICAgICAgICAgIHZhciBnbG9iYWxPcHRpb24gPSB0aGlzLmVjTW9kZWwub3B0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uLnRocm90dGxlID1cbiAgICAgICAgICAgICAgICAgICAgKGdsb2JhbE9wdGlvbi5hbmltYXRpb24gJiYgZ2xvYmFsT3B0aW9uLmFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlID4gMClcbiAgICAgICAgICAgICAgICAgICAgPyAxMDAgOiAyMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Rmlyc3RUYXJnZXRBeGlzTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdEF4aXNNb2RlbDtcbiAgICAgICAgICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEF4aXNNb2RlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5nZXQoZGltTmFtZXMuYXhpc0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEF4aXNNb2RlbCA9IHRoaXMuZGVwZW5kZW50TW9kZWxzW2RpbU5hbWVzLmF4aXNdW2luZGljZXNbMF1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaXJzdEF4aXNNb2RlbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBwYXJhbTogYXhpc01vZGVsLCBkaW1OYW1lcywgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsLCBlY01vZGVsXG4gICAgICAgICAqL1xuICAgICAgICBlYWNoVGFyZ2V0QXhpczogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICAgICAgICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgICAgICAgICAgIGVhY2goXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0KGRpbU5hbWVzLmF4aXNJbmRleCksXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChheGlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZGltTmFtZXMsIGF4aXNJbmRleCwgdGhpcywgZWNNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QXhpc1Byb3h5OiBmdW5jdGlvbiAoZGltTmFtZSwgYXhpc0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXhpc1Byb3hpZXNbZGltTmFtZSArICdfJyArIGF4aXNJbmRleF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG5vdCBzcGVjaWZpZWQsIHNldCB0byB1bmRlZmluZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5zdGFydF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuZW5kXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5zdGFydFZhbHVlXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5lbmRWYWx1ZV1cbiAgICAgICAgICovXG4gICAgICAgIHNldFJhd1JhbmdlOiBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgICBlYWNoKFsnc3RhcnQnLCAnZW5kJywgJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbnkgb2YgdGhvc2UgcHJvcCBpcyBudWxsL3VuZGVmaW5lZCwgd2Ugc2hvdWxkIGFsb3Mgc2V0XG4gICAgICAgICAgICAgICAgLy8gdGhlbSwgYmVjYXVzZSBvbmx5IG9uZSBwYWlyIGJldHdlZW4gc3RhcnQvZW5kIGFuZFxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0VmFsdWUvZW5kVmFsdWUgY2FuIHdvcmsuXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25bbmFtZV0gPSBvcHRbbmFtZV07XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gW3N0YXJ0UGVyY2VudCwgZW5kUGVyY2VudF1cbiAgICAgICAgICovXG4gICAgICAgIGdldFBlcmNlbnRSYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF4aXNQcm94eSA9IHRoaXMuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCk7XG4gICAgICAgICAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF4aXNQcm94eS5nZXREYXRhUGVyY2VudFdpbmRvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEZvciBleGFtcGxlLCBjaGFydC5nZXRNb2RlbCgpLmdldENvbXBvbmVudCgnZGF0YVpvb20nKS5nZXRWYWx1ZVJhbmdlKCd5JywgMCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXhpc0RpbU5hbWVdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXhpc0luZGV4XVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gW3N0YXJ0VmFsdWUsIGVuZFZhbHVlXSB2YWx1ZSBjYW4gb25seSBiZSAnLScgb3IgZmluaXRlIG51bWJlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldFZhbHVlUmFuZ2U6IGZ1bmN0aW9uIChheGlzRGltTmFtZSwgYXhpc0luZGV4KSB7XG4gICAgICAgICAgICBpZiAoYXhpc0RpbU5hbWUgPT0gbnVsbCAmJiBheGlzSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBheGlzUHJveHkgPSB0aGlzLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuICAgICAgICAgICAgICAgIGlmIChheGlzUHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF4aXNQcm94eS5nZXREYXRhVmFsdWVXaW5kb3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBeGlzUHJveHkoYXhpc0RpbU5hbWUsIGF4aXNJbmRleCkuZ2V0RGF0YVZhbHVlV2luZG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0F4aXNQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgaG9zdGVkIGF4aXNQcm94eVxuICAgICAgICAgICAgdmFyIGF4aXNQcm94aWVzID0gdGhpcy5fYXhpc1Byb3hpZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXhpc1Byb3hpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpc1Byb3hpZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBheGlzUHJveGllc1trZXldLmhvc3RlZEJ5KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBheGlzUHJveGllc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gaG9zdGVkIGF4aXMgZmluZCBub3QgaG9zdGVkIGF4aXNQcm94eS5cbiAgICAgICAgICAgIC8vIENvbnNpZGVyIHRoaXMgY2FzZTogZGF0YVpvb21Nb2RlbDEgYW5kIGRhdGFab29tTW9kZWwyIGNvbnRyb2wgdGhlIHNhbWUgYXhpcyxcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgb3B0aW9uLnN0YXJ0IG9yIG9wdGlvbi5lbmQgc2V0dGluZ3MgYXJlIGRpZmZlcmVudC4gVGhlIHBlcmNlbnRSYW5nZVxuICAgICAgICAgICAgLy8gc2hvdWxkIGZvbGxvdyBheGlzUHJveHkuXG4gICAgICAgICAgICAvLyAoV2UgZW5jb3VudGVyIHRoaXMgcHJvYmxlbSBpbiB0b29sYm94IGRhdGEgem9vbS4pXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXhpc1Byb3hpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpc1Byb3hpZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhYXhpc1Byb3hpZXNba2V5XS5ob3N0ZWRCeSh0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXhpc1Byb3hpZXNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcmV0cmlldmVSYXcob3B0aW9uKSB7XG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgZWFjaChcbiAgICAgICAgICAgIFsnc3RhcnQnLCAnZW5kJywgJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnLCAndGhyb3R0bGUnXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLmhhc093blByb3BlcnR5KG5hbWUpICYmIChyZXRbbmFtZV0gPSBvcHRpb25bbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NSYW5nZVByb3AocGVyY2VudFByb3AsIHZhbHVlUHJvcCwgcmF3T3B0aW9uLCB0aGlzT3B0aW9uKSB7XG4gICAgICAgIC8vIHN0YXJ0L2VuZCBoYXMgaGlnaGVyIHByaW9yaXR5IG92ZXIgc3RhcnRWYWx1ZS9lbmRWYWx1ZSxcbiAgICAgICAgLy8gYnV0IHdlIHNob3VsZCBtYWtlIGNoYXJ0LnNldE9wdGlvbih7ZW5kVmFsdWU6IDEwMDB9KSBlZmZlY3RpdmUsXG4gICAgICAgIC8vIHJhdGhlciB0aGFuIGNoYXJ0LnNldE9wdGlvbih7ZW5kVmFsdWU6IDEwMDAsIGVuZDogbnVsbH0pLlxuICAgICAgICBpZiAocmF3T3B0aW9uW3ZhbHVlUHJvcF0gIT0gbnVsbCAmJiByYXdPcHRpb25bcGVyY2VudFByb3BdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXNPcHRpb25bcGVyY2VudFByb3BdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgZG8gbm90aGluZyBhbmQgdXNlIHRoZSBtZXJnZSByZXN1bHQuXG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEYXRhWm9vbU1vZGVsO1xuXG4iLCJcblxuICAgIHZhciBDb21wb25lbnRWaWV3ID0gcmVxdWlyZSgnLi4vLi4vdmlldy9Db21wb25lbnQnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50Vmlldy5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdkYXRhWm9vbScsXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFab29tTW9kZWwgPSBkYXRhWm9vbU1vZGVsO1xuICAgICAgICAgICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgICAgICAgICAgIHRoaXMuYXBpID0gYXBpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSBmaXJzdCB0YXJnZXQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB7XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgIGdyaWQ6IFtcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgIHttb2RlbDogY29vcmQwLCBheGlzTW9kZWxzOiBbYXhpczEsIGF4aXMzXSwgY29vcmRJbmRleDogMX0sXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICB7bW9kZWw6IGNvb3JkMSwgYXhpc01vZGVsczogW2F4aXMwLCBheGlzMl0sIGNvb3JkSW5kZXg6IDB9LFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgIF0sICAvLyBjYXJ0ZXNpYW5zIG11c3Qgbm90IGJlIG51bGwvdW5kZWZpbmVkLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICBwb2xhcjogW1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAge21vZGVsOiBjb29yZDAsIGF4aXNNb2RlbHM6IFtheGlzNF0sIGNvb3JkSW5kZXg6IDB9LFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgIF0sICAvLyBwb2xhcnMgbXVzdCBub3QgYmUgbnVsbC91bmRlZmluZWQuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgIHNpbmdsZUF4aXM6IFtcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgIHttb2RlbDogY29vcmQwLCBheGlzTW9kZWxzOiBbXSwgY29vcmRJbmRleDogMH1cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGFyZ2V0Q29vcmRJbmZvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzTGlzdHMgPSB7fTtcblxuICAgICAgICAgICAgZGF0YVpvb21Nb2RlbC5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoZGltTmFtZXMsIGF4aXNJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudChkaW1OYW1lcy5heGlzLCBheGlzSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChheGlzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkTW9kZWwgPSBheGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpO1xuICAgICAgICAgICAgICAgICAgICBjb29yZE1vZGVsICYmIHNhdmUoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZE1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRTeXNMaXN0c1tjb29yZE1vZGVsLm1haW5UeXBlXSB8fCAoY29vcmRTeXNMaXN0c1tjb29yZE1vZGVsLm1haW5UeXBlXSA9IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkTW9kZWwuY29tcG9uZW50SW5kZXhcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gc2F2ZShjb29yZE1vZGVsLCBheGlzTW9kZWwsIHN0b3JlLCBjb29yZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmVbaV0ubW9kZWwgPT09IGNvb3JkTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBzdG9yZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDogY29vcmRNb2RlbCwgYXhpc01vZGVsczogW10sIGNvb3JkSW5kZXg6IGNvb3JkSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0uYXhpc01vZGVscy5wdXNoKGF4aXNNb2RlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb29yZFN5c0xpc3RzO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuIiwiLyoqXG4gKiBAZmlsZSBEYXRhIHpvb20gbW9kZWxcbiAqL1xuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vRGF0YVpvb21Nb2RlbCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2RhdGFab29tLmluc2lkZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZSwgICAvLyBXaGV0aGVyIGRpc2FibGUgdGhpcyBpbnNpZGUgem9vbS5cbiAgICAgICAgICAgIHpvb21Mb2NrOiBmYWxzZSAgLy8gV2hldGhlciBkaXNhYmxlIHpvb20gYnV0IG9ubHkgcGFuLlxuICAgICAgICB9XG4gICAgfSk7XG4iLCJcblxuICAgIHZhciBEYXRhWm9vbVZpZXcgPSByZXF1aXJlKCcuL0RhdGFab29tVmlldycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgc2xpZGVyTW92ZSA9IHJlcXVpcmUoJy4uL2hlbHBlci9zbGlkZXJNb3ZlJyk7XG4gICAgdmFyIHJvYW1zID0gcmVxdWlyZSgnLi9yb2FtcycpO1xuICAgIHZhciBiaW5kID0genJVdGlsLmJpbmQ7XG5cbiAgICB2YXIgSW5zaWRlWm9vbVZpZXcgPSBEYXRhWm9vbVZpZXcuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnZGF0YVpvb20uaW5zaWRlJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBpbml0OiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqICd0aHJvdHRsZScgaXMgdXNlZCBpbiB0aGlzLmRpc3BhdGNoQWN0aW9uLCBzbyB3ZSBzYXZlIHJhbmdlXG4gICAgICAgICAgICAgKiB0byBhdm9pZCBtaXNzaW5nIHNvbWUgJ3BhbicgaW5mby5cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3JhbmdlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGRhdGFab29tTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgSW5zaWRlWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVuZGVyJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gTm90aWNlOiBvcmlnaW4gdGhpcy5fcmFuZ2Ugc2hvdWxkIGJlIG1haW50YWluZWQsIGFuZCBzaG91bGQgbm90IGJlIHJlLWZldGNoZWRcbiAgICAgICAgICAgIC8vIGZyb20gZGF0YVpvb21Nb2RlbCB3aGVuIHBheWxvYWQudHlwZSBpcyAnZGF0YVpvb20nLCBvdGhlcndpc2UgJ3Bhbicgb3IgJ3pvb20nXG4gICAgICAgICAgICAvLyBpbmZvIHdpbGwgYmUgbWlzc2VkIGJlY2F1c2Ugb2YgJ3Rocm90dGxlJyBvZiB0aGlzLmRpc3BhdGNoQWN0aW9uLlxuICAgICAgICAgICAgaWYgKHJvYW1zLnNob3VsZFJlY29yZFJhbmdlKHBheWxvYWQsIGRhdGFab29tTW9kZWwuaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFuZ2UgPSBkYXRhWm9vbU1vZGVsLmdldFBlcmNlbnRSYW5nZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXNldCBjb250cm9sbGVycy5cbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuZ2V0VGFyZ2V0Q29vcmRJbmZvKCksIGZ1bmN0aW9uIChjb29yZEluZm9MaXN0LCBjb29yZFN5c05hbWUpIHtcblxuICAgICAgICAgICAgICAgIHZhciBhbGxDb29yZElkcyA9IHpyVXRpbC5tYXAoY29vcmRJbmZvTGlzdCwgZnVuY3Rpb24gKGNvb3JkSW5mbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9hbXMuZ2VuZXJhdGVDb29yZElkKGNvb3JkSW5mby5tb2RlbCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChjb29yZEluZm9MaXN0LCBmdW5jdGlvbiAoY29vcmRJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb29yZE1vZGVsID0gY29vcmRJbmZvLm1vZGVsO1xuXG4gICAgICAgICAgICAgICAgICAgIHJvYW1zLnJlZ2lzdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkSWQ6IHJvYW1zLmdlbmVyYXRlQ29vcmRJZChjb29yZE1vZGVsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxDb29yZElkczogYWxsQ29vcmRJZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5jb250YWluUG9pbnQoW3gsIHldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFab29tSWQ6IGRhdGFab29tTW9kZWwuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGVSYXRlOiBkYXRhWm9vbU1vZGVsLmdldCgndGhyb3R0bGUnLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYW5HZXRSYW5nZTogYmluZCh0aGlzLl9vblBhbiwgdGhpcywgY29vcmRJbmZvLCBjb29yZFN5c05hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpvb21HZXRSYW5nZTogYmluZCh0aGlzLl9vblpvb20sIHRoaXMsIGNvb3JkSW5mbywgY29vcmRTeXNOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByb2Ftcy51bnJlZ2lzdGVyKHRoaXMuYXBpLCB0aGlzLmRhdGFab29tTW9kZWwuaWQpO1xuICAgICAgICAgICAgSW5zaWRlWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAnZGlzcG9zZScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLl9yYW5nZSA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfb25QYW46IGZ1bmN0aW9uIChjb29yZEluZm8sIGNvb3JkU3lzTmFtZSwgY29udHJvbGxlciwgZHgsIGR5LCBvbGRYLCBvbGRZLCBuZXdYLCBuZXdZKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhWm9vbU1vZGVsLm9wdGlvbi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYW5nZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2Uuc2xpY2UoKTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyYW5zZm9ybSBieSB0aGUgZmlyc3QgYXhpcy5cbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBjb29yZEluZm8uYXhpc01vZGVsc1swXTtcbiAgICAgICAgICAgIGlmICghYXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uSW5mbyA9IGdldERpcmVjdGlvbkluZm9bY29vcmRTeXNOYW1lXShcbiAgICAgICAgICAgICAgICBbb2xkWCwgb2xkWV0sIFtuZXdYLCBuZXdZXSwgYXhpc01vZGVsLCBjb250cm9sbGVyLCBjb29yZEluZm9cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBwZXJjZW50RGVsdGEgPSBkaXJlY3Rpb25JbmZvLnNpZ25hbFxuICAgICAgICAgICAgICAgICogKHJhbmdlWzFdIC0gcmFuZ2VbMF0pXG4gICAgICAgICAgICAgICAgKiBkaXJlY3Rpb25JbmZvLnBpeGVsIC8gZGlyZWN0aW9uSW5mby5waXhlbExlbmd0aDtcblxuICAgICAgICAgICAgc2xpZGVyTW92ZShwZXJjZW50RGVsdGEsIHJhbmdlLCBbMCwgMTAwXSwgJ3JpZ2lkJyk7XG5cbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fcmFuZ2UgPSByYW5nZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfb25ab29tOiBmdW5jdGlvbiAoY29vcmRJbmZvLCBjb29yZFN5c05hbWUsIGNvbnRyb2xsZXIsIHNjYWxlLCBtb3VzZVgsIG1vdXNlWSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMuZGF0YVpvb21Nb2RlbC5vcHRpb247XG5cbiAgICAgICAgICAgIGlmIChvcHRpb24uZGlzYWJsZWQgfHwgb3B0aW9uLnpvb21Mb2NrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JhbmdlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZS5zbGljZSgpO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJhbnNmb3JtIGJ5IHRoZSBmaXJzdCBheGlzLlxuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGNvb3JkSW5mby5heGlzTW9kZWxzWzBdO1xuICAgICAgICAgICAgaWYgKCFheGlzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb25JbmZvID0gZ2V0RGlyZWN0aW9uSW5mb1tjb29yZFN5c05hbWVdKFxuICAgICAgICAgICAgICAgIG51bGwsIFttb3VzZVgsIG1vdXNlWV0sIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRJbmZvXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgcGVyY2VudFBvaW50ID0gKGRpcmVjdGlvbkluZm8ucGl4ZWwgLSBkaXJlY3Rpb25JbmZvLnBpeGVsU3RhcnQpIC9cbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25JbmZvLnBpeGVsTGVuZ3RoICogKHJhbmdlWzFdIC0gcmFuZ2VbMF0pICsgcmFuZ2VbMF07XG5cbiAgICAgICAgICAgIHNjYWxlID0gTWF0aC5tYXgoMSAvIHNjYWxlLCAwKTtcbiAgICAgICAgICAgIHJhbmdlWzBdID0gKHJhbmdlWzBdIC0gcGVyY2VudFBvaW50KSAqIHNjYWxlICsgcGVyY2VudFBvaW50O1xuICAgICAgICAgICAgcmFuZ2VbMV0gPSAocmFuZ2VbMV0gLSBwZXJjZW50UG9pbnQpICogc2NhbGUgKyBwZXJjZW50UG9pbnQ7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX3JhbmdlID0gZml4UmFuZ2UocmFuZ2UpKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0RGlyZWN0aW9uSW5mbyA9IHtcblxuICAgICAgICBncmlkOiBmdW5jdGlvbiAob2xkUG9pbnQsIG5ld1BvaW50LCBheGlzTW9kZWwsIGNvbnRyb2xsZXIsIGNvb3JkSW5mbykge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICAgICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gY29vcmRJbmZvLm1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpO1xuICAgICAgICAgICAgb2xkUG9pbnQgPSBvbGRQb2ludCB8fCBbMCwgMF07XG5cbiAgICAgICAgICAgIGlmIChheGlzLmRpbSA9PT0gJ3gnKSB7XG4gICAgICAgICAgICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMF0gLSBvbGRQb2ludFswXTtcbiAgICAgICAgICAgICAgICByZXQucGl4ZWxMZW5ndGggPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIHJldC5waXhlbFN0YXJ0ID0gcmVjdC54O1xuICAgICAgICAgICAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAxIDogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gYXhpcy5kaW0gPT09ICd5J1xuICAgICAgICAgICAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzFdIC0gb2xkUG9pbnRbMV07XG4gICAgICAgICAgICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmV0LnBpeGVsU3RhcnQgPSByZWN0Lnk7XG4gICAgICAgICAgICAgICAgcmV0LnNpZ25hbCA9IGF4aXMuaW52ZXJzZSA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2xhcjogZnVuY3Rpb24gKG9sZFBvaW50LCBuZXdQb2ludCwgYXhpc01vZGVsLCBjb250cm9sbGVyLCBjb29yZEluZm8pIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgICAgICAgICB2YXIgcmV0ID0ge307XG4gICAgICAgICAgICB2YXIgcG9sYXIgPSBjb29yZEluZm8ubW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHZhciByYWRpdXNFeHRlbnQgPSBwb2xhci5nZXRSYWRpdXNBeGlzKCkuZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICB2YXIgYW5nbGVFeHRlbnQgPSBwb2xhci5nZXRBbmdsZUF4aXMoKS5nZXRFeHRlbnQoKTtcblxuICAgICAgICAgICAgb2xkUG9pbnQgPSBvbGRQb2ludCA/IHBvbGFyLnBvaW50VG9Db29yZChvbGRQb2ludCkgOiBbMCwgMF07XG4gICAgICAgICAgICBuZXdQb2ludCA9IHBvbGFyLnBvaW50VG9Db29yZChuZXdQb2ludCk7XG5cbiAgICAgICAgICAgIGlmIChheGlzTW9kZWwubWFpblR5cGUgPT09ICdyYWRpdXNBeGlzJykge1xuICAgICAgICAgICAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzBdIC0gb2xkUG9pbnRbMF07XG4gICAgICAgICAgICAgICAgLy8gcmV0LnBpeGVsTGVuZ3RoID0gTWF0aC5hYnMocmFkaXVzRXh0ZW50WzFdIC0gcmFkaXVzRXh0ZW50WzBdKTtcbiAgICAgICAgICAgICAgICAvLyByZXQucGl4ZWxTdGFydCA9IE1hdGgubWluKHJhZGl1c0V4dGVudFswXSwgcmFkaXVzRXh0ZW50WzFdKTtcbiAgICAgICAgICAgICAgICByZXQucGl4ZWxMZW5ndGggPSByYWRpdXNFeHRlbnRbMV0gLSByYWRpdXNFeHRlbnRbMF07XG4gICAgICAgICAgICAgICAgcmV0LnBpeGVsU3RhcnQgPSByYWRpdXNFeHRlbnRbMF07XG4gICAgICAgICAgICAgICAgcmV0LnNpZ25hbCA9IGF4aXMuaW52ZXJzZSA/IDEgOiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyAnYW5nbGVBeGlzJ1xuICAgICAgICAgICAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzFdIC0gb2xkUG9pbnRbMV07XG4gICAgICAgICAgICAgICAgLy8gcmV0LnBpeGVsTGVuZ3RoID0gTWF0aC5hYnMoYW5nbGVFeHRlbnRbMV0gLSBhbmdsZUV4dGVudFswXSk7XG4gICAgICAgICAgICAgICAgLy8gcmV0LnBpeGVsU3RhcnQgPSBNYXRoLm1pbihhbmdsZUV4dGVudFswXSwgYW5nbGVFeHRlbnRbMV0pO1xuICAgICAgICAgICAgICAgIHJldC5waXhlbExlbmd0aCA9IGFuZ2xlRXh0ZW50WzFdIC0gYW5nbGVFeHRlbnRbMF07XG4gICAgICAgICAgICAgICAgcmV0LnBpeGVsU3RhcnQgPSBhbmdsZUV4dGVudFswXTtcbiAgICAgICAgICAgICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gLTEgOiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpbmdsZUF4aXM6IGZ1bmN0aW9uIChvbGRQb2ludCwgbmV3UG9pbnQsIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBjb29yZEluZm8ubW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgcmV0ID0ge307XG5cbiAgICAgICAgICAgIG9sZFBvaW50ID0gb2xkUG9pbnQgfHwgWzAsIDBdO1xuXG4gICAgICAgICAgICBpZiAoYXhpcy5vcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzBdIC0gb2xkUG9pbnRbMF07XG4gICAgICAgICAgICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICByZXQucGl4ZWxTdGFydCA9IHJlY3QueDtcbiAgICAgICAgICAgICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gMSA6IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vICd2ZXJ0aWNhbCdcbiAgICAgICAgICAgICAgICByZXQucGl4ZWwgPSBuZXdQb2ludFsxXSAtIG9sZFBvaW50WzFdO1xuICAgICAgICAgICAgICAgIHJldC5waXhlbExlbmd0aCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHJldC5waXhlbFN0YXJ0ID0gcmVjdC55O1xuICAgICAgICAgICAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAtMSA6IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZml4UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgLy8gQ2xhbXAsIHVzaW5nICEoPD0gb3IgPj0pIHRvIGhhbmRsZSBOYU4uXG4gICAgICAgIC8vIGpzaGludCBpZ25vcmU6c3RhcnRcbiAgICAgICAgdmFyIGJvdW5kID0gWzAsIDEwMF07XG4gICAgICAgICEocmFuZ2VbMF0gPD0gYm91bmRbMV0pICYmIChyYW5nZVswXSA9IGJvdW5kWzFdKTtcbiAgICAgICAgIShyYW5nZVsxXSA8PSBib3VuZFsxXSkgJiYgKHJhbmdlWzFdID0gYm91bmRbMV0pO1xuICAgICAgICAhKHJhbmdlWzBdID49IGJvdW5kWzBdKSAmJiAocmFuZ2VbMF0gPSBib3VuZFswXSk7XG4gICAgICAgICEocmFuZ2VbMV0gPj0gYm91bmRbMF0pICYmIChyYW5nZVsxXSA9IGJvdW5kWzBdKTtcbiAgICAgICAgLy8ganNoaW50IGlnbm9yZTplbmRcblxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBJbnNpZGVab29tVmlldztcbiIsIi8qKlxuICogQGZpbGUgRGF0YSB6b29tIGFjdGlvblxuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgaGVscGVyID0gcmVxdWlyZSgnLi9oZWxwZXInKTtcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKTtcblxuXG4gICAgZWNoYXJ0cy5yZWdpc3RlckFjdGlvbignZGF0YVpvb20nLCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuXG4gICAgICAgIHZhciBsaW5rZWROb2Rlc0ZpbmRlciA9IGhlbHBlci5jcmVhdGVMaW5rZWROb2Rlc0ZpbmRlcihcbiAgICAgICAgICAgIHpyVXRpbC5iaW5kKGVjTW9kZWwuZWFjaENvbXBvbmVudCwgZWNNb2RlbCwgJ2RhdGFab29tJyksXG4gICAgICAgICAgICBoZWxwZXIuZWFjaEF4aXNEaW0sXG4gICAgICAgICAgICBmdW5jdGlvbiAobW9kZWwsIGRpbU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsLmdldChkaW1OYW1lcy5heGlzSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBlZmZlY3RlZE1vZGVscyA9IFtdO1xuXG4gICAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudChcbiAgICAgICAgICAgIHttYWluVHlwZTogJ2RhdGFab29tJywgcXVlcnk6IHBheWxvYWR9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGVmZmVjdGVkTW9kZWxzLnB1c2guYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdGVkTW9kZWxzLCBsaW5rZWROb2Rlc0ZpbmRlcihtb2RlbCkubm9kZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHpyVXRpbC5lYWNoKGVmZmVjdGVkTW9kZWxzLCBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGRhdGFab29tTW9kZWwuc2V0UmF3UmFuZ2Uoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXlsb2FkLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogcGF5bG9hZC5lbmQsXG4gICAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogcGF5bG9hZC5zdGFydFZhbHVlLFxuICAgICAgICAgICAgICAgIGVuZFZhbHVlOiBwYXlsb2FkLmVuZFZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuIiwiLyoqXG4gKiBAZmlsZSBEYXRhIHpvb20gcHJvY2Vzc29yXG4gKi9cblxuXG4gICAgdmFyIGVjaGFydHMgPSByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJyk7XG5cbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcblxuICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ2RhdGFab29tJywgZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbGN1bGF0ZSB3aW5kb3cgYW5kIHJlc2V0IGF4aXMgaGVyZSBidXQgbm90IGluIG1vZGVsXG4gICAgICAgICAgICAvLyBpbml0IHN0YWdlIGFuZCBub3QgYWZ0ZXIgYWN0aW9uIGRpc3BhdGNoIGhhbmRsZXIsIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHJlc2V0IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgc2VyaWVzRGF0YS5yZXN0b3JlRGF0YS5cbiAgICAgICAgICAgIGRhdGFab29tTW9kZWwuZWFjaFRhcmdldEF4aXMocmVzZXRTaW5nbGVBeGlzKTtcblxuICAgICAgICAgICAgLy8gQ2F1dGlvbjogZGF0YSB6b29tIGZpbHRlcmluZyBpcyBvcmRlciBzZW5zaXRpdmUgd2hlbiB1c2luZ1xuICAgICAgICAgICAgLy8gcGVyY2VudCByYW5nZSBhbmQgbm8gbWluL21heC9zY2FsZSBzZXQgb24gYXhpcy5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCB3ZSBoYXZlIGRhdGFab29tIGRlZmluaXRpb246XG4gICAgICAgICAgICAvLyBbXG4gICAgICAgICAgICAvLyAgICAgIHt4QXhpc0luZGV4OiAwLCBzdGFydDogMzAsIGVuZDogNzB9LFxuICAgICAgICAgICAgLy8gICAgICB7eUF4aXNJbmRleDogMCwgc3RhcnQ6IDIwLCBlbmQ6IDgwfVxuICAgICAgICAgICAgLy8gXVxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBbMjAsIDgwXSBvZiB5LWRhdGFab29tIHNob3VsZCBiZSBiYXNlZCBvbiBkYXRhXG4gICAgICAgICAgICAvLyB0aGF0IGhhdmUgZmlsdGVyZWQgYnkgeC1kYXRhWm9vbSB1c2luZyByYW5nZSBvZiBbMzAsIDcwXSxcbiAgICAgICAgICAgIC8vIGJ1dCBzaG91bGQgbm90IGJlIGJhc2VkIG9uIGZ1bGwgcmF3IGRhdGEuIFRodXMgc2xpZGluZ1xuICAgICAgICAgICAgLy8geC1kYXRhWm9vbSB3aWxsIGNoYW5nZSBib3RoIHJhbmdlcyBvZiB4QXhpcyBhbmQgeUF4aXMsXG4gICAgICAgICAgICAvLyB3aGlsZSBzbGlkaW5nIHktZGF0YVpvb20gd2lsbCBvbmx5IGNoYW5nZSB0aGUgcmFuZ2Ugb2YgeUF4aXMuXG4gICAgICAgICAgICAvLyBTbyB3ZSBzaG91bGQgZmlsdGVyIHgtYXhpcyBhZnRlciByZXNldCB4LWF4aXMgaW1tZWRpYXRlbHksXG4gICAgICAgICAgICAvLyBhbmQgdGhlbiByZXNldCB5LWF4aXMgYW5kIGZpbHRlciB5LWF4aXMuXG4gICAgICAgICAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZpbHRlclNpbmdsZUF4aXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ2RhdGFab29tJywgZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICAgICAgICAgIC8vIEZ1bGxmaWxsIGFsbCBvZiB0aGUgcmFuZ2UgcHJvcHMgc28gdGhhdCB1c2VyXG4gICAgICAgICAgICAvLyBpcyBhYmxlIHRvIGdldCB0aGVtIGZyb20gY2hhcnQuZ2V0T3B0aW9uKCkuXG4gICAgICAgICAgICB2YXIgYXhpc1Byb3h5ID0gZGF0YVpvb21Nb2RlbC5maW5kUmVwcmVzZW50YXRpdmVBeGlzUHJveHkoKTtcbiAgICAgICAgICAgIHZhciBwZXJjZW50UmFuZ2UgPSBheGlzUHJveHkuZ2V0RGF0YVBlcmNlbnRXaW5kb3coKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZVJhbmdlID0gYXhpc1Byb3h5LmdldERhdGFWYWx1ZVdpbmRvdygpO1xuXG4gICAgICAgICAgICBkYXRhWm9vbU1vZGVsLnNldFJhd1JhbmdlKHtcbiAgICAgICAgICAgICAgICBzdGFydDogcGVyY2VudFJhbmdlWzBdLFxuICAgICAgICAgICAgICAgIGVuZDogcGVyY2VudFJhbmdlWzFdLFxuICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWU6IHZhbHVlUmFuZ2VbMF0sXG4gICAgICAgICAgICAgICAgZW5kVmFsdWU6IHZhbHVlUmFuZ2VbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHJlc2V0U2luZ2xlQXhpcyhkaW1OYW1lcywgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgIGRhdGFab29tTW9kZWwuZ2V0QXhpc1Byb3h5KGRpbU5hbWVzLm5hbWUsIGF4aXNJbmRleCkucmVzZXQoZGF0YVpvb21Nb2RlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyU2luZ2xlQXhpcyhkaW1OYW1lcywgYXhpc0luZGV4LCBkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgIGRhdGFab29tTW9kZWwuZ2V0QXhpc1Byb3h5KGRpbU5hbWVzLm5hbWUsIGF4aXNJbmRleCkuZmlsdGVyRGF0YShkYXRhWm9vbU1vZGVsKTtcbiAgICB9XG5cblxuIiwiXG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2Zvcm1hdCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBoZWxwZXIgPSB7fTtcblxuICAgIHZhciBBWElTX0RJTVMgPSBbJ3gnLCAneScsICd6JywgJ3JhZGl1cycsICdhbmdsZScsICdzaW5nbGUnXTtcbiAgICAvLyBTdXBwb3J0ZWQgY29vcmRzLlxuICAgIHZhciBDT09SRFMgPSBbJ2NhcnRlc2lhbjJkJywgJ3BvbGFyJywgJ3NpbmdsZUF4aXMnXTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZFR5cGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGhlbHBlci5pc0Nvb3JkU3VwcG9ydGVkID0gZnVuY3Rpb24gKGNvb3JkVHlwZSkge1xuICAgICAgICByZXR1cm4genJVdGlsLmluZGV4T2YoQ09PUkRTLCBjb29yZFR5cGUpID49IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBcImVhY2hcIiBtZXRob2QgdG8gaXRlcmF0ZSBuYW1lcy5cbiAgICAgKlxuICAgICAqIEBwdWJpbGNcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48c3RyaW5nPn0gbmFtZXNcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48c3RyaW5nPj19IGF0dHJzXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaGVscGVyLmNyZWF0ZU5hbWVFYWNoID0gZnVuY3Rpb24gKG5hbWVzLCBhdHRycykge1xuICAgICAgICBuYW1lcyA9IG5hbWVzLnNsaWNlKCk7XG4gICAgICAgIHZhciBjYXBpdGFsTmFtZXMgPSB6clV0aWwubWFwKG5hbWVzLCBmb3JtYXRVdGlsLmNhcGl0YWxGaXJzdCk7XG4gICAgICAgIGF0dHJzID0gKGF0dHJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICB2YXIgY2FwaXRhbEF0dHJzID0genJVdGlsLm1hcChhdHRycywgZm9ybWF0VXRpbC5jYXBpdGFsRmlyc3QpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZU9iaiA9IHtuYW1lOiBuYW1lLCBjYXBpdGFsOiBjYXBpdGFsTmFtZXNbaW5kZXhdfTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXR0cnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZU9ialthdHRyc1tqXV0gPSBuYW1lICsgY2FwaXRhbEF0dHJzW2pdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgbmFtZU9iaik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBlYWNoIGRpbWVuc2lvbiBuYW1lLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBwYXJhbWV0ZXIgaXMgbGlrZTpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhbmdsZScsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcGl0YWw6ICdBbmdsZScsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXM6ICdhbmdsZUF4aXMnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzSW5kZXg6ICdhbmdsZUFpeHMnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogJ2FuZ2xlSW5kZXgnXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAgICovXG4gICAgaGVscGVyLmVhY2hBeGlzRGltID0gaGVscGVyLmNyZWF0ZU5hbWVFYWNoKEFYSVNfRElNUywgWydheGlzSW5kZXgnLCAnYXhpcycsICdpbmRleCcsICdpZCddKTtcblxuICAgIC8qKlxuICAgICAqIElmIHRvdyBkYXRhWm9vbU1vZGVscyBoYXMgdGhlIHNhbWUgYXhpcyBjb250cm9sbGVkLCB3ZSBzYXkgdGhhdCB0aGV5IGFyZSAnbGlua2VkJy5cbiAgICAgKiBkYXRhWm9vbU1vZGVscyBhbmQgJ2xpbmtzJyBtYWtlIHVwIG9uZSBvciBtb3JlIGdyYXBoaWNzLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZmluZHMgdGhlIGdyYXBoaWMgd2hlcmUgdGhlIHNvdXJjZSBkYXRhWm9vbU1vZGVsIGlzIGluLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZvckVhY2hOb2RlIE5vZGUgaXRlcmF0b3IuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm9yRWFjaEVkZ2VUeXBlIGVkZ2VUeXBlIGl0ZXJhdG9yXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWRnZUlkR2V0dGVyIEdpdmluZyBub2RlIGFuZCBlZGdlVHlwZSwgcmV0dXJuIGFuIGFycmF5IG9mIGVkZ2UgaWQuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IElucHV0OiBzb3VyY2VOb2RlLCBPdXRwdXQ6IExpa2Uge25vZGVzOiBbXSwgZGltczoge319XG4gICAgICovXG4gICAgaGVscGVyLmNyZWF0ZUxpbmtlZE5vZGVzRmluZGVyID0gZnVuY3Rpb24gKGZvckVhY2hOb2RlLCBmb3JFYWNoRWRnZVR5cGUsIGVkZ2VJZEdldHRlcikge1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlTm9kZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgICAgICAgcmVjb3Jkczoge30gLy8ga2V5OiBlZGdlVHlwZS5uYW1lLCB2YWx1ZTogT2JqZWN0IChrZXk6IGVkZ2UgaWQsIHZhbHVlOiBib29sZWFuKS5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvckVhY2hFZGdlVHlwZShmdW5jdGlvbiAoZWRnZVR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVjb3Jkc1tlZGdlVHlwZS5uYW1lXSA9IHt9O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghc291cmNlTm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFic29yYihzb3VyY2VOb2RlLCByZXN1bHQpO1xuXG4gICAgICAgICAgICB2YXIgZXhpc3RzTGluaztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBleGlzdHNMaW5rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yRWFjaE5vZGUocHJvY2Vzc1NpbmdsZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGV4aXN0c0xpbmspO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzU2luZ2xlTm9kZShub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGVBYnNvcmRlZChub2RlLCByZXN1bHQpICYmIGlzTGlua2VkKG5vZGUsIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJzb3JiKG5vZGUsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0c0xpbmsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBpc05vZGVBYnNvcmRlZChub2RlLCByZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiB6clV0aWwuaW5kZXhPZihyZXN1bHQubm9kZXMsIG5vZGUpID49IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc0xpbmtlZChub2RlLCByZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBoYXNMaW5rID0gZmFsc2U7XG4gICAgICAgICAgICBmb3JFYWNoRWRnZVR5cGUoZnVuY3Rpb24gKGVkZ2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2goZWRnZUlkR2V0dGVyKG5vZGUsIGVkZ2VUeXBlKSB8fCBbXSwgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVjb3Jkc1tlZGdlVHlwZS5uYW1lXVtlZGdlSWRdICYmIChoYXNMaW5rID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBoYXNMaW5rO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWJzb3JiKG5vZGUsIHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0Lm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBmb3JFYWNoRWRnZVR5cGUoZnVuY3Rpb24gKGVkZ2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2goZWRnZUlkR2V0dGVyKG5vZGUsIGVkZ2VUeXBlKSB8fCBbXSwgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVjb3Jkc1tlZGdlVHlwZS5uYW1lXVtlZGdlSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuIiwiLyoqXG4gKiBAZmlsZSBSb2FtIGNvbnRyb2xsZXIgbWFuYWdlci5cbiAqL1xuXG5cbiAgICAvLyBPbmx5IGNyZWF0ZSBvbmUgcm9hbSBjb250cm9sbGVyIGZvciBlYWNoIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgIC8vIG9uZSByb2FtIGNvbnRyb2xsZXIgbWlnaHQgYmUgcmVmZXJlZCBieSB0d28gaW5zaWRlIGRhdGEgem9vbVxuICAgIC8vIGNvbXBvbmVudHMgKGZvciBleGFtcGxlLCBvbmUgZm9yIHggYW5kIG9uZSBmb3IgeSkuIFdoZW4gdXNlclxuICAgIC8vIHBhbiBvciB6b29tLCBvbmx5IGRpc3BhdGNoIG9uZSBhY3Rpb24gZm9yIHRob3NlIGRhdGEgem9vbVxuICAgIC8vIGNvbXBvbmVudHMuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIFJvYW1Db250cm9sbGVyID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlcicpO1xuICAgIHZhciB0aHJvdHRsZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdGhyb3R0bGUnKTtcbiAgICB2YXIgY3VycnkgPSB6clV0aWwuY3Vycnk7XG5cbiAgICB2YXIgQVRUUiA9ICdcXDBfZWNfZGF0YVpvb21fcm9hbXMnO1xuXG4gICAgdmFyIHJvYW1zID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFab29tSW5mb1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVpvb21JbmZvLmNvb3JkSWRcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGF0YVpvb21JbmZvLmNvbnRhaW5zUG9pbnRcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gZGF0YVpvb21JbmZvLmFsbENvb3JkSWRzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhWm9vbUluZm8uZGF0YVpvb21JZFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YVpvb21JbmZvLnRocm90dGxlUmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkYXRhWm9vbUluZm8ucGFuR2V0UmFuZ2VcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGF0YVpvb21JbmZvLnpvb21HZXRSYW5nZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChhcGksIGRhdGFab29tSW5mbykge1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gZ2l2ZVN0b3JlKGFwaSk7XG4gICAgICAgICAgICB2YXIgdGhlRGF0YVpvb21JZCA9IGRhdGFab29tSW5mby5kYXRhWm9vbUlkO1xuICAgICAgICAgICAgdmFyIHRoZUNvb3JkSWQgPSBkYXRhWm9vbUluZm8uY29vcmRJZDtcblxuICAgICAgICAgICAgLy8gRG8gY2xlYW4gd2hlbiBhIGRhdGFab29tIGNoYW5nZXMgaXRzIHRhcmdldCBjb29yZG5hdGUgc3lzdGVtLlxuICAgICAgICAgICAgLy8gQXZvaWQgbWVtb3J5IGxlYWssIGRpc3Bvc2UgYWxsIG5vdC11c2VkLXJlZ2lzdGVyZWQuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdG9yZSwgZnVuY3Rpb24gKHJlY29yZCwgY29vcmRJZCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhWm9vbUluZm9zID0gcmVjb3JkLmRhdGFab29tSW5mb3M7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFab29tSW5mb3NbdGhlRGF0YVpvb21JZF1cbiAgICAgICAgICAgICAgICAgICAgJiYgenJVdGlsLmluZGV4T2YoZGF0YVpvb21JbmZvLmFsbENvb3JkSWRzLCB0aGVDb29yZElkKSA8IDBcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFab29tSW5mb3NbdGhlRGF0YVpvb21JZF07XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5jb3VudC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjbGVhblN0b3JlKHN0b3JlKTtcblxuICAgICAgICAgICAgdmFyIHJlY29yZCA9IHN0b3JlW3RoZUNvb3JkSWRdO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGlmIG5lZWRlZC5cbiAgICAgICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkID0gc3RvcmVbdGhlQ29vcmRJZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkSWQ6IHRoZUNvb3JkSWQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFab29tSW5mb3M6IHt9LFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVjb3JkLmNvbnRyb2xsZXIgPSBjcmVhdGVDb250cm9sbGVyKGFwaSwgZGF0YVpvb21JbmZvLCByZWNvcmQpO1xuICAgICAgICAgICAgICAgIHJlY29yZC5kaXNwYXRjaEFjdGlvbiA9IHpyVXRpbC5jdXJyeShkaXNwYXRjaEFjdGlvbiwgYXBpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29uc2lkZXIgcmVzaXplLCBhcmVhIHNob3VsZCBiZSBhbHdheXMgdXBkYXRlZC5cbiAgICAgICAgICAgIHJlY29yZC5jb250cm9sbGVyLnNldENvbnRhaW5zUG9pbnQoZGF0YVpvb21JbmZvLmNvbnRhaW5zUG9pbnQpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhyb3R0bGUuXG4gICAgICAgICAgICB0aHJvdHRsZS5jcmVhdGVPclVwZGF0ZShcbiAgICAgICAgICAgICAgICByZWNvcmQsXG4gICAgICAgICAgICAgICAgJ2Rpc3BhdGNoQWN0aW9uJyxcbiAgICAgICAgICAgICAgICBkYXRhWm9vbUluZm8udGhyb3R0bGVSYXRlLFxuICAgICAgICAgICAgICAgICdmaXhSYXRlJ1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHJlZmVyZW5jZSBvZiBkYXRhWm9vbS5cbiAgICAgICAgICAgICEocmVjb3JkLmRhdGFab29tSW5mb3NbdGhlRGF0YVpvb21JZF0pICYmIHJlY29yZC5jb3VudCsrO1xuICAgICAgICAgICAgcmVjb3JkLmRhdGFab29tSW5mb3NbdGhlRGF0YVpvb21JZF0gPSBkYXRhWm9vbUluZm87XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVpvb21JZFxuICAgICAgICAgKi9cbiAgICAgICAgdW5yZWdpc3RlcjogZnVuY3Rpb24gKGFwaSwgZGF0YVpvb21JZCkge1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gZ2l2ZVN0b3JlKGFwaSk7XG5cbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHN0b3JlLCBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkLmNvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhWm9vbUluZm9zID0gcmVjb3JkLmRhdGFab29tSW5mb3M7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFab29tSW5mb3NbZGF0YVpvb21JZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFab29tSW5mb3NbZGF0YVpvb21JZF07XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5jb3VudC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjbGVhblN0b3JlKHN0b3JlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgc2hvdWxkUmVjb3JkUmFuZ2U6IGZ1bmN0aW9uIChwYXlsb2FkLCBkYXRhWm9vbUlkKSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLnR5cGUgPT09ICdkYXRhWm9vbScgJiYgcGF5bG9hZC5iYXRjaCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXlsb2FkLmJhdGNoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmJhdGNoW2ldLmRhdGFab29tSWQgPT09IGRhdGFab29tSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICBnZW5lcmF0ZUNvb3JkSWQ6IGZ1bmN0aW9uIChjb29yZE1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29vcmRNb2RlbC50eXBlICsgJ1xcMF8nICsgY29vcmRNb2RlbC5pZDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBLZXk6IGNvb3JkSWQsIHZhbHVlOiB7ZGF0YVpvb21JbmZvczogW10sIGNvdW50LCBjb250cm9sbGVyfVxuICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnaXZlU3RvcmUoYXBpKSB7XG4gICAgICAgIC8vIE1vdW50IHN0b3JlIG9uIHpyZW5kZXIgaW5zdGFuY2UsIHNvIHRoYXQgd2UgZG8gbm90XG4gICAgICAgIC8vIG5lZWQgdG8gd29ycnkgYWJvdXQgZGlzcG9zZS5cbiAgICAgICAgdmFyIHpyID0gYXBpLmdldFpyKCk7XG4gICAgICAgIHJldHVybiB6cltBVFRSXSB8fCAoenJbQVRUUl0gPSB7fSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29udHJvbGxlcihhcGksIGRhdGFab29tSW5mbywgbmV3UmVjb3JkKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IFJvYW1Db250cm9sbGVyKGFwaS5nZXRacigpKTtcbiAgICAgICAgY29udHJvbGxlci5lbmFibGUoKTtcbiAgICAgICAgY29udHJvbGxlci5vbigncGFuJywgY3Vycnkob25QYW4sIG5ld1JlY29yZCkpO1xuICAgICAgICBjb250cm9sbGVyLm9uKCd6b29tJywgY3Vycnkob25ab29tLCBuZXdSZWNvcmQpKTtcblxuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhblN0b3JlKHN0b3JlKSB7XG4gICAgICAgIHpyVXRpbC5lYWNoKHN0b3JlLCBmdW5jdGlvbiAocmVjb3JkLCBjb29yZElkKSB7XG4gICAgICAgICAgICBpZiAoIXJlY29yZC5jb3VudCkge1xuICAgICAgICAgICAgICAgIHJlY29yZC5jb250cm9sbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RvcmVbY29vcmRJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUGFuKHJlY29yZCwgZHgsIGR5LCBvbGRYLCBvbGRZLCBuZXdYLCBuZXdZKSB7XG4gICAgICAgIHdyYXBBbmREaXNwYXRjaChyZWNvcmQsIGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mby5wYW5HZXRSYW5nZShyZWNvcmQuY29udHJvbGxlciwgZHgsIGR5LCBvbGRYLCBvbGRZLCBuZXdYLCBuZXdZKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25ab29tKHJlY29yZCwgc2NhbGUsIG1vdXNlWCwgbW91c2VZKSB7XG4gICAgICAgIHdyYXBBbmREaXNwYXRjaChyZWNvcmQsIGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mby56b29tR2V0UmFuZ2UocmVjb3JkLmNvbnRyb2xsZXIsIHNjYWxlLCBtb3VzZVgsIG1vdXNlWSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBBbmREaXNwYXRjaChyZWNvcmQsIGdldFJhbmdlKSB7XG4gICAgICAgIHZhciBiYXRjaCA9IFtdO1xuXG4gICAgICAgIHpyVXRpbC5lYWNoKHJlY29yZC5kYXRhWm9vbUluZm9zLCBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZ2V0UmFuZ2UoaW5mbyk7XG4gICAgICAgICAgICByYW5nZSAmJiBiYXRjaC5wdXNoKHtcbiAgICAgICAgICAgICAgICBkYXRhWm9vbUlkOiBpbmZvLmRhdGFab29tSWQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHJhbmdlWzBdLFxuICAgICAgICAgICAgICAgIGVuZDogcmFuZ2VbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZWNvcmQuZGlzcGF0Y2hBY3Rpb24oYmF0Y2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYWN0aW9uIHdpbGwgYmUgdGhyb3R0bGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uKGFwaSwgYmF0Y2gpIHtcbiAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXRhWm9vbScsXG4gICAgICAgICAgICBiYXRjaDogYmF0Y2hcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByb2FtcztcblxuIiwiXG5cbiAgICByZXF1aXJlKCcuLi8uLi9tb2RlbC9Db21wb25lbnQnKS5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIoJ2RhdGFab29tJywgZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAvLyBEZWZhdWx0ICdzbGlkZXInIHdoZW4gbm8gdHlwZSBzcGVjaWZpZWQuXG4gICAgICAgIHJldHVybiAnc2xpZGVyJztcbiAgICB9KTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcblxuICAgIHJlcXVpcmUoJy4uL2Nvb3JkL2NhcnRlc2lhbi9HcmlkJyk7XG5cbiAgICByZXF1aXJlKCcuL2F4aXMnKTtcblxuICAgIC8vIEdyaWQgdmlld1xuICAgIGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ2dyaWQnLFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGdyaWRNb2RlbCwgZWNNb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICAgICAgICAgIGlmIChncmlkTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFJlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBncmlkTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKVxuICAgICAgICAgICAgICAgICAgICB9LCBncmlkTW9kZWwuZ2V0SXRlbVN0eWxlKCkpLFxuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHoyOiAtMVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgLy8gT25seSBjcmVhdGUgZ3JpZCB3aGVuIG5lZWRcbiAgICAgICAgaWYgKG9wdGlvbi54QXhpcyAmJiBvcHRpb24ueUF4aXMgJiYgIW9wdGlvbi5ncmlkKSB7XG4gICAgICAgICAgICBvcHRpb24uZ3JpZCA9IHt9O1xuICAgICAgICB9XG4gICAgfSk7XG4iLCIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb21wb25lbnQvaGVscGVyL1JvYW1Db250cm9sbGVyXG4gKi9cblxuXG5cbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZXZlbnRUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9ldmVudCcpO1xuICAgIHZhciBpbnRlcmFjdGlvbk11dGV4ID0gcmVxdWlyZSgnLi9pbnRlcmFjdGlvbk11dGV4Jyk7XG5cbiAgICBmdW5jdGlvbiBtb3VzZWRvd24oZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQgJiYgZS50YXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgICAgICAgdmFyIHkgPSBlLm9mZnNldFk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGFpbnNQb2ludCAmJiB0aGlzLmNvbnRhaW5zUG9pbnQoeCwgeSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmUoZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2RyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcblxuICAgICAgICBpZiAoZS5nZXN0dXJlRXZlbnQgIT09ICdwaW5jaCcpIHtcblxuICAgICAgICAgICAgaWYgKGludGVyYWN0aW9uTXV0ZXguaXNUYWtlbih0aGlzLl96ciwgJ2dsb2JhbFBhbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgIHZhciB5ID0gZS5vZmZzZXRZO1xuXG4gICAgICAgICAgICB2YXIgb2xkWCA9IHRoaXMuX3g7XG4gICAgICAgICAgICB2YXIgb2xkWSA9IHRoaXMuX3k7XG5cbiAgICAgICAgICAgIHZhciBkeCA9IHggLSBvbGRYO1xuICAgICAgICAgICAgdmFyIGR5ID0geSAtIG9sZFk7XG5cbiAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgdGhpcy5feSA9IHk7XG5cbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcblxuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0YXJnZXQucG9zaXRpb247XG4gICAgICAgICAgICAgICAgcG9zWzBdICs9IGR4O1xuICAgICAgICAgICAgICAgIHBvc1sxXSArPSBkeTtcbiAgICAgICAgICAgICAgICB0YXJnZXQuZGlydHkoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbicsIGR4LCBkeSwgb2xkWCwgb2xkWSwgeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXVwKGUpIHtcbiAgICAgICAgdGhpcy5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXdoZWVsKGUpIHtcbiAgICAgICAgLy8gQ29udmVuaWVuY2U6XG4gICAgICAgIC8vIE1hYyBhbmQgVk0gV2luZG93cyBvbiBNYWM6IHNjcm9sbCB1cDogem9vbSBvdXQuXG4gICAgICAgIC8vIFdpbmRvd3M6IHNjcm9sbCB1cDogem9vbSBpbi5cbiAgICAgICAgdmFyIHpvb21EZWx0YSA9IGUud2hlZWxEZWx0YSA+IDAgPyAxLjEgOiAxIC8gMS4xO1xuICAgICAgICB6b29tLmNhbGwodGhpcywgZSwgem9vbURlbHRhLCBlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGluY2goZSkge1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb25NdXRleC5pc1Rha2VuKHRoaXMuX3pyLCAnZ2xvYmFsUGFuJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgem9vbURlbHRhID0gZS5waW5jaFNjYWxlID4gMSA/IDEuMSA6IDEgLyAxLjE7XG4gICAgICAgIHpvb20uY2FsbCh0aGlzLCBlLCB6b29tRGVsdGEsIGUucGluY2hYLCBlLnBpbmNoWSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gem9vbShlLCB6b29tRGVsdGEsIHpvb21YLCB6b29tWSkge1xuICAgICAgICBpZiAodGhpcy5jb250YWluc1BvaW50ICYmIHRoaXMuY29udGFpbnNQb2ludCh6b29tWCwgem9vbVkpKSB7XG4gICAgICAgICAgICAvLyBXaGVuIG1vdXNlIGlzIG91dCBvZiByb2FtQ29udHJvbGxlciByZWN0LFxuICAgICAgICAgICAgLy8gZGVmYXVsdCBiZWZhdm9pdXMgc2hvdWxkIGJlIGJlIGRpc2FibGVkLCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIHBhZ2Ugc2xpZGluZyBpcyBkaXNhYmxlZCwgY29udHJhcnkgdG8gZXhwZWN0YXRpb24uXG4gICAgICAgICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcblxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgICAgICAgdmFyIHpvb21MaW1pdCA9IHRoaXMuem9vbUxpbWl0O1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IHRhcmdldC5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB0YXJnZXQuc2NhbGU7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV3Wm9vbSA9IHRoaXMuem9vbSA9IHRoaXMuem9vbSB8fCAxO1xuICAgICAgICAgICAgICAgIG5ld1pvb20gKj0gem9vbURlbHRhO1xuICAgICAgICAgICAgICAgIGlmICh6b29tTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHpvb21NaW4gPSB6b29tTGltaXQubWluIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB6b29tTWF4ID0gem9vbUxpbWl0Lm1heCB8fCBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Wm9vbSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oem9vbU1heCwgbmV3Wm9vbSksXG4gICAgICAgICAgICAgICAgICAgICAgICB6b29tTWluXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB6b29tU2NhbGUgPSBuZXdab29tIC8gdGhpcy56b29tO1xuICAgICAgICAgICAgICAgIHRoaXMuem9vbSA9IG5ld1pvb207XG4gICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgbW91c2UgY2VudGVyIHdoZW4gc2NhbGluZ1xuICAgICAgICAgICAgICAgIHBvc1swXSAtPSAoem9vbVggLSBwb3NbMF0pICogKHpvb21TY2FsZSAtIDEpO1xuICAgICAgICAgICAgICAgIHBvc1sxXSAtPSAoem9vbVkgLSBwb3NbMV0pICogKHpvb21TY2FsZSAtIDEpO1xuICAgICAgICAgICAgICAgIHNjYWxlWzBdICo9IHpvb21TY2FsZTtcbiAgICAgICAgICAgICAgICBzY2FsZVsxXSAqPSB6b29tU2NhbGU7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQuZGlydHkoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd6b29tJywgem9vbURlbHRhLCB6b29tWCwgem9vbVkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWl4aW4ge21vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsfVxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci96cmVuZGVyflpSZW5kZXJ9IHpyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSB0YXJnZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSb2FtQ29udHJvbGxlcih6ciwgdGFyZ2V0KSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGFpbnNQb2ludDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogeyBtaW46IDEsIG1heDogMiB9XG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpvb21MaW1pdDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuem9vbTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3pyID0genI7XG5cbiAgICAgICAgLy8gQXZvaWQgdHdvIHJvYW1Db250cm9sbGVyIGJpbmQgdGhlIHNhbWUgaGFuZGxlclxuICAgICAgICB2YXIgYmluZCA9IHpyVXRpbC5iaW5kO1xuICAgICAgICB2YXIgbW91c2Vkb3duSGFuZGxlciA9IGJpbmQobW91c2Vkb3duLCB0aGlzKTtcbiAgICAgICAgdmFyIG1vdXNlbW92ZUhhbmRsZXIgPSBiaW5kKG1vdXNlbW92ZSwgdGhpcyk7XG4gICAgICAgIHZhciBtb3VzZXVwSGFuZGxlciA9IGJpbmQobW91c2V1cCwgdGhpcyk7XG4gICAgICAgIHZhciBtb3VzZXdoZWVsSGFuZGxlciA9IGJpbmQobW91c2V3aGVlbCwgdGhpcyk7XG4gICAgICAgIHZhciBwaW5jaEhhbmRsZXIgPSBiaW5kKHBpbmNoLCB0aGlzKTtcblxuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb250YWluc1BvaW50XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgIGlucHV0OiB4LCB5XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgIG91dHB1dDogYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRDb250YWluc1BvaW50ID0gZnVuY3Rpb24gKGNvbnRhaW5zUG9pbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbnNQb2ludCA9IGNvbnRhaW5zUG9pbnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGljZTogb25seSBlbmFibGUgbmVlZGVkIHR5cGVzLiBGb3IgZXhhbXBsZSwgaWYgJ3pvb20nXG4gICAgICAgICAqIGlzIG5vdCBuZWVkZWQsICd6b29tJyBzaG91bGQgbm90IGJlIGVuYWJsZWQsIG90aGVyd2lzZVxuICAgICAgICAgKiBkZWZhdWx0IG1vdXNld2hlZWwgYmVoYXZpb3VyIChzY3JvbGwgcGFnZSkgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbnxzdHJpbmd9IFtjb250cm9sVHlwZT10cnVlXSBTcGVjaWZ5IHRoZSBjb250cm9sIHR5cGUsXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBjYW4gYmUgbnVsbC91bmRlZmluZWQgb3IgdHJ1ZS9mYWxzZVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgJ3Bhbi9tb3ZlJyBvciAnem9vbScvJ3NjYWxlJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbmFibGUgPSBmdW5jdGlvbiAoY29udHJvbFR5cGUpIHtcbiAgICAgICAgICAgIC8vIERpc2FibGUgcHJldmlvdXMgZmlyc3RcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuXG4gICAgICAgICAgICBpZiAoY29udHJvbFR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnRyb2xUeXBlID09PSB0cnVlIHx8IChjb250cm9sVHlwZSA9PT0gJ21vdmUnIHx8IGNvbnRyb2xUeXBlID09PSAncGFuJykpIHtcbiAgICAgICAgICAgICAgICB6ci5vbignbW91c2Vkb3duJywgbW91c2Vkb3duSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgenIub24oJ21vdXNlbW92ZScsIG1vdXNlbW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHpyLm9uKCdtb3VzZXVwJywgbW91c2V1cEhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRyb2xUeXBlID09PSB0cnVlIHx8IChjb250cm9sVHlwZSA9PT0gJ3NjYWxlJyB8fCBjb250cm9sVHlwZSA9PT0gJ3pvb20nKSkge1xuICAgICAgICAgICAgICAgIHpyLm9uKCdtb3VzZXdoZWVsJywgbW91c2V3aGVlbEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHpyLm9uKCdwaW5jaCcsIHBpbmNoSGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgenIub2ZmKCdtb3VzZWRvd24nLCBtb3VzZWRvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIHpyLm9mZignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICB6ci5vZmYoJ21vdXNldXAnLCBtb3VzZXVwSGFuZGxlcik7XG4gICAgICAgICAgICB6ci5vZmYoJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsSGFuZGxlcik7XG4gICAgICAgICAgICB6ci5vZmYoJ3BpbmNoJywgcGluY2hIYW5kbGVyKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRpc3Bvc2UgPSB0aGlzLmRpc2FibGU7XG5cbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RyYWdnaW5nO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaXNQaW5jaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9waW5jaGluZztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB6clV0aWwubWl4aW4oUm9hbUNvbnRyb2xsZXIsIEV2ZW50ZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUm9hbUNvbnRyb2xsZXI7XG4iLCJcblxuICAgIHZhciBBVFRSID0gJ1xcMF9lY19pbnRlcmFjdGlvbl9tdXRleCc7XG5cbiAgICB2YXIgaW50ZXJhY3Rpb25NdXRleCA9IHtcblxuICAgICAgICB0YWtlOiBmdW5jdGlvbiAoenIsIHJlc291cmNlS2V5LCB1c2VyS2V5KSB7XG4gICAgICAgICAgICB2YXIgc3RvcmUgPSBnZXRTdG9yZSh6cik7XG4gICAgICAgICAgICBzdG9yZVtyZXNvdXJjZUtleV0gPSB1c2VyS2V5O1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbGVhc2U6IGZ1bmN0aW9uICh6ciwgcmVzb3VyY2VLZXksIHVzZXJLZXkpIHtcbiAgICAgICAgICAgIHZhciBzdG9yZSA9IGdldFN0b3JlKHpyKTtcbiAgICAgICAgICAgIHZhciB1S2V5ID0gc3RvcmVbcmVzb3VyY2VLZXldO1xuXG4gICAgICAgICAgICBpZiAodUtleSA9PT0gdXNlcktleSkge1xuICAgICAgICAgICAgICAgIHN0b3JlW3Jlc291cmNlS2V5XSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNUYWtlbjogZnVuY3Rpb24gKHpyLCByZXNvdXJjZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuICEhZ2V0U3RvcmUoenIpW3Jlc291cmNlS2V5XTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRTdG9yZSh6cikge1xuICAgICAgICByZXR1cm4genJbQVRUUl0gfHwgKHpyW0FUVFJdID0ge30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHBheWxvYWQ6IHtcbiAgICAgKiAgICAgdHlwZTogJ3Rha2VHbG9iYWxDdXJzb3InLFxuICAgICAqICAgICBrZXk6ICdkYXRhWm9vbVNlbGVjdCcsIG9yICdicnVzaCcsIG9yIC4uLixcbiAgICAgKiAgICAgICAgIElmIG5vIHVzZXJLZXksIHJlbGVhc2UgZ2xvYmFsIGN1cnNvci5cbiAgICAgKiB9XG4gICAgICovXG4gICAgcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLnJlZ2lzdGVyQWN0aW9uKFxuICAgICAgICB7dHlwZTogJ3Rha2VHbG9iYWxDdXJzb3InLCBldmVudDogJ2dsb2JhbEN1cnNvclRha2VuJywgdXBkYXRlOiAndXBkYXRlJ30sXG4gICAgICAgIGZ1bmN0aW9uICgpIHt9XG4gICAgKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gaW50ZXJhY3Rpb25NdXRleDtcbiIsIlxuICAgIC8vIExpc3QgbGF5b3V0XG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbGF5b3V0Jyk7XG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2Zvcm1hdCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbkdyb3VwKGdyb3VwLCBtb2RlbCwgYXBpKSB7XG4gICAgICAgIGxheW91dC5wb3NpdGlvbkVsZW1lbnQoXG4gICAgICAgICAgICBncm91cCwgbW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9kZWwuZ2V0KCdwYWRkaW5nJylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExheW91dCBsaXN0IGxpa2UgY29tcG9uZW50LlxuICAgICAgICAgKiBJdCB3aWxsIGJveCBsYXlvdXQgZWFjaCBpdGVtcyBpbiBncm91cCBvZiBjb21wb25lbnQgYW5kIHRoZW4gcG9zaXRpb24gdGhlIHdob2xlIGdyb3VwIGluIHRoZSB2aWV3cG9ydFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyb3VwL0dyb3VwfSBncm91cFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gY29tcG9uZW50TW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9XG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IGZ1bmN0aW9uIChncm91cCwgY29tcG9uZW50TW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBsYXlvdXQuZ2V0TGF5b3V0UmVjdChjb21wb25lbnRNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgICAgICAgICAgfSwgY29tcG9uZW50TW9kZWwuZ2V0KCdwYWRkaW5nJykpO1xuICAgICAgICAgICAgbGF5b3V0LmJveChcbiAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5nZXQoJ29yaWVudCcpLFxuICAgICAgICAgICAgICAgIGdyb3VwLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLmdldCgnaXRlbUdhcCcpLFxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgcmVjdC5oZWlnaHRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uR3JvdXAoZ3JvdXAsIGNvbXBvbmVudE1vZGVsLCBhcGkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZEJhY2tncm91bmQ6IGZ1bmN0aW9uIChncm91cCwgY29tcG9uZW50TW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShcbiAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5nZXQoJ3BhZGRpbmcnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGNvbXBvbmVudE1vZGVsLmdldEl0ZW1TdHlsZShbJ2NvbG9yJywgJ29wYWNpdHknXSk7XG4gICAgICAgICAgICBzdHlsZS5maWxsID0gY29tcG9uZW50TW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogYm91bmRpbmdSZWN0LnggLSBwYWRkaW5nWzNdLFxuICAgICAgICAgICAgICAgICAgICB5OiBib3VuZGluZ1JlY3QueSAtIHBhZGRpbmdbMF0sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBib3VuZGluZ1JlY3Qud2lkdGggKyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ1JlY3QuaGVpZ2h0ICsgcGFkZGluZ1swXSArIHBhZGRpbmdbMl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgejI6IC0xXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZVJlY3QocmVjdCk7XG5cbiAgICAgICAgICAgIGdyb3VwLmFkZChyZWN0KTtcbiAgICAgICAgfVxuICAgIH07XG4iLCIvKipcbiAqIERhdGEgc2VsZWN0YWJsZSBtaXhpbiBmb3IgY2hhcnQgc2VyaWVzLlxuICogVG8gZWFuYmxlIGRhdGEgc2VsZWN0LCBvcHRpb24gb2Ygc2VyaWVzIG11c3QgaGF2ZSBgc2VsZWN0ZWRNb2RlYC5cbiAqIEFuZCBlYWNoIGRhdGEgaXRlbSB3aWxsIHVzZSBgc2VsZWN0ZWRgIHRvIHRvZ2dsZSBpdHNlbGYgc2VsZWN0ZWQgc3RhdHVzXG4gKlxuICogQG1vZHVsZSBlY2hhcnRzL2NoYXJ0L2hlbHBlci9EYXRhU2VsZWN0YWJsZVxuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIHVwZGF0ZVNlbGVjdGVkTWFwOiBmdW5jdGlvbiAodGFyZ2V0TGlzdCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0VGFyZ2V0TWFwID0genJVdGlsLnJlZHVjZSh0YXJnZXRMaXN0IHx8IFtdLCBmdW5jdGlvbiAodGFyZ2V0TWFwLCB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRNYXBbdGFyZ2V0Lm5hbWVdID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRNYXA7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gUEVOR0lORyBJZiBzZWxlY3RlZE1vZGUgaXMgbnVsbCA/XG4gICAgICAgIHNlbGVjdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRNYXAgPSB0aGlzLl9zZWxlY3RUYXJnZXRNYXA7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0TWFwW25hbWVdO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkTW9kZSA9IHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2godGFyZ2V0TWFwLCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0ICYmICh0YXJnZXQuc2VsZWN0ZWQgPSB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIHVuU2VsZWN0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3NlbGVjdFRhcmdldE1hcFtuYW1lXTtcbiAgICAgICAgICAgIC8vIHZhciBzZWxlY3RlZE1vZGUgPSB0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG4gICAgICAgICAgICAvLyBzZWxlY3RlZE1vZGUgIT09ICdzaW5nbGUnICYmIHRhcmdldCAmJiAodGFyZ2V0LnNlbGVjdGVkID0gZmFsc2UpO1xuICAgICAgICAgICAgdGFyZ2V0ICYmICh0YXJnZXQuc2VsZWN0ZWQgPSBmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICB0b2dnbGVTZWxlY3RlZDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zZWxlY3RUYXJnZXRNYXBbbmFtZV07XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3RhcmdldC5zZWxlY3RlZCA/ICd1blNlbGVjdCcgOiAnc2VsZWN0J10obmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5zZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fc2VsZWN0VGFyZ2V0TWFwW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXQuc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuIiwiXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgc2xpZGVyIG1vdmUgcmVzdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIE1vdmUgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGhhbmRsZUVuZHMgaGFuZGxlRW5kc1swXSBhbmQgYmUgYmlnZ2VyIHRoZW4gaGFuZGxlRW5kc1sxXS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVuZHMgd2lsbCBiZSBtb2RpZmllZCBpbiB0aGlzIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBleHRlbnQgaGFuZGxlRW5kcyBpcyByZXN0cmljdGVkIGJ5IGV4dGVudC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW50WzBdIHNob3VsZCBsZXNzIG9yIGVxdWFscyB0aGFuIGV4dGVudFsxXS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAncmlnaWQnOiBNYXRoLmFicyhoYW5kbGVFbmRzWzBdIC0gaGFuZGxlRW5kc1sxXSkgcmVtYWluIHVuY2hhbmdlZCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAnY3Jvc3MnIGhhbmRsZUVuZHNbMF0gY2FuIGJlIGJpZ2dlciB0aGVuIGhhbmRsZUVuZHNbMV0sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgJ3B1c2gnIGhhbmRsZUVuZHNbMF0gY2FuIG5vdCBiZSBiaWdnZXIgdGhlbiBoYW5kbGVFbmRzWzFdLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGV5IHRvdWNoLCBvbmUgcHVzaCBvdGhlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlSW5kZXggSWYgbW9kZSBpcyAncmlnaWQnLCBoYW5kbGVJbmRleCBpcyBub3QgcmVxdWlyZWQuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gVGhlIGlucHV0IGhhbmRsZUVuZHMuXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVsdGEsIGhhbmRsZUVuZHMsIGV4dGVudCwgbW9kZSwgaGFuZGxlSW5kZXgpIHtcbiAgICAgICAgaWYgKCFkZWx0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVuZHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9kZSA9PT0gJ3JpZ2lkJykge1xuICAgICAgICAgICAgZGVsdGEgPSBnZXRSZWFsRGVsdGEoZGVsdGEsIGhhbmRsZUVuZHMsIGV4dGVudCk7XG4gICAgICAgICAgICBoYW5kbGVFbmRzWzBdICs9IGRlbHRhO1xuICAgICAgICAgICAgaGFuZGxlRW5kc1sxXSArPSBkZWx0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gZ2V0UmVhbERlbHRhKGRlbHRhLCBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XSwgZXh0ZW50KTtcbiAgICAgICAgICAgIGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdICs9IGRlbHRhO1xuXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3B1c2gnICYmIGhhbmRsZUVuZHNbMF0gPiBoYW5kbGVFbmRzWzFdKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRW5kc1sxIC0gaGFuZGxlSW5kZXhdID0gaGFuZGxlRW5kc1toYW5kbGVJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFuZGxlRW5kcztcblxuICAgICAgICBmdW5jdGlvbiBnZXRSZWFsRGVsdGEoZGVsdGEsIGhhbmRsZUVuZHMsIGV4dGVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZU1pbk1heCA9ICFoYW5kbGVFbmRzLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gW2hhbmRsZUVuZHMsIGhhbmRsZUVuZHNdXG4gICAgICAgICAgICAgICAgOiBoYW5kbGVFbmRzLnNsaWNlKCk7XG4gICAgICAgICAgICBoYW5kbGVFbmRzWzBdID4gaGFuZGxlRW5kc1sxXSAmJiBoYW5kbGVNaW5NYXgucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICBpZiAoZGVsdGEgPCAwICYmIGhhbmRsZU1pbk1heFswXSArIGRlbHRhIDwgZXh0ZW50WzBdKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgPSBleHRlbnRbMF0gLSBoYW5kbGVNaW5NYXhbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVsdGEgPiAwICYmIGhhbmRsZU1pbk1heFsxXSArIGRlbHRhID4gZXh0ZW50WzFdKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgPSBleHRlbnRbMV0gLSBoYW5kbGVNaW5NYXhbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVsdGE7XG4gICAgICAgIH1cbiAgICB9O1xuIiwiLyoqXG4gKiBMZWdlbmQgY29tcG9uZW50IGVudHJ5IGZpbGU4XG4gKi9cblxuXG4gICAgcmVxdWlyZSgnLi9sZWdlbmQvTGVnZW5kTW9kZWwnKTtcbiAgICByZXF1aXJlKCcuL2xlZ2VuZC9sZWdlbmRBY3Rpb24nKTtcbiAgICByZXF1aXJlKCcuL2xlZ2VuZC9MZWdlbmRWaWV3Jyk7XG5cbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcbiAgICAvLyBTZXJpZXMgRmlsdGVyXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3NvcihyZXF1aXJlKCcuL2xlZ2VuZC9sZWdlbmRGaWx0ZXInKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9Nb2RlbCcpO1xuXG4gICAgdmFyIExlZ2VuZE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENvbXBvbmVudE1vZGVsKHtcblxuICAgICAgICB0eXBlOiAnbGVnZW5kJyxcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IFsnc2VyaWVzJ10sXG5cbiAgICAgICAgbGF5b3V0TW9kZToge1xuICAgICAgICAgICAgdHlwZTogJ2JveCcsXG4gICAgICAgICAgICBpZ25vcmVTaXplOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uLnNlbGVjdGVkIHx8IHt9O1xuICAgICAgICB9LFxuXG4gICAgICAgIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICBMZWdlbmRNb2RlbC5zdXBlckNhbGwodGhpcywgJ21lcmdlT3B0aW9uJywgb3B0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvcHRpb25VcGRhdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEYXRhKHRoaXMuZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIHZhciBsZWdlbmREYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgICAgICAgLy8gSWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZSwgdHJ5IHRvIHNlbGVjdCBvbmVcbiAgICAgICAgICAgIGlmIChsZWdlbmREYXRhWzBdICYmIHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBJZiBoYXMgYW55IHNlbGVjdGVkIGluIG9wdGlvbi5zZWxlY3RlZFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVnZW5kRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGxlZ2VuZERhdGFbaV0uZ2V0KCduYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIHRvIHVuc2VsZWN0IG90aGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUcnkgc2VsZWN0IHRoZSBmaXJzdCBpZiBzZWxlY3RlZE1vZGUgaXMgc2luZ2xlXG4gICAgICAgICAgICAgICAgIWhhc1NlbGVjdGVkICYmIHRoaXMuc2VsZWN0KGxlZ2VuZERhdGFbMF0uZ2V0KCduYW1lJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVEYXRhOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGxlZ2VuZERhdGEgPSB6clV0aWwubWFwKHRoaXMuZ2V0KCdkYXRhJykgfHwgW10sIGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICAgICAgICAgIC8vIENhbiBiZSBzdHJpbmcgb3IgbnVtYmVyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhSXRlbSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGRhdGFJdGVtID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGRhdGFJdGVtXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW9kZWwoZGF0YUl0ZW0sIHRoaXMsIHRoaXMuZWNNb2RlbCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBsZWdlbmREYXRhO1xuXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlTmFtZXMgPSB6clV0aWwubWFwKGVjTW9kZWwuZ2V0U2VyaWVzKCksIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzLm5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWVzTW9kZWwubGVnZW5kRGF0YVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwubGVnZW5kRGF0YVByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZU5hbWVzID0gYXZhaWxhYmxlTmFtZXMuY29uY2F0KGRhdGEubWFwQXJyYXkoZGF0YS5nZXROYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2F2YWlsYWJsZU5hbWVzID0gYXZhaWxhYmxlTmFtZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD59XG4gICAgICAgICAqL1xuICAgICAgICBnZXREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMub3B0aW9uLnNlbGVjdGVkO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkTW9kZSA9IHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFtkYXRhSXRlbS5nZXQoJ25hbWUnKV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGVkW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIHVuU2VsZWN0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKSAhPT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbi5zZWxlY3RlZFtuYW1lXSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdG9nZ2xlU2VsZWN0ZWQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbi5zZWxlY3RlZDtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbc2VsZWN0ZWRbbmFtZV0gPyAndW5TZWxlY3QnIDogJ3NlbGVjdCddKG5hbWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNTZWxlY3RlZDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMub3B0aW9uLnNlbGVjdGVkO1xuICAgICAgICAgICAgcmV0dXJuICEoc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIXNlbGVjdGVkW25hbWVdKVxuICAgICAgICAgICAgICAgICYmIHpyVXRpbC5pbmRleE9mKHRoaXMuX2F2YWlsYWJsZU5hbWVzLCBuYW1lKSA+PSAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIC8vIOS4gOe6p+WxguWPoFxuICAgICAgICAgICAgemxldmVsOiAwLFxuICAgICAgICAgICAgLy8g5LqM57qn5bGC5Y+gXG4gICAgICAgICAgICB6OiA0LFxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcblxuICAgICAgICAgICAgLy8g5biD5bGA5pa55byP77yM6buY6K6k5Li65rC05bmz5biD5bGA77yM5Y+v6YCJ5Li677yaXG4gICAgICAgICAgICAvLyAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnXG4gICAgICAgICAgICBvcmllbnQ6ICdob3Jpem9udGFsJyxcblxuICAgICAgICAgICAgbGVmdDogJ2NlbnRlcicsXG4gICAgICAgICAgICAvLyByaWdodDogJ2NlbnRlcicsXG5cbiAgICAgICAgICAgIHRvcDogJ3RvcCcsXG4gICAgICAgICAgICAvLyBib3R0b206ICd0b3AnLFxuXG4gICAgICAgICAgICAvLyDmsLTlubPlr7npvZBcbiAgICAgICAgICAgIC8vICdhdXRvJyB8ICdsZWZ0JyB8ICdyaWdodCdcbiAgICAgICAgICAgIC8vIOm7mOiupOS4uiAnYXV0bycsIOagueaNriB4IOeahOS9jee9ruWIpOaWreaYr+W3puWvuem9kOi/mOaYr+WPs+Wvuem9kFxuICAgICAgICAgICAgYWxpZ246ICdhdXRvJyxcblxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgICAgICAgICAvLyDlm77kvovovrnmoYbpopzoibJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgICAgICAgICAvLyDlm77kvovovrnmoYbnur/lrr3vvIzljZXkvY1weO+8jOm7mOiupOS4ujDvvIjml6DovrnmoYbvvIlcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgICAgICAgLy8g5Zu+5L6L5YaF6L656Led77yM5Y2V5L2NcHjvvIzpu5jorqTlkITmlrnlkJHlhoXovrnot53kuLo177yMXG4gICAgICAgICAgICAvLyDmjqXlj5fmlbDnu4TliIbliKvorr7lrprkuIrlj7PkuIvlt6bovrnot53vvIzlkIxjc3NcbiAgICAgICAgICAgIHBhZGRpbmc6IDUsXG4gICAgICAgICAgICAvLyDlkITkuKppdGVt5LmL6Ze055qE6Ze06ZqU77yM5Y2V5L2NcHjvvIzpu5jorqTkuLoxMO+8jFxuICAgICAgICAgICAgLy8g5qiq5ZCR5biD5bGA5pe25Li65rC05bmz6Ze06ZqU77yM57q15ZCR5biD5bGA5pe25Li657q15ZCR6Ze06ZqUXG4gICAgICAgICAgICBpdGVtR2FwOiAxMCxcbiAgICAgICAgICAgIC8vIOWbvuS+i+WbvuW9ouWuveW6plxuICAgICAgICAgICAgaXRlbVdpZHRoOiAyNSxcbiAgICAgICAgICAgIC8vIOWbvuS+i+WbvuW9oumrmOW6plxuICAgICAgICAgICAgaXRlbUhlaWdodDogMTQsXG5cbiAgICAgICAgICAgIC8vIOWbvuS+i+WFs+mXreaXtuWAmeeahOminOiJslxuICAgICAgICAgICAgaW5hY3RpdmVDb2xvcjogJyNjY2MnLFxuXG4gICAgICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICAgICAgICAvLyDlm77kvovmloflrZfpopzoibJcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMzMzMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZm9ybWF0dGVyOiAnJyxcbiAgICAgICAgICAgIC8vIOmAieaLqeaooeW8j++8jOm7mOiupOW8gOWQr+WbvuS+i+W8gOWFs1xuICAgICAgICAgICAgc2VsZWN0ZWRNb2RlOiB0cnVlLFxuICAgICAgICAgICAgLy8g6YWN572u6buY6K6k6YCJ5Lit54q25oCB77yM5Y+v6YWN5ZCITEVHRU5ELlNFTEVDVEVE5LqL5Lu25YGa5Yqo5oCB5pWw5o2u6L295YWlXG4gICAgICAgICAgICAvLyBzZWxlY3RlZDogbnVsbCxcbiAgICAgICAgICAgIC8vIOWbvuS+i+WGheWuue+8iOivpuingWxlZ2VuZC5kYXRh77yM5pWw57uE5Lit5q+P5LiA6aG55Luj6KGo5LiA5LiqaXRlbVxuICAgICAgICAgICAgLy8gZGF0YTogW10sXG5cbiAgICAgICAgICAgIC8vIFRvb2x0aXAg55u45YWz6YWN572uXG4gICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMZWdlbmRNb2RlbDtcbiIsIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBzeW1ib2xDcmVhdG9yID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9zeW1ib2wnKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciBsaXN0Q29tcG9uZW50SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL2xpc3RDb21wb25lbnQnKTtcblxuICAgIHZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcblxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoU2VsZWN0QWN0aW9uKG5hbWUsIGFwaSkge1xuICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgdHlwZTogJ2xlZ2VuZFRvZ2dsZVNlbGVjdCcsXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoSGlnaGxpZ2h0QWN0aW9uKHNlcmllc01vZGVsLCBkYXRhTmFtZSwgYXBpKSB7XG4gICAgICAgIC8vIElmIGVsZW1lbnQgaG92ZXIgd2lsbCBtb3ZlIHRvIGEgaG92ZXJMYXllci5cbiAgICAgICAgdmFyIGVsID0gYXBpLmdldFpyKCkuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpWzBdO1xuICAgICAgICBpZiAoIShlbCAmJiBlbC51c2VIb3ZlckxheWVyKSkge1xuICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCdsZWdlbmRIb3ZlckxpbmsnKSAmJiBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoaWdobGlnaHQnLFxuICAgICAgICAgICAgICAgIHNlcmllc05hbWU6IHNlcmllc01vZGVsLm5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogZGF0YU5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hEb3ducGxheUFjdGlvbihzZXJpZXNNb2RlbCwgZGF0YU5hbWUsIGFwaSkge1xuICAgICAgICAvLyBJZiBlbGVtZW50IGhvdmVyIHdpbGwgbW92ZSB0byBhIGhvdmVyTGF5ZXIuXG4gICAgICAgIHZhciBlbCA9IGFwaS5nZXRacigpLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKVswXTtcbiAgICAgICAgaWYgKCEoZWwgJiYgZWwudXNlSG92ZXJMYXllcikpIHtcbiAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgnbGVnZW5kSG92ZXJMaW5rJykgJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZG93bnBsYXknLFxuICAgICAgICAgICAgICAgIHNlcmllc05hbWU6IHNlcmllc01vZGVsLm5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogZGF0YU5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ2xlZ2VuZCcsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fc3ltYm9sVHlwZVN0b3JlID0ge307XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgICAgICAgICBpZiAoIWxlZ2VuZE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VsZWN0TW9kZSA9IGxlZ2VuZE1vZGVsLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG4gICAgICAgICAgICB2YXIgaXRlbUFsaWduID0gbGVnZW5kTW9kZWwuZ2V0KCdhbGlnbicpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbUFsaWduID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICBpdGVtQWxpZ24gPSAobGVnZW5kTW9kZWwuZ2V0KCdsZWZ0JykgPT09ICdyaWdodCdcbiAgICAgICAgICAgICAgICAgICAgJiYgbGVnZW5kTW9kZWwuZ2V0KCdvcmllbnQnKSA9PT0gJ3ZlcnRpY2FsJylcbiAgICAgICAgICAgICAgICAgICAgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGVnZW5kRHJhd2VkTWFwID0ge307XG5cbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGxlZ2VuZE1vZGVsLmdldERhdGEoKSwgZnVuY3Rpb24gKGl0ZW1Nb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gaXRlbU1vZGVsLmdldCgnbmFtZScpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGVtcHR5IHN0cmluZyBvciBcXG4gYXMgYSBuZXdsaW5lIHN0cmluZ1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnJyB8fCBuYW1lID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5hZGQobmV3IGdyYXBoaWMuR3JvdXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3bGluZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBlY01vZGVsLmdldFNlcmllc0J5TmFtZShuYW1lKVswXTtcblxuICAgICAgICAgICAgICAgIGlmIChsZWdlbmREcmF3ZWRNYXBbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGF2ZSBiZWVuIGRyYXdlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2VyaWVzIGxlZ2VuZFxuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gZGF0YS5nZXRWaXN1YWwoJ2NvbG9yJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgY29sb3IgaXMgYSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3Ioc2VyaWVzTW9kZWwuZ2V0RGF0YVBhcmFtcygwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBVc2luZyByZWN0IHN5bWJvbCBkZWZhdWx0bHlcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZ2VuZFN5bWJvbFR5cGUgPSBkYXRhLmdldFZpc3VhbCgnbGVnZW5kU3ltYm9sJykgfHwgJ3JvdW5kUmVjdCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xUeXBlID0gZGF0YS5nZXRWaXN1YWwoJ3N5bWJvbCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtR3JvdXAgPSB0aGlzLl9jcmVhdGVJdGVtKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSwgaXRlbU1vZGVsLCBsZWdlbmRNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZFN5bWJvbFR5cGUsIHN5bWJvbFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtQWxpZ24sIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0TW9kZVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Hcm91cC5vbignY2xpY2snLCBjdXJyeShkaXNwYXRjaFNlbGVjdEFjdGlvbiwgbmFtZSwgYXBpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgY3VycnkoZGlzcGF0Y2hIaWdobGlnaHRBY3Rpb24sIHNlcmllc01vZGVsLCBudWxsLCBhcGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGN1cnJ5KGRpc3BhdGNoRG93bnBsYXlBY3Rpb24sIHNlcmllc01vZGVsLCBudWxsLCBhcGkpKTtcblxuICAgICAgICAgICAgICAgICAgICBsZWdlbmREcmF3ZWRNYXBbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGF0YSBsZWdlbmQgb2YgcGllLCBmdW5uZWxcbiAgICAgICAgICAgICAgICAgICAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBtdWx0aXBsZSBzZXJpZXMgaGFzIHNhbWUgZGF0YSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVnZW5kRHJhd2VkTWFwW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwubGVnZW5kRGF0YVByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGRhdGEuaW5kZXhPZk5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZ2VuZFN5bWJvbFR5cGUgPSAncm91bmRSZWN0JztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtR3JvdXAgPSB0aGlzLl9jcmVhdGVJdGVtKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmRTeW1ib2xUeXBlLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQWxpZ24sIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RNb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Hcm91cC5vbignY2xpY2snLCBjdXJyeShkaXNwYXRjaFNlbGVjdEFjdGlvbiwgbmFtZSwgYXBpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgU2hvdWxkIG5vdCBzcGVjaWZ5IHRoZSBzZXJpZXMgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGN1cnJ5KGRpc3BhdGNoSGlnaGxpZ2h0QWN0aW9uLCBzZXJpZXNNb2RlbCwgbmFtZSwgYXBpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGN1cnJ5KGRpc3BhdGNoRG93bnBsYXlBY3Rpb24sIHNlcmllc01vZGVsLCBuYW1lLCBhcGkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZERyYXdlZE1hcFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVnZW5kRHJhd2VkTWFwW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArICcgc2VyaWVzIG5vdCBleGlzdHMuIExlZ2VuZCBkYXRhIHNob3VsZCBiZSBzYW1lIHdpdGggc2VyaWVzIG5hbWUgb3IgZGF0YSBuYW1lLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGxpc3RDb21wb25lbnRIZWxwZXIubGF5b3V0KGdyb3VwLCBsZWdlbmRNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgIC8vIFJlbmRlciBiYWNrZ3JvdW5kIGFmdGVyIGdyb3VwIGlzIGxheW91dFxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGxpc3RDb21wb25lbnRIZWxwZXIuYWRkQmFja2dyb3VuZChncm91cCwgbGVnZW5kTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVJdGVtOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBuYW1lLCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLFxuICAgICAgICAgICAgbGVnZW5kU3ltYm9sVHlwZSwgc3ltYm9sVHlwZSxcbiAgICAgICAgICAgIGl0ZW1BbGlnbiwgY29sb3IsIHNlbGVjdE1vZGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgaXRlbVdpZHRoID0gbGVnZW5kTW9kZWwuZ2V0KCdpdGVtV2lkdGgnKTtcbiAgICAgICAgICAgIHZhciBpdGVtSGVpZ2h0ID0gbGVnZW5kTW9kZWwuZ2V0KCdpdGVtSGVpZ2h0Jyk7XG4gICAgICAgICAgICB2YXIgaW5hY3RpdmVDb2xvciA9IGxlZ2VuZE1vZGVsLmdldCgnaW5hY3RpdmVDb2xvcicpO1xuXG4gICAgICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IGxlZ2VuZE1vZGVsLmlzU2VsZWN0ZWQobmFtZSk7XG4gICAgICAgICAgICB2YXIgaXRlbUdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgICAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcblxuICAgICAgICAgICAgdmFyIGl0ZW1JY29uID0gaXRlbU1vZGVsLmdldCgnaWNvbicpO1xuXG4gICAgICAgICAgICB2YXIgdG9vbHRpcE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCd0b29sdGlwJyk7XG4gICAgICAgICAgICB2YXIgbGVnZW5kR2xvYmFsVG9vbHRpcE1vZGVsID0gdG9vbHRpcE1vZGVsLnBhcmVudE1vZGVsO1xuXG4gICAgICAgICAgICAvLyBVc2UgdXNlciBnaXZlbiBpY29uIGZpcnN0XG4gICAgICAgICAgICBsZWdlbmRTeW1ib2xUeXBlID0gaXRlbUljb24gfHwgbGVnZW5kU3ltYm9sVHlwZTtcbiAgICAgICAgICAgIGl0ZW1Hcm91cC5hZGQoc3ltYm9sQ3JlYXRvci5jcmVhdGVTeW1ib2woXG4gICAgICAgICAgICAgICAgbGVnZW5kU3ltYm9sVHlwZSwgMCwgMCwgaXRlbVdpZHRoLCBpdGVtSGVpZ2h0LCBpc1NlbGVjdGVkID8gY29sb3IgOiBpbmFjdGl2ZUNvbG9yXG4gICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgLy8gQ29tcG9zZSBzeW1ib2xzXG4gICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICBpZiAoIWl0ZW1JY29uICYmIHN5bWJvbFR5cGVcbiAgICAgICAgICAgICAgICAvLyBBdCBsZWFzdCBzaG93IG9uZSBzeW1ib2wsIGNhbid0IGJlIGFsbCBub25lXG4gICAgICAgICAgICAgICAgJiYgKChzeW1ib2xUeXBlICE9PSBsZWdlbmRTeW1ib2xUeXBlKSB8fCBzeW1ib2xUeXBlID09ICdub25lJylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gaXRlbUhlaWdodCAqIDAuODtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sVHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGUgPSAnY2lyY2xlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUHV0IHN5bWJvbCBpbiB0aGUgY2VudGVyXG4gICAgICAgICAgICAgICAgaXRlbUdyb3VwLmFkZChzeW1ib2xDcmVhdG9yLmNyZWF0ZVN5bWJvbChcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sVHlwZSwgKGl0ZW1XaWR0aCAtIHNpemUpIC8gMiwgKGl0ZW1IZWlnaHQgLSBzaXplKSAvIDIsIHNpemUsIHNpemUsXG4gICAgICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQgPyBjb2xvciA6IGluYWN0aXZlQ29sb3JcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGV4dFxuICAgICAgICAgICAgdmFyIHRleHRYID0gaXRlbUFsaWduID09PSAnbGVmdCcgPyBpdGVtV2lkdGggKyA1IDogLTU7XG4gICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gaXRlbUFsaWduO1xuXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gbGVnZW5kTW9kZWwuZ2V0KCdmb3JtYXR0ZXInKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gbmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJyAmJiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gZm9ybWF0dGVyLnJlcGxhY2UoJ3tuYW1lfScsIG5hbWUgIT0gbnVsbCA/IG5hbWUgOiAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IGZvcm1hdHRlcihuYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB4OiB0ZXh0WCxcbiAgICAgICAgICAgICAgICAgICAgeTogaXRlbUhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IGlzU2VsZWN0ZWQgPyB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSA6IGluYWN0aXZlQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHRleHRGb250OiB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KCksXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0ZW1Hcm91cC5hZGQodGV4dCk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhIGludmlzaWJsZSByZWN0IHRvIGluY3JlYXNlIHRoZSBhcmVhIG9mIG1vdXNlIGhvdmVyXG4gICAgICAgICAgICB2YXIgaGl0UmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgICAgICAgICAgIHNoYXBlOiBpdGVtR3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCksXG4gICAgICAgICAgICAgICAgaW52aXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IHRvb2x0aXBNb2RlbC5nZXQoJ3Nob3cnKSA/IHpyVXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWwgZm9ybWF0dGVyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogbGVnZW5kR2xvYmFsVG9vbHRpcE1vZGVsLmdldCgnZm9ybWF0dGVyJywgdHJ1ZSkgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlclBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZTogJ2xlZ2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmRJbmRleDogbGVnZW5kTW9kZWwuY29tcG9uZW50SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJHZhcnM6IFsnbmFtZSddXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0b29sdGlwTW9kZWwub3B0aW9uKSA6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXRlbUdyb3VwLmFkZChoaXRSZWN0KTtcblxuICAgICAgICAgICAgaXRlbUdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5zaWxlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGhpdFJlY3Quc2lsZW50ID0gIXNlbGVjdE1vZGU7XG5cblxuXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChpdGVtR3JvdXApO1xuXG4gICAgICAgICAgICBncmFwaGljLnNldEhvdmVyU3R5bGUoaXRlbUdyb3VwKTtcblxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1Hcm91cDtcbiAgICAgICAgfVxuICAgIH0pO1xuIiwiLyoqXG4gKiBAZmlsZSBMZWdlbmQgYWN0aW9uXG4gKi9cblxuXG4gICAgdmFyIGVjaGFydHMgPSByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgZnVuY3Rpb24gbGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlcihtZXRob2ROYW1lLCBwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZE1hcCA9IHt9O1xuICAgICAgICB2YXIgaXNUb2dnbGVTZWxlY3QgPSBtZXRob2ROYW1lID09PSAndG9nZ2xlU2VsZWN0ZWQnO1xuICAgICAgICB2YXIgaXNTZWxlY3RlZDtcbiAgICAgICAgLy8gVXBkYXRlIGFsbCBsZWdlbmQgY29tcG9uZW50c1xuICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ2xlZ2VuZCcsIGZ1bmN0aW9uIChsZWdlbmRNb2RlbCkge1xuICAgICAgICAgICAgaWYgKGlzVG9nZ2xlU2VsZWN0ICYmIGlzU2VsZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEZvcmNlIG90aGVyIGxlZ2VuZCBoYXMgc2FtZSBzZWxlY3RlZCBzdGF0dXNcbiAgICAgICAgICAgICAgICAvLyBPciB0aGUgZmlyc3QgaXMgdG9nZ2xlZCB0byB0cnVlIGFuZCBvdGhlciBhcmUgdG9nZ2xlZCB0byBmYWxzZVxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9uZSBsZWdlbmQgaGFzIHNvbWUgaXRlbSB1blNlbGVjdGVkIGluIG9wdGlvbi4gQW5kIGlmIG90aGVyIGxlZ2VuZFxuICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgaGFzIHRoZSBpdGVtLCB0aGV5IHdpbGwgYXNzdW1lIGl0IGlzIHNlbGVjdGVkLlxuICAgICAgICAgICAgICAgIGxlZ2VuZE1vZGVsW2lzU2VsZWN0ZWQgPyAnc2VsZWN0JyA6ICd1blNlbGVjdCddKHBheWxvYWQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZWdlbmRNb2RlbFttZXRob2ROYW1lXShwYXlsb2FkLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBsZWdlbmRNb2RlbC5pc1NlbGVjdGVkKHBheWxvYWQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVnZW5kRGF0YSA9IGxlZ2VuZE1vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGxlZ2VuZERhdGEsIGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbW9kZWwuZ2V0KCduYW1lJyk7XG4gICAgICAgICAgICAgICAgLy8gV3JhcCBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdcXG4nIHx8IG5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGlzSXRlbVNlbGVjdGVkID0gbGVnZW5kTW9kZWwuaXNTZWxlY3RlZChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBzZWxlY3RlZE1hcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbnNlbGVjdGVkIGlmIGFueSBsZWdlbmQgaXMgdW5zZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE1hcFtuYW1lXSA9IHNlbGVjdGVkTWFwW25hbWVdICYmIGlzSXRlbVNlbGVjdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRNYXBbbmFtZV0gPSBpc0l0ZW1TZWxlY3RlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZXZlbnQgZXhwbGljaXRseVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5uYW1lLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkTWFwXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBldmVudCBsZWdlbmRUb2dnbGVTZWxlY3RcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlICdsZWdlbmRUb2dnbGVTZWxlY3QnXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmcm9tXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFNlcmllcyBuYW1lIG9yIGRhdGEgaXRlbSBuYW1lXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlckFjdGlvbihcbiAgICAgICAgJ2xlZ2VuZFRvZ2dsZVNlbGVjdCcsICdsZWdlbmRzZWxlY3RjaGFuZ2VkJyxcbiAgICAgICAgenJVdGlsLmN1cnJ5KGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIsICd0b2dnbGVTZWxlY3RlZCcpXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBsZWdlbmRTZWxlY3RcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlICdsZWdlbmRTZWxlY3QnXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgU2VyaWVzIG5hbWUgb3IgZGF0YSBpdGVtIG5hbWVcbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKFxuICAgICAgICAnbGVnZW5kU2VsZWN0JywgJ2xlZ2VuZHNlbGVjdGVkJyxcbiAgICAgICAgenJVdGlsLmN1cnJ5KGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIsICdzZWxlY3QnKVxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbGVnZW5kVW5TZWxlY3RcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlICdsZWdlbmRVblNlbGVjdCdcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBTZXJpZXMgbmFtZSBvciBkYXRhIGl0ZW0gbmFtZVxuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24oXG4gICAgICAgICdsZWdlbmRVblNlbGVjdCcsICdsZWdlbmR1bnNlbGVjdGVkJyxcbiAgICAgICAgenJVdGlsLmN1cnJ5KGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIsICd1blNlbGVjdCcpXG4gICAgKTtcbiIsIlxuICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgICB2YXIgbGVnZW5kTW9kZWxzID0gZWNNb2RlbC5maW5kQ29tcG9uZW50cyh7XG4gICAgICAgICAgICBtYWluVHlwZTogJ2xlZ2VuZCdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsZWdlbmRNb2RlbHMgJiYgbGVnZW5kTW9kZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgZWNNb2RlbC5maWx0ZXJTZXJpZXMoZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgICAgICAgICAgIC8vIElmIGluIGFueSBsZWdlbmQgY29tcG9uZW50IHRoZSBzdGF0dXMgaXMgbm90IHNlbGVjdGVkLlxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgaW4gbGVnZW5kIHNlcmllcyBpcyBhc3N1bWVkIHNlbGVjdGVkIHdoZW4gaXQgaXMgbm90IGluIHRoZSBsZWdlbmQgZGF0YS5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZE1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxlZ2VuZE1vZGVsc1tpXS5pc1NlbGVjdGVkKHNlcmllcy5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuIiwiXG5cbiAgICByZXF1aXJlKCcuL21hcmtlci9NYXJrTGluZU1vZGVsJyk7XG4gICAgcmVxdWlyZSgnLi9tYXJrZXIvTWFya0xpbmVWaWV3Jyk7XG5cbiAgICByZXF1aXJlKCcuLi9lY2hhcnRzJykucmVnaXN0ZXJQcmVwcm9jZXNzb3IoZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgbWFya0xpbmUgY29tcG9uZW50IGlzIGVuYWJsZWRcbiAgICAgICAgb3B0Lm1hcmtMaW5lID0gb3B0Lm1hcmtMaW5lIHx8IHt9O1xuICAgIH0pO1xuIiwiLy8gSElOVCBNYXJrcG9pbnQgY2FuJ3QgYmUgdXNlZCB0b28gbXVjaFxuXG5cbiAgICByZXF1aXJlKCcuL21hcmtlci9NYXJrUG9pbnRNb2RlbCcpO1xuICAgIHJlcXVpcmUoJy4vbWFya2VyL01hcmtQb2ludFZpZXcnKTtcblxuICAgIHJlcXVpcmUoJy4uL2VjaGFydHMnKS5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBtYXJrUG9pbnQgY29tcG9uZW50IGlzIGVuYWJsZWRcbiAgICAgICAgb3B0Lm1hcmtQb2ludCA9IG9wdC5tYXJrUG9pbnQgfHwge307XG4gICAgfSk7XG4iLCJcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9NYXJrZXJNb2RlbCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ21hcmtMaW5lJyxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICB6bGV2ZWw6IDAsXG4gICAgICAgICAgICB6OiA1LFxuXG4gICAgICAgICAgICBzeW1ib2w6IFsnY2lyY2xlJywgJ2Fycm93J10sXG4gICAgICAgICAgICBzeW1ib2xTaXplOiBbOCwgMTZdLFxuXG4gICAgICAgICAgICAvL3N5bWJvbFJvdGF0ZTogMCxcblxuICAgICAgICAgICAgcHJlY2lzaW9uOiAyLFxuICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICAgIHRyaWdnZXI6ICdpdGVtJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZW5kJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Rhc2hlZCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVtcGhhc2lzOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcidcbiAgICAgICAgfVxuICAgIH0pO1xuIiwiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIExpc3QgPSByZXF1aXJlKCcuLi8uLi9kYXRhL0xpc3QnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbnVtYmVyJyk7XG5cbiAgICB2YXIgbWFya2VySGVscGVyID0gcmVxdWlyZSgnLi9tYXJrZXJIZWxwZXInKTtcblxuICAgIHZhciBMaW5lRHJhdyA9IHJlcXVpcmUoJy4uLy4uL2NoYXJ0L2hlbHBlci9MaW5lRHJhdycpO1xuXG4gICAgdmFyIG1hcmtMaW5lVHJhbnNmb3JtID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBjb29yZFN5cywgbWxNb2RlbCwgaXRlbSkge1xuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgLy8gU3BlY2lhbCB0eXBlIG1hcmtMaW5lIGxpa2UgJ21pbicsICdtYXgnLCAnYXZlcmFnZSdcbiAgICAgICAgdmFyIG1sVHlwZSA9IGl0ZW0udHlwZTtcblxuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGl0ZW0pXG4gICAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAgICAgbWxUeXBlID09PSAnbWluJyB8fCBtbFR5cGUgPT09ICdtYXgnIHx8IG1sVHlwZSA9PT0gJ2F2ZXJhZ2UnXG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZVxuICAgICAgICAgICAgICAgIC8vIGRhdGE6IFt7XG4gICAgICAgICAgICAgICAgLy8gICB5QXhpczogMTBcbiAgICAgICAgICAgICAgICAvLyB9XVxuICAgICAgICAgICAgICAgIHx8IChpdGVtLnhBeGlzICE9IG51bGwgfHwgaXRlbS55QXhpcyAhPSBudWxsKVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZUF4aXM7XG4gICAgICAgICAgICB2YXIgdmFsdWVEYXRhRGltO1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoaXRlbS55QXhpcyAhPSBudWxsIHx8IGl0ZW0ueEF4aXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlRGF0YURpbSA9IGl0ZW0ueUF4aXMgIT0gbnVsbCA/ICd5JyA6ICd4JztcbiAgICAgICAgICAgICAgICB2YWx1ZUF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKHZhbHVlRGF0YURpbSk7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHpyVXRpbC5yZXRyaWV2ZShpdGVtLnlBeGlzLCBpdGVtLnhBeGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBheGlzSW5mbyA9IG1hcmtlckhlbHBlci5nZXRBeGlzSW5mbyhpdGVtLCBkYXRhLCBjb29yZFN5cywgc2VyaWVzTW9kZWwpO1xuICAgICAgICAgICAgICAgIHZhbHVlRGF0YURpbSA9IGF4aXNJbmZvLnZhbHVlRGF0YURpbTtcbiAgICAgICAgICAgICAgICB2YWx1ZUF4aXMgPSBheGlzSW5mby52YWx1ZUF4aXM7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtYXJrZXJIZWxwZXIubnVtQ2FsY3VsYXRlKGRhdGEsIHZhbHVlRGF0YURpbSwgbWxUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZUluZGV4ID0gdmFsdWVEYXRhRGltID09PSAneCcgPyAwIDogMTtcbiAgICAgICAgICAgIHZhciBiYXNlSW5kZXggPSAxIC0gdmFsdWVJbmRleDtcblxuICAgICAgICAgICAgdmFyIG1sRnJvbSA9IHpyVXRpbC5jbG9uZShpdGVtKTtcbiAgICAgICAgICAgIHZhciBtbFRvID0ge307XG5cbiAgICAgICAgICAgIG1sRnJvbS50eXBlID0gbnVsbDtcblxuICAgICAgICAgICAgbWxGcm9tLmNvb3JkID0gW107XG4gICAgICAgICAgICBtbFRvLmNvb3JkID0gW107XG4gICAgICAgICAgICBtbEZyb20uY29vcmRbYmFzZUluZGV4XSA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIG1sVG8uY29vcmRbYmFzZUluZGV4XSA9IEluZmluaXR5O1xuXG4gICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gbWxNb2RlbC5nZXQoJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiA+PSAwICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZS50b0ZpeGVkKHByZWNpc2lvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1sRnJvbS5jb29yZFt2YWx1ZUluZGV4XSA9IG1sVG8uY29vcmRbdmFsdWVJbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgaXRlbSA9IFttbEZyb20sIG1sVG8sIHsgLy8gRXh0cmEgb3B0aW9uIGZvciB0b29sdGlwIGFuZCBsYWJlbFxuICAgICAgICAgICAgICAgIHR5cGU6IG1sVHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZUluZGV4OiBpdGVtLnZhbHVlSW5kZXgsXG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgdG8gdXNlIHRoZSB2YWx1ZSBvZiBjYWxjdWxhdGVkIHZhbHVlLlxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtID0gW1xuICAgICAgICAgICAgbWFya2VySGVscGVyLmRhdGFUcmFuc2Zvcm0oc2VyaWVzTW9kZWwsIGl0ZW1bMF0pLFxuICAgICAgICAgICAgbWFya2VySGVscGVyLmRhdGFUcmFuc2Zvcm0oc2VyaWVzTW9kZWwsIGl0ZW1bMV0pLFxuICAgICAgICAgICAgenJVdGlsLmV4dGVuZCh7fSwgaXRlbVsyXSlcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBBdm9pZCBsaW5lIGRhdGEgdHlwZSBpcyBleHRlbmRlZCBieSBmcm9tKHRvKSBkYXRhIHR5cGVcbiAgICAgICAgaXRlbVsyXS50eXBlID0gaXRlbVsyXS50eXBlIHx8ICcnO1xuXG4gICAgICAgIC8vIE1lcmdlIGZyb20gb3B0aW9uIGFuZCB0byBvcHRpb24gaW50byBsaW5lIG9wdGlvblxuICAgICAgICB6clV0aWwubWVyZ2UoaXRlbVsyXSwgaXRlbVswXSk7XG4gICAgICAgIHpyVXRpbC5tZXJnZShpdGVtWzJdLCBpdGVtWzFdKTtcblxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNJbmlmaW5pdHkodmFsKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4odmFsKSAmJiAhaXNGaW5pdGUodmFsKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhIG1hcmtMaW5lIGhhcyBvbmUgZGltXG4gICAgZnVuY3Rpb24gaWZNYXJrTGluZUhhc09ubHlEaW0oZGltSW5kZXgsIGZyb21Db29yZCwgdG9Db29yZCwgY29vcmRTeXMpIHtcbiAgICAgICAgdmFyIG90aGVyRGltSW5kZXggPSAxIC0gZGltSW5kZXg7XG4gICAgICAgIHZhciBkaW1OYW1lID0gY29vcmRTeXMuZGltZW5zaW9uc1tkaW1JbmRleF07XG4gICAgICAgIHJldHVybiBpc0luaWZpbml0eShmcm9tQ29vcmRbb3RoZXJEaW1JbmRleF0pICYmIGlzSW5pZmluaXR5KHRvQ29vcmRbb3RoZXJEaW1JbmRleF0pXG4gICAgICAgICAgICAmJiBmcm9tQ29vcmRbZGltSW5kZXhdID09PSB0b0Nvb3JkW2RpbUluZGV4XSAmJiBjb29yZFN5cy5nZXRBeGlzKGRpbU5hbWUpLmNvbnRhaW5EYXRhKGZyb21Db29yZFtkaW1JbmRleF0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcmtMaW5lRmlsdGVyKGNvb3JkU3lzLCBpdGVtKSB7XG4gICAgICAgIGlmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICB2YXIgZnJvbUNvb3JkID0gaXRlbVswXS5jb29yZDtcbiAgICAgICAgICAgIHZhciB0b0Nvb3JkID0gaXRlbVsxXS5jb29yZDtcbiAgICAgICAgICAgIC8vIEluIGNhc2VcbiAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgIC8vICBtYXJrTGluZToge1xuICAgICAgICAgICAgLy8gICAgZGF0YTogW3sgeUF4aXM6IDIgfV1cbiAgICAgICAgICAgIC8vICB9XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZnJvbUNvb3JkICYmIHRvQ29vcmQgJiZcbiAgICAgICAgICAgICAgICAoaWZNYXJrTGluZUhhc09ubHlEaW0oMSwgZnJvbUNvb3JkLCB0b0Nvb3JkLCBjb29yZFN5cylcbiAgICAgICAgICAgICAgICB8fCBpZk1hcmtMaW5lSGFzT25seURpbSgwLCBmcm9tQ29vcmQsIHRvQ29vcmQsIGNvb3JkU3lzKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXJIZWxwZXIuZGF0YUZpbHRlcihjb29yZFN5cywgaXRlbVswXSlcbiAgICAgICAgICAgICYmIG1hcmtlckhlbHBlci5kYXRhRmlsdGVyKGNvb3JkU3lzLCBpdGVtWzFdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTaW5nbGVNYXJrZXJFbmRMYXlvdXQoXG4gICAgICAgIGRhdGEsIGlkeCwgaXNGcm9tLCBzZXJpZXNNb2RlbCwgYXBpXG4gICAgKSB7XG4gICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuXG4gICAgICAgIHZhciBwb2ludDtcbiAgICAgICAgdmFyIHhQeCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGl0ZW1Nb2RlbC5nZXQoJ3gnKSwgYXBpLmdldFdpZHRoKCkpO1xuICAgICAgICB2YXIgeVB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgneScpLCBhcGkuZ2V0SGVpZ2h0KCkpO1xuICAgICAgICBpZiAoIWlzTmFOKHhQeCkgJiYgIWlzTmFOKHlQeCkpIHtcbiAgICAgICAgICAgIHBvaW50ID0gW3hQeCwgeVB4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENoYXJ0IGxpa2UgYmFyIG1heSBoYXZlIHRoZXJlIG93biBtYXJrZXIgcG9zaXRpb25pbmcgbG9naWNcbiAgICAgICAgICAgIGlmIChzZXJpZXNNb2RlbC5nZXRNYXJrZXJQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZ2V0TWFya2VyUG9pc2l0aW9uXG4gICAgICAgICAgICAgICAgcG9pbnQgPSBzZXJpZXNNb2RlbC5nZXRNYXJrZXJQb3NpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5nZXRWYWx1ZXMoZGF0YS5kaW1lbnNpb25zLCBpZHgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkaW1zID0gY29vcmRTeXMuZGltZW5zaW9ucztcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGRhdGEuZ2V0KGRpbXNbMF0sIGlkeCk7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBkYXRhLmdldChkaW1zWzFdLCBpZHgpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoW3gsIHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4cGFuZCBsaW5lIHRvIHRoZSBlZGdlIG9mIGdyaWQgaWYgdmFsdWUgb24gb25lIGF4aXMgaXMgSW5pZm5pdHlcbiAgICAgICAgICAgIC8vIEluIGNhc2VcbiAgICAgICAgICAgIC8vICBtYXJrTGluZToge1xuICAgICAgICAgICAgLy8gICAgZGF0YTogW3tcbiAgICAgICAgICAgIC8vICAgICAgeUF4aXM6IDJcbiAgICAgICAgICAgIC8vICAgICAgLy8gb3JcbiAgICAgICAgICAgIC8vICAgICAgdHlwZTogJ2F2ZXJhZ2UnXG4gICAgICAgICAgICAvLyAgICB9XVxuICAgICAgICAgICAgLy8gIH1cbiAgICAgICAgICAgIGlmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhBeGlzID0gY29vcmRTeXMuZ2V0QXhpcygneCcpO1xuICAgICAgICAgICAgICAgIHZhciB5QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3knKTtcbiAgICAgICAgICAgICAgICB2YXIgZGltcyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5pZmluaXR5KGRhdGEuZ2V0KGRpbXNbMF0sIGlkeCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50WzBdID0geEF4aXMudG9HbG9iYWxDb29yZCh4QXhpcy5nZXRFeHRlbnQoKVtpc0Zyb20gPyAwIDogMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0luaWZpbml0eShkYXRhLmdldChkaW1zWzFdLCBpZHgpKSkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludFsxXSA9IHlBeGlzLnRvR2xvYmFsQ29vcmQoeUF4aXMuZ2V0RXh0ZW50KClbaXNGcm9tID8gMCA6IDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSB4LCB5IGlmIGhhcyBhbnlcbiAgICAgICAgICAgIGlmICghaXNOYU4oeFB4KSkge1xuICAgICAgICAgICAgICAgIHBvaW50WzBdID0geFB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05hTih5UHgpKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRbMV0gPSB5UHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBwb2ludCk7XG4gICAgfVxuXG4gICAgcmVxdWlyZSgnLi9NYXJrZXJWaWV3JykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnbWFya0xpbmUnLFxuXG4gICAgICAgIHVwZGF0ZUxheW91dDogZnVuY3Rpb24gKG1hcmtMaW5lTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBtbE1vZGVsID0gc2VyaWVzTW9kZWwubWFya0xpbmVNb2RlbDtcbiAgICAgICAgICAgICAgICBpZiAobWxNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWxEYXRhID0gbWxNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcm9tRGF0YSA9IG1sTW9kZWwuX19mcm9tO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9EYXRhID0gbWxNb2RlbC5fX3RvO1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdmlzdWFsIGFuZCBsYXlvdXQgb2YgZnJvbSBzeW1ib2wgYW5kIHRvIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICBmcm9tRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNpbmdsZU1hcmtlckVuZExheW91dChmcm9tRGF0YSwgaWR4LCB0cnVlLCBzZXJpZXNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNpbmdsZU1hcmtlckVuZExheW91dCh0b0RhdGEsIGlkeCwgZmFsc2UsIHNlcmllc01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGxheW91dCBvZiBsaW5lXG4gICAgICAgICAgICAgICAgICAgIG1sRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1sRGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21EYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0RhdGEuZ2V0SXRlbUxheW91dChpZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJHcm91cE1hcFtzZXJpZXNNb2RlbC5uYW1lXS51cGRhdGVMYXlvdXQoKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlclNlcmllczogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBtbE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICB2YXIgc2VyaWVzTmFtZSA9IHNlcmllc01vZGVsLm5hbWU7XG4gICAgICAgICAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcblxuICAgICAgICAgICAgdmFyIGxpbmVEcmF3TWFwID0gdGhpcy5tYXJrZXJHcm91cE1hcDtcbiAgICAgICAgICAgIHZhciBsaW5lRHJhdyA9IGxpbmVEcmF3TWFwW3Nlcmllc05hbWVdO1xuICAgICAgICAgICAgaWYgKCFsaW5lRHJhdykge1xuICAgICAgICAgICAgICAgIGxpbmVEcmF3ID0gbGluZURyYXdNYXBbc2VyaWVzTmFtZV0gPSBuZXcgTGluZURyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKGxpbmVEcmF3Lmdyb3VwKTtcblxuICAgICAgICAgICAgdmFyIG1sRGF0YSA9IGNyZWF0ZUxpc3QoY29vcmRTeXMsIHNlcmllc01vZGVsLCBtbE1vZGVsKTtcblxuICAgICAgICAgICAgdmFyIGZyb21EYXRhID0gbWxEYXRhLmZyb207XG4gICAgICAgICAgICB2YXIgdG9EYXRhID0gbWxEYXRhLnRvO1xuICAgICAgICAgICAgdmFyIGxpbmVEYXRhID0gbWxEYXRhLmxpbmU7XG5cbiAgICAgICAgICAgIG1sTW9kZWwuX19mcm9tID0gZnJvbURhdGE7XG4gICAgICAgICAgICBtbE1vZGVsLl9fdG8gPSB0b0RhdGE7XG4gICAgICAgICAgICAvLyBMaW5lIGRhdGEgZm9yIHRvb2x0aXAgYW5kIGZvcm1hdHRlclxuICAgICAgICAgICAgbWxNb2RlbC5zZXREYXRhKGxpbmVEYXRhKTtcblxuICAgICAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBtbE1vZGVsLmdldCgnc3ltYm9sJyk7XG4gICAgICAgICAgICB2YXIgc3ltYm9sU2l6ZSA9IG1sTW9kZWwuZ2V0KCdzeW1ib2xTaXplJyk7XG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHN5bWJvbFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sVHlwZSA9IFtzeW1ib2xUeXBlLCBzeW1ib2xUeXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ltYm9sU2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xTaXplID0gW3N5bWJvbFNpemUsIHN5bWJvbFNpemVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdmlzdWFsIGFuZCBsYXlvdXQgb2YgZnJvbSBzeW1ib2wgYW5kIHRvIHN5bWJvbFxuICAgICAgICAgICAgbWxEYXRhLmZyb20uZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRGF0YVZpc3VhbEFuZExheW91dChmcm9tRGF0YSwgaWR4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVEYXRhVmlzdWFsQW5kTGF5b3V0KHRvRGF0YSwgaWR4LCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHZpc3VhbCBhbmQgbGF5b3V0IG9mIGxpbmVcbiAgICAgICAgICAgIGxpbmVEYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lQ29sb3IgPSBsaW5lRGF0YS5nZXRJdGVtTW9kZWwoaWR4KS5nZXQoJ2xpbmVTdHlsZS5ub3JtYWwuY29sb3InKTtcbiAgICAgICAgICAgICAgICBsaW5lRGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogbGluZUNvbG9yIHx8IGZyb21EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxpbmVEYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBbXG4gICAgICAgICAgICAgICAgICAgIGZyb21EYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSxcbiAgICAgICAgICAgICAgICAgICAgdG9EYXRhLmdldEl0ZW1MYXlvdXQoaWR4KVxuICAgICAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICAgICAgbGluZURhdGEuc2V0SXRlbVZpc3VhbChpZHgsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2Zyb21TeW1ib2xTaXplJzogZnJvbURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xTaXplJyksXG4gICAgICAgICAgICAgICAgICAgICdmcm9tU3ltYm9sJzogZnJvbURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSxcbiAgICAgICAgICAgICAgICAgICAgJ3RvU3ltYm9sU2l6ZSc6IHRvRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFNpemUnKSxcbiAgICAgICAgICAgICAgICAgICAgJ3RvU3ltYm9sJzogdG9EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsaW5lRHJhdy51cGRhdGVEYXRhKGxpbmVEYXRhKTtcblxuICAgICAgICAgICAgLy8gU2V0IGhvc3QgbW9kZWwgZm9yIHRvb2x0aXBcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBtbERhdGEubGluZS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgICAgICAgICAgIGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kYXRhTW9kZWwgPSBtbE1vZGVsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZURhdGFWaXN1YWxBbmRMYXlvdXQoZGF0YSwgaWR4LCBpc0Zyb20pIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcblxuICAgICAgICAgICAgICAgIHVwZGF0ZVNpbmdsZU1hcmtlckVuZExheW91dChcbiAgICAgICAgICAgICAgICAgICAgZGF0YSwgaWR4LCBpc0Zyb20sIHNlcmllc01vZGVsLCBhcGlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xTaXplOiBpdGVtTW9kZWwuZ2V0KCdzeW1ib2xTaXplJykgfHwgc3ltYm9sU2l6ZVtpc0Zyb20gPyAwIDogMV0sXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogaXRlbU1vZGVsLmdldCgnc3ltYm9sJywgdHJ1ZSkgfHwgc3ltYm9sVHlwZVtpc0Zyb20gPyAwIDogMV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBpdGVtTW9kZWwuZ2V0KCdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJykgfHwgc2VyaWVzRGF0YS5nZXRWaXN1YWwoJ2NvbG9yJylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZURyYXcuX19rZWVwID0gdHJ1ZTtcblxuICAgICAgICAgICAgbGluZURyYXcuZ3JvdXAuc2lsZW50ID0gbWxNb2RlbC5nZXQoJ3NpbGVudCcpIHx8IHNlcmllc01vZGVsLmdldCgnc2lsZW50Jyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvKn0gY29vcmRTeXNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBtcE1vZGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTGlzdChjb29yZFN5cywgc2VyaWVzTW9kZWwsIG1sTW9kZWwpIHtcblxuICAgICAgICB2YXIgY29vcmREaW1zSW5mb3M7XG4gICAgICAgIGlmIChjb29yZFN5cykge1xuICAgICAgICAgICAgY29vcmREaW1zSW5mb3MgPSB6clV0aWwubWFwKGNvb3JkU3lzICYmIGNvb3JkU3lzLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChjb29yZERpbSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmdldERpbWVuc2lvbkluZm8oXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKGNvb3JkRGltKVswXVxuICAgICAgICAgICAgICAgICkgfHwge307IC8vIEluIG1hcCBzZXJpZXMgZGF0YSBkb24ndCBoYXZlIGxuZyBhbmQgbGF0IGRpbWVuc2lvbi4gRmFsbGJhY2sgdG8gc2FtZSB3aXRoIGNvb3JkU3lzXG4gICAgICAgICAgICAgICAgaW5mby5uYW1lID0gY29vcmREaW07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvb3JkRGltc0luZm9zID1be1xuICAgICAgICAgICAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Zsb2F0J1xuICAgICAgICAgICAgfV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnJvbURhdGEgPSBuZXcgTGlzdChjb29yZERpbXNJbmZvcywgbWxNb2RlbCk7XG4gICAgICAgIHZhciB0b0RhdGEgPSBuZXcgTGlzdChjb29yZERpbXNJbmZvcywgbWxNb2RlbCk7XG4gICAgICAgIC8vIE5vIGRpbWVuc2lvbnNcbiAgICAgICAgdmFyIGxpbmVEYXRhID0gbmV3IExpc3QoW10sIG1sTW9kZWwpO1xuXG4gICAgICAgIHZhciBvcHREYXRhID0genJVdGlsLm1hcChtbE1vZGVsLmdldCgnZGF0YScpLCB6clV0aWwuY3VycnkoXG4gICAgICAgICAgICBtYXJrTGluZVRyYW5zZm9ybSwgc2VyaWVzTW9kZWwsIGNvb3JkU3lzLCBtbE1vZGVsXG4gICAgICAgICkpO1xuICAgICAgICBpZiAoY29vcmRTeXMpIHtcbiAgICAgICAgICAgIG9wdERhdGEgPSB6clV0aWwuZmlsdGVyKFxuICAgICAgICAgICAgICAgIG9wdERhdGEsIHpyVXRpbC5jdXJyeShtYXJrTGluZUZpbHRlciwgY29vcmRTeXMpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaW1WYWx1ZUdldHRlciA9IGNvb3JkU3lzID8gbWFya2VySGVscGVyLmRpbVZhbHVlR2V0dGVyIDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBmcm9tRGF0YS5pbml0RGF0YShcbiAgICAgICAgICAgIHpyVXRpbC5tYXAob3B0RGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW1bMF07IH0pLFxuICAgICAgICAgICAgbnVsbCwgZGltVmFsdWVHZXR0ZXJcbiAgICAgICAgKTtcbiAgICAgICAgdG9EYXRhLmluaXREYXRhKFxuICAgICAgICAgICAgenJVdGlsLm1hcChvcHREYXRhLCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbVsxXTsgfSksXG4gICAgICAgICAgICBudWxsLCBkaW1WYWx1ZUdldHRlclxuICAgICAgICApO1xuICAgICAgICBsaW5lRGF0YS5pbml0RGF0YShcbiAgICAgICAgICAgIHpyVXRpbC5tYXAob3B0RGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW1bMl07IH0pXG4gICAgICAgICk7XG4gICAgICAgIGxpbmVEYXRhLmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogZnJvbURhdGEsXG4gICAgICAgICAgICB0bzogdG9EYXRhLFxuICAgICAgICAgICAgbGluZTogbGluZURhdGFcbiAgICAgICAgfTtcbiAgICB9XG4iLCJcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9NYXJrZXJNb2RlbCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ21hcmtQb2ludCcsXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICAgICAgemxldmVsOiAwLFxuICAgICAgICAgICAgejogNSxcbiAgICAgICAgICAgIHN5bWJvbDogJ3BpbicsXG4gICAgICAgICAgICBzeW1ib2xTaXplOiA1MCxcbiAgICAgICAgICAgIC8vc3ltYm9sUm90YXRlOiAwLFxuICAgICAgICAgICAgLy9zeW1ib2xPZmZzZXQ6IFswLCAwXVxuICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICAgIHRyaWdnZXI6ICdpdGVtJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnaW5zaWRlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiIsIlxuXG4gICAgdmFyIFN5bWJvbERyYXcgPSByZXF1aXJlKCcuLi8uLi9jaGFydC9oZWxwZXIvU3ltYm9sRHJhdycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbnVtYmVyJyk7XG5cbiAgICB2YXIgTGlzdCA9IHJlcXVpcmUoJy4uLy4uL2RhdGEvTGlzdCcpO1xuXG4gICAgdmFyIG1hcmtlckhlbHBlciA9IHJlcXVpcmUoJy4vbWFya2VySGVscGVyJyk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVNYXJrZXJMYXlvdXQobXBEYXRhLCBzZXJpZXNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgIG1wRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBtcERhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgICAgICB2YXIgcG9pbnQ7XG4gICAgICAgICAgICB2YXIgeFB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgneCcpLCBhcGkuZ2V0V2lkdGgoKSk7XG4gICAgICAgICAgICB2YXIgeVB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgneScpLCBhcGkuZ2V0SGVpZ2h0KCkpO1xuICAgICAgICAgICAgaWYgKCFpc05hTih4UHgpICYmICFpc05hTih5UHgpKSB7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBbeFB4LCB5UHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hhcnQgbGlrZSBiYXIgbWF5IGhhdmUgdGhlcmUgb3duIG1hcmtlciBwb3NpdGlvbmluZyBsb2dpY1xuICAgICAgICAgICAgZWxzZSBpZiAoc2VyaWVzTW9kZWwuZ2V0TWFya2VyUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGdldE1hcmtlclBvaXNpdGlvblxuICAgICAgICAgICAgICAgIHBvaW50ID0gc2VyaWVzTW9kZWwuZ2V0TWFya2VyUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIG1wRGF0YS5nZXRWYWx1ZXMobXBEYXRhLmRpbWVuc2lvbnMsIGlkeClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29vcmRTeXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IG1wRGF0YS5nZXQoY29vcmRTeXMuZGltZW5zaW9uc1swXSwgaWR4KTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IG1wRGF0YS5nZXQoY29vcmRTeXMuZGltZW5zaW9uc1sxXSwgaWR4KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KFt4LCB5XSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIHgsIHkgaWYgaGFzIGFueVxuICAgICAgICAgICAgaWYgKCFpc05hTih4UHgpKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRbMF0gPSB4UHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHlQeCkpIHtcbiAgICAgICAgICAgICAgICBwb2ludFsxXSA9IHlQeDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXBEYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBwb2ludCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlcXVpcmUoJy4vTWFya2VyVmlldycpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ21hcmtQb2ludCcsXG5cbiAgICAgICAgdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAobWFya1BvaW50TW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBtcE1vZGVsID0gc2VyaWVzTW9kZWwubWFya1BvaW50TW9kZWw7XG4gICAgICAgICAgICAgICAgaWYgKG1wTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTWFya2VyTGF5b3V0KG1wTW9kZWwuZ2V0RGF0YSgpLCBzZXJpZXNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJHcm91cE1hcFtzZXJpZXNNb2RlbC5uYW1lXS51cGRhdGVMYXlvdXQobXBNb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyU2VyaWVzOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIG1wTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHZhciBzZXJpZXNOYW1lID0gc2VyaWVzTW9kZWwubmFtZTtcbiAgICAgICAgICAgIHZhciBzZXJpZXNEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgICAgICAgICB2YXIgc3ltYm9sRHJhd01hcCA9IHRoaXMubWFya2VyR3JvdXBNYXA7XG4gICAgICAgICAgICB2YXIgc3ltYm9sRHJhdyA9IHN5bWJvbERyYXdNYXBbc2VyaWVzTmFtZV07XG4gICAgICAgICAgICBpZiAoIXN5bWJvbERyYXcpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xEcmF3ID0gc3ltYm9sRHJhd01hcFtzZXJpZXNOYW1lXSA9IG5ldyBTeW1ib2xEcmF3KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtcERhdGEgPSBjcmVhdGVMaXN0KGNvb3JkU3lzLCBzZXJpZXNNb2RlbCwgbXBNb2RlbCk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBtcE1vZGVsLnNldERhdGEobXBEYXRhKTtcblxuICAgICAgICAgICAgdXBkYXRlTWFya2VyTGF5b3V0KG1wTW9kZWwuZ2V0RGF0YSgpLCBzZXJpZXNNb2RlbCwgYXBpKTtcblxuICAgICAgICAgICAgbXBEYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBtcERhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbFNpemUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnc3ltYm9sU2l6ZScpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ltYm9sU2l6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSDov5nph4zkuI3lhbzlrrkgRUNoYXJ0cyAyLnjvvIwyLngg6LKM5Ly85Y+C5pWw5piv5pW05Liq5pWw5o2u77yfXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFNpemUgPSBzeW1ib2xTaXplKFxuICAgICAgICAgICAgICAgICAgICAgICAgbXBNb2RlbC5nZXRSYXdWYWx1ZShpZHgpLCBtcE1vZGVsLmdldERhdGFQYXJhbXMoaWR4KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtcERhdGEuc2V0SXRlbVZpc3VhbChpZHgsIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sU2l6ZTogc3ltYm9sU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGl0ZW1Nb2RlbC5nZXQoJ2l0ZW1TdHlsZS5ub3JtYWwuY29sb3InKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgc2VyaWVzRGF0YS5nZXRWaXN1YWwoJ2NvbG9yJyksXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbCcpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVE9ETyBUZXh0IGFyZSB3cm9uZ1xuICAgICAgICAgICAgc3ltYm9sRHJhdy51cGRhdGVEYXRhKG1wRGF0YSk7XG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChzeW1ib2xEcmF3Lmdyb3VwKTtcblxuICAgICAgICAgICAgLy8gU2V0IGhvc3QgbW9kZWwgZm9yIHRvb2x0aXBcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBtcERhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRhdGFNb2RlbCA9IG1wTW9kZWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc3ltYm9sRHJhdy5fX2tlZXAgPSB0cnVlO1xuXG4gICAgICAgICAgICBzeW1ib2xEcmF3Lmdyb3VwLnNpbGVudCA9IG1wTW9kZWwuZ2V0KCdzaWxlbnQnKSB8fCBzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkLyp9IFtjb29yZFN5c11cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBtcE1vZGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTGlzdChjb29yZFN5cywgc2VyaWVzTW9kZWwsIG1wTW9kZWwpIHtcbiAgICAgICAgdmFyIGNvb3JkRGltc0luZm9zO1xuICAgICAgICBpZiAoY29vcmRTeXMpIHtcbiAgICAgICAgICAgIGNvb3JkRGltc0luZm9zID0genJVdGlsLm1hcChjb29yZFN5cyAmJiBjb29yZFN5cy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoY29vcmREaW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHNlcmllc01vZGVsLmdldERhdGEoKS5nZXREaW1lbnNpb25JbmZvKFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShjb29yZERpbSlbMF1cbiAgICAgICAgICAgICAgICApIHx8IHt9OyAvLyBJbiBtYXAgc2VyaWVzIGRhdGEgZG9uJ3QgaGF2ZSBsbmcgYW5kIGxhdCBkaW1lbnNpb24uIEZhbGxiYWNrIHRvIHNhbWUgd2l0aCBjb29yZFN5c1xuICAgICAgICAgICAgICAgIGluZm8ubmFtZSA9IGNvb3JkRGltO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb29yZERpbXNJbmZvcyA9W3tcbiAgICAgICAgICAgICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdmbG9hdCdcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1wRGF0YSA9IG5ldyBMaXN0KGNvb3JkRGltc0luZm9zLCBtcE1vZGVsKTtcbiAgICAgICAgdmFyIGRhdGFPcHQgPSB6clV0aWwubWFwKG1wTW9kZWwuZ2V0KCdkYXRhJyksIHpyVXRpbC5jdXJyeShcbiAgICAgICAgICAgICAgICBtYXJrZXJIZWxwZXIuZGF0YVRyYW5zZm9ybSwgc2VyaWVzTW9kZWxcbiAgICAgICAgICAgICkpO1xuICAgICAgICBpZiAoY29vcmRTeXMpIHtcbiAgICAgICAgICAgIGRhdGFPcHQgPSB6clV0aWwuZmlsdGVyKFxuICAgICAgICAgICAgICAgIGRhdGFPcHQsIHpyVXRpbC5jdXJyeShtYXJrZXJIZWxwZXIuZGF0YUZpbHRlciwgY29vcmRTeXMpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbXBEYXRhLmluaXREYXRhKGRhdGFPcHQsIG51bGwsXG4gICAgICAgICAgICBjb29yZFN5cyA/IG1hcmtlckhlbHBlci5kaW1WYWx1ZUdldHRlciA6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBtcERhdGE7XG4gICAgfVxuXG4iLCJcblxuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xuXG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2Zvcm1hdCcpO1xuICAgIHZhciBhZGRDb21tYXMgPSBmb3JtYXRVdGlsLmFkZENvbW1hcztcbiAgICB2YXIgZW5jb2RlSFRNTCA9IGZvcm1hdFV0aWwuZW5jb2RlSFRNTDtcblxuICAgIGZ1bmN0aW9uIGZpbGxMYWJlbChvcHQpIHtcbiAgICAgICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyhcbiAgICAgICAgICAgIG9wdC5sYWJlbCxcbiAgICAgICAgICAgIG1vZGVsVXRpbC5MQUJFTF9PUFRJT05TXG4gICAgICAgICk7XG4gICAgfVxuICAgIHZhciBNYXJrZXJNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRNb2RlbCh7XG5cbiAgICAgICAgdHlwZTogJ21hcmtlcicsXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbJ3NlcmllcycsICdncmlkJywgJ3BvbGFyJywgJ2dlbyddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaXRlXG4gICAgICAgICAqL1xuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpIHtcblxuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbWFya2VyJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hcmtlciBjb21wb25lbnQgaXMgYWJzdHJhY3QgY29tcG9uZW50LiBVc2UgbWFya0xpbmUsIG1hcmtQb2ludCwgbWFya0FyZWEgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1lcmdlRGVmYXVsdEFuZFRoZW1lKG9wdGlvbiwgZWNNb2RlbCk7XG4gICAgICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKG9wdGlvbiwgZWNNb2RlbCwgZXh0cmFPcHQuY3JlYXRlZEJ5U2VsZiwgdHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc0FuaW1hdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhvc3RTZXJpZXMgPSB0aGlzLl9faG9zdFNlcmllcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNoYWxsb3coJ2FuaW1hdGlvbicpICYmIGhvc3RTZXJpZXMgJiYgaG9zdFNlcmllcy5pc0FuaW1hdGlvbkVuYWJsZWQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld09wdCwgZWNNb2RlbCwgY3JlYXRlZEJ5U2VsZiwgaXNJbml0KSB7XG4gICAgICAgICAgICB2YXIgTWFya2VyTW9kZWwgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgdmFyIG1vZGVsUHJvcE5hbWUgPSB0aGlzLm1haW5UeXBlICsgJ01vZGVsJztcbiAgICAgICAgICAgIGlmICghY3JlYXRlZEJ5U2VsZikge1xuICAgICAgICAgICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFya2VyT3B0ID0gc2VyaWVzTW9kZWwuZ2V0KHRoaXMubWFpblR5cGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXJrZXJNb2RlbCA9IHNlcmllc01vZGVsW21vZGVsUHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcmtlck9wdCB8fCAhbWFya2VyT3B0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsW21vZGVsUHJvcE5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcmtlck1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbml0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBsYWJlbCBlbXBoYXNpcyBgcG9zaXRpb25gIGFuZCBgc2hvd2BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsTGFiZWwobWFya2VyT3B0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKG1hcmtlck9wdC5kYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIE92ZXJ3cml0ZSBmaWxsTGFiZWwgbWV0aG9kID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxMYWJlbChpdGVtWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbExhYmVsKGl0ZW1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbExhYmVsKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJNb2RlbCA9IG5ldyBNYXJrZXJNb2RlbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJPcHQsIHRoaXMsIGVjTW9kZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHpyVXRpbC5leHRlbmQobWFya2VyTW9kZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluVHlwZTogdGhpcy5tYWluVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHNhbWUgc2VyaWVzIGluZGV4IGFuZCBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc01vZGVsLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNlcmllc01vZGVsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEJ5U2VsZjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlck1vZGVsLl9faG9zdFNlcmllcyA9IHNlcmllc01vZGVsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyTW9kZWwubWVyZ2VPcHRpb24obWFya2VyT3B0LCBlY01vZGVsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbFttb2RlbFByb3BOYW1lXSA9IG1hcmtlck1vZGVsO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdFRvb2x0aXA6IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFJhd1ZhbHVlKGRhdGFJbmRleCk7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSB6clV0aWwuaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgICAgICA/IHpyVXRpbC5tYXAodmFsdWUsIGFkZENvbW1hcykuam9pbignLCAnKSA6IGFkZENvbW1hcyh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGRhdGEuZ2V0TmFtZShkYXRhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIGh0bWwgPSBlbmNvZGVIVE1MKHRoaXMubmFtZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCB8fCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPGJyIC8+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSBlbmNvZGVIVE1MKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJyA6ICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBodG1sICs9IGVuY29kZUhUTUwoZm9ybWF0dGVkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB6clV0aWwubWl4aW4oTWFya2VyTW9kZWwsIG1vZGVsVXRpbC5kYXRhRm9ybWF0TWl4aW4pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNYXJrZXJNb2RlbDtcbiIsIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ21hcmtlcicsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXJrbGluZSBncm91cGVkIGJ5IHNlcmllc1xuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubWFya2VyR3JvdXBNYXAgPSB7fTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChtYXJrZXJNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgbWFya2VyR3JvdXBNYXAgPSB0aGlzLm1hcmtlckdyb3VwTWFwO1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBtYXJrZXJHcm91cE1hcCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXJHcm91cE1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJHcm91cE1hcFtuYW1lXS5fX2tlZXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtYXJrZXJNb2RlbEtleSA9IHRoaXMudHlwZSArICdNb2RlbCc7XG4gICAgICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtlck1vZGVsID0gc2VyaWVzTW9kZWxbbWFya2VyTW9kZWxLZXldO1xuICAgICAgICAgICAgICAgIG1hcmtlck1vZGVsICYmIHRoaXMucmVuZGVyU2VyaWVzKHNlcmllc01vZGVsLCBtYXJrZXJNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG1hcmtlckdyb3VwTWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlckdyb3VwTWFwLmhhc093blByb3BlcnR5KG5hbWUpICYmICFtYXJrZXJHcm91cE1hcFtuYW1lXS5fX2tlZXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmUobWFya2VyR3JvdXBNYXBbbmFtZV0uZ3JvdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXJTZXJpZXM6IGZ1bmN0aW9uICgpIHt9XG4gICAgfSk7XG4iLCJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbnVtYmVyJyk7XG4gICAgdmFyIGluZGV4T2YgPSB6clV0aWwuaW5kZXhPZjtcblxuICAgIGZ1bmN0aW9uIGhhc1hPclkoaXRlbSkge1xuICAgICAgICByZXR1cm4gIShpc05hTihwYXJzZUZsb2F0KGl0ZW0ueCkpICYmIGlzTmFOKHBhcnNlRmxvYXQoaXRlbS55KSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc1hBbmRZKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KGl0ZW0ueCkpICYmICFpc05hTihwYXJzZUZsb2F0KGl0ZW0ueSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByZWNpc2lvbihkYXRhLCB2YWx1ZUF4aXNEaW0sIGRhdGFJbmRleCkge1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gLTE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uKGRhdGEuZ2V0KFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUF4aXNEaW0sIGRhdGFJbmRleFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLnN0YWNrZWRPbjtcbiAgICAgICAgfSB3aGlsZSAoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHByZWNpc2lvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXJrZXJUeXBlQ2FsY3VsYXRvcldpdGhFeHRlbnQoXG4gICAgICAgIG1sVHlwZSwgZGF0YSwgb3RoZXJEYXRhRGltLCB0YXJnZXREYXRhRGltLCBvdGhlckNvb3JkSW5kZXgsIHRhcmdldENvb3JkSW5kZXhcbiAgICApIHtcbiAgICAgICAgdmFyIGNvb3JkQXJyID0gW107XG4gICAgICAgIHZhciB2YWx1ZSA9IG51bUNhbGN1bGF0ZShkYXRhLCB0YXJnZXREYXRhRGltLCBtbFR5cGUpO1xuXG4gICAgICAgIHZhciBkYXRhSW5kZXggPSBkYXRhLmluZGV4T2ZOZWFyZXN0KHRhcmdldERhdGFEaW0sIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgY29vcmRBcnJbb3RoZXJDb29yZEluZGV4XSA9IGRhdGEuZ2V0KG90aGVyRGF0YURpbSwgZGF0YUluZGV4LCB0cnVlKTtcbiAgICAgICAgY29vcmRBcnJbdGFyZ2V0Q29vcmRJbmRleF0gPSBkYXRhLmdldCh0YXJnZXREYXRhRGltLCBkYXRhSW5kZXgsIHRydWUpO1xuXG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBnZXRQcmVjaXNpb24oZGF0YSwgdGFyZ2V0RGF0YURpbSwgZGF0YUluZGV4KTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiA+PSAwKSB7XG4gICAgICAgICAgICBjb29yZEFyclt0YXJnZXRDb29yZEluZGV4XSA9ICtjb29yZEFyclt0YXJnZXRDb29yZEluZGV4XS50b0ZpeGVkKHByZWNpc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29vcmRBcnI7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJ5ID0genJVdGlsLmN1cnJ5O1xuICAgIC8vIFRPRE8gU3BlY2lmaWVkIHBlcmNlbnRcbiAgICB2YXIgbWFya2VyVHlwZUNhbGN1bGF0b3IgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlQXhpc0RpbVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVBeGlzRGltXG4gICAgICAgICAqL1xuICAgICAgICBtaW46IGN1cnJ5KG1hcmtlclR5cGVDYWxjdWxhdG9yV2l0aEV4dGVudCwgJ21pbicpLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZUF4aXNEaW1cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlQXhpc0RpbVxuICAgICAgICAgKi9cbiAgICAgICAgbWF4OiBjdXJyeShtYXJrZXJUeXBlQ2FsY3VsYXRvcldpdGhFeHRlbnQsICdtYXgnKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZUF4aXNEaW1cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlQXhpc0RpbVxuICAgICAgICAgKi9cbiAgICAgICAgYXZlcmFnZTogY3VycnkobWFya2VyVHlwZUNhbGN1bGF0b3JXaXRoRXh0ZW50LCAnYXZlcmFnZScpXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBtYXJrUG9pbnQgZGF0YSBpdGVtIHRvIGZvcm1hdCB1c2VkIGluIExpc3QgYnkgZG8gdGhlIGZvbGxvd2luZ1xuICAgICAqIDEuIENhbGN1bGF0ZSBzdGF0aXN0aWMgbGlrZSBgbWF4YCwgYG1pbmAsIGBhdmVyYWdlYFxuICAgICAqIDIuIENvbnZlcnQgYGl0ZW0ueEF4aXNgLCBgaXRlbS55QXhpc2AgdG8gYGl0ZW0uY29vcmRgIGFycmF5XG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL2Nvb3JkLyp9IFtjb29yZFN5c11cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIGRhdGFUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGl0ZW0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICAgICAgLy8gMS4gSWYgbm90IHNwZWNpZnkgdGhlIHBvc2l0aW9uIHdpdGggcGl4ZWwgZGlyZWN0bHlcbiAgICAgICAgLy8gMi4gSWYgYGNvb3JkYCBpcyBub3QgYSBkYXRhIGFycmF5LiBXaGljaCB1c2VzIGB4QXhpc2AsXG4gICAgICAgIC8vIGB5QXhpc2AgdG8gc3BlY2lmeSB0aGUgY29vcmQgb24gZWFjaCBkaW1lbnNpb25cblxuICAgICAgICAvLyBwYXJzZUZsb2F0IGZpcnN0IGJlY2F1c2UgaXRlbS54IGFuZCBpdGVtLnkgY2FuIGJlIHBlcmNlbnQgc3RyaW5nIGxpa2UgJzIwJSdcbiAgICAgICAgaWYgKGl0ZW0gJiYgIWhhc1hBbmRZKGl0ZW0pICYmICF6clV0aWwuaXNBcnJheShpdGVtLmNvb3JkKSAmJiBjb29yZFN5cykge1xuICAgICAgICAgICAgdmFyIGRpbXMgPSBjb29yZFN5cy5kaW1lbnNpb25zO1xuICAgICAgICAgICAgdmFyIGF4aXNJbmZvID0gZ2V0QXhpc0luZm8oaXRlbSwgZGF0YSwgY29vcmRTeXMsIHNlcmllc01vZGVsKTtcblxuICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIG9wdGlvblxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIHhBeGlzLCB5QXhpcywgcmFkaXVzQXhpcywgYW5nbGVBeGlzLCBnZW9Db29yZCB0byB2YWx1ZVxuICAgICAgICAgICAgaXRlbSA9IHpyVXRpbC5jbG9uZShpdGVtKTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZVxuICAgICAgICAgICAgICAgICYmIG1hcmtlclR5cGVDYWxjdWxhdG9yW2l0ZW0udHlwZV1cbiAgICAgICAgICAgICAgICAmJiBheGlzSW5mby5iYXNlQXhpcyAmJiBheGlzSW5mby52YWx1ZUF4aXNcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlckNvb3JkSW5kZXggPSBpbmRleE9mKGRpbXMsIGF4aXNJbmZvLmJhc2VBeGlzLmRpbSk7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldENvb3JkSW5kZXggPSBpbmRleE9mKGRpbXMsIGF4aXNJbmZvLnZhbHVlQXhpcy5kaW0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5jb29yZCA9IG1hcmtlclR5cGVDYWxjdWxhdG9yW2l0ZW0udHlwZV0oXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsIGF4aXNJbmZvLmJhc2VEYXRhRGltLCBheGlzSW5mby52YWx1ZURhdGFEaW0sXG4gICAgICAgICAgICAgICAgICAgIG90aGVyQ29vcmRJbmRleCwgdGFyZ2V0Q29vcmRJbmRleFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgdG8gdXNlIHRoZSB2YWx1ZSBvZiBjYWxjdWxhdGVkIHZhbHVlLlxuICAgICAgICAgICAgICAgIGl0ZW0udmFsdWUgPSBpdGVtLmNvb3JkW3RhcmdldENvb3JkSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgT25seSBoYXMgb25lIG9mIHhBeGlzIGFuZCB5QXhpcy5cbiAgICAgICAgICAgICAgICB2YXIgY29vcmQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ueEF4aXMgIT0gbnVsbCA/IGl0ZW0ueEF4aXMgOiBpdGVtLnJhZGl1c0F4aXMsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ueUF4aXMgIT0gbnVsbCA/IGl0ZW0ueUF4aXMgOiBpdGVtLmFuZ2xlQXhpc1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgLy8gRWFjaCBjb29yZCBzdXBwb3J0IG1heCwgbWluLCBhdmVyYWdlXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlclR5cGVDYWxjdWxhdG9yW2Nvb3JkW2ldXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFEaW0gPSBzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShkaW1zW2ldKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkW2ldID0gbnVtQ2FsY3VsYXRlKGRhdGEsIGRhdGFEaW0sIGNvb3JkW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtLmNvb3JkID0gY29vcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfTtcblxuICAgIHZhciBnZXRBeGlzSW5mbyA9IGZ1bmN0aW9uIChpdGVtLCBkYXRhLCBjb29yZFN5cywgc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgdmFyIHJldCA9IHt9O1xuXG4gICAgICAgIGlmIChpdGVtLnZhbHVlSW5kZXggIT0gbnVsbCB8fCBpdGVtLnZhbHVlRGltICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldC52YWx1ZURhdGFEaW0gPSBpdGVtLnZhbHVlSW5kZXggIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZGF0YS5nZXREaW1lbnNpb24oaXRlbS52YWx1ZUluZGV4KSA6IGl0ZW0udmFsdWVEaW07XG4gICAgICAgICAgICByZXQudmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0QXhpcyhzZXJpZXNNb2RlbC5kYXRhRGltVG9Db29yZERpbShyZXQudmFsdWVEYXRhRGltKSk7XG4gICAgICAgICAgICByZXQuYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRPdGhlckF4aXMocmV0LnZhbHVlQXhpcyk7XG4gICAgICAgICAgICByZXQuYmFzZURhdGFEaW0gPSBzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShyZXQuYmFzZUF4aXMuZGltKVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldC5iYXNlQXhpcyA9IHNlcmllc01vZGVsLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAgICByZXQudmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKHJldC5iYXNlQXhpcyk7XG4gICAgICAgICAgICByZXQuYmFzZURhdGFEaW0gPSBzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShyZXQuYmFzZUF4aXMuZGltKVswXTtcbiAgICAgICAgICAgIHJldC52YWx1ZURhdGFEaW0gPSBzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShyZXQudmFsdWVBeGlzLmRpbSlbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgZGF0YSB3aGljaCBpcyBvdXQgb2YgY29vcmRpbmF0ZVN5c3RlbSByYW5nZVxuICAgICAqIFtkYXRhRmlsdGVyIGRlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL2Nvb3JkLyp9IFtjb29yZFN5c11cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIHZhciBkYXRhRmlsdGVyID0gZnVuY3Rpb24gKGNvb3JkU3lzLCBpdGVtKSB7XG4gICAgICAgIC8vIEFsd2FseXMgcmV0dXJuIHRydWUgaWYgdGhlcmUgaXMgbm8gY29vcmRTeXNcbiAgICAgICAgcmV0dXJuIChjb29yZFN5cyAmJiBjb29yZFN5cy5jb250YWluRGF0YSAmJiBpdGVtLmNvb3JkICYmICFoYXNYT3JZKGl0ZW0pKVxuICAgICAgICAgICAgPyBjb29yZFN5cy5jb250YWluRGF0YShpdGVtLmNvb3JkKSA6IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBkaW1WYWx1ZUdldHRlciA9IGZ1bmN0aW9uIChpdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgICAgIC8vIHgsIHksIHJhZGl1cywgYW5nbGVcbiAgICAgICAgaWYgKGRpbUluZGV4IDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uY29vcmQgJiYgaXRlbS5jb29yZFtkaW1JbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfTtcblxuICAgIHZhciBudW1DYWxjdWxhdGUgPSBmdW5jdGlvbiAoZGF0YSwgdmFsdWVEYXRhRGltLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnYXZlcmFnZScpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIGRhdGEuZWFjaCh2YWx1ZURhdGFEaW0sIGZ1bmN0aW9uICh2YWwsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gdmFsO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bSAvIGNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuZ2V0RGF0YUV4dGVudCh2YWx1ZURhdGFEaW0sIHRydWUpW3R5cGUgPT09ICdtYXgnID8gMSA6IDBdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBkYXRhVHJhbnNmb3JtOiBkYXRhVHJhbnNmb3JtLFxuICAgICAgICBkYXRhRmlsdGVyOiBkYXRhRmlsdGVyLFxuICAgICAgICBkaW1WYWx1ZUdldHRlcjogZGltVmFsdWVHZXR0ZXIsXG4gICAgICAgIGdldEF4aXNJbmZvOiBnZXRBeGlzSW5mbyxcbiAgICAgICAgbnVtQ2FsY3VsYXRlOiBudW1DYWxjdWxhdGVcbiAgICB9O1xuIiwiXG5cbiAgICByZXF1aXJlKCcuLi9jb29yZC9yYWRhci9SYWRhcicpO1xuICAgIHJlcXVpcmUoJy4uL2Nvb3JkL3JhZGFyL1JhZGFyTW9kZWwnKTtcblxuICAgIHJlcXVpcmUoJy4vcmFkYXIvUmFkYXJWaWV3Jyk7XG4iLCJcblxuICAgIHZhciBBeGlzQnVpbGRlciA9IHJlcXVpcmUoJy4uL2F4aXMvQXhpc0J1aWxkZXInKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcblxuICAgIHZhciBheGlzQnVpbGRlckF0dHJzID0gW1xuICAgICAgICAnYXhpc0xpbmUnLCAnYXhpc0xhYmVsJywgJ2F4aXNUaWNrJywgJ2F4aXNOYW1lJ1xuICAgIF07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRWaWV3KHtcblxuICAgICAgICB0eXBlOiAncmFkYXInLFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKHJhZGFyTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgICAgICAgICB0aGlzLl9idWlsZEF4ZXMocmFkYXJNb2RlbCk7XG4gICAgICAgICAgICB0aGlzLl9idWlsZFNwbGl0TGluZUFuZEFyZWEocmFkYXJNb2RlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2J1aWxkQXhlczogZnVuY3Rpb24gKHJhZGFyTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciByYWRhciA9IHJhZGFyTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3JBeGVzID0gcmFkYXIuZ2V0SW5kaWNhdG9yQXhlcygpO1xuICAgICAgICAgICAgdmFyIGF4aXNCdWlsZGVycyA9IHpyVXRpbC5tYXAoaW5kaWNhdG9yQXhlcywgZnVuY3Rpb24gKGluZGljYXRvckF4aXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc0J1aWxkZXIgPSBuZXcgQXhpc0J1aWxkZXIoaW5kaWNhdG9yQXhpcy5tb2RlbCwge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogW3JhZGFyLmN4LCByYWRhci5jeV0sXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBpbmRpY2F0b3JBeGlzLmFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbERpcmVjdGlvbjogLTEsXG4gICAgICAgICAgICAgICAgICAgIHRpY2tEaXJlY3Rpb246IC0xLFxuICAgICAgICAgICAgICAgICAgICBuYW1lRGlyZWN0aW9uOiAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF4aXNCdWlsZGVyO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGF4aXNCdWlsZGVycywgZnVuY3Rpb24gKGF4aXNCdWlsZGVyKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2goYXhpc0J1aWxkZXJBdHRycywgYXhpc0J1aWxkZXIuYWRkLCBheGlzQnVpbGRlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoYXhpc0J1aWxkZXIuZ2V0R3JvdXAoKSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYnVpbGRTcGxpdExpbmVBbmRBcmVhOiBmdW5jdGlvbiAocmFkYXJNb2RlbCkge1xuICAgICAgICAgICAgdmFyIHJhZGFyID0gcmFkYXJNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIGluZGljYXRvckF4ZXMgPSByYWRhci5nZXRJbmRpY2F0b3JBeGVzKCk7XG4gICAgICAgICAgICBpZiAoIWluZGljYXRvckF4ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNoYXBlID0gcmFkYXJNb2RlbC5nZXQoJ3NoYXBlJyk7XG4gICAgICAgICAgICB2YXIgc3BsaXRMaW5lTW9kZWwgPSByYWRhck1vZGVsLmdldE1vZGVsKCdzcGxpdExpbmUnKTtcbiAgICAgICAgICAgIHZhciBzcGxpdEFyZWFNb2RlbCA9IHJhZGFyTW9kZWwuZ2V0TW9kZWwoJ3NwbGl0QXJlYScpO1xuICAgICAgICAgICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gc3BsaXRMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgICAgICAgICAgdmFyIGFyZWFTdHlsZU1vZGVsID0gc3BsaXRBcmVhTW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZScpO1xuXG4gICAgICAgICAgICB2YXIgc2hvd1NwbGl0TGluZSA9IHNwbGl0TGluZU1vZGVsLmdldCgnc2hvdycpO1xuICAgICAgICAgICAgdmFyIHNob3dTcGxpdEFyZWEgPSBzcGxpdEFyZWFNb2RlbC5nZXQoJ3Nob3cnKTtcbiAgICAgICAgICAgIHZhciBzcGxpdExpbmVDb2xvcnMgPSBsaW5lU3R5bGVNb2RlbC5nZXQoJ2NvbG9yJyk7XG4gICAgICAgICAgICB2YXIgc3BsaXRBcmVhQ29sb3JzID0gYXJlYVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuXG4gICAgICAgICAgICBzcGxpdExpbmVDb2xvcnMgPSB6clV0aWwuaXNBcnJheShzcGxpdExpbmVDb2xvcnMpID8gc3BsaXRMaW5lQ29sb3JzIDogW3NwbGl0TGluZUNvbG9yc107XG4gICAgICAgICAgICBzcGxpdEFyZWFDb2xvcnMgPSB6clV0aWwuaXNBcnJheShzcGxpdEFyZWFDb2xvcnMpID8gc3BsaXRBcmVhQ29sb3JzIDogW3NwbGl0QXJlYUNvbG9yc107XG5cbiAgICAgICAgICAgIHZhciBzcGxpdExpbmVzID0gW107XG4gICAgICAgICAgICB2YXIgc3BsaXRBcmVhcyA9IFtdO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRDb2xvckluZGV4KGFyZWFPckxpbmUsIGFyZWFPckxpbmVDb2xvckxpc3QsIGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvckluZGV4ID0gaWR4ICUgYXJlYU9yTGluZUNvbG9yTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYXJlYU9yTGluZVtjb2xvckluZGV4XSA9IGFyZWFPckxpbmVbY29sb3JJbmRleF0gfHwgW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9ySW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaGFwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGlja3NSYWRpdXMgPSBpbmRpY2F0b3JBeGVzWzBdLmdldFRpY2tzQ29vcmRzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gcmFkYXIuY3g7XG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gcmFkYXIuY3k7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrc1JhZGl1cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd1NwbGl0TGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9ySW5kZXggPSBnZXRDb2xvckluZGV4KHNwbGl0TGluZXMsIHNwbGl0TGluZUNvbG9ycywgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdExpbmVzW2NvbG9ySW5kZXhdLnB1c2gobmV3IGdyYXBoaWMuQ2lyY2xlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcjogdGlja3NSYWRpdXNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dTcGxpdEFyZWEgJiYgaSA8IHRpY2tzUmFkaXVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvckluZGV4ID0gZ2V0Q29sb3JJbmRleChzcGxpdEFyZWFzLCBzcGxpdEFyZWFDb2xvcnMsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRBcmVhc1tjb2xvckluZGV4XS5wdXNoKG5ldyBncmFwaGljLlJpbmcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByMDogdGlja3NSYWRpdXNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI6IHRpY2tzUmFkaXVzW2kgKyAxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvbHl5b25cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZWFsU3BsaXROdW1iZXIgPSAtMTtcbiAgICAgICAgICAgICAgICB2YXIgYXhlc1RpY2tzUG9pbnRzID0genJVdGlsLm1hcChpbmRpY2F0b3JBeGVzLCBmdW5jdGlvbiAoaW5kaWNhdG9yQXhpcywgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aWNrc0Nvb3JkcyA9IGluZGljYXRvckF4aXMuZ2V0VGlja3NDb29yZHMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhbFNwbGl0TnVtYmVyID0gTWF0aC5tYXgodGlja3NDb29yZHMubGVuZ3RoIC0gMSwgcmVhbFNwbGl0TnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAodGlja3NDb29yZHMsIGZ1bmN0aW9uICh0aWNrQ29vcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByYWRhci5jb29yZFRvUG9pbnQodGlja0Nvb3JkLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBwcmV2UG9pbnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcmVhbFNwbGl0TnVtYmVyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGluZGljYXRvckF4ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGF4ZXNUaWNrc1BvaW50c1tqXVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnRzWzBdLnNsaWNlKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5cXCd0IGRyYXcgdmFsdWUgYXhpcyAnICsgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dTcGxpdExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvckluZGV4ID0gZ2V0Q29sb3JJbmRleChzcGxpdExpbmVzLCBzcGxpdExpbmVDb2xvcnMsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRMaW5lc1tjb2xvckluZGV4XS5wdXNoKG5ldyBncmFwaGljLlBvbHlsaW5lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd1NwbGl0QXJlYSAmJiBwcmV2UG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IGdldENvbG9ySW5kZXgoc3BsaXRBcmVhcywgc3BsaXRBcmVhQ29sb3JzLCBpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdEFyZWFzW2NvbG9ySW5kZXhdLnB1c2gobmV3IGdyYXBoaWMuUG9seWdvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMuY29uY2F0KHByZXZQb2ludHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZXZQb2ludHMgPSBwb2ludHMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGluZVN0eWxlID0gbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCk7XG4gICAgICAgICAgICB2YXIgYXJlYVN0eWxlID0gYXJlYVN0eWxlTW9kZWwuZ2V0QXJlYVN0eWxlKCk7XG4gICAgICAgICAgICAvLyBBZGQgc3BsaXRBcmVhIGJlZm9yZSBzcGxpdExpbmVcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHNwbGl0QXJlYXMsIGZ1bmN0aW9uIChzcGxpdEFyZWFzLCBpZHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChncmFwaGljLm1lcmdlUGF0aChcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRBcmVhcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogc3BsaXRBcmVhQ29sb3JzW2lkeCAlIHNwbGl0QXJlYUNvbG9ycy5sZW5ndGhdXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBhcmVhU3R5bGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChzcGxpdExpbmVzLCBmdW5jdGlvbiAoc3BsaXRMaW5lcywgaWR4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoZ3JhcGhpYy5tZXJnZVBhdGgoXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0TGluZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHNwbGl0TGluZUNvbG9yc1tpZHggJSBzcGxpdExpbmVDb2xvcnMubGVuZ3RoXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgbGluZVN0eWxlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB9XG4gICAgfSk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vZWNoYXJ0cycpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoJy4uL3V0aWwvbGF5b3V0Jyk7XG5cbiAgICAvLyBNb2RlbFxuICAgIGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50TW9kZWwoe1xuXG4gICAgICAgIHR5cGU6ICd0aXRsZScsXG5cbiAgICAgICAgbGF5b3V0TW9kZToge3R5cGU6ICdib3gnLCBpZ25vcmVTaXplOiB0cnVlfSxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICAvLyDkuIDnuqflsYLlj6BcbiAgICAgICAgICAgIHpsZXZlbDogMCxcbiAgICAgICAgICAgIC8vIOS6jOe6p+WxguWPoFxuICAgICAgICAgICAgejogNixcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG5cbiAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgLy8g6LaF6ZO+5o6l6Lez6L2sXG4gICAgICAgICAgICAvLyBsaW5rOiBudWxsLFxuICAgICAgICAgICAgLy8g5LuF5pSv5oyBc2VsZiB8IGJsYW5rXG4gICAgICAgICAgICB0YXJnZXQ6ICdibGFuaycsXG4gICAgICAgICAgICBzdWJ0ZXh0OiAnJyxcblxuICAgICAgICAgICAgLy8g6LaF6ZO+5o6l6Lez6L2sXG4gICAgICAgICAgICAvLyBzdWJsaW5rOiBudWxsLFxuICAgICAgICAgICAgLy8g5LuF5pSv5oyBc2VsZiB8IGJsYW5rXG4gICAgICAgICAgICBzdWJ0YXJnZXQ6ICdibGFuaycsXG5cbiAgICAgICAgICAgIC8vICdjZW50ZXInIMKmICdsZWZ0JyDCpiAncmlnaHQnXG4gICAgICAgICAgICAvLyDCpiB7bnVtYmVyfe+8iHjlnZDmoIfvvIzljZXkvY1weO+8iVxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIC8vICd0b3AnIMKmICdib3R0b20nIMKmICdjZW50ZXInXG4gICAgICAgICAgICAvLyDCpiB7bnVtYmVyfe+8iHnlnZDmoIfvvIzljZXkvY1weO+8iVxuICAgICAgICAgICAgdG9wOiAwLFxuXG4gICAgICAgICAgICAvLyDmsLTlubPlr7npvZBcbiAgICAgICAgICAgIC8vICdhdXRvJyB8ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJ1xuICAgICAgICAgICAgLy8g6buY6K6k5qC55o2uIGxlZnQg55qE5L2N572u5Yik5pat5piv5bem5a+56b2Q6L+Y5piv5Y+z5a+56b2QXG4gICAgICAgICAgICAvLyB0ZXh0QWxpZ246IG51bGxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyDlnoLnm7Tlr7npvZBcbiAgICAgICAgICAgIC8vICdhdXRvJyB8ICd0b3AnIHwgJ2JvdHRvbScgfCAnbWlkZGxlJ1xuICAgICAgICAgICAgLy8g6buY6K6k5qC55o2uIHRvcCDkvY3nva7liKTmlq3mmK/kuIrlr7npvZDov5jmmK/kuIvlr7npvZBcbiAgICAgICAgICAgIC8vIHRleHRCYXNlbGluZTogbnVsbFxuXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcblxuICAgICAgICAgICAgLy8g5qCH6aKY6L655qGG6aKc6ImyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyNjY2MnLFxuXG4gICAgICAgICAgICAvLyDmoIfpopjovrnmoYbnur/lrr3vvIzljZXkvY1weO+8jOm7mOiupOS4ujDvvIjml6DovrnmoYbvvIlcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAwLFxuXG4gICAgICAgICAgICAvLyDmoIfpopjlhoXovrnot53vvIzljZXkvY1weO+8jOm7mOiupOWQhOaWueWQkeWGhei+uei3neS4ujXvvIxcbiAgICAgICAgICAgIC8vIOaOpeWPl+aVsOe7hOWIhuWIq+iuvuWumuS4iuWPs+S4i+W3pui+uei3ne+8jOWQjGNzc1xuICAgICAgICAgICAgcGFkZGluZzogNSxcblxuICAgICAgICAgICAgLy8g5Li75Ymv5qCH6aKY57q15ZCR6Ze06ZqU77yM5Y2V5L2NcHjvvIzpu5jorqTkuLoxMO+8jFxuICAgICAgICAgICAgaXRlbUdhcDogMTAsXG4gICAgICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTgsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGRlcicsXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMzMzJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1YnRleHRTdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2FhYSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVmlld1xuICAgIGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ3RpdGxlJyxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICh0aXRsZU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgICAgIGlmICghdGl0bGVNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcblxuICAgICAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdGl0bGVNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgICAgICAgICB2YXIgc3VidGV4dFN0eWxlTW9kZWwgPSB0aXRsZU1vZGVsLmdldE1vZGVsKCdzdWJ0ZXh0U3R5bGUnKTtcblxuICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHRpdGxlTW9kZWwuZ2V0KCd0ZXh0QWxpZ24nKTtcbiAgICAgICAgICAgIHZhciB0ZXh0QmFzZWxpbmUgPSB0aXRsZU1vZGVsLmdldCgndGV4dEJhc2VsaW5lJyk7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aXRsZU1vZGVsLmdldCgndGV4dCcpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgejI6IDEwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dEVsLmdldEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgICAgICAgICB2YXIgc3ViVGV4dCA9IHRpdGxlTW9kZWwuZ2V0KCdzdWJ0ZXh0Jyk7XG4gICAgICAgICAgICB2YXIgc3ViVGV4dEVsID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogc3ViVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZvbnQ6IHN1YnRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogc3VidGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCksXG4gICAgICAgICAgICAgICAgICAgIHk6IHRleHRSZWN0LmhlaWdodCArIHRpdGxlTW9kZWwuZ2V0KCdpdGVtR2FwJyksXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHoyOiAxMFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBsaW5rID0gdGl0bGVNb2RlbC5nZXQoJ2xpbmsnKTtcbiAgICAgICAgICAgIHZhciBzdWJsaW5rID0gdGl0bGVNb2RlbC5nZXQoJ3N1YmxpbmsnKTtcblxuICAgICAgICAgICAgdGV4dEVsLnNpbGVudCA9ICFsaW5rO1xuICAgICAgICAgICAgc3ViVGV4dEVsLnNpbGVudCA9ICFzdWJsaW5rO1xuXG4gICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgIHRleHRFbC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKGxpbmssICdfJyArIHRpdGxlTW9kZWwuZ2V0KCd0YXJnZXQnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VibGluaykge1xuICAgICAgICAgICAgICAgIHN1YlRleHRFbC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKHN1YmxpbmssICdfJyArIHRpdGxlTW9kZWwuZ2V0KCdzdWJ0YXJnZXQnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLmFkZCh0ZXh0RWwpO1xuICAgICAgICAgICAgc3ViVGV4dCAmJiBncm91cC5hZGQoc3ViVGV4dEVsKTtcbiAgICAgICAgICAgIC8vIElmIG5vIHN1YlRleHQsIGJ1dCBhZGQgc3ViVGV4dEVsLCB0aGVyZSB3aWxsIGJlIGFuIGVtcHR5IGxpbmUuXG5cbiAgICAgICAgICAgIHZhciBncm91cFJlY3QgPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBsYXlvdXRPcHRpb24gPSB0aXRsZU1vZGVsLmdldEJveExheW91dFBhcmFtcygpO1xuICAgICAgICAgICAgbGF5b3V0T3B0aW9uLndpZHRoID0gZ3JvdXBSZWN0LndpZHRoO1xuICAgICAgICAgICAgbGF5b3V0T3B0aW9uLmhlaWdodCA9IGdyb3VwUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbGF5b3V0UmVjdCA9IGxheW91dC5nZXRMYXlvdXRSZWN0KFxuICAgICAgICAgICAgICAgIGxheW91dE9wdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgICAgICAgICAgICAgfSwgdGl0bGVNb2RlbC5nZXQoJ3BhZGRpbmcnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIEFkanVzdCB0ZXh0IGFsaWduIGJhc2VkIG9uIHBvc2l0aW9uXG4gICAgICAgICAgICBpZiAoIXRleHRBbGlnbikge1xuICAgICAgICAgICAgICAgIC8vIEFsaWduIGxlZnQgaWYgdGl0bGUgaXMgb24gdGhlIGxlZnQuIGNlbnRlciBhbmQgcmlnaHQgaXMgc2FtZVxuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IHRpdGxlTW9kZWwuZ2V0KCdsZWZ0JykgfHwgdGl0bGVNb2RlbC5nZXQoJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkanVzdCBsYXlvdXQgYnkgdGV4dCBhbGlnblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0UmVjdC54ICs9IGxheW91dFJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0UmVjdC54ICs9IGxheW91dFJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGV4dEJhc2VsaW5lKSB7XG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gdGl0bGVNb2RlbC5nZXQoJ3RvcCcpIHx8IHRpdGxlTW9kZWwuZ2V0KCdib3R0b20nKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dEJhc2VsaW5lID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHRCYXNlbGluZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0UmVjdC55ICs9IGxheW91dFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dFJlY3QueSArPSBsYXlvdXRSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lIHx8ICd0b3AnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncm91cC5hdHRyKCdwb3NpdGlvbicsIFtsYXlvdXRSZWN0LngsIGxheW91dFJlY3QueV0pO1xuICAgICAgICAgICAgdmFyIGFsaWduU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRCYXNlbGluZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRleHRFbC5zZXRTdHlsZShhbGlnblN0eWxlKTtcbiAgICAgICAgICAgIHN1YlRleHRFbC5zZXRTdHlsZShhbGlnblN0eWxlKTtcblxuICAgICAgICAgICAgLy8gUmVuZGVyIGJhY2tncm91bmRcbiAgICAgICAgICAgIC8vIEdldCBncm91cFJlY3QgYWdhaW4gYmVjYXVzZSB0ZXh0QWxpZ24gaGFzIGJlZW4gY2hhbmdlZFxuICAgICAgICAgICAgZ3JvdXBSZWN0ID0gZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IGxheW91dFJlY3QubWFyZ2luO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGl0bGVNb2RlbC5nZXRJdGVtU3R5bGUoWydjb2xvcicsICdvcGFjaXR5J10pO1xuICAgICAgICAgICAgc3R5bGUuZmlsbCA9IHRpdGxlTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZ3JvdXBSZWN0LnggLSBwYWRkaW5nWzNdLFxuICAgICAgICAgICAgICAgICAgICB5OiBncm91cFJlY3QueSAtIHBhZGRpbmdbMF0sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBncm91cFJlY3Qud2lkdGggKyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBncm91cFJlY3QuaGVpZ2h0ICsgcGFkZGluZ1swXSArIHBhZGRpbmdbMl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdChyZWN0KTtcblxuICAgICAgICAgICAgZ3JvdXAuYWRkKHJlY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG4iLCIvLyBGSVhNRSBCZXR0ZXIgd2F5IHRvIHBhY2sgZGF0YSBpbiBncmFwaGljIGVsZW1lbnRcblxuXG4gICAgcmVxdWlyZSgnLi90b29sdGlwL1Rvb2x0aXBNb2RlbCcpO1xuXG4gICAgcmVxdWlyZSgnLi90b29sdGlwL1Rvb2x0aXBWaWV3Jyk7XG5cbiAgICAvLyBTaG93IHRpcCBhY3Rpb25cbiAgICAvKipcbiAgICAgKiBAYWN0aW9uXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2VyaWVzSW5kZXhcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0YUluZGV4XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt4XVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeV1cbiAgICAgKi9cbiAgICByZXF1aXJlKCcuLi9lY2hhcnRzJykucmVnaXN0ZXJBY3Rpb24oXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdzaG93VGlwJyxcbiAgICAgICAgICAgIGV2ZW50OiAnc2hvd1RpcCcsXG4gICAgICAgICAgICB1cGRhdGU6ICd0b29sdGlwOm1hbnVhbGx5U2hvd1RpcCdcbiAgICAgICAgfSxcbiAgICAgICAgLy8gbm9vcFxuICAgICAgICBmdW5jdGlvbiAoKSB7fVxuICAgICk7XG4gICAgLy8gSGlkZSB0aXAgYWN0aW9uXG4gICAgcmVxdWlyZSgnLi4vZWNoYXJ0cycpLnJlZ2lzdGVyQWN0aW9uKFxuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnaGlkZVRpcCcsXG4gICAgICAgICAgICBldmVudDogJ2hpZGVUaXAnLFxuICAgICAgICAgICAgdXBkYXRlOiAndG9vbHRpcDptYW51YWxseUhpZGVUaXAnXG4gICAgICAgIH0sXG4gICAgICAgIC8vIG5vb3BcbiAgICAgICAgZnVuY3Rpb24gKCkge31cbiAgICApO1xuIiwiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcENvbnRlbnRcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIHpyQ29sb3IgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi90b29sL2NvbG9yJyk7XG4gICAgdmFyIGV2ZW50VXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZm9ybWF0Jyk7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgdG9DYW1lbENhc2UgPSBmb3JtYXRVdGlsLnRvQ2FtZWxDYXNlO1xuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xuXG4gICAgdmFyIHZlbmRvcnMgPSBbJycsICctd2Via2l0LScsICctbW96LScsICctby0nXTtcblxuICAgIHZhciBnQ3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO2JvcmRlci1zdHlsZTpzb2xpZDt3aGl0ZS1zcGFjZTpub3dyYXA7ei1pbmRleDo5OTk5OTk5Oyc7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZW1ibGVUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uQ3VydmUgPSAnY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpJztcbiAgICAgICAgdmFyIHRyYW5zaXRpb25UZXh0ID0gJ2xlZnQgJyArIGR1cmF0aW9uICsgJ3MgJyArIHRyYW5zaXRpb25DdXJ2ZSArICcsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJ3RvcCAnICsgZHVyYXRpb24gKyAncyAnICsgdHJhbnNpdGlvbkN1cnZlO1xuICAgICAgICByZXR1cm4genJVdGlsLm1hcCh2ZW5kb3JzLCBmdW5jdGlvbiAodmVuZG9yUHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gdmVuZG9yUHJlZml4ICsgJ3RyYW5zaXRpb246JyArIHRyYW5zaXRpb25UZXh0O1xuICAgICAgICB9KS5qb2luKCc7Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRleHRTdHlsZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlbWJsZUZvbnQodGV4dFN0eWxlTW9kZWwpIHtcbiAgICAgICAgdmFyIGNzc1RleHQgPSBbXTtcblxuICAgICAgICB2YXIgZm9udFNpemUgPSB0ZXh0U3R5bGVNb2RlbC5nZXQoJ2ZvbnRTaXplJyk7XG4gICAgICAgIHZhciBjb2xvciA9IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpO1xuXG4gICAgICAgIGNvbG9yICYmIGNzc1RleHQucHVzaCgnY29sb3I6JyArIGNvbG9yKTtcblxuICAgICAgICBjc3NUZXh0LnB1c2goJ2ZvbnQ6JyArIHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSk7XG5cbiAgICAgICAgZm9udFNpemUgJiZcbiAgICAgICAgICAgIGNzc1RleHQucHVzaCgnbGluZS1oZWlnaHQ6JyArIE1hdGgucm91bmQoZm9udFNpemUgKiAzIC8gMikgKyAncHgnKTtcblxuICAgICAgICBlYWNoKFsnZGVjb3JhdGlvbicsICdhbGlnbiddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHRleHRTdHlsZU1vZGVsLmdldChuYW1lKTtcbiAgICAgICAgICAgIHZhbCAmJiBjc3NUZXh0LnB1c2goJ3RleHQtJyArIG5hbWUgKyAnOicgKyB2YWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY3NzVGV4dC5qb2luKCc7Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRvb2x0aXBNb2RlbFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlbWJsZUNzc1RleHQodG9vbHRpcE1vZGVsKSB7XG5cbiAgICAgICAgdG9vbHRpcE1vZGVsID0gdG9vbHRpcE1vZGVsO1xuXG4gICAgICAgIHZhciBjc3NUZXh0ID0gW107XG5cbiAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3RyYW5zaXRpb25EdXJhdGlvbicpO1xuICAgICAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gdG9vbHRpcE1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IHRvb2x0aXBNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgICAgIHZhciBwYWRkaW5nID0gdG9vbHRpcE1vZGVsLmdldCgncGFkZGluZycpO1xuXG4gICAgICAgIC8vIEFuaW1hdGlvbiB0cmFuc2l0aW9uXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbiAmJlxuICAgICAgICAgICAgY3NzVGV4dC5wdXNoKGFzc2VtYmxlVHJhbnNpdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pKTtcblxuICAgICAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICBpZiAoZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIGNzc1RleHQucHVzaCgnYmFja2dyb3VuZC1Db2xvcjonICsgYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZvciBpZVxuICAgICAgICAgICAgICAgIGNzc1RleHQucHVzaChcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtQ29sb3I6IycgKyB6ckNvbG9yLnRvSGV4KGJhY2tncm91bmRDb2xvcilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNzc1RleHQucHVzaCgnZmlsdGVyOmFscGhhKG9wYWNpdHk9NzApJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCb3JkZXIgc3R5bGVcbiAgICAgICAgZWFjaChbJ3dpZHRoJywgJ2NvbG9yJywgJ3JhZGl1cyddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGJvcmRlck5hbWUgPSAnYm9yZGVyLScgKyBuYW1lO1xuICAgICAgICAgICAgdmFyIGNhbWVsQ2FzZSA9IHRvQ2FtZWxDYXNlKGJvcmRlck5hbWUpO1xuICAgICAgICAgICAgdmFyIHZhbCA9IHRvb2x0aXBNb2RlbC5nZXQoY2FtZWxDYXNlKTtcbiAgICAgICAgICAgIHZhbCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKGJvcmRlck5hbWUgKyAnOicgKyB2YWwgKyAobmFtZSA9PT0gJ2NvbG9yJyA/ICcnIDogJ3B4JykpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUZXh0IHN0eWxlXG4gICAgICAgIGNzc1RleHQucHVzaChhc3NlbWJsZUZvbnQodGV4dFN0eWxlTW9kZWwpKTtcblxuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIGlmIChwYWRkaW5nICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNzc1RleHQucHVzaCgncGFkZGluZzonICsgZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShwYWRkaW5nKS5qb2luKCdweCAnKSArICdweCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNzc1RleHQuam9pbignOycpICsgJzsnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwQ29udGVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRvb2x0aXBDb250ZW50KGNvbnRhaW5lciwgYXBpKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcblxuICAgICAgICB0aGlzLmVsID0gZWw7XG5cbiAgICAgICAgdGhpcy5feCA9IGFwaS5nZXRXaWR0aCgpIC8gMjtcbiAgICAgICAgdGhpcy5feSA9IGFwaS5nZXRIZWlnaHQoKSAvIDI7XG5cbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcblxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAgICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGlkZVRpbWVvdXQ7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBlbC5vbm1vdXNlZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjbGVhciB0aGUgdGltZW91dCBpbiBoaWRlTGF0ZXIgYW5kIGtlZXAgc2hvd2luZyB0b29sdGlwXG4gICAgICAgICAgICBpZiAoc2VsZi5lbnRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5faGlkZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHNlbGYuX3Nob3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5faW5Db250ZW50ID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgZWwub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuICAgICAgICAgICAgaWYgKCFzZWxmLmVudGVyYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0cmlnZ2VyIHpyZW5kZXIgZXZlbnQgdG8gYXZvaWQgbW91c2VcbiAgICAgICAgICAgICAgICAvLyBpbiBhbmQgb3V0IHNoYXBlIHRvbyBmcmVxdWVudGx5XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB6ci5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIGV2ZW50VXRpbC5ub3JtYWxpemVFdmVudChjb250YWluZXIsIGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuZGlzcGF0Y2goJ21vdXNlbW92ZScsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlbC5vbm1vdXNlbGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5lbnRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fc2hvdykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmhpZGVMYXRlcihzZWxmLl9oaWRlRGVsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuX2luQ29udGVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIFRvb2x0aXBDb250ZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogVG9vbHRpcENvbnRlbnQsXG5cbiAgICAgICAgZW50ZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgd2hlbiB0b29sdGlwIGlzIHJlbmRlcmVkXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG4gICAgICAgICAgICB2YXIgc3RsID0gY29udGFpbmVyLmN1cnJlbnRTdHlsZVxuICAgICAgICAgICAgICAgIHx8IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICAgICAgICAgIHZhciBkb21TdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcbiAgICAgICAgICAgIGlmIChkb21TdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBzdGwucG9zaXRpb24gIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgICAgICAgICBkb21TdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIaWRlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAvLyB0aGlzLmhpZGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93OiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faGlkZVRpbWVvdXQpO1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgICAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9IGdDc3NUZXh0ICsgYXNzZW1ibGVDc3NUZXh0KHRvb2x0aXBNb2RlbClcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxMTI1NTg3L2NzczMtdHJhbnNpdGlvbi1ub3Qtd29ya2luZy1pbi1jaHJvbWUtYW55bW9yZVxuICAgICAgICAgICAgICAgICsgJztsZWZ0OicgKyB0aGlzLl94ICsgJ3B4O3RvcDonICsgdGhpcy5feSArICdweDsnXG4gICAgICAgICAgICAgICAgKyAodG9vbHRpcE1vZGVsLmdldCgnZXh0cmFDc3NUZXh0JykgfHwgJycpO1xuXG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuaW5uZXJIVE1MID8gICdibG9jaycgOiAnbm9uZSc7XG5cbiAgICAgICAgICAgIHRoaXMuX3Nob3cgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBjb250ZW50ID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmVsLnN0eWxlO1xuICAgICAgICAgICAgc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgICAgICAgc3R5bGUudG9wID0geSArICdweCc7XG5cbiAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNob3dMYXRlcjogZnVuY3Rpb24gKClcblxuICAgICAgICBoaWRlTGF0ZXI6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvdyAmJiAhKHRoaXMuX2luQ29udGVudCAmJiB0aGlzLmVudGVyYWJsZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlRGVsYXkgPSB0aW1lO1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgc2hvdyBmYWxzZSB0byBhdm9pZCBpbnZva2UgaGlkZUxhdGVyIG11dGlwbGUgdGltZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlVGltZW91dCA9IHNldFRpbWVvdXQoenJVdGlsLmJpbmQodGhpcy5oaWRlLCB0aGlzKSwgdGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNTaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hvdztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvb2x0aXBDb250ZW50O1xuIiwiXG5cbiAgICByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ29tcG9uZW50TW9kZWwoe1xuXG4gICAgICAgIHR5cGU6ICd0b29sdGlwJyxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICB6bGV2ZWw6IDAsXG5cbiAgICAgICAgICAgIHo6IDgsXG5cbiAgICAgICAgICAgIHNob3c6IHRydWUsXG5cbiAgICAgICAgICAgIC8vIHRvb2x0aXDkuLvkvZPlhoXlrrlcbiAgICAgICAgICAgIHNob3dDb250ZW50OiB0cnVlLFxuXG4gICAgICAgICAgICAvLyDop6blj5HnsbvlnovvvIzpu5jorqTmlbDmja7op6blj5HvvIzop4HkuIvlm77vvIzlj6/pgInkuLrvvJonaXRlbScgwqYgJ2F4aXMnXG4gICAgICAgICAgICB0cmlnZ2VyOiAnaXRlbScsXG5cbiAgICAgICAgICAgIC8vIOinpuWPkeadoeS7tu+8jOaUr+aMgSAnY2xpY2snIHwgJ21vdXNlbW92ZScgfCAnbm9uZSdcbiAgICAgICAgICAgIHRyaWdnZXJPbjogJ21vdXNlbW92ZScsXG5cbiAgICAgICAgICAgIC8vIOaYr+WQpuawuOi/nOaYvuekuiBjb250ZW50XG4gICAgICAgICAgICBhbHdheXNTaG93Q29udGVudDogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIOS9jee9riB7QXJyYXl9IHwge0Z1bmN0aW9ufVxuICAgICAgICAgICAgLy8gcG9zaXRpb246IG51bGxcblxuICAgICAgICAgICAgLy8g5piv5ZCm57qm5p2fIGNvbnRlbnQg5ZyoIHZpZXdSZWN0IOS4reOAgum7mOiupCBmYWxzZSDmmK/kuLrkuoblhbzlrrnku6XliY3niYjmnKzjgIJcbiAgICAgICAgICAgIGNvbmZpbmU6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyDlhoXlrrnmoLzlvI/lmajvvJp7c3RyaW5nfe+8iFRlbXBsYXRl77yJIMKmIHtGdW5jdGlvbn1cbiAgICAgICAgICAgIC8vIGZvcm1hdHRlcjogbnVsbFxuXG4gICAgICAgICAgICBzaG93RGVsYXk6IDAsXG5cbiAgICAgICAgICAgIC8vIOmakOiXj+W7tui/n++8jOWNleS9jW1zXG4gICAgICAgICAgICBoaWRlRGVsYXk6IDEwMCxcblxuICAgICAgICAgICAgLy8g5Yqo55S75Y+Y5o2i5pe26Ze077yM5Y2V5L2Nc1xuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAwLjQsXG5cbiAgICAgICAgICAgIGVudGVyYWJsZTogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIOaPkOekuuiDjOaZr+minOiJsu+8jOm7mOiupOS4uumAj+aYjuW6puS4ujAuN+eahOm7keiJslxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSg1MCw1MCw1MCwwLjcpJyxcblxuICAgICAgICAgICAgLy8g5o+Q56S66L655qGG6aKc6ImyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyMzMzMnLFxuXG4gICAgICAgICAgICAvLyDmj5DnpLrovrnmoYblnIbop5LvvIzljZXkvY1weO+8jOm7mOiupOS4ujRcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogNCxcblxuICAgICAgICAgICAgLy8g5o+Q56S66L655qGG57q/5a6977yM5Y2V5L2NcHjvvIzpu5jorqTkuLow77yI5peg6L655qGG77yJXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMCxcblxuICAgICAgICAgICAgLy8g5o+Q56S65YaF6L656Led77yM5Y2V5L2NcHjvvIzpu5jorqTlkITmlrnlkJHlhoXovrnot53kuLo177yMXG4gICAgICAgICAgICAvLyDmjqXlj5fmlbDnu4TliIbliKvorr7lrprkuIrlj7PkuIvlt6bovrnot53vvIzlkIxjc3NcbiAgICAgICAgICAgIHBhZGRpbmc6IDUsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhIGNzcyB0ZXh0XG4gICAgICAgICAgICBleHRyYUNzc1RleHQ6ICcnLFxuXG4gICAgICAgICAgICAvLyDlnZDmoIfovbTmjIfnpLrlmajvvIzlnZDmoIfovbTop6blj5HmnInmlYhcbiAgICAgICAgICAgIGF4aXNQb2ludGVyOiB7XG4gICAgICAgICAgICAgICAgLy8g6buY6K6k5Li655u057q/XG4gICAgICAgICAgICAgICAgLy8g5Y+v6YCJ5Li677yaJ2xpbmUnIHwgJ3NoYWRvdycgfCAnY3Jvc3MnXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuXG4gICAgICAgICAgICAgICAgLy8gdHlwZSDkuLogbGluZSDnmoTml7blgJnmnInmlYjvvIzmjIflrpogdG9vbHRpcCBsaW5lIOaJgOWcqOeahOi9tO+8jOWPr+mAiVxuICAgICAgICAgICAgICAgIC8vIOWPr+mAiSAneCcgfCAneScgfCAnYW5nbGUnIHwgJ3JhZGl1cycgfCAnYXV0bydcbiAgICAgICAgICAgICAgICAvLyDpu5jorqQgJ2F1dG8n77yM5Lya6YCJ5oup57G75Z6L5Li6IGNhdGVvZ3J5IOeahOi9tO+8jOWvueS6juWPjOaVsOWAvOi9tO+8jOesm+WNoeWwlOWdkOagh+ezu+S8mum7mOiupOmAieaLqSB4IOi9tFxuICAgICAgICAgICAgICAgIC8vIOaegeWdkOagh+ezu+S8mum7mOiupOmAieaLqSBhbmdsZSDovbRcbiAgICAgICAgICAgICAgICBheGlzOiAnYXV0bycsXG5cbiAgICAgICAgICAgICAgICBhbmltYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDIwMCxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25FYXNpbmdVcGRhdGU6ICdleHBvbmVudGlhbE91dCcsXG5cbiAgICAgICAgICAgICAgICAvLyDnm7Tnur/mjIfnpLrlmajmoLflvI/orr7nva5cbiAgICAgICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjNTU1JyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgY3Jvc3NTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyM1NTUnLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Rhc2hlZCcsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBmb3JtYXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFN0eWxlOiB7fVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyDpmLTlvbHmjIfnpLrlmajmoLflvI/orr7nva5cbiAgICAgICAgICAgICAgICBzaGFkb3dTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMTUwLDE1MCwxNTAsMC4zKSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuIiwiXG5cbiAgICB2YXIgVG9vbHRpcENvbnRlbnQgPSByZXF1aXJlKCcuL1Rvb2x0aXBDb250ZW50Jyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2Zvcm1hdCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBwYXJzZVBlcmNlbnQgPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudDtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9Nb2RlbCcpO1xuXG4gICAgZnVuY3Rpb24gZGF0YUVxdWFsKGEsIGIpIHtcbiAgICAgICAgaWYgKCFhIHx8ICFiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvdW5kID0gbnVtYmVyVXRpbC5yb3VuZDtcbiAgICAgICAgcmV0dXJuIHJvdW5kKGFbMF0pID09PSByb3VuZChiWzBdKVxuICAgICAgICAgICAgJiYgcm91bmQoYVsxXSkgPT09IHJvdW5kKGJbMV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlTGluZVNoYXBlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4MTogeDEsXG4gICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICB4MjogeDIsXG4gICAgICAgICAgICB5MjogeTJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlUmVjdFNoYXBlKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlU2VjdG9yU2hhcGUoY3gsIGN5LCByMCwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgIHIwOiByMCxcbiAgICAgICAgICAgIHI6IHIsXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgZW5kQW5nbGU6IGVuZEFuZ2xlLFxuICAgICAgICAgICAgY2xvY2t3aXNlOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVmaXhUb29sdGlwUG9zaXRpb24oeCwgeSwgZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodCkge1xuICAgICAgICB2YXIgd2lkdGggPSBlbC5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIGdhcCA9IDIwO1xuXG4gICAgICAgIGlmICh4ICsgd2lkdGggKyBnYXAgPiB2aWV3V2lkdGgpIHtcbiAgICAgICAgICAgIHggLT0gd2lkdGggKyBnYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4ICs9IGdhcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSArIGhlaWdodCArIGdhcCA+IHZpZXdIZWlnaHQpIHtcbiAgICAgICAgICAgIHkgLT0gaGVpZ2h0ICsgZ2FwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeSArPSBnYXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maW5lVG9vbHRpcFBvc2l0aW9uKHgsIHksIGVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgeCA9IE1hdGgubWluKHggKyB3aWR0aCwgdmlld1dpZHRoKSAtIHdpZHRoO1xuICAgICAgICB5ID0gTWF0aC5taW4oeSArIGhlaWdodCwgdmlld0hlaWdodCkgLSBoZWlnaHQ7XG4gICAgICAgIHggPSBNYXRoLm1heCh4LCAwKTtcbiAgICAgICAgeSA9IE1hdGgubWF4KHksIDApO1xuXG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY1Rvb2x0aXBQb3NpdGlvbihwb3NpdGlvbiwgcmVjdCwgZG9tKSB7XG4gICAgICAgIHZhciBkb21XaWR0aCA9IGRvbS5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIGRvbUhlaWdodCA9IGRvbS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciBnYXAgPSA1O1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgdmFyIHJlY3RXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIHZhciByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZSc6XG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCAvIDIgLSBkb21XaWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgLyAyIC0gZG9tSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCAvIDIgLSBkb21XaWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSAtIGRvbUhlaWdodCAtIGdhcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCAvIDIgLSBkb21XaWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgKyBnYXA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54IC0gZG9tV2lkdGggLSBnYXA7XG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgLyAyIC0gZG9tSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoICsgZ2FwO1xuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0IC8gMiAtIGRvbUhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd8RnVuY3Rpb258QXJyYXkuPG51bWJlcj59IHBvc2l0aW9uRXhwclxuICAgICAqIEBwYXJhbSAge251bWJlcn0geCBNb3VzZSB4XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB5IE1vdXNlIHlcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjb25maW5lIFdoZXRoZXIgY29uZmluZSB0b29sdGlwIGNvbnRlbnQgaW4gdmlldyByZWN0LlxuICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBDb250ZW50fSBjb250ZW50XG4gICAgICogQHBhcmFtICB7T2JqZWN0fDxBcnJheS48T2JqZWN0Pn0gcGFyYW1zXG4gICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKHBvc2l0aW9uRXhwciwgeCwgeSwgY29uZmluZSwgY29udGVudCwgcGFyYW1zLCBlbCwgYXBpKSB7XG4gICAgICAgIHZhciB2aWV3V2lkdGggPSBhcGkuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIHZpZXdIZWlnaHQgPSBhcGkuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBlbCAmJiBlbC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuICAgICAgICBlbCAmJiByZWN0LmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSk7XG4gICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb25FeHByID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBDYWxsYmFjayBvZiBwb3NpdGlvbiBjYW4gYmUgYW4gYXJyYXkgb3IgYSBzdHJpbmcgc3BlY2lmeSB0aGUgcG9zaXRpb25cbiAgICAgICAgICAgIHBvc2l0aW9uRXhwciA9IHBvc2l0aW9uRXhwcihbeCwgeV0sIHBhcmFtcywgY29udGVudC5lbCwgcmVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXkocG9zaXRpb25FeHByKSkge1xuICAgICAgICAgICAgeCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkV4cHJbMF0sIHZpZXdXaWR0aCk7XG4gICAgICAgICAgICB5ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uRXhwclsxXSwgdmlld0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BlY2lmeSB0b29sdGlwIHBvc2l0aW9uIGJ5IHN0cmluZyAndG9wJyAnYm90dG9tJyAnbGVmdCcgJ3JpZ2h0JyBhcm91bmQgZ3JhcGhpYyBlbGVtZW50XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwb3NpdGlvbkV4cHIgPT09ICdzdHJpbmcnICYmIGVsKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gY2FsY1Rvb2x0aXBQb3NpdGlvbihcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIsIHJlY3QsIGNvbnRlbnQuZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gcG9zWzBdO1xuICAgICAgICAgICAgeSA9IHBvc1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSByZWZpeFRvb2x0aXBQb3NpdGlvbihcbiAgICAgICAgICAgICAgICB4LCB5LCBjb250ZW50LmVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gcG9zWzBdO1xuICAgICAgICAgICAgeSA9IHBvc1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maW5lKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gY29uZmluZVRvb2x0aXBQb3NpdGlvbihcbiAgICAgICAgICAgICAgICB4LCB5LCBjb250ZW50LmVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gcG9zWzBdO1xuICAgICAgICAgICAgeSA9IHBvc1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRlbnQubW92ZVRvKHgsIHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlmU2VyaWVzU3VwcG9ydEF4aXNUcmlnZ2VyKHNlcmllc01vZGVsKSB7XG4gICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgIHZhciB0cmlnZ2VyID0gc2VyaWVzTW9kZWwuZ2V0KCd0b29sdGlwLnRyaWdnZXInLCB0cnVlKTtcbiAgICAgICAgLy8gSWdub3JlIHNlcmllcyB1c2UgaXRlbSB0b29sdGlwIHRyaWdnZXIgYW5kIHNlcmllcyBjb29yZGluYXRlIHN5c3RlbSBpcyBub3QgY2FydGVzaWFuIG9yXG4gICAgICAgIHJldHVybiAhKCFjb29yZFN5c1xuICAgICAgICAgICAgfHwgKGNvb3JkU3lzLnR5cGUgIT09ICdjYXJ0ZXNpYW4yZCcgJiYgY29vcmRTeXMudHlwZSAhPT0gJ3BvbGFyJyAmJiBjb29yZFN5cy50eXBlICE9PSAnc2luZ2xlQXhpcycpXG4gICAgICAgICAgICB8fCB0cmlnZ2VyID09PSAnaXRlbScpO1xuICAgIH1cblxuICAgIHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRWaWV3KHtcblxuICAgICAgICB0eXBlOiAndG9vbHRpcCcsXG5cbiAgICAgICAgX2F4aXNQb2ludGVyczoge30sXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRvb2x0aXBDb250ZW50ID0gbmV3IFRvb2x0aXBDb250ZW50KGFwaS5nZXREb20oKSwgYXBpKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBDb250ZW50ID0gdG9vbHRpcENvbnRlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzZXRcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2F4aXNQb2ludGVycyA9IHt9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcE1vZGVsfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwTW9kZWwgPSB0b29sdGlwTW9kZWw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2VjTW9kZWwgPSBlY01vZGVsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9hcGkgPSBhcGk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2xhc3RIb3ZlciA9IHtcbiAgICAgICAgICAgICAgICAvLyBkYXRhXG4gICAgICAgICAgICAgICAgLy8gcGF5bG9hZEJhdGNoXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSB0aGlzLl90b29sdGlwQ29udGVudDtcbiAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LnVwZGF0ZSgpO1xuICAgICAgICAgICAgdG9vbHRpcENvbnRlbnQuZW50ZXJhYmxlID0gdG9vbHRpcE1vZGVsLmdldCgnZW50ZXJhYmxlJyk7XG4gICAgICAgICAgICB0aGlzLl9hbHdheXNTaG93Q29udGVudCA9IHRvb2x0aXBNb2RlbC5nZXQoJ2Fsd2F5c1Nob3dDb250ZW50Jyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBBcnJheT59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3Nlcmllc0dyb3VwQnlBeGlzID0gdGhpcy5fcHJlcGFyZUF4aXNUcmlnZ2VyRGF0YShcbiAgICAgICAgICAgICAgICB0b29sdGlwTW9kZWwsIGVjTW9kZWxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBjcm9zc1RleHQgPSB0aGlzLl9jcm9zc1RleHQ7XG4gICAgICAgICAgICBpZiAoY3Jvc3NUZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoY3Jvc3NUZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRyaWdnZXJPbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXJPbicpO1xuXG4gICAgICAgICAgICAvLyBUcnkgdG8ga2VlcCB0aGUgdG9vbHRpcCBzaG93IHdoZW4gcmVmcmVzaGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RYICE9IG51bGxcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9sYXN0WSAhPSBudWxsXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB1c2VyIGlzIHdpbGxpbmcgdG8gY29udHJvbCB0b29sdGlwIHRvdGFsbHkgdXNpbmcgQVBJLFxuICAgICAgICAgICAgICAgIC8vIHNlbGYubWFudWFsbHlTaG93VGlwKHt4LCB5fSkgbWlnaHQgY2F1c2UgdG9vbHRpcCBoaWRlLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIG5vdCBleHBlY3RlZC5cbiAgICAgICAgICAgICAgICAmJiB0cmlnZ2VyT24gIT09ICdub25lJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoVXBkYXRlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmcmVzaFVwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyB0aXAgbmV4dCB0aWNrIGFmdGVyIG90aGVyIGNoYXJ0cyBhcmUgcmVuZGVyZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBoaWdobGlnaHQgYWN0aW9uIGhhcyB3cm9uZyByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tYW51YWxseVNob3dUaXAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYuX2xhc3RYLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5fbGFzdFlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX2FwaS5nZXRacigpO1xuICAgICAgICAgICAgenIub2ZmKCdjbGljaycsIHRoaXMuX3RyeVNob3cpO1xuICAgICAgICAgICAgenIub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3VzZW1vdmUpO1xuICAgICAgICAgICAgenIub2ZmKCdtb3VzZW91dCcsIHRoaXMuX2hpZGUpO1xuICAgICAgICAgICAgenIub2ZmKCdnbG9iYWxvdXQnLCB0aGlzLl9oaWRlKTtcblxuICAgICAgICAgICAgaWYgKHRyaWdnZXJPbiA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgIHpyLm9uKCdjbGljaycsIHRoaXMuX3RyeVNob3csIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJpZ2dlck9uID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgICAgICAgICAgIHpyLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3VzZW1vdmUsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHpyLm9uKCdtb3VzZW91dCcsIHRoaXMuX2hpZGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHpyLm9uKCdnbG9iYWxvdXQnLCB0aGlzLl9oaWRlLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2UgdHJpZ2dlck9uIGlzICdub25lJywgd2hpY2ggZW5hYmxlIHVzZXJcbiAgICAgICAgICAgIC8vIHRvIGNvbnRyb2wgdG9vbHRpcCB0b3RhbGx5IHVzaW5nIEFQSS5cbiAgICAgICAgfSxcblxuICAgICAgICBfbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHNob3dEZWxheSA9IHRoaXMuX3Rvb2x0aXBNb2RlbC5nZXQoJ3Nob3dEZWxheScpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1lb3V0KTtcbiAgICAgICAgICAgIGlmIChzaG93RGVsYXkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fdHJ5U2hvdyhlKTtcbiAgICAgICAgICAgICAgICB9LCBzaG93RGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5U2hvdyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aXAgbWFudWFsbHkgYnlcbiAgICAgICAgICogZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgKiAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgICAgKiAgICAgeDogMTAsXG4gICAgICAgICAqICAgICB5OiAxMFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogT3JcbiAgICAgICAgICogZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgKiAgICAgIHR5cGU6ICdzaG93VGlwJyxcbiAgICAgICAgICogICAgICBzZXJpZXNJbmRleDogMCxcbiAgICAgICAgICogICAgICBkYXRhSW5kZXggb3IgZGF0YUluZGV4SW5zaWRlIG9yIG5hbWVcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICBUT0RPIEJhdGNoXG4gICAgICAgICAqL1xuICAgICAgICBtYW51YWxseVNob3dUaXA6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgLy8gRnJvbSBzZWxmXG4gICAgICAgICAgICBpZiAocGF5bG9hZC5mcm9tID09PSB0aGlzLnVpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9lY01vZGVsO1xuICAgICAgICAgICAgdmFyIHNlcmllc0luZGV4ID0gcGF5bG9hZC5zZXJpZXNJbmRleDtcbiAgICAgICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChzZXJpZXNJbmRleCk7XG4gICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuXG4gICAgICAgICAgICB2YXIgaXNUcmlnZ2VyQXhpcyA9IHRoaXMuX3Rvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXInKSA9PT0gJ2F4aXMnO1xuICAgICAgICAgICAgZnVuY3Rpb24gc2VyaWVzSGF2ZURhdGFPbkluZGV4KF9zZXJpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IF9zZXJpZXMuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgLy8gSGF2ZSBzaW5nbGUgZGF0YUluZGV4XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFJbmRleCAhPSBudWxsICYmICF6clV0aWwuaXNBcnJheShkYXRhSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICYmIGRhdGEuaGFzVmFsdWUoZGF0YUluZGV4KVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXlsb2FkLnggPT0gbnVsbCB8fCBwYXlsb2FkLnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1RyaWdnZXJBeGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgYW5vdGhlciBzZXJpZXMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJpZXNNb2RlbCAmJiAhc2VyaWVzSGF2ZURhdGFPbkluZGV4KHNlcmllc01vZGVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IHNlcmllcyBjYW4gdXNlIGF4aXMgdHJpZ2dlciBBbmQgZGF0YSBpcyBub3QgbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChfc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlmU2VyaWVzU3VwcG9ydEF4aXNUcmlnZ2VyKF9zZXJpZXMpICYmICFzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VyaWVzSGF2ZURhdGFPbkluZGV4KF9zZXJpZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbCA9IF9zZXJpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBmaXJzdCBzZXJpZXMgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwgPSBzZXJpZXNNb2RlbCB8fCBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleChkYXRhLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUluZGV4ID09IG51bGwgfHwgenJVdGlsLmlzQXJyYXkoZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN5O1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZ2V0IHRoZSBwb2ludCBpbiBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VyaWVzTW9kZWwuZ2V0VG9vbHRpcFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBzZXJpZXNNb2RlbC5nZXRUb29sdGlwUG9zaXRpb24oZGF0YUluZGV4KSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4ID0gcG9pbnRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjeSA9IHBvaW50WzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvb3JkU3lzICYmIGNvb3JkU3lzLmRhdGFUb1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBjb29yZFN5cy5kYXRhVG9Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmdldFZhbHVlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLm1hcChjb29yZFN5cy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzTW9kZWwuY29vcmREaW1Ub0RhdGFEaW0oZGltKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGRhdGFJbmRleCwgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeCA9IHBvaW50ICYmIHBvaW50WzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3kgPSBwb2ludCAmJiBwb2ludFsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGdyYXBoaWMgYm91bmRpbmcgcmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3ggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN4ICE9IG51bGwgJiYgY3kgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WDogY3gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gYXBpLmdldFpyKCkuaGFuZGxlci5maW5kSG92ZXIocGF5bG9hZC54LCBwYXlsb2FkLnkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyeVNob3coe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRYOiBwYXlsb2FkLngsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFk6IHBheWxvYWQueSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogZWwsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1hbnVhbGx5SGlkZVRpcDogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5mcm9tID09PSB0aGlzLnVpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faGlkZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9wcmVwYXJlQXhpc1RyaWdnZXJEYXRhOiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIGRhdGEgZm9yIGF4aXMgdHJpZ2dlclxuICAgICAgICAgICAgdmFyIHNlcmllc0dyb3VwQnlBeGlzID0ge307XG4gICAgICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlmU2VyaWVzU3VwcG9ydEF4aXNUcmlnZ2VyKHNlcmllc01vZGVsKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZUF4aXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBjYXJ0ZXNpYW4yZCwgcG9sYXIgYW5kIHNpbmdsZSBzdXBwb3J0IGF4aXMgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgYGF4aXNQb2ludGVyLmF4aXNgIGlzIG5vdCBiYXNlQXhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gYmFzZUF4aXMuZGltICsgYmFzZUF4aXMuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29vcmRTeXMudHlwZSA9PT0gJ3NpbmdsZUF4aXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGJhc2VBeGlzLmRpbSArIGJhc2VBeGlzLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBiYXNlQXhpcy5kaW0gKyBjb29yZFN5cy5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzR3JvdXBCeUF4aXNba2V5XSA9IHNlcmllc0dyb3VwQnlBeGlzW2tleV0gfHwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRTeXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNHcm91cEJ5QXhpc1trZXldLmNvb3JkU3lzLnB1c2goY29vcmRTeXMpO1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNHcm91cEJ5QXhpc1trZXldLnNlcmllcy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlcmllc0dyb3VwQnlBeGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtb3VzZW1vdmUgaGFuZGxlclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RyeVNob3c6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIHZhciB0b29sdGlwTW9kZWwgPSB0aGlzLl90b29sdGlwTW9kZWw7XG4gICAgICAgICAgICB2YXIgZ2xvYmFsVHJpZ2dlciA9IHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXInKTtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDtcbiAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG5cbiAgICAgICAgICAgIGlmICghdG9vbHRpcE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTYXZlIG1vdXNlIHgsIG1vdXNlIHkuIFNvIHdlIGNhbiB0cnkgdG8ga2VlcCBzaG93aW5nIHRoZSB0aXAgaWYgY2hhcnQgaXMgcmVmcmVzaGVkXG4gICAgICAgICAgICB0aGlzLl9sYXN0WCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RZID0gZS5vZmZzZXRZO1xuXG4gICAgICAgICAgICAvLyBBbHdheXMgc2hvdyBpdGVtIHRvb2x0aXAgaWYgbW91c2UgaXMgb24gdGhlIGVsZW1lbnQgd2l0aCBkYXRhSW5kZXhcbiAgICAgICAgICAgIGlmIChlbCAmJiBlbC5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBkYXRhTW9kZWwgaW4gZWxlbWVudCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIC8vIFVzZWQgd2hlbiBtb3VzZW92ZXIgb24gYSBlbGVtZW50IGxpa2UgbWFya1BvaW50IG9yIGVkZ2VcbiAgICAgICAgICAgICAgICAvLyBJbiB3aGljaCBjYXNlLCB0aGUgZGF0YSBpcyBub3QgbWFpbiBkYXRhIGluIHNlcmllcy5cbiAgICAgICAgICAgICAgICB2YXIgZGF0YU1vZGVsID0gZWwuZGF0YU1vZGVsIHx8IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChlbC5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGVsLmRhdGFJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGRhdGFNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgLy8gU2VyaWVzIG9yIHNpbmdsZSBkYXRhIG1heSB1c2UgaXRlbSB0cmlnZ2VyIHdoZW4gZ2xvYmFsIGlzIGF4aXMgdHJpZ2dlclxuICAgICAgICAgICAgICAgIGlmICgoaXRlbU1vZGVsLmdldCgndG9vbHRpcC50cmlnZ2VyJykgfHwgZ2xvYmFsVHJpZ2dlcikgPT09ICdheGlzJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93QXhpc1Rvb2x0aXAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRpY2tldFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aWNrZXQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZWl0aGVyIHNpbmdsZSBkYXRhIG9yIHNlcmllcyB1c2UgaXRlbSB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVBeGlzUG9pbnRlcigpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBsYXN0IGhvdmVyIGFuZCBkaXNwYXRjaCBkb3ducGxheSBhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRMYXN0SG92ZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93SXRlbVRvb2x0aXBDb250ZW50KGRhdGFNb2RlbCwgZGF0YUluZGV4LCBlbC5kYXRhVHlwZSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLnVpZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YUluZGV4SW5zaWRlOiBkYXRhSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFJbmRleDogZGF0YS5nZXRSYXdJbmRleChkYXRhSW5kZXgpLCAvLyBleHBvc2UgdG8gdXNlci5cbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGVsLnNlcmllc0luZGV4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUb29sdGlwIHByb3ZpZGVkIGRpcmVjdGx5LiBMaWtlIGxlZ2VuZFxuICAgICAgICAgICAgZWxzZSBpZiAoZWwgJiYgZWwudG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIHZhciB0b29sdGlwT3B0ID0gZWwudG9vbHRpcDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvb2x0aXBPcHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gdG9vbHRpcE9wdDtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcE9wdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXhlZCBmb3JtYXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogY29udGVudFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3ViVG9vbHRpcE1vZGVsID0gbmV3IE1vZGVsKHRvb2x0aXBPcHQsIHRvb2x0aXBNb2RlbCk7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRIdG1sID0gc3ViVG9vbHRpcE1vZGVsLmdldCgnY29udGVudCcpO1xuICAgICAgICAgICAgICAgIHZhciBhc3luY1RpY2tldCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXBDb250ZW50KFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICBzdWJUb29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBzdWJUb29sdGlwTW9kZWwuZ2V0KCdmb3JtYXR0ZXJQYXJhbXMnKSB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNUaWNrZXQsIGUub2Zmc2V0WCwgZS5vZmZzZXRZLCBlLnBvc2l0aW9uLCBlbCwgYXBpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChnbG9iYWxUcmlnZ2VyID09PSAnaXRlbScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHNob3cgYXhpcyB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dBeGlzVG9vbHRpcCh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFjdGlvbiBvZiBjcm9zcyBwb2ludGVyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgcG9pbnRlciB0eXBlcyB3aWxsIHRyaWdnZXIgYWN0aW9uIGluIF9kaXNwYXRjaEFuZFNob3dTZXJpZXNUb29sdGlwQ29udGVudCBtZXRob2RcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcE1vZGVsLmdldCgnYXhpc1BvaW50ZXIudHlwZScpID09PSAnY3Jvc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLnVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGUub2Zmc2V0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGUub2Zmc2V0WVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdG9vbHRpcCBvbiBheGlzXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcE1vZGVsfSB0b29sdGlwTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zaG93QXhpc1Rvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGUpIHtcbiAgICAgICAgICAgIHZhciBheGlzUG9pbnRlck1vZGVsID0gdG9vbHRpcE1vZGVsLmdldE1vZGVsKCdheGlzUG9pbnRlcicpO1xuICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVyVHlwZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJyk7XG5cbiAgICAgICAgICAgIGlmIChheGlzUG9pbnRlclR5cGUgPT09ICdjcm9zcycpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgZWwuZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KGVsLnNlcmllc0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGVsLmRhdGFJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvd0l0ZW1Ub29sdGlwQ29udGVudChzZXJpZXNNb2RlbCwgZGF0YUluZGV4LCBlbC5kYXRhVHlwZSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zaG93QXhpc1BvaW50ZXIoKTtcbiAgICAgICAgICAgIHZhciBhbGxOb3RTaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuX3Nlcmllc0dyb3VwQnlBeGlzLCBmdW5jdGlvbiAoc2VyaWVzQ29vcmRTeXNTYW1lQXhpcykge1xuICAgICAgICAgICAgICAgIC8vIFRyeSBzaG93IHRoZSBheGlzIHBvaW50ZXJcbiAgICAgICAgICAgICAgICB2YXIgYWxsQ29vcmRTeXMgPSBzZXJpZXNDb29yZFN5c1NhbWVBeGlzLmNvb3JkU3lzO1xuICAgICAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IGFsbENvb3JkU3lzWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgbW91c2UgcG9zaXRpb24gaXMgbm90IGluIHRoZSBncmlkIG9yIHBvbGFyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gW2Uub2Zmc2V0WCwgZS5vZmZzZXRZXTtcblxuICAgICAgICAgICAgICAgIGlmICghY29vcmRTeXMuY29udGFpblBvaW50KHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIaWRlIGF4aXMgcG9pbnRlclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlQXhpc1BvaW50ZXIoY29vcmRTeXMubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhbGxOb3RTaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHBvaW50IGlzIGRpc2NyZXRlIG9uIGNhdGVvZ3J5IGF4aXNcbiAgICAgICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY29vcmRTeXMucG9pbnRUb0RhdGEocG9pbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc1R5cGUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnYXhpcycpO1xuICAgICAgICAgICAgICAgIGlmIChheGlzVHlwZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNUeXBlID0gYmFzZUF4aXMuZGltO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChiYXNlQXhpcy5pc0JsYW5rKCkgfHwgenJVdGlsLmVxTmFOKHBvaW50WzBdKSB8fCB6clV0aWwuZXFOYU4ocG9pbnRbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVBeGlzUG9pbnRlcihjb29yZFN5cy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50Tm90Q2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RIb3ZlciA9IHRoaXMuX2xhc3RIb3ZlcjtcbiAgICAgICAgICAgICAgICBpZiAoYXhpc1BvaW50ZXJUeXBlID09PSAnY3Jvc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGhvdmVyIGRhdGEgbm90IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libGUgd2hlbiB0d28gYXhlcyBhcmUgYWxsIGNhdGVnb3J5XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhRXF1YWwobGFzdEhvdmVyLmRhdGEsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudE5vdENoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdEhvdmVyLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWxJbmRleCA9IHpyVXRpbC5pbmRleE9mKGRpbWVuc2lvbnMsIGF4aXNUeXBlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBob3ZlciBkYXRhIG5vdCBjaGFuZ2VkIG9uIHRoZSBheGlzIGRpbWVuc2lvblxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEhvdmVyLmRhdGEgPT09IHZhbHVlW3ZhbEluZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudE5vdENoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdEhvdmVyLmRhdGEgPSB2YWx1ZVt2YWxJbmRleF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGVuYWJsZUFuaW1hdGlvbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ2FuaW1hdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgJiYgIWNvbnRlbnROb3RDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvd0NhcnRlc2lhblBvaW50ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzUG9pbnRlck1vZGVsLCBjb29yZFN5cywgYXhpc1R5cGUsIHBvaW50LCBlbmFibGVBbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJyAmJiAhY29udGVudE5vdENoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93UG9sYXJQb2ludGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc1BvaW50ZXJNb2RlbCwgY29vcmRTeXMsIGF4aXNUeXBlLCBwb2ludCwgZW5hYmxlQW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvb3JkU3lzLnR5cGUgPT09ICdzaW5nbGVBeGlzJyAmJiAhY29udGVudE5vdENoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93U2luZ2xlUG9pbnRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNQb2ludGVyTW9kZWwsIGNvb3JkU3lzLCBheGlzVHlwZSwgcG9pbnQsIGVuYWJsZUFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChheGlzUG9pbnRlclR5cGUgIT09ICdjcm9zcycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hBbmRTaG93U2VyaWVzVG9vbHRpcENvbnRlbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZFN5cywgc2VyaWVzQ29vcmRTeXNTYW1lQXhpcy5zZXJpZXMsIHBvaW50LCB2YWx1ZSwgY29udGVudE5vdENoYW5nZSwgZS5wb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3Rvb2x0aXBNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVBeGlzUG9pbnRlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsTm90U2hvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0b29sdGlwIG9uIGF4aXMgb2YgY2FydGVzaWFuIGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gYXhpc1BvaW50ZXJNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRH0gY2FydGVzaWFuc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXhpc1R5cGVcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcG9pbnRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zaG93Q2FydGVzaWFuUG9pbnRlcjogZnVuY3Rpb24gKGF4aXNQb2ludGVyTW9kZWwsIGNhcnRlc2lhbiwgYXhpc1R5cGUsIHBvaW50LCBlbmFibGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVyVHlwZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJyk7XG4gICAgICAgICAgICB2YXIgYmFzZUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgICAgIHZhciBtb3ZlQW5pbWF0aW9uID0gZW5hYmxlQW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgJiYgYXhpc1BvaW50ZXJUeXBlICE9PSAnY3Jvc3MnXG4gICAgICAgICAgICAgICAgJiYgYmFzZUF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5J1xuICAgICAgICAgICAgICAgICYmIGJhc2VBeGlzLmdldEJhbmRXaWR0aCgpID4gMjA7XG5cbiAgICAgICAgICAgIGlmIChheGlzUG9pbnRlclR5cGUgPT09ICdjcm9zcycpIHtcbiAgICAgICAgICAgICAgICBtb3ZlR3JpZExpbmUoJ3gnLCBwb2ludCwgY2FydGVzaWFuLmdldEF4aXMoJ3knKS5nZXRHbG9iYWxFeHRlbnQoKSk7XG4gICAgICAgICAgICAgICAgbW92ZUdyaWRMaW5lKCd5JywgcG9pbnQsIGNhcnRlc2lhbi5nZXRBeGlzKCd4JykuZ2V0R2xvYmFsRXh0ZW50KCkpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ3Jvc3NUZXh0KGNhcnRlc2lhbiwgcG9pbnQsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyQXhpcyA9IGNhcnRlc2lhbi5nZXRBeGlzKGF4aXNUeXBlID09PSAneCcgPyAneScgOiAneCcpO1xuICAgICAgICAgICAgICAgIHZhciBvdGhlckV4dGVudCA9IG90aGVyQXhpcy5nZXRHbG9iYWxFeHRlbnQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChjYXJ0ZXNpYW4udHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICAgICAgICAgICAgICAoYXhpc1BvaW50ZXJUeXBlID09PSAnbGluZScgPyBtb3ZlR3JpZExpbmUgOiBtb3ZlR3JpZFNoYWRvdykoXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzVHlwZSwgcG9pbnQsIG90aGVyRXh0ZW50XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBpbm5lclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBtb3ZlR3JpZExpbmUoYXhpc1R5cGUsIHBvaW50LCBvdGhlckV4dGVudCkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTaGFwZSA9IGF4aXNUeXBlID09PSAneCdcbiAgICAgICAgICAgICAgICAgICAgPyBtYWtlTGluZVNoYXBlKHBvaW50WzBdLCBvdGhlckV4dGVudFswXSwgcG9pbnRbMF0sIG90aGVyRXh0ZW50WzFdKVxuICAgICAgICAgICAgICAgICAgICA6IG1ha2VMaW5lU2hhcGUob3RoZXJFeHRlbnRbMF0sIHBvaW50WzFdLCBvdGhlckV4dGVudFsxXSwgcG9pbnRbMV0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ZXJFbCA9IHNlbGYuX2dldFBvaW50ZXJFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICBjYXJ0ZXNpYW4sIGF4aXNQb2ludGVyTW9kZWwsIGF4aXNUeXBlLCB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSh7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB0YXJnZXRTaGFwZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHBvaW50ZXJFbC5zdHlsZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbW92ZUFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICA/IGdyYXBoaWMudXBkYXRlUHJvcHMocG9pbnRlckVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogdGFyZ2V0U2hhcGVcbiAgICAgICAgICAgICAgICAgICAgfSwgYXhpc1BvaW50ZXJNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgOiAgcG9pbnRlckVsLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHRhcmdldFNoYXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBpbm5lclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBtb3ZlR3JpZFNoYWRvdyhheGlzVHlwZSwgcG9pbnQsIG90aGVyRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QXhpcyhheGlzVHlwZSk7XG4gICAgICAgICAgICAgICAgdmFyIGJhbmRXaWR0aCA9IGF4aXMuZ2V0QmFuZFdpZHRoKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNwYW4gPSBvdGhlckV4dGVudFsxXSAtIG90aGVyRXh0ZW50WzBdO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTaGFwZSA9IGF4aXNUeXBlID09PSAneCdcbiAgICAgICAgICAgICAgICAgICAgPyBtYWtlUmVjdFNoYXBlKHBvaW50WzBdIC0gYmFuZFdpZHRoIC8gMiwgb3RoZXJFeHRlbnRbMF0sIGJhbmRXaWR0aCwgc3BhbilcbiAgICAgICAgICAgICAgICAgICAgOiBtYWtlUmVjdFNoYXBlKG90aGVyRXh0ZW50WzBdLCBwb2ludFsxXSAtIGJhbmRXaWR0aCAvIDIsIHNwYW4sIGJhbmRXaWR0aCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRlckVsID0gc2VsZi5fZ2V0UG9pbnRlckVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIGNhcnRlc2lhbiwgYXhpc1BvaW50ZXJNb2RlbCwgYXhpc1R5cGUsIHRhcmdldFNoYXBlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBtb3ZlQW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2ludGVyRWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgICAgICAgICB9LCBheGlzUG9pbnRlck1vZGVsKVxuICAgICAgICAgICAgICAgICAgICA6ICBwb2ludGVyRWwuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogdGFyZ2V0U2hhcGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Nob3dTaW5nbGVQb2ludGVyOiBmdW5jdGlvbiAoYXhpc1BvaW50ZXJNb2RlbCwgc2luZ2xlLCBheGlzVHlwZSwgcG9pbnQsIGVuYWJsZUFuaW1hdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVyVHlwZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJyk7XG4gICAgICAgICAgICB2YXIgbW92ZUFuaW1hdGlvbiA9XG4gICAgICAgICAgICAgICAgZW5hYmxlQW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgJiYgYXhpc1BvaW50ZXJUeXBlICE9PSAnY3Jvc3MnXG4gICAgICAgICAgICAgICAgJiYgc2luZ2xlLmdldEJhc2VBeGlzKCkudHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgICAgICAgICAgIHZhciByZWN0ID0gc2luZ2xlLmdldFJlY3QoKTtcbiAgICAgICAgICAgIHZhciBvdGhlckV4dGVudCA9IFtyZWN0LnksIHJlY3QueSArIHJlY3QuaGVpZ2h0XTtcblxuICAgICAgICAgICAgbW92ZVNpbmdsZUxpbmUoYXhpc1R5cGUsIHBvaW50LCBvdGhlckV4dGVudCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGlubmVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1vdmVTaW5nbGVMaW5lKGF4aXNUeXBlLCBwb2ludCwgb3RoZXJFeHRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IHNpbmdsZS5nZXRBeGlzKCk7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWVudCA9IGF4aXMub3JpZW50O1xuXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFNoYXBlID0gb3JpZW50ID09PSAnaG9yaXpvbnRhbCdcbiAgICAgICAgICAgICAgICAgICAgPyBtYWtlTGluZVNoYXBlKHBvaW50WzBdLCBvdGhlckV4dGVudFswXSwgcG9pbnRbMF0sIG90aGVyRXh0ZW50WzFdKVxuICAgICAgICAgICAgICAgICAgICA6IG1ha2VMaW5lU2hhcGUob3RoZXJFeHRlbnRbMF0sIHBvaW50WzFdLCBvdGhlckV4dGVudFsxXSwgcG9pbnRbMV0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ZXJFbCA9IHNlbGYuX2dldFBvaW50ZXJFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICBzaW5nbGUsIGF4aXNQb2ludGVyTW9kZWwsIGF4aXNUeXBlLCB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbW92ZUFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICA/IGdyYXBoaWMudXBkYXRlUHJvcHMocG9pbnRlckVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogdGFyZ2V0U2hhcGVcbiAgICAgICAgICAgICAgICAgICAgfSwgYXhpc1BvaW50ZXJNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgOiAgcG9pbnRlckVsLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHRhcmdldFNoYXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdG9vbHRpcCBvbiBheGlzIG9mIHBvbGFyIGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gYXhpc1BvaW50ZXJNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9jb29yZC9wb2xhci9Qb2xhcj59IHBvbGFyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBheGlzVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgX3Nob3dQb2xhclBvaW50ZXI6IGZ1bmN0aW9uIChheGlzUG9pbnRlck1vZGVsLCBwb2xhciwgYXhpc1R5cGUsIHBvaW50LCBlbmFibGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVyVHlwZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJyk7XG5cbiAgICAgICAgICAgIHZhciBhbmdsZUF4aXMgPSBwb2xhci5nZXRBbmdsZUF4aXMoKTtcbiAgICAgICAgICAgIHZhciByYWRpdXNBeGlzID0gcG9sYXIuZ2V0UmFkaXVzQXhpcygpO1xuXG4gICAgICAgICAgICB2YXIgbW92ZUFuaW1hdGlvbiA9IGVuYWJsZUFuaW1hdGlvblxuICAgICAgICAgICAgICAgICYmIGF4aXNQb2ludGVyVHlwZSAhPT0gJ2Nyb3NzJ1xuICAgICAgICAgICAgICAgICYmIHBvbGFyLmdldEJhc2VBeGlzKCkudHlwZSA9PT0gJ2NhdGVnb3J5JztcblxuICAgICAgICAgICAgaWYgKGF4aXNQb2ludGVyVHlwZSA9PT0gJ2Nyb3NzJykge1xuICAgICAgICAgICAgICAgIG1vdmVQb2xhckxpbmUoJ2FuZ2xlJywgcG9pbnQsIHJhZGl1c0F4aXMuZ2V0RXh0ZW50KCkpO1xuICAgICAgICAgICAgICAgIG1vdmVQb2xhckxpbmUoJ3JhZGl1cycsIHBvaW50LCBhbmdsZUF4aXMuZ2V0RXh0ZW50KCkpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ3Jvc3NUZXh0KHBvbGFyLCBwb2ludCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJBeGlzID0gcG9sYXIuZ2V0QXhpcyhheGlzVHlwZSA9PT0gJ3JhZGl1cycgPyAnYW5nbGUnIDogJ3JhZGl1cycpO1xuICAgICAgICAgICAgICAgIHZhciBvdGhlckV4dGVudCA9IG90aGVyQXhpcy5nZXRFeHRlbnQoKTtcblxuICAgICAgICAgICAgICAgIChheGlzUG9pbnRlclR5cGUgPT09ICdsaW5lJyA/IG1vdmVQb2xhckxpbmUgOiBtb3ZlUG9sYXJTaGFkb3cpKFxuICAgICAgICAgICAgICAgICAgICBheGlzVHlwZSwgcG9pbnQsIG90aGVyRXh0ZW50XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGlubmVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1vdmVQb2xhckxpbmUoYXhpc1R5cGUsIHBvaW50LCBvdGhlckV4dGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBtb3VzZUNvb3JkID0gcG9sYXIucG9pbnRUb0Nvb3JkKHBvaW50KTtcblxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTaGFwZTtcblxuICAgICAgICAgICAgICAgIGlmIChheGlzVHlwZSA9PT0gJ2FuZ2xlJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcDEgPSBwb2xhci5jb29yZFRvUG9pbnQoW290aGVyRXh0ZW50WzBdLCBtb3VzZUNvb3JkWzFdXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMiA9IHBvbGFyLmNvb3JkVG9Qb2ludChbb3RoZXJFeHRlbnRbMV0sIG1vdXNlQ29vcmRbMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2hhcGUgPSBtYWtlTGluZVNoYXBlKHAxWzBdLCBwMVsxXSwgcDJbMF0sIHAyWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNoYXBlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3g6IHBvbGFyLmN4LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHBvbGFyLmN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcjogbW91c2VDb29yZFswXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwb2ludGVyRWwgPSBzZWxmLl9nZXRQb2ludGVyRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgcG9sYXIsIGF4aXNQb2ludGVyTW9kZWwsIGF4aXNUeXBlLCB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBtb3ZlQW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2ludGVyRWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgICAgICAgICB9LCBheGlzUG9pbnRlck1vZGVsKVxuICAgICAgICAgICAgICAgICAgICA6ICBwb2ludGVyRWwuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogdGFyZ2V0U2hhcGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGlubmVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1vdmVQb2xhclNoYWRvdyhheGlzVHlwZSwgcG9pbnQsIG90aGVyRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXMgPSBwb2xhci5nZXRBeGlzKGF4aXNUeXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgYmFuZFdpZHRoID0gYXhpcy5nZXRCYW5kV2lkdGgoKTtcblxuICAgICAgICAgICAgICAgIHZhciBtb3VzZUNvb3JkID0gcG9sYXIucG9pbnRUb0Nvb3JkKHBvaW50KTtcblxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTaGFwZTtcblxuICAgICAgICAgICAgICAgIHZhciByYWRpYW4gPSBNYXRoLlBJIC8gMTgwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGF4aXNUeXBlID09PSAnYW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNoYXBlID0gbWFrZVNlY3RvclNoYXBlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9sYXIuY3gsIHBvbGFyLmN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJFeHRlbnRbMF0sIG90aGVyRXh0ZW50WzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gRUNoYXJ0cyB5IGlzIG5lZ2F0aXZlIGlmIGFuZ2xlIGlzIHBvc2l0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAoLW1vdXNlQ29vcmRbMV0gLSBiYW5kV2lkdGggLyAyKSAqIHJhZGlhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICgtbW91c2VDb29yZFsxXSArIGJhbmRXaWR0aCAvIDIpICogcmFkaWFuXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTaGFwZSA9IG1ha2VTZWN0b3JTaGFwZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbGFyLmN4LCBwb2xhci5jeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlQ29vcmRbMF0gLSBiYW5kV2lkdGggLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VDb29yZFswXSArIGJhbmRXaWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLCBNYXRoLlBJICogMlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwb2ludGVyRWwgPSBzZWxmLl9nZXRQb2ludGVyRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgcG9sYXIsIGF4aXNQb2ludGVyTW9kZWwsIGF4aXNUeXBlLCB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbW92ZUFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICA/IGdyYXBoaWMudXBkYXRlUHJvcHMocG9pbnRlckVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogdGFyZ2V0U2hhcGVcbiAgICAgICAgICAgICAgICAgICAgfSwgYXhpc1BvaW50ZXJNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgOiAgcG9pbnRlckVsLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHRhcmdldFNoYXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVDcm9zc1RleHQ6IGZ1bmN0aW9uIChjb29yZFN5cywgcG9pbnQsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBjcm9zc1N0eWxlTW9kZWwgPSBheGlzUG9pbnRlck1vZGVsLmdldE1vZGVsKCdjcm9zc1N0eWxlJyk7XG4gICAgICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBjcm9zc1N0eWxlTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuXG4gICAgICAgICAgICB2YXIgdG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2Nyb3NzVGV4dDtcbiAgICAgICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0aGlzLl9jcm9zc1RleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246ICdib3R0b20nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZCh0ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29vcmRTeXMucG9pbnRUb0RhdGEocG9pbnQpO1xuXG4gICAgICAgICAgICB2YXIgZGltcyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7XG4gICAgICAgICAgICB2YWx1ZSA9IHpyVXRpbC5tYXAodmFsdWUsIGZ1bmN0aW9uICh2YWwsIGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBheGlzID0gY29vcmRTeXMuZ2V0QXhpcyhkaW1zW2lkeF0pO1xuICAgICAgICAgICAgICAgIGlmIChheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgfHwgYXhpcy50eXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gYXhpcy5zY2FsZS5nZXRMYWJlbCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZm9ybWF0VXRpbC5hZGRDb21tYXMoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwudG9GaXhlZChheGlzLmdldFBpeGVsUHJlY2lzaW9uKCkpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGV4dC5zZXRTdHlsZSh7XG4gICAgICAgICAgICAgICAgZmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCkgfHwgY3Jvc3NTdHlsZU1vZGVsLmdldCgnY29sb3InKSxcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgICAgIHRleHQ6IHZhbHVlLmpvaW4oJywgJyksXG4gICAgICAgICAgICAgICAgeDogcG9pbnRbMF0gKyA1LFxuICAgICAgICAgICAgICAgIHk6IHBvaW50WzFdIC0gNVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0ZXh0LnogPSB0b29sdGlwTW9kZWwuZ2V0KCd6Jyk7XG4gICAgICAgICAgICB0ZXh0LnpsZXZlbCA9IHRvb2x0aXBNb2RlbC5nZXQoJ3psZXZlbCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRQb2ludGVyRWxlbWVudDogZnVuY3Rpb24gKGNvb3JkU3lzLCBwb2ludGVyTW9kZWwsIGF4aXNUeXBlLCBpbml0U2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB0b29sdGlwTW9kZWwgPSB0aGlzLl90b29sdGlwTW9kZWw7XG4gICAgICAgICAgICB2YXIgeiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3onKTtcbiAgICAgICAgICAgIHZhciB6bGV2ZWwgPSB0b29sdGlwTW9kZWwuZ2V0KCd6bGV2ZWwnKTtcbiAgICAgICAgICAgIHZhciBheGlzUG9pbnRlcnMgPSB0aGlzLl9heGlzUG9pbnRlcnM7XG4gICAgICAgICAgICB2YXIgY29vcmRTeXNOYW1lID0gY29vcmRTeXMubmFtZTtcbiAgICAgICAgICAgIGF4aXNQb2ludGVyc1tjb29yZFN5c05hbWVdID0gYXhpc1BvaW50ZXJzW2Nvb3JkU3lzTmFtZV0gfHwge307XG4gICAgICAgICAgICBpZiAoYXhpc1BvaW50ZXJzW2Nvb3JkU3lzTmFtZV1bYXhpc1R5cGVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF4aXNQb2ludGVyc1tjb29yZFN5c05hbWVdW2F4aXNUeXBlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGlmIG5vdCBleGlzdHNcbiAgICAgICAgICAgIHZhciBwb2ludGVyVHlwZSA9IHBvaW50ZXJNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgICAgIHZhciBzdHlsZU1vZGVsID0gcG9pbnRlck1vZGVsLmdldE1vZGVsKHBvaW50ZXJUeXBlICsgJ1N0eWxlJyk7XG4gICAgICAgICAgICB2YXIgaXNTaGFkb3cgPSBwb2ludGVyVHlwZSA9PT0gJ3NoYWRvdyc7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZU1vZGVsW2lzU2hhZG93ID8gJ2dldEFyZWFTdHlsZScgOiAnZ2V0TGluZVN0eWxlJ10oKTtcblxuICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJ1xuICAgICAgICAgICAgICAgID8gKGlzU2hhZG93ID8gJ1NlY3RvcicgOiAoYXhpc1R5cGUgPT09ICdyYWRpdXMnID8gJ0NpcmNsZScgOiAnTGluZScpKVxuICAgICAgICAgICAgICAgIDogKGlzU2hhZG93ID8gJ1JlY3QnIDogJ0xpbmUnKTtcblxuICAgICAgICAgICAgaXNTaGFkb3cgPyAoc3R5bGUuc3Ryb2tlID0gbnVsbCkgOiAoc3R5bGUuZmlsbCA9IG51bGwpO1xuXG4gICAgICAgICAgICB2YXIgZWwgPSBheGlzUG9pbnRlcnNbY29vcmRTeXNOYW1lXVtheGlzVHlwZV0gPSBuZXcgZ3JhcGhpY1tlbGVtZW50VHlwZV0oe1xuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICB6OiB6LFxuICAgICAgICAgICAgICAgIHpsZXZlbDogemxldmVsLFxuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaGFwZTogaW5pdFNoYXBlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaCBhY3Rpb25zIGFuZCBzaG93IHRvb2x0aXAgb24gc2VyaWVzXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59IHNlcmllc0xpc3RcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcG9pbnRcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBjb250ZW50Tm90Q2hhbmdlXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj58c3RyaW5nfEZ1bmN0aW9ufSBbcG9zaXRpb25FeHByXVxuICAgICAgICAgKi9cbiAgICAgICAgX2Rpc3BhdGNoQW5kU2hvd1Nlcmllc1Rvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBjb29yZFN5cywgc2VyaWVzTGlzdCwgcG9pbnQsIHZhbHVlLCBjb250ZW50Tm90Q2hhbmdlLCBwb3NpdGlvbkV4cHJcbiAgICAgICAgKSB7XG5cbiAgICAgICAgICAgIHZhciByb290VG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuXG4gICAgICAgICAgICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICAgICAgdmFyIGJhc2VEaW1JbmRleCA9ICh7eDogMSwgcmFkaXVzOiAxLCBzaW5nbGU6IDF9KVtiYXNlQXhpcy5kaW1dID8gMCA6IDE7XG5cbiAgICAgICAgICAgIGlmICghc2VyaWVzTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXlsb2FkQmF0Y2ggPSB6clV0aWwubWFwKHNlcmllc0xpc3QsIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgICAgICBkYXRhSW5kZXhJbnNpZGU6IHNlcmllcy5nZXRBeGlzVG9vbHRpcERhdGFJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZXJpZXMuZ2V0QXhpc1Rvb2x0aXBEYXRhSW5kZXgoc2VyaWVzLmNvb3JkRGltVG9EYXRhRGltKGJhc2VBeGlzLmRpbSksIHZhbHVlLCBiYXNlQXhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VyaWVzLmdldERhdGEoKS5pbmRleE9mTmVhcmVzdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuY29vcmREaW1Ub0RhdGFEaW0oYmFzZUF4aXMuZGltKVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtiYXNlRGltSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhIHRocmVzaG9sZCB0byBhdm9pZCBmaW5kIHRoZSB3cm9uZyBkYXRhSW5kZXggd2hlbiBkYXRhIGxlbmd0aCBpcyBub3Qgc2FtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLCBiYXNlQXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gMC41IDogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzYW1wbGVTZXJpZXNJbmRleDtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHBheWxvYWRCYXRjaCwgZnVuY3Rpb24gKHBheWxvYWQsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNMaXN0W2lkeF0uZ2V0RGF0YSgpLmhhc1ZhbHVlKHBheWxvYWQuZGF0YUluZGV4SW5zaWRlKSkge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVTZXJpZXNJbmRleCA9IGlkeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIDAuXG4gICAgICAgICAgICBzYW1wbGVTZXJpZXNJbmRleCA9IHNhbXBsZVNlcmllc0luZGV4IHx8IDA7XG5cbiAgICAgICAgICAgIHZhciBsYXN0SG92ZXIgPSB0aGlzLl9sYXN0SG92ZXI7XG4gICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuICAgICAgICAgICAgLy8gRGlzcGF0Y2ggZG93bnBsYXkgYWN0aW9uXG4gICAgICAgICAgICBpZiAobGFzdEhvdmVyLnBheWxvYWRCYXRjaCAmJiAhY29udGVudE5vdENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkb3ducGxheScsXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoOiBsYXN0SG92ZXIucGF5bG9hZEJhdGNoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEaXNwYXRjaCBoaWdobGlnaHQgYWN0aW9uXG4gICAgICAgICAgICBpZiAoIWNvbnRlbnROb3RDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaGlnaGxpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2g6IHBheWxvYWRCYXRjaFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxhc3RIb3Zlci5wYXlsb2FkQmF0Y2ggPSBwYXlsb2FkQmF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEaXNwYXRjaCBzaG93VGlwIGFjdGlvblxuICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IHBheWxvYWRCYXRjaFtzYW1wbGVTZXJpZXNJbmRleF0uZGF0YUluZGV4SW5zaWRlO1xuICAgICAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICAgICAgICAgICAgZGF0YUluZGV4SW5zaWRlOiBkYXRhSW5kZXgsXG4gICAgICAgICAgICAgICAgLy8gZXhwb3NlIHRvIHVzZXIuXG4gICAgICAgICAgICAgICAgZGF0YUluZGV4OiBzZXJpZXNMaXN0W3NhbXBsZVNlcmllc0luZGV4XS5nZXREYXRhKCkuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KSxcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogcGF5bG9hZEJhdGNoW3NhbXBsZVNlcmllc0luZGV4XS5zZXJpZXNJbmRleCxcbiAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLnVpZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChiYXNlQXhpcyAmJiByb290VG9vbHRpcE1vZGVsLmdldCgnc2hvd0NvbnRlbnQnKSAmJiByb290VG9vbHRpcE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtc0xpc3QgPSB6clV0aWwubWFwKHNlcmllc0xpc3QsIGZ1bmN0aW9uIChzZXJpZXMsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpZXMuZ2V0RGF0YVBhcmFtcyhwYXlsb2FkQmF0Y2hbaW5kZXhdLmRhdGFJbmRleEluc2lkZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnROb3RDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGh0bWwgY29udGVudFxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3REYXRhSW5kZXggPSBwYXlsb2FkQmF0Y2hbc2FtcGxlU2VyaWVzSW5kZXhdLmRhdGFJbmRleEluc2lkZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHRvb2x0aXAgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgICAgICAvLyAoMSkgc2hvbGQgYmUgdGhlIGZpcnN0IGRhdGEgd2hpY2ggaGFzIG5hbWU/XG4gICAgICAgICAgICAgICAgICAgIC8vICgyKSB0aGVtZVJpdmVyLCBmaXJzdERhdGFJbmRleCBpcyBhcnJheSwgYW5kIGZpcnN0IGxpbmUgaXMgdW5uZWNlc3NhcnkuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdExpbmUgPSBiYXNlQXhpcy50eXBlID09PSAndGltZSdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYmFzZUF4aXMuc2NhbGUuZ2V0TGFiZWwodmFsdWVbYmFzZURpbUluZGV4XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VyaWVzTGlzdFtzYW1wbGVTZXJpZXNJbmRleF0uZ2V0RGF0YSgpLmdldE5hbWUoZmlyc3REYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdEh0bWwgPSAoZmlyc3RMaW5lID8gZm9ybWF0VXRpbC5lbmNvZGVIVE1MKGZpcnN0TGluZSkgKyAnPGJyIC8+JyA6ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyB6clV0aWwubWFwKHNlcmllc0xpc3QsIGZ1bmN0aW9uIChzZXJpZXMsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllcy5mb3JtYXRUb29sdGlwKHBheWxvYWRCYXRjaFtpbmRleF0uZGF0YUluZGV4SW5zaWRlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJzxiciAvPicpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhc3luY1RpY2tldCA9ICdheGlzXycgKyBjb29yZFN5cy5uYW1lICsgJ18nICsgZmlyc3REYXRhSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXBDb250ZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFRvb2x0aXBNb2RlbCwgZGVmYXVsdEh0bWwsIHBhcmFtc0xpc3QsIGFzeW5jVGlja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRbMF0sIHBvaW50WzFdLCBwb3NpdGlvbkV4cHIsIG51bGwsIGFwaVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIgfHwgcm9vdFRvb2x0aXBNb2RlbC5nZXQoJ3Bvc2l0aW9uJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludFswXSwgcG9pbnRbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICByb290VG9vbHRpcE1vZGVsLmdldCgnY29uZmluZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcENvbnRlbnQsIHBhcmFtc0xpc3QsIG51bGwsIGFwaVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0b29sdGlwIG9uIGl0ZW1cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAgICAgICAqL1xuICAgICAgICBfc2hvd0l0ZW1Ub29sdGlwQ29udGVudDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBkYXRhSW5kZXgsIGRhdGFUeXBlLCBlKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBHcmFwaCBkYXRhXG4gICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKGRhdGFUeXBlKTtcbiAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChkYXRhSW5kZXgpO1xuXG4gICAgICAgICAgICB2YXIgdG9vbHRpcE9wdCA9IGl0ZW1Nb2RlbC5nZXQoJ3Rvb2x0aXAnLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9vbHRpcE9wdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBlYWNoIGRhdGEgaXRlbSB0b29sdGlwIGNhbiBiZSBzaW1wbHkgd3JpdGU6XG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICB2YWx1ZTogMTAsXG4gICAgICAgICAgICAgICAgLy8gIHRvb2x0aXA6ICdTb21ldGhpbmcgeW91IG5lZWQgdG8ga25vdydcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgdmFyIHRvb2x0aXBDb250ZW50ID0gdG9vbHRpcE9wdDtcbiAgICAgICAgICAgICAgICB0b29sdGlwT3B0ID0ge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IHRvb2x0aXBDb250ZW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByb290VG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuICAgICAgICAgICAgdmFyIHNlcmllc1Rvb2x0aXBNb2RlbCA9IHNlcmllc01vZGVsLmdldE1vZGVsKFxuICAgICAgICAgICAgICAgICd0b29sdGlwJywgcm9vdFRvb2x0aXBNb2RlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciB0b29sdGlwTW9kZWwgPSBuZXcgTW9kZWwodG9vbHRpcE9wdCwgc2VyaWVzVG9vbHRpcE1vZGVsLCBzZXJpZXNUb29sdGlwTW9kZWwuZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBzZXJpZXNNb2RlbC5nZXREYXRhUGFyYW1zKGRhdGFJbmRleCwgZGF0YVR5cGUpO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRIdG1sID0gc2VyaWVzTW9kZWwuZm9ybWF0VG9vbHRpcChkYXRhSW5kZXgsIGZhbHNlLCBkYXRhVHlwZSk7XG5cbiAgICAgICAgICAgIHZhciBhc3luY1RpY2tldCA9ICdpdGVtXycgKyBzZXJpZXNNb2RlbC5uYW1lICsgJ18nICsgZGF0YUluZGV4O1xuXG4gICAgICAgICAgICB0aGlzLl9zaG93VG9vbHRpcENvbnRlbnQoXG4gICAgICAgICAgICAgICAgdG9vbHRpcE1vZGVsLCBkZWZhdWx0SHRtbCwgcGFyYW1zLCBhc3luY1RpY2tldCxcbiAgICAgICAgICAgICAgICBlLm9mZnNldFgsIGUub2Zmc2V0WSwgZS5wb3NpdGlvbiwgZS50YXJnZXQsIGFwaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2hvd1Rvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAoXG4gICAgICAgICAgICB0b29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBwYXJhbXMsIGFzeW5jVGlja2V0LCB4LCB5LCBwb3NpdGlvbkV4cHIsIHRhcmdldCwgYXBpXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gUmVzZXQgdGlja2V0XG4gICAgICAgICAgICB0aGlzLl90aWNrZXQgPSAnJztcblxuICAgICAgICAgICAgaWYgKHRvb2x0aXBNb2RlbC5nZXQoJ3Nob3dDb250ZW50JykgJiYgdG9vbHRpcE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvb2x0aXBDb250ZW50ID0gdGhpcy5fdG9vbHRpcENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpbmUgPSB0b29sdGlwTW9kZWwuZ2V0KCdjb25maW5lJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gdG9vbHRpcE1vZGVsLmdldCgnZm9ybWF0dGVyJyk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25FeHByID0gcG9zaXRpb25FeHByIHx8IHRvb2x0aXBNb2RlbC5nZXQoJ3Bvc2l0aW9uJyk7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBkZWZhdWx0SHRtbDtcblxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sID0gZm9ybWF0VXRpbC5mb3JtYXRUcGwoZm9ybWF0dGVyLCBwYXJhbXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aWNrZXQgPSBhc3luY1RpY2tldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChjYlRpY2tldCwgaHRtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYlRpY2tldCA9PT0gc2VsZi5fdGlja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LnNldENvbnRlbnQoaHRtbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIsIHgsIHksIGNvbmZpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwQ29udGVudCwgcGFyYW1zLCB0YXJnZXQsIGFwaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl90aWNrZXQgPSB0aWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sID0gZm9ybWF0dGVyKHBhcmFtcywgdGlja2V0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b29sdGlwQ29udGVudC5zaG93KHRvb2x0aXBNb2RlbCk7XG4gICAgICAgICAgICAgICAgdG9vbHRpcENvbnRlbnQuc2V0Q29udGVudChodG1sKTtcblxuICAgICAgICAgICAgICAgIHVwZGF0ZVBvc2l0aW9uKFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIsIHgsIHksIGNvbmZpbmUsXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LCBwYXJhbXMsIHRhcmdldCwgYXBpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyBheGlzIHBvaW50ZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb29yZFN5c05hbWVdXG4gICAgICAgICAqL1xuICAgICAgICBfc2hvd0F4aXNQb2ludGVyOiBmdW5jdGlvbiAoY29vcmRTeXNOYW1lKSB7XG4gICAgICAgICAgICBpZiAoY29vcmRTeXNOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVycyA9IHRoaXMuX2F4aXNQb2ludGVyc1tjb29yZFN5c05hbWVdO1xuICAgICAgICAgICAgICAgIGF4aXNQb2ludGVycyAmJiB6clV0aWwuZWFjaChheGlzUG9pbnRlcnMsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5zaG93KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2hvdygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9yZXNldExhc3RIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxhc3RIb3ZlciA9IHRoaXMuX2xhc3RIb3ZlcjtcbiAgICAgICAgICAgIGlmIChsYXN0SG92ZXIucGF5bG9hZEJhdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Rvd25wbGF5JyxcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2g6IGxhc3RIb3Zlci5wYXlsb2FkQmF0Y2hcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlc2V0IGxhc3RIb3ZlclxuICAgICAgICAgICAgdGhpcy5fbGFzdEhvdmVyID0ge307XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIGF4aXMgcG9pbnRlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Nvb3JkU3lzTmFtZV1cbiAgICAgICAgICovXG4gICAgICAgIF9oaWRlQXhpc1BvaW50ZXI6IGZ1bmN0aW9uIChjb29yZFN5c05hbWUpIHtcbiAgICAgICAgICAgIGlmIChjb29yZFN5c05hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc1BvaW50ZXJzID0gdGhpcy5fYXhpc1BvaW50ZXJzW2Nvb3JkU3lzTmFtZV07XG4gICAgICAgICAgICAgICAgYXhpc1BvaW50ZXJzICYmIHpyVXRpbC5lYWNoKGF4aXNQb2ludGVycywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwLmNoaWxkcmVuKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1lb3V0KTtcblxuICAgICAgICAgICAgdGhpcy5faGlkZUF4aXNQb2ludGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNldExhc3RIb3ZlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hbHdheXNTaG93Q29udGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBDb250ZW50LmhpZGVMYXRlcih0aGlzLl90b29sdGlwTW9kZWwuZ2V0KCdoaWRlRGVsYXknKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2FwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hpZGVUaXAnLFxuICAgICAgICAgICAgICAgIGZyb206IHRoaXMudWlkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fbGFzdFggPSB0aGlzLl9sYXN0WSA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHpyID0gYXBpLmdldFpyKCk7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwQ29udGVudC5oaWRlKCk7XG5cbiAgICAgICAgICAgIHpyLm9mZignY2xpY2snLCB0aGlzLl90cnlTaG93KTtcbiAgICAgICAgICAgIHpyLm9mZignbW91c2Vtb3ZlJywgdGhpcy5fbW91c2Vtb3ZlKTtcbiAgICAgICAgICAgIHpyLm9mZignbW91c2VvdXQnLCB0aGlzLl9oaWRlKTtcbiAgICAgICAgICAgIHpyLm9mZignZ2xvYmFsb3V0JywgdGhpcy5faGlkZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiIsIlxuXG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL251bWJlcicpO1xuICAgIHZhciBsaW5lYXJNYXAgPSBudW1iZXJVdGlsLmxpbmVhck1hcDtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICBmdW5jdGlvbiBmaXhFeHRlbnRXaXRoQmFuZHMoZXh0ZW50LCBuVGljaykge1xuICAgICAgICB2YXIgc2l6ZSA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICAgICAgdmFyIGxlbiA9IG5UaWNrO1xuICAgICAgICB2YXIgbWFyZ2luID0gc2l6ZSAvIGxlbiAvIDI7XG4gICAgICAgIGV4dGVudFswXSArPSBtYXJnaW47XG4gICAgICAgIGV4dGVudFsxXSAtPSBtYXJnaW47XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbGl6ZWRFeHRlbnQgPSBbMCwgMV07XG4gICAgLyoqXG4gICAgICogQG5hbWUgbW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFuQXhpc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBBeGlzID0gZnVuY3Rpb24gKGRpbSwgc2NhbGUsIGV4dGVudCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBeGlzIGRpbWVuc2lvbi4gU3VjaCBhcyAneCcsICd5JywgJ3onLCAnYW5nbGUnLCAncmFkaXVzJ1xuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaW0gPSBkaW07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgc2NhbGVcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2Nvb3JkL3NjYWxlLyp9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2V4dGVudCA9IGV4dGVudCB8fCBbMCwgMF07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnZlcnNlID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzdWFsbHkgdHJ1ZSB3aGVuIGF4aXMgaGFzIGEgb3JkaW5hbCBzY2FsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CYW5kID0gZmFsc2U7XG4gICAgfTtcblxuICAgIEF4aXMucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBBeGlzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBheGlzIGV4dGVudCBjb250YWluIGdpdmVuIGNvb3JkXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb29yZFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1heChleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gICAgICAgICAgICByZXR1cm4gY29vcmQgPj0gbWluICYmIGNvb3JkIDw9IG1heDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYXhpcyBleHRlbnQgY29udGFpbiBnaXZlbiBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluRGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW4odGhpcy5kYXRhVG9Db29yZChkYXRhKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjb29yZCBleHRlbnQuXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXh0ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gdGhpcy5fZXh0ZW50LnNsaWNlKCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcHJlY2lzaW9uIHVzZWQgZm9yIGZvcm1hdHRpbmdcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW2RhdGFFeHRlbnRdXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFBpeGVsUHJlY2lzaW9uOiBmdW5jdGlvbiAoZGF0YUV4dGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclV0aWwuZ2V0UGl4ZWxQcmVjaXNpb24oXG4gICAgICAgICAgICAgICAgZGF0YUV4dGVudCB8fCB0aGlzLnNjYWxlLmdldEV4dGVudCgpLFxuICAgICAgICAgICAgICAgIHRoaXMuX2V4dGVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGNvb3JkIGV4dGVudFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RXh0ZW50OiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIGV4dGVudFswXSA9IHN0YXJ0O1xuICAgICAgICAgICAgZXh0ZW50WzFdID0gZW5kO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IGRhdGEgdG8gY29vcmQuIERhdGEgaXMgdGhlIHJhbmsgaWYgaXQgaGFzIGEgb3JkaW5hbCBzY2FsZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YVxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBkYXRhVG9Db29yZDogZnVuY3Rpb24gKGRhdGEsIGNsYW1wKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGRhdGEgPSBzY2FsZS5ub3JtYWxpemUoZGF0YSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9uQmFuZCAmJiBzY2FsZS50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgICAgICBleHRlbnQgPSBleHRlbnQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBmaXhFeHRlbnRXaXRoQmFuZHMoZXh0ZW50LCBzY2FsZS5jb3VudCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxpbmVhck1hcChkYXRhLCBub3JtYWxpemVkRXh0ZW50LCBleHRlbnQsIGNsYW1wKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCBjb29yZCB0byBkYXRhLiBEYXRhIGlzIHRoZSByYW5rIGlmIGl0IGhhcyBhIG9yZGluYWwgc2NhbGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvb3JkXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGNvb3JkVG9EYXRhOiBmdW5jdGlvbiAoY29vcmQsIGNsYW1wKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub25CYW5kICYmIHNjYWxlLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgICAgIGV4dGVudCA9IGV4dGVudC5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGZpeEV4dGVudFdpdGhCYW5kcyhleHRlbnQsIHNjYWxlLmNvdW50KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdCA9IGxpbmVhck1hcChjb29yZCwgZXh0ZW50LCBub3JtYWxpemVkRXh0ZW50LCBjbGFtcCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlLnNjYWxlKHQpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaWNrc0Nvb3JkczogZnVuY3Rpb24gKGFsaWduV2l0aExhYmVsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vbkJhbmQgJiYgIWFsaWduV2l0aExhYmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhbmRzID0gdGhpcy5nZXRCYW5kcygpO1xuICAgICAgICAgICAgICAgIHZhciBjb29yZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKGJhbmRzW2ldWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJhbmRzW2kgLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICBjb29yZHMucHVzaChiYW5kc1tpIC0gMV1bMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAodGhpcy5zY2FsZS5nZXRUaWNrcygpLCB0aGlzLmRhdGFUb0Nvb3JkLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29vcmRzIG9mIGxhYmVscyBhcmUgb24gdGhlIHRpY2tzIG9yIG9uIHRoZSBtaWRkbGUgb2YgYmFuZHNcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYWJlbHNDb29yZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB6clV0aWwubWFwKHRoaXMuc2NhbGUuZ2V0VGlja3MoKSwgdGhpcy5kYXRhVG9Db29yZCwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBiYW5kcy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYXhpcyBoYXMgbGFiZWxzIFsxLCAyLCAzLCA0XS4gQmFuZHMgb24gdGhlIGF4aXMgYXJlXG4gICAgICAgICAqIHwtLS0xLS0tfC0tLTItLS18LS0tMy0tLXwtLS00LS0tfC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICAgLy8gRklYTUUgU2l0dWF0aW9uIHdoZW4gbGFiZWxzIGlzIG9uIHRpY2tzXG4gICAgICAgIGdldEJhbmRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICAgICAgICAgIHZhciBiYW5kcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuc2NhbGUuY291bnQoKTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGV4dGVudFswXTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBleHRlbnRbMV07XG4gICAgICAgICAgICB2YXIgc3BhbiA9IGVuZCAtIHN0YXJ0O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmFuZHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHNwYW4gKiBpIC8gbGVuICsgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHNwYW4gKiAoaSArIDEpIC8gbGVuICsgc3RhcnRcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiYW5kcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHdpZHRoIG9mIGJhbmRcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QmFuZFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXhpc0V4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIHZhciBkYXRhRXh0ZW50ID0gdGhpcy5zY2FsZS5nZXRFeHRlbnQoKTtcblxuICAgICAgICAgICAgdmFyIGxlbiA9IGRhdGFFeHRlbnRbMV0gLSBkYXRhRXh0ZW50WzBdICsgKHRoaXMub25CYW5kID8gMSA6IDApO1xuICAgICAgICAgICAgLy8gRml4ICMyNzI4LCBhdm9pZCBOYU4gd2hlbiBvbmx5IG9uZSBkYXRhLlxuICAgICAgICAgICAgbGVuID09PSAwICYmIChsZW4gPSAxKTtcblxuICAgICAgICAgICAgdmFyIHNpemUgPSBNYXRoLmFicyhheGlzRXh0ZW50WzFdIC0gYXhpc0V4dGVudFswXSk7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhzaXplKSAvIGxlbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBheGlzIGV4dGVudCBkZXBlbmRzIG9uIGRhdGEgYW5kIG5vIGRhdGEgZXhpc3RzLFxuICAgICAgICAgKiBheGlzIHRpY2tzIHNob3VsZCBub3QgYmUgZHJhd24sIHdoaWNoIGlzIG5hbWVkICdibGFuaycuXG4gICAgICAgICAqL1xuICAgICAgICBpc0JsYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNCbGFuaztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBheGlzIGV4dGVudCBkZXBlbmRzIG9uIGRhdGEgYW5kIG5vIGRhdGEgZXhpc3RzLFxuICAgICAgICAgKiBheGlzIHRpY2tzIHNob3VsZCBub3QgYmUgZHJhd24sIHdoaWNoIGlzIG5hbWVkICdibGFuaycuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRCbGFuazogZnVuY3Rpb24gKGlzQmxhbmspIHtcbiAgICAgICAgICAgIHRoaXMuX2lzQmxhbmsgPSBpc0JsYW5rO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBeGlzO1xuIiwiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgemxldmVsOiAwLCAgICAgICAgICAgICAgICAgIC8vIOS4gOe6p+WxguWPoFxuICAgICAgICB6OiAwLCAgICAgICAgICAgICAgICAgICAgICAgLy8g5LqM57qn5bGC5Y+gXG4gICAgICAgIC8vIOWPjeWQkeWdkOagh+i9tFxuICAgICAgICBpbnZlcnNlOiBmYWxzZSxcblxuICAgICAgICAvLyDlnZDmoIfovbTlkI3lrZfvvIzpu5jorqTkuLrnqbpcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIC8vIOWdkOagh+i9tOWQjeWtl+S9jee9ru+8jOaUr+aMgSdzdGFydCcgfCAnbWlkZGxlJyB8ICdlbmQnXG4gICAgICAgIG5hbWVMb2NhdGlvbjogJ2VuZCcsXG4gICAgICAgIC8vIOWdkOagh+i9tOWQjeWtl+aXi+i9rO+8jGRlZ3JlZeOAglxuICAgICAgICBuYW1lUm90YXRlOiBudWxsLCAvLyBBZGFwdCB0byBheGlzIHJvdGF0ZSwgd2hlbiBuYW1lTG9jYXRpb24gaXMgJ21pZGRsZScuXG4gICAgICAgIG5hbWVUcnVuY2F0ZToge1xuICAgICAgICAgICAgbWF4V2lkdGg6IG51bGwsXG4gICAgICAgICAgICBlbGxpcHNpczogJy4uLicsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogJy4nXG4gICAgICAgIH0sXG4gICAgICAgIC8vIOWdkOagh+i9tOaWh+Wtl+agt+W8j++8jOm7mOiupOWPluWFqOWxgOagt+W8j1xuICAgICAgICBuYW1lVGV4dFN0eWxlOiB7fSxcbiAgICAgICAgLy8g5paH5a2X5LiO6L2057q/6Led56a7XG4gICAgICAgIG5hbWVHYXA6IDE1LFxuXG4gICAgICAgIHNpbGVudDogZmFsc2UsIC8vIERlZmF1bHQgZmFsc2UgdG8gc3VwcG9ydCB0b29sdGlwLlxuICAgICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlLCAvLyBEZWZhdWx0IGZhbHNlIHRvIGF2b2lkIGxlZ2FjeSB1c2VyIGV2ZW50IGxpc3RlbmVyIGZhaWwuXG5cbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDlnZDmoIfovbTnur9cbiAgICAgICAgYXhpc0xpbmU6IHtcbiAgICAgICAgICAgIC8vIOm7mOiupOaYvuekuu+8jOWxnuaAp3Nob3fmjqfliLbmmL7npLrkuI7lkKZcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICBvblplcm86IHRydWUsXG4gICAgICAgICAgICAvLyDlsZ7mgKdsaW5lU3R5bGXmjqfliLbnur/mnaHmoLflvI9cbiAgICAgICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzMzMycsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyDlnZDmoIfovbTlsI/moIforrBcbiAgICAgICAgYXhpc1RpY2s6IHtcbiAgICAgICAgICAgIC8vIOWxnuaAp3Nob3fmjqfliLbmmL7npLrkuI7lkKbvvIzpu5jorqTmmL7npLpcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAvLyDmjqfliLblsI/moIforrDmmK/lkKblnKhncmlk6YeMXG4gICAgICAgICAgICBpbnNpZGU6IGZhbHNlLFxuICAgICAgICAgICAgLy8g5bGe5oCnbGVuZ3Ro5o6n5Yi257q/6ZW/XG4gICAgICAgICAgICBsZW5ndGg6IDUsXG4gICAgICAgICAgICAvLyDlsZ7mgKdsaW5lU3R5bGXmjqfliLbnur/mnaHmoLflvI9cbiAgICAgICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIOWdkOagh+i9tOaWh+acrOagh+etvu+8jOivpuingWF4aXMuYXhpc0xhYmVsXG4gICAgICAgIGF4aXNMYWJlbDoge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIOaOp+WItuaWh+acrOagh+etvuaYr+WQpuWcqGdyaWTph4xcbiAgICAgICAgICAgIGluc2lkZTogZmFsc2UsXG4gICAgICAgICAgICByb3RhdGU6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDgsXG4gICAgICAgICAgICAvLyBmb3JtYXR0ZXI6IG51bGwsXG4gICAgICAgICAgICAvLyDlhbbkvZnlsZ7mgKfpu5jorqTkvb/nlKjlhajlsYDmlofmnKzmoLflvI/vvIzor6bop4FURVhUU1RZTEVcbiAgICAgICAgICAgIHRleHRTdHlsZToge1xuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyDliIbpmpTnur9cbiAgICAgICAgc3BsaXRMaW5lOiB7XG4gICAgICAgICAgICAvLyDpu5jorqTmmL7npLrvvIzlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCmXG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgLy8g5bGe5oCnbGluZVN0eWxl77yI6K+m6KeBbGluZVN0eWxl77yJ5o6n5Yi257q/5p2h5qC35byPXG4gICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogWycjY2NjJ10sXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyDliIbpmpTljLrln59cbiAgICAgICAgc3BsaXRBcmVhOiB7XG4gICAgICAgICAgICAvLyDpu5jorqTkuI3mmL7npLrvvIzlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCmXG4gICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgIC8vIOWxnuaAp2FyZWFTdHlsZe+8iOivpuingWFyZWFTdHlsZe+8ieaOp+WItuWMuuWfn+agt+W8j1xuICAgICAgICAgICAgYXJlYVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IFsncmdiYSgyNTAsMjUwLDI1MCwwLjMpJywncmdiYSgyMDAsMjAwLDIwMCwwLjMpJ11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY2F0ZWdvcnlBeGlzID0genJVdGlsLm1lcmdlKHtcbiAgICAgICAgLy8g57G755uu6LW35aeL5ZKM57uT5p2f5Lik56uv56m655m9562W55WlXG4gICAgICAgIGJvdW5kYXJ5R2FwOiB0cnVlLFxuICAgICAgICAvLyBzcGxpdEFyZWE6IHtcbiAgICAgICAgICAgIC8vIHNob3c6IGZhbHNlXG4gICAgICAgIC8vIH0sXG4gICAgICAgIHNwbGl0TGluZToge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgLy8g5Z2Q5qCH6L205bCP5qCH6K6wXG4gICAgICAgIGF4aXNUaWNrOiB7XG4gICAgICAgICAgICAvLyBJZiB0aWNrIGlzIGFsaWduIHdpdGggbGFiZWwgd2hlbiBib3VuZGFyeUdhcCBpcyB0cnVlXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHdpdGggYXhpc1RpY2tcbiAgICAgICAgICAgIGFsaWduV2l0aExhYmVsOiBmYWxzZSxcbiAgICAgICAgICAgIGludGVydmFsOiAnYXV0bydcbiAgICAgICAgfSxcbiAgICAgICAgLy8g5Z2Q5qCH6L205paH5pys5qCH562+77yM6K+m6KeBYXhpcy5heGlzTGFiZWxcbiAgICAgICAgYXhpc0xhYmVsOiB7XG4gICAgICAgICAgICBpbnRlcnZhbDogJ2F1dG8nXG4gICAgICAgIH1cbiAgICB9LCBkZWZhdWx0T3B0aW9uKTtcblxuICAgIHZhciB2YWx1ZUF4aXMgPSB6clV0aWwubWVyZ2Uoe1xuICAgICAgICAvLyDmlbDlgLzotbflp4vlkoznu5PmnZ/kuKTnq6/nqbrnmb3nrZbnlaVcbiAgICAgICAgYm91bmRhcnlHYXA6IFswLCAwXSxcbiAgICAgICAgLy8g5pyA5bCP5YC8LCDorr7nva7miJAgJ2RhdGFNaW4nIOWImeS7juaVsOaNruS4reiuoeeul+acgOWwj+WAvFxuICAgICAgICAvLyBtaW46IG51bGwsXG4gICAgICAgIC8vIOacgOWkp+WAvO+8jOiuvue9ruaIkCAnZGF0YU1heCcg5YiZ5LuO5pWw5o2u5Lit6K6h566X5pyA5aSn5YC8XG4gICAgICAgIC8vIG1heDogbnVsbCxcbiAgICAgICAgLy8gUmVhZG9ubHkgcHJvcCwgc3BlY2lmaWVzIHN0YXJ0IHZhbHVlIG9mIHRoZSByYW5nZSB3aGVuIHVzaW5nIGRhdGEgem9vbS5cbiAgICAgICAgLy8gcmFuZ2VTdGFydDogbnVsbFxuICAgICAgICAvLyBSZWFkb25seSBwcm9wLCBzcGVjaWZpZXMgZW5kIHZhbHVlIG9mIHRoZSByYW5nZSB3aGVuIHVzaW5nIGRhdGEgem9vbS5cbiAgICAgICAgLy8gcmFuZ2VFbmQ6IG51bGxcbiAgICAgICAgLy8g6ISx56a7MOWAvOavlOS+i++8jOaUvuWkp+iBmueEpuWIsOacgOe7iF9taW7vvIxfbWF45Yy66Ze0XG4gICAgICAgIC8vIHNjYWxlOiBmYWxzZSxcbiAgICAgICAgLy8g5YiG5Ymy5q615pWw77yM6buY6K6k5Li6NVxuICAgICAgICBzcGxpdE51bWJlcjogNVxuICAgICAgICAvLyBNaW5pbXVtIGludGVydmFsXG4gICAgICAgIC8vIG1pbkludGVydmFsOiBudWxsXG4gICAgfSwgZGVmYXVsdE9wdGlvbik7XG5cbiAgICAvLyBGSVhNRVxuICAgIHZhciB0aW1lQXhpcyA9IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgIHNjYWxlOiB0cnVlLFxuICAgICAgICBtaW46ICdkYXRhTWluJyxcbiAgICAgICAgbWF4OiAnZGF0YU1heCdcbiAgICB9LCB2YWx1ZUF4aXMpO1xuICAgIHZhciBsb2dBeGlzID0genJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgbG9nQmFzZTogMTBcbiAgICB9LCB2YWx1ZUF4aXMpO1xuICAgIGxvZ0F4aXMuc2NhbGUgPSB0cnVlO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGNhdGVnb3J5QXhpczogY2F0ZWdvcnlBeGlzLFxuICAgICAgICB2YWx1ZUF4aXM6IHZhbHVlQXhpcyxcbiAgICAgICAgdGltZUF4aXM6IHRpbWVBeGlzLFxuICAgICAgICBsb2dBeGlzOiBsb2dBeGlzXG4gICAgfTtcbiIsIlxuXG4gICAgdmFyIE9yZGluYWxTY2FsZSA9IHJlcXVpcmUoJy4uL3NjYWxlL09yZGluYWwnKTtcbiAgICB2YXIgSW50ZXJ2YWxTY2FsZSA9IHJlcXVpcmUoJy4uL3NjYWxlL0ludGVydmFsJyk7XG4gICAgcmVxdWlyZSgnLi4vc2NhbGUvVGltZScpO1xuICAgIHJlcXVpcmUoJy4uL3NjYWxlL0xvZycpO1xuICAgIHZhciBTY2FsZSA9IHJlcXVpcmUoJy4uL3NjYWxlL1NjYWxlJyk7XG5cbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbnVtYmVyJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xuICAgIHZhciBheGlzSGVscGVyID0ge307XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYXhpcyBzY2FsZSBleHRlbnQgYmVmb3JlIG5pY2VkLlxuICAgICAqIEl0ZW0gb2YgcmV0dXJuZWQgYXJyYXkgY2FuIG9ubHkgYmUgbnVtYmVyIChpbmNsdWRpbmcgSW5maW5pdHkgYW5kIE5hTikuXG4gICAgICovXG4gICAgYXhpc0hlbHBlci5nZXRTY2FsZUV4dGVudCA9IGZ1bmN0aW9uIChheGlzLCBtb2RlbCkge1xuICAgICAgICB2YXIgc2NhbGUgPSBheGlzLnNjYWxlO1xuICAgICAgICB2YXIgc2NhbGVUeXBlID0gc2NhbGUudHlwZTtcblxuICAgICAgICB2YXIgbWluID0gbW9kZWwuZ2V0TWluKCk7XG4gICAgICAgIHZhciBtYXggPSBtb2RlbC5nZXRNYXgoKTtcbiAgICAgICAgdmFyIGZpeE1pbiA9IG1pbiAhPSBudWxsO1xuICAgICAgICB2YXIgZml4TWF4ID0gbWF4ICE9IG51bGw7XG4gICAgICAgIHZhciBvcmlnaW5hbEV4dGVudCA9IHNjYWxlLmdldEV4dGVudCgpO1xuXG4gICAgICAgIHZhciBheGlzRGF0YUxlbjtcbiAgICAgICAgdmFyIGJvdW5kYXJ5R2FwO1xuICAgICAgICB2YXIgc3BhbjtcbiAgICAgICAgaWYgKHNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICBheGlzRGF0YUxlbiA9IChtb2RlbC5nZXQoJ2RhdGEnKSB8fCBbXSkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm91bmRhcnlHYXAgPSBtb2RlbC5nZXQoJ2JvdW5kYXJ5R2FwJyk7XG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGJvdW5kYXJ5R2FwKSkge1xuICAgICAgICAgICAgICAgIGJvdW5kYXJ5R2FwID0gW2JvdW5kYXJ5R2FwIHx8IDAsIGJvdW5kYXJ5R2FwIHx8IDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm91bmRhcnlHYXBbMF0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFswXSwgMSk7XG4gICAgICAgICAgICBib3VuZGFyeUdhcFsxXSA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGJvdW5kYXJ5R2FwWzFdLCAxKTtcbiAgICAgICAgICAgIHNwYW4gPSBvcmlnaW5hbEV4dGVudFsxXSAtIG9yaWdpbmFsRXh0ZW50WzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtaW4gPSBzY2FsZVR5cGUgPT09ICdvcmRpbmFsJ1xuICAgICAgICAgICAgICAgID8gKGF4aXNEYXRhTGVuID8gMCA6IE5hTilcbiAgICAgICAgICAgICAgICA6IG9yaWdpbmFsRXh0ZW50WzBdIC0gYm91bmRhcnlHYXBbMF0gKiBzcGFuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgICAgICAgbWF4ID0gc2NhbGVUeXBlID09PSAnb3JkaW5hbCdcbiAgICAgICAgICAgICAgICA/IChheGlzRGF0YUxlbiA/IGF4aXNEYXRhTGVuIC0gMSA6IE5hTilcbiAgICAgICAgICAgICAgICA6IG9yaWdpbmFsRXh0ZW50WzFdICsgYm91bmRhcnlHYXBbMV0gKiBzcGFuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pbiA9PT0gJ2RhdGFNaW4nKSB7XG4gICAgICAgICAgICBtaW4gPSBvcmlnaW5hbEV4dGVudFswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ID09PSAnZGF0YU1heCcpIHtcbiAgICAgICAgICAgIG1heCA9IG9yaWdpbmFsRXh0ZW50WzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgKG1pbiA9PSBudWxsIHx8ICFpc0Zpbml0ZShtaW4pKSAmJiAobWluID0gTmFOKTtcbiAgICAgICAgKG1heCA9PSBudWxsIHx8ICFpc0Zpbml0ZShtYXgpKSAmJiAobWF4ID0gTmFOKTtcblxuICAgICAgICBheGlzLnNldEJsYW5rKHpyVXRpbC5lcU5hTihtaW4pIHx8IHpyVXRpbC5lcU5hTihtYXgpKTtcblxuICAgICAgICAvLyBFdmFsdWF0ZSBpZiBheGlzIG5lZWRzIGNyb3NzIHplcm9cbiAgICAgICAgaWYgKG1vZGVsLmdldE5lZWRDcm9zc1plcm8oKSkge1xuICAgICAgICAgICAgLy8gQXhpcyBpcyBvdmVyIHplcm8gYW5kIG1pbiBpcyBub3Qgc2V0XG4gICAgICAgICAgICBpZiAobWluID4gMCAmJiBtYXggPiAwICYmICFmaXhNaW4pIHtcbiAgICAgICAgICAgICAgICBtaW4gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXhpcyBpcyB1bmRlciB6ZXJvIGFuZCBtYXggaXMgbm90IHNldFxuICAgICAgICAgICAgaWYgKG1pbiA8IDAgJiYgbWF4IDwgMCAmJiAhZml4TWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH07XG5cbiAgICBheGlzSGVscGVyLm5pY2VTY2FsZUV4dGVudCA9IGZ1bmN0aW9uIChheGlzLCBtb2RlbCkge1xuICAgICAgICB2YXIgc2NhbGUgPSBheGlzLnNjYWxlO1xuICAgICAgICB2YXIgZXh0ZW50ID0gYXhpc0hlbHBlci5nZXRTY2FsZUV4dGVudChheGlzLCBtb2RlbCk7XG4gICAgICAgIHZhciBmaXhNaW4gPSBtb2RlbC5nZXRNaW4oKSAhPSBudWxsO1xuICAgICAgICB2YXIgZml4TWF4ID0gbW9kZWwuZ2V0TWF4KCkgIT0gbnVsbDtcbiAgICAgICAgdmFyIHNwbGl0TnVtYmVyID0gbW9kZWwuZ2V0KCdzcGxpdE51bWJlcicpO1xuXG4gICAgICAgIGlmIChzY2FsZS50eXBlID09PSAnbG9nJykge1xuICAgICAgICAgICAgc2NhbGUuYmFzZSA9IG1vZGVsLmdldCgnbG9nQmFzZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NhbGUuc2V0RXh0ZW50KGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICAgICAgc2NhbGUubmljZUV4dGVudChzcGxpdE51bWJlciwgZml4TWluLCBmaXhNYXgpO1xuXG4gICAgICAgIC8vIFVzZSBtaW5JbnRlcnZhbCB0byBjb25zdHJhaW50IHRoZSBjYWxjdWxhdGVkIGludGVydmFsLlxuICAgICAgICAvLyBJZiBjYWxjdWxhdGVkIGludGVydmFsIGlzIGxlc3MgdGhhbiBtaW5JbnRlcnZhbC4gaW5jcmVhc2UgdGhlIGludGVydmFsIHF1YW50aXR5IHVudGlsXG4gICAgICAgIC8vIGl0IGlzIGxhcmdlciB0aGFuIG1pbkludGVydmFsLlxuICAgICAgICAvLyBGb3IgZXhhbXBsZTpcbiAgICAgICAgLy8gIG1pbkludGVydmFsIGlzIDEsIGNhbGN1bGF0ZWQgaW50ZXJ2YWwgaXMgMC4yLCBzbyBpbmNyZWFzZSBpdCB0byBiZSAxLiBJbiB0aGlzIHdheSB3ZSBjYW4gZ2V0XG4gICAgICAgIC8vICBhbiBpbnRlZ2VyIGF4aXMuXG4gICAgICAgIHZhciBtaW5JbnRlcnZhbCA9IG1vZGVsLmdldCgnbWluSW50ZXJ2YWwnKTtcbiAgICAgICAgaWYgKGlzRmluaXRlKG1pbkludGVydmFsKSAmJiAhZml4TWluICYmICFmaXhNYXggJiYgc2NhbGUudHlwZSA9PT0gJ2ludGVydmFsJykge1xuICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2NhbGUuZ2V0SW50ZXJ2YWwoKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbFNjYWxlID0gTWF0aC5tYXgoTWF0aC5hYnMoaW50ZXJ2YWwpLCBtaW5JbnRlcnZhbCkgLyBpbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIHdoaWxlIChpbnRlcnZhbCA8IG1pbkludGVydmFsKSB7XG4gICAgICAgICAgICAvLyAgICAgdmFyIHF1YW50aXR5ID0gbnVtYmVyVXRpbC5xdWFudGl0eShpbnRlcnZhbCk7XG4gICAgICAgICAgICAvLyAgICAgaW50ZXJ2YWwgPSBxdWFudGl0eSAqIDEwO1xuICAgICAgICAgICAgLy8gICAgIHNjYWxlUXVhbnRpdHkgKj0gMTA7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBleHRlbnQgPSBzY2FsZS5nZXRFeHRlbnQoKTtcbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSAoZXh0ZW50WzFdICsgZXh0ZW50WzBdKSAvIDI7XG4gICAgICAgICAgICBzY2FsZS5zZXRFeHRlbnQoXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxTY2FsZSAqIChleHRlbnRbMF0gLSBvcmlnaW4pICsgb3JpZ2luLFxuICAgICAgICAgICAgICAgIGludGVydmFsU2NhbGUgKiAoZXh0ZW50WzFdIC0gb3JpZ2luKSArIG9yaWdpblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNjYWxlLm5pY2VFeHRlbnQoc3BsaXROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgc29tZSBvbmUgc3BlY2lmaWVkIHRoZSBtaW4sIG1heC4gQW5kIHRoZSBkZWZhdWx0IGNhbGN1bGF0ZWQgaW50ZXJ2YWxcbiAgICAgICAgLy8gaXMgbm90IGdvb2QgZW5vdWdoLiBIZSBjYW4gc3BlY2lmeSB0aGUgaW50ZXJ2YWwuIEl0IGlzIG9mdGVuIGFwcGVhcmVkXG4gICAgICAgIC8vIGluIGFuZ2xlIGF4aXMgd2l0aCBhbmdsZSAwIC0gMzYwLiBJbnRlcnZhbCBjYWxjdWxhdGVkIGluIGludGVydmFsIHNjYWxlIGlzIGhhcmRcbiAgICAgICAgLy8gdG8gYmUgNjAuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIHZhciBpbnRlcnZhbCA9IG1vZGVsLmdldCgnaW50ZXJ2YWwnKTtcbiAgICAgICAgaWYgKGludGVydmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNjYWxlLnNldEludGVydmFsICYmIHNjYWxlLnNldEludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBtb2RlbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXhpc1R5cGVdIERlZmF1bHQgcmV0cmlldmUgZnJvbSBtb2RlbC50eXBlXG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvc2NhbGUvKn1cbiAgICAgKi9cbiAgICBheGlzSGVscGVyLmNyZWF0ZVNjYWxlQnlNb2RlbCA9IGZ1bmN0aW9uKG1vZGVsLCBheGlzVHlwZSkge1xuICAgICAgICBheGlzVHlwZSA9IGF4aXNUeXBlIHx8IG1vZGVsLmdldCgndHlwZScpO1xuICAgICAgICBpZiAoYXhpc1R5cGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXhpc1R5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBCdWlsZGluIHNjYWxlXG4gICAgICAgICAgICAgICAgY2FzZSAnY2F0ZWdvcnknOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9yZGluYWxTY2FsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmdldENhdGVnb3JpZXMoKSwgW0luZmluaXR5LCAtSW5maW5pdHldXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludGVydmFsU2NhbGUoKTtcbiAgICAgICAgICAgICAgICAvLyBFeHRlbmRlZCBzY2FsZSwgbGlrZSB0aW1lIGFuZCBsb2dcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFNjYWxlLmdldENsYXNzKGF4aXNUeXBlKSB8fCBJbnRlcnZhbFNjYWxlKS5jcmVhdGUobW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBheGlzIGNvcnNzIDBcbiAgICAgKi9cbiAgICBheGlzSGVscGVyLmlmQXhpc0Nyb3NzWmVybyA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgIHZhciBkYXRhRXh0ZW50ID0gYXhpcy5zY2FsZS5nZXRFeHRlbnQoKTtcbiAgICAgICAgdmFyIG1pbiA9IGRhdGFFeHRlbnRbMF07XG4gICAgICAgIHZhciBtYXggPSBkYXRhRXh0ZW50WzFdO1xuICAgICAgICByZXR1cm4gISgobWluID4gMCAmJiBtYXggPiAwKSB8fCAobWluIDwgMCAmJiBtYXggPCAwKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRpY2tDb29yZHMgSW4gYXhpcyBzZWxmIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbGFiZWxzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQXhpc0hvcml6b250YWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgYXhpc0hlbHBlci5nZXRBeGlzTGFiZWxJbnRlcnZhbCA9IGZ1bmN0aW9uICh0aWNrQ29vcmRzLCBsYWJlbHMsIGZvbnQsIGlzQXhpc0hvcml6b250YWwpIHtcbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLy8g5LiN5ZCM6KeS55qEYXhpc+WSjGxhYmVs77yM5LiN5Y+q5pivaG9yaXpvbnRhbOWSjHZlcnRpY2FsLlxuXG4gICAgICAgIHZhciB0ZXh0U3BhY2VUYWtlblJlY3Q7XG4gICAgICAgIHZhciBhdXRvTGFiZWxJbnRlcnZhbCA9IDA7XG4gICAgICAgIHZhciBhY2N1bXVsYXRlZExhYmVsSW50ZXJ2YWwgPSAwO1xuXG4gICAgICAgIHZhciBzdGVwID0gMTtcbiAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPiA0MCkge1xuICAgICAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvbiBmb3IgbGFyZ2UgYW1vdW50IG9mIGxhYmVsc1xuICAgICAgICAgICAgc3RlcCA9IE1hdGguZmxvb3IobGFiZWxzLmxlbmd0aCAvIDQwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja0Nvb3Jkcy5sZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgICAgICAgdmFyIHRpY2tDb29yZCA9IHRpY2tDb29yZHNbaV07XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICBsYWJlbHNbaV0sIGZvbnQsICdjZW50ZXInLCAndG9wJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlY3RbaXNBeGlzSG9yaXpvbnRhbCA/ICd4JyA6ICd5J10gKz0gdGlja0Nvb3JkO1xuICAgICAgICAgICAgLy8gRklYTUUgTWFnaWMgbnVtYmVyIDEuNVxuICAgICAgICAgICAgcmVjdFtpc0F4aXNIb3Jpem9udGFsID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSAqPSAxLjM7XG4gICAgICAgICAgICBpZiAoIXRleHRTcGFjZVRha2VuUmVjdCkge1xuICAgICAgICAgICAgICAgIHRleHRTcGFjZVRha2VuUmVjdCA9IHJlY3QuY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHNwYWNlIGZvciBjdXJyZW50IGxhYmVsO1xuICAgICAgICAgICAgZWxzZSBpZiAodGV4dFNwYWNlVGFrZW5SZWN0LmludGVyc2VjdChyZWN0KSkge1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkTGFiZWxJbnRlcnZhbCsrO1xuICAgICAgICAgICAgICAgIGF1dG9MYWJlbEludGVydmFsID0gTWF0aC5tYXgoYXV0b0xhYmVsSW50ZXJ2YWwsIGFjY3VtdWxhdGVkTGFiZWxJbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0U3BhY2VUYWtlblJlY3QudW5pb24ocmVjdCk7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXRcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZExhYmVsSW50ZXJ2YWwgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhdXRvTGFiZWxJbnRlcnZhbCA9PT0gMCAmJiBzdGVwID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhdXRvTGFiZWxJbnRlcnZhbCArIDEpICogc3RlcCAtIDE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBheGlzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGFiZWxGb3JtYXR0ZXJcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBheGlzSGVscGVyLmdldEZvcm1hdHRlZExhYmVscyA9IGZ1bmN0aW9uIChheGlzLCBsYWJlbEZvcm1hdHRlcikge1xuICAgICAgICB2YXIgc2NhbGUgPSBheGlzLnNjYWxlO1xuICAgICAgICB2YXIgbGFiZWxzID0gc2NhbGUuZ2V0VGlja3NMYWJlbHMoKTtcbiAgICAgICAgdmFyIHRpY2tzID0gc2NhbGUuZ2V0VGlja3MoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsYWJlbEZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxhYmVsRm9ybWF0dGVyID0gKGZ1bmN0aW9uICh0cGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHBsLnJlcGxhY2UoJ3t2YWx1ZX0nLCB2YWwgIT0gbnVsbCA/IHZhbCA6ICcnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkobGFiZWxGb3JtYXR0ZXIpO1xuICAgICAgICAgICAgLy8gQ29uc2lkZXIgZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIHJldHVybiB6clV0aWwubWFwKGxhYmVscywgbGFiZWxGb3JtYXR0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsYWJlbEZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAodGlja3MsIGZ1bmN0aW9uICh0aWNrLCBpZHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxGb3JtYXR0ZXIoXG4gICAgICAgICAgICAgICAgICAgIGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IHNjYWxlLmdldExhYmVsKHRpY2spIDogdGljayxcbiAgICAgICAgICAgICAgICAgICAgaWR4XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGF4aXNIZWxwZXI7XG4iLCJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoJy4vYXhpc0hlbHBlcicpO1xuXG4gICAgZnVuY3Rpb24gZ2V0TmFtZShvYmopIHtcbiAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChvYmopICYmIG9iai52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JtYXQgbGFiZWxzXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Rm9ybWF0dGVkTGFiZWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXhpc0hlbHBlci5nZXRGb3JtYXR0ZWRMYWJlbHMoXG4gICAgICAgICAgICAgICAgdGhpcy5heGlzLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0KCdheGlzTGFiZWwuZm9ybWF0dGVyJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjYXRlZ29yaWVzXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDYXRlZ29yaWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoJ3R5cGUnKSA9PT0gJ2NhdGVnb3J5J1xuICAgICAgICAgICAgICAgICYmIHpyVXRpbC5tYXAodGhpcy5nZXQoJ2RhdGEnKSwgZ2V0TmFtZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3JpZ2luXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9IG1pbiB2YWx1ZSBvciAnZGF0YU1pbicgb3IgbnVsbC91bmRlZmluZWQgKG1lYW5zIGF1dG8pIG9yIE5hTlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TWluOiBmdW5jdGlvbiAob3JpZ2luKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgICAgICAgICB2YXIgbWluID0gKCFvcmlnaW4gJiYgb3B0aW9uLnJhbmdlU3RhcnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICA/IG9wdGlvbi5yYW5nZVN0YXJ0IDogb3B0aW9uLm1pbjtcblxuICAgICAgICAgICAgaWYgKG1pbiAhPSBudWxsICYmIG1pbiAhPT0gJ2RhdGFNaW4nICYmICF6clV0aWwuZXFOYU4obWluKSkge1xuICAgICAgICAgICAgICAgIG1pbiA9IHRoaXMuYXhpcy5zY2FsZS5wYXJzZShtaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBvcmlnaW5cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ30gbWF4IHZhbHVlIG9yICdkYXRhTWF4JyBvciBudWxsL3VuZGVmaW5lZCAobWVhbnMgYXV0bykgb3IgTmFOXG4gICAgICAgICAqL1xuICAgICAgICBnZXRNYXg6IGZ1bmN0aW9uIChvcmlnaW4pIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgICAgIHZhciBtYXggPSAoIW9yaWdpbiAmJiBvcHRpb24ucmFuZ2VFbmQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICA/IG9wdGlvbi5yYW5nZUVuZCA6IG9wdGlvbi5tYXg7XG5cbiAgICAgICAgICAgIGlmIChtYXggIT0gbnVsbCAmJiBtYXggIT09ICdkYXRhTWF4JyAmJiAhenJVdGlsLmVxTmFOKG1heCkpIHtcbiAgICAgICAgICAgICAgICBtYXggPSB0aGlzLmF4aXMuc2NhbGUucGFyc2UobWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBnZXROZWVkQ3Jvc3NaZXJvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgICAgICAgICByZXR1cm4gKG9wdGlvbi5yYW5nZVN0YXJ0ICE9IG51bGwgfHwgb3B0aW9uLnJhbmdlRW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgPyBmYWxzZSA6ICFvcHRpb24uc2NhbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIGF4aXMgbW9kZWwgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9IGNvb3JkaW5hdGUgc3lzdGVtIG1vZGVsXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDb29yZFN5c01vZGVsOiB6clV0aWwubm9vcCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlU3RhcnQgQ2FuIG9ubHkgYmUgZmluaXRlIG51bWJlciBvciBudWxsL3VuZGVmaW5lZCBvciBOYU4uXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZUVuZCBDYW4gb25seSBiZSBmaW5pdGUgbnVtYmVyIG9yIG51bGwvdW5kZWZpbmVkIG9yIE5hTi5cbiAgICAgICAgICovXG4gICAgICAgIHNldFJhbmdlOiBmdW5jdGlvbiAocmFuZ2VTdGFydCwgcmFuZ2VFbmQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uLnJhbmdlU3RhcnQgPSByYW5nZVN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5vcHRpb24ucmFuZ2VFbmQgPSByYW5nZUVuZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXQgcmFuZ2VcbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0UmFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJhbmdlU3RhcnQgYW5kIHJhbmdlRW5kIGlzIHJlYWRvbmx5LlxuICAgICAgICAgICAgdGhpcy5vcHRpb24ucmFuZ2VTdGFydCA9IHRoaXMub3B0aW9uLnJhbmdlRW5kID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4iLCJcblxuICAgIHZhciBheGlzRGVmYXVsdCA9IHJlcXVpcmUoJy4vYXhpc0RlZmF1bHQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWwvQ29tcG9uZW50Jyk7XG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoJy4uL3V0aWwvbGF5b3V0Jyk7XG5cbiAgICAvLyBGSVhNRSBheGlzVHlwZSBpcyBmaXhlZCA/XG4gICAgdmFyIEFYSVNfVFlQRVMgPSBbJ3ZhbHVlJywgJ2NhdGVnb3J5JywgJ3RpbWUnLCAnbG9nJ107XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBzdWIgYXhpcyBtb2RlbCBjbGFzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBheGlzTmFtZSAneCcgJ3knICdyYWRpdXMnICdhbmdsZScgJ3BhcmFsbGVsJ1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBCYXNlQXhpc01vZGVsQ2xhc3NcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBheGlzVHlwZURlZmF1bHRlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0cmFEZWZhdWx0T3B0aW9uXVxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGF4aXNOYW1lLCBCYXNlQXhpc01vZGVsQ2xhc3MsIGF4aXNUeXBlRGVmYXVsdGVyLCBleHRyYURlZmF1bHRPcHRpb24pIHtcblxuICAgICAgICB6clV0aWwuZWFjaChBWElTX1RZUEVTLCBmdW5jdGlvbiAoYXhpc1R5cGUpIHtcblxuICAgICAgICAgICAgQmFzZUF4aXNNb2RlbENsYXNzLmV4dGVuZCh7XG5cbiAgICAgICAgICAgICAgICB0eXBlOiBheGlzTmFtZSArICdBeGlzLicgKyBheGlzVHlwZSxcblxuICAgICAgICAgICAgICAgIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGxheW91dE1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbGF5b3V0LmdldExheW91dFBhcmFtcyhvcHRpb24pIDoge307XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZW1lTW9kZWwgPSBlY01vZGVsLmdldFRoZW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoZW1lTW9kZWwuZ2V0KGF4aXNUeXBlICsgJ0F4aXMnKSk7XG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTtcblxuICAgICAgICAgICAgICAgICAgICBvcHRpb24udHlwZSA9IGF4aXNUeXBlRGVmYXVsdGVyKGF4aXNOYW1lLCBvcHRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbShvcHRpb24sIGlucHV0UG9zaXRpb25QYXJhbXMsIGxheW91dE1vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb246IHpyVXRpbC5tZXJnZUFsbChcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzRGVmYXVsdFtheGlzVHlwZSArICdBeGlzJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYURlZmF1bHRPcHRpb25cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBDb21wb25lbnRNb2RlbC5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIoXG4gICAgICAgICAgICBheGlzTmFtZSArICdBeGlzJyxcbiAgICAgICAgICAgIHpyVXRpbC5jdXJyeShheGlzVHlwZURlZmF1bHRlciwgYXhpc05hbWUpXG4gICAgICAgICk7XG4gICAgfTtcbiIsIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBBeGlzID0gcmVxdWlyZSgnLi4vQXhpcycpO1xuICAgIHZhciBheGlzTGFiZWxJbnRlcnZhbCA9IHJlcXVpcmUoJy4vYXhpc0xhYmVsSW50ZXJ2YWwnKTtcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBheGlzIDJkXG4gICAgICogQGNvbnN0cnVjdG9yIG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkRcbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXN9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICAgICAqIEBwYXJhbSB7Kn0gc2NhbGVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBjb29yZEV4dGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBheGlzVHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvblxuICAgICAqL1xuICAgIHZhciBBeGlzMkQgPSBmdW5jdGlvbiAoZGltLCBzY2FsZSwgY29vcmRFeHRlbnQsIGF4aXNUeXBlLCBwb3NpdGlvbikge1xuICAgICAgICBBeGlzLmNhbGwodGhpcywgZGltLCBzY2FsZSwgY29vcmRFeHRlbnQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXhpcyB0eXBlXG4gICAgICAgICAqICAtICdjYXRlZ29yeSdcbiAgICAgICAgICogIC0gJ3ZhbHVlJ1xuICAgICAgICAgKiAgLSAndGltZSdcbiAgICAgICAgICogIC0gJ2xvZydcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IGF4aXNUeXBlIHx8ICd2YWx1ZSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgcG9zaXRpb25cbiAgICAgICAgICogIC0gJ3RvcCdcbiAgICAgICAgICogIC0gJ2JvdHRvbSdcbiAgICAgICAgICogIC0gJ2xlZnQnXG4gICAgICAgICAqICAtICdyaWdodCdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbiB8fCAnYm90dG9tJztcbiAgICB9O1xuXG4gICAgQXhpczJELnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQXhpczJELFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRleCBvZiBheGlzLCBjYW4gYmUgdXNlZCBhcyBrZXlcbiAgICAgICAgICovXG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYXhpcyBpcyBvbiB0aGUgemVybyBwb3NpdGlvbiBvZiB0aGUgb3RoZXIgYXhpc1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIG9uWmVybzogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgbW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWw6IG51bGwsXG5cbiAgICAgICAgaXNIb3Jpem9udGFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0R2xvYmFsRXh0ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICAgICAgICAgIHJldFswXSA9IHRoaXMudG9HbG9iYWxDb29yZChyZXRbMF0pO1xuICAgICAgICAgICAgcmV0WzFdID0gdGhpcy50b0dsb2JhbENvb3JkKHJldFsxXSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYWJlbEludGVydmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWxJbnRlcnZhbCA9IHRoaXMuX2xhYmVsSW50ZXJ2YWw7XG4gICAgICAgICAgICBpZiAoIWxhYmVsSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICBsYWJlbEludGVydmFsID0gdGhpcy5fbGFiZWxJbnRlcnZhbCA9IGF4aXNMYWJlbEludGVydmFsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsSW50ZXJ2YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGxhYmVsIGlzIGlnbm9yZWQuXG4gICAgICAgICAqIEF1dG9tYXRpY2FsbHkgdXNlZCB3aGVuIGF4aXMgaXMgY2F0ZWdvcnkgYW5kIGxhYmVsIGNhbiBub3QgYmUgYWxsIHNob3duXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGlkeFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNMYWJlbElnbm9yZWQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxJbnRlcnZhbCA9IHRoaXMuZ2V0TGFiZWxJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKHR5cGVvZiBsYWJlbEludGVydmFsID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICAmJiAhbGFiZWxJbnRlcnZhbChpZHgsIHRoaXMuc2NhbGUuZ2V0TGFiZWwoaWR4KSkpXG4gICAgICAgICAgICAgICAgICAgIHx8IGlkeCAlIChsYWJlbEludGVydmFsICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zZm9ybSBnbG9iYWwgY29vcmQgdG8gbG9jYWwgY29vcmQsXG4gICAgICAgICAqIGkuZS4gdmFyIGxvY2FsQ29vcmQgPSBheGlzLnRvTG9jYWxDb29yZCg4MCk7XG4gICAgICAgICAqIGRlc2lnbmF0ZSBieSBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZC5cbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdG9Mb2NhbENvb3JkOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFuc2Zvcm0gZ2xvYmFsIGNvb3JkIHRvIGxvY2FsIGNvb3JkLFxuICAgICAgICAgKiBpLmUuIHZhciBnbG9iYWxDb29yZCA9IGF4aXMudG9Mb2NhbENvb3JkKDQwKTtcbiAgICAgICAgICogZGVzaWduYXRlIGJ5IG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkLlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0b0dsb2JhbENvb3JkOiBudWxsXG5cbiAgICB9O1xuICAgIHpyVXRpbC5pbmhlcml0cyhBeGlzMkQsIEF4aXMpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBeGlzMkQ7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL0NvbXBvbmVudCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgYXhpc01vZGVsQ3JlYXRvciA9IHJlcXVpcmUoJy4uL2F4aXNNb2RlbENyZWF0b3InKTtcblxuICAgIHZhciBBeGlzTW9kZWwgPSBDb21wb25lbnRNb2RlbC5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdjYXJ0ZXNpYW4yZEF4aXMnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXMyRH1cbiAgICAgICAgICovXG4gICAgICAgIGF4aXM6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQXhpc01vZGVsLnN1cGVyQXBwbHkodGhpcywgJ2luaXQnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFJhbmdlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEF4aXNNb2RlbC5zdXBlckFwcGx5KHRoaXMsICdtZXJnZU9wdGlvbicsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UmFuZ2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQXhpc01vZGVsLnN1cGVyQXBwbHkodGhpcywgJ3Jlc3RvcmVEYXRhJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRSYW5nZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29vcmRTeXNNb2RlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICAgICAgICAgIG1haW5UeXBlOiAnZ3JpZCcsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMub3B0aW9uLmdyaWRJbmRleCxcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5vcHRpb24uZ3JpZElkXG4gICAgICAgICAgICB9KVswXTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBnZXRBeGlzVHlwZShheGlzRGltLCBvcHRpb24pIHtcbiAgICAgICAgLy8gRGVmYXVsdCBheGlzIHdpdGggZGF0YSBpcyBjYXRlZ29yeSBheGlzXG4gICAgICAgIHJldHVybiBvcHRpb24udHlwZSB8fCAob3B0aW9uLmRhdGEgPyAnY2F0ZWdvcnknIDogJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgenJVdGlsLm1lcmdlKEF4aXNNb2RlbC5wcm90b3R5cGUsIHJlcXVpcmUoJy4uL2F4aXNNb2RlbENvbW1vbk1peGluJykpO1xuXG4gICAgdmFyIGV4dHJhT3B0aW9uID0ge1xuICAgICAgICAvLyBncmlkSW5kZXg6IDAsXG4gICAgICAgIC8vIGdyaWRJZDogJycsXG5cbiAgICAgICAgLy8gT2Zmc2V0IGlzIGZvciBtdWx0aXBsZSBheGlzIG9uIHRoZSBzYW1lIHBvc2l0aW9uXG4gICAgICAgIG9mZnNldDogMFxuICAgIH07XG5cbiAgICBheGlzTW9kZWxDcmVhdG9yKCd4JywgQXhpc01vZGVsLCBnZXRBeGlzVHlwZSwgZXh0cmFPcHRpb24pO1xuICAgIGF4aXNNb2RlbENyZWF0b3IoJ3knLCBBeGlzTW9kZWwsIGdldEF4aXNUeXBlLCBleHRyYU9wdGlvbik7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEF4aXNNb2RlbDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQ2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtXG4gKiBAbW9kdWxlICBlY2hhcnRzL2Nvb3JkL0NhcnRlc2lhblxuICpcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICBmdW5jdGlvbiBkaW1BeGlzTWFwcGVyKGRpbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXhlc1tkaW1dO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9DYXJ0ZXNpYW5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQ2FydGVzaWFuID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fYXhlcyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2RpbUxpc3QgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgJyc7XG4gICAgfTtcblxuICAgIENhcnRlc2lhbi5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IENhcnRlc2lhbixcblxuICAgICAgICB0eXBlOiAnY2FydGVzaWFuJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGF4aXNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ30gZGltXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2Nvb3JkL0NhcnRlc2lhbn5BeGlzfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhpczogZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F4ZXNbZGltXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGF4ZXMgbGlzdFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFufkF4aXM+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAodGhpcy5fZGltTGlzdCwgZGltQXhpc01hcHBlciwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBheGVzIGxpc3QgYnkgZ2l2ZW4gc2NhbGUgdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhlc0J5U2NhbGU6IGZ1bmN0aW9uIChzY2FsZVR5cGUpIHtcbiAgICAgICAgICAgIHNjYWxlVHlwZSA9IHNjYWxlVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBeGVzKCksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF4aXMuc2NhbGUudHlwZSA9PT0gc2NhbGVUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBheGlzXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFuLkF4aXN9XG4gICAgICAgICAqL1xuICAgICAgICBhZGRBeGlzOiBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgdmFyIGRpbSA9IGF4aXMuZGltO1xuXG4gICAgICAgICAgICB0aGlzLl9heGVzW2RpbV0gPSBheGlzO1xuXG4gICAgICAgICAgICB0aGlzLl9kaW1MaXN0LnB1c2goZGltKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCBkYXRhIHRvIGNvb3JkIGluIG5kIHNwYWNlXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj58T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHZhbFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPnxPYmplY3QuPHN0cmluZywgbnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGRhdGFUb0Nvb3JkOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNvb3JkQ29udmVydCh2YWwsICdkYXRhVG9Db29yZCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IGNvb3JkIGluIG5kIHNwYWNlIHRvIGRhdGFcbiAgICAgICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj58T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHZhbFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPnxPYmplY3QuPHN0cmluZywgbnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGNvb3JkVG9EYXRhOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNvb3JkQ29udmVydCh2YWwsICdjb29yZFRvRGF0YScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kYXRhQ29vcmRDb252ZXJ0OiBmdW5jdGlvbiAoaW5wdXQsIG1ldGhvZCkge1xuICAgICAgICAgICAgdmFyIGRpbUxpc3QgPSB0aGlzLl9kaW1MaXN0O1xuXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSA/IFtdIDoge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBkaW0gPSBkaW1MaXN0W2ldO1xuICAgICAgICAgICAgICAgIHZhciBheGlzID0gdGhpcy5fYXhlc1tkaW1dO1xuXG4gICAgICAgICAgICAgICAgb3V0cHV0W2RpbV0gPSBheGlzW21ldGhvZF0oaW5wdXRbZGltXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYXJ0ZXNpYW47XG4iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQ2FydGVzaWFuID0gcmVxdWlyZSgnLi9DYXJ0ZXNpYW4nKTtcblxuICAgIGZ1bmN0aW9uIENhcnRlc2lhbjJEKG5hbWUpIHtcblxuICAgICAgICBDYXJ0ZXNpYW4uY2FsbCh0aGlzLCBuYW1lKTtcbiAgICB9XG5cbiAgICBDYXJ0ZXNpYW4yRC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IENhcnRlc2lhbjJELFxuXG4gICAgICAgIHR5cGU6ICdjYXJ0ZXNpYW4yZCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBkaW1lbnNpb25zOiBbJ3gnLCAneSddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYXNlIGF4aXMgd2lsbCBiZSB1c2VkIG9uIHN0YWNraW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpczJEfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QmFzZUF4aXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF4ZXNCeVNjYWxlKCdvcmRpbmFsJylbMF1cbiAgICAgICAgICAgICAgICB8fCB0aGlzLmdldEF4ZXNCeVNjYWxlKCd0aW1lJylbMF1cbiAgICAgICAgICAgICAgICB8fCB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgY29udGFpbiBwb2ludFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBheGlzWCA9IHRoaXMuZ2V0QXhpcygneCcpO1xuICAgICAgICAgICAgdmFyIGF4aXNZID0gdGhpcy5nZXRBeGlzKCd5Jyk7XG4gICAgICAgICAgICByZXR1cm4gYXhpc1guY29udGFpbihheGlzWC50b0xvY2FsQ29vcmQocG9pbnRbMF0pKVxuICAgICAgICAgICAgICAgICYmIGF4aXNZLmNvbnRhaW4oYXhpc1kudG9Mb2NhbENvb3JkKHBvaW50WzFdKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGNvbnRhaW4gZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkYXRhXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluRGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF4aXMoJ3gnKS5jb250YWluRGF0YShkYXRhWzBdKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuZ2V0QXhpcygneScpLmNvbnRhaW5EYXRhKGRhdGFbMV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHNlcmllcyBkYXRhIHRvIGFuIGFycmF5IG9mIHBvaW50c1xuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICAgKiAgUmV0dXJuIGFycmF5IG9mIHBvaW50cy4gRm9yIGV4YW1wbGU6XG4gICAgICAgICAqICBgW1sxMCwgMTBdLCBbMjAsIDIwXSwgWzMwLCAzMF1dYFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YVRvUG9pbnRzOiBmdW5jdGlvbiAoZGF0YSwgc3RhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcEFycmF5KFsneCcsICd5J10sIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVRvUG9pbnQoW3gsIHldKTtcbiAgICAgICAgICAgIH0sIHN0YWNrLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGFtcD1mYWxzZV1cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBkYXRhVG9Qb2ludDogZnVuY3Rpb24gKGRhdGEsIGNsYW1wKSB7XG4gICAgICAgICAgICB2YXIgeEF4aXMgPSB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgICAgICAgICAgIHZhciB5QXhpcyA9IHRoaXMuZ2V0QXhpcygneScpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB4QXhpcy50b0dsb2JhbENvb3JkKHhBeGlzLmRhdGFUb0Nvb3JkKGRhdGFbMF0sIGNsYW1wKSksXG4gICAgICAgICAgICAgICAgeUF4aXMudG9HbG9iYWxDb29yZCh5QXhpcy5kYXRhVG9Db29yZChkYXRhWzFdLCBjbGFtcCkpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGFtcD1mYWxzZV1cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBwb2ludFRvRGF0YTogZnVuY3Rpb24gKHBvaW50LCBjbGFtcCkge1xuICAgICAgICAgICAgdmFyIHhBeGlzID0gdGhpcy5nZXRBeGlzKCd4Jyk7XG4gICAgICAgICAgICB2YXIgeUF4aXMgPSB0aGlzLmdldEF4aXMoJ3knKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeEF4aXMuY29vcmRUb0RhdGEoeEF4aXMudG9Mb2NhbENvb3JkKHBvaW50WzBdKSwgY2xhbXApLFxuICAgICAgICAgICAgICAgIHlBeGlzLmNvb3JkVG9EYXRhKHlBeGlzLnRvTG9jYWxDb29yZChwb2ludFsxXSksIGNsYW1wKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IG90aGVyIGF4aXNcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpczJEfSBheGlzXG4gICAgICAgICAqL1xuICAgICAgICBnZXRPdGhlckF4aXM6IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBeGlzKGF4aXMuZGltID09PSAneCcgPyAneScgOiAneCcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhDYXJ0ZXNpYW4yRCwgQ2FydGVzaWFuKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2FydGVzaWFuMkQ7XG4iLCIvKipcbiAqIEdyaWQgaXMgYSByZWdpb24gd2hpY2ggY29udGFpbnMgYXQgbW9zdCA0IGNhcnRlc2lhbiBzeXN0ZW1zXG4gKlxuICogVE9ETyBEZWZhdWx0IGNhcnRlc2lhblxuICovXG52YXIgZmFjdG9yeSA9IGV4cG9ydHM7XG5cbiAgICB2YXIgbGF5b3V0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9sYXlvdXQnKTtcbiAgICB2YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoJy4uLy4uL2Nvb3JkL2F4aXNIZWxwZXInKTtcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQ2FydGVzaWFuMkQgPSByZXF1aXJlKCcuL0NhcnRlc2lhbjJEJyk7XG4gICAgdmFyIEF4aXMyRCA9IHJlcXVpcmUoJy4vQXhpczJEJyk7XG5cbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuXG4gICAgdmFyIGlmQXhpc0Nyb3NzWmVybyA9IGF4aXNIZWxwZXIuaWZBeGlzQ3Jvc3NaZXJvO1xuICAgIHZhciBuaWNlU2NhbGVFeHRlbnQgPSBheGlzSGVscGVyLm5pY2VTY2FsZUV4dGVudDtcblxuICAgIC8vIOS+nei1liBHcmlkTW9kZWwsIEF4aXNNb2RlbCDlgZrpooTlpITnkIZcbiAgICByZXF1aXJlKCcuL0dyaWRNb2RlbCcpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGF4aXMgaXMgdXNlZCBpbiB0aGUgc3BlY2lmaWVkIGdyaWRcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0F4aXNVc2VkSW5UaGVHcmlkKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgIHJldHVybiBheGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpID09PSBncmlkTW9kZWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TGFiZWxVbmlvblJlY3QoYXhpcykge1xuICAgICAgICB2YXIgYXhpc01vZGVsID0gYXhpcy5tb2RlbDtcbiAgICAgICAgdmFyIGxhYmVscyA9IGF4aXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbHMoKTtcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwudGV4dFN0eWxlJyk7XG4gICAgICAgIHZhciByZWN0O1xuICAgICAgICB2YXIgc3RlcCA9IDE7XG4gICAgICAgIHZhciBsYWJlbENvdW50ID0gbGFiZWxzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxhYmVsQ291bnQgPiA0MCkge1xuICAgICAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvbiBmb3IgbGFyZ2UgYW1vdW50IG9mIGxhYmVsc1xuICAgICAgICAgICAgc3RlcCA9IE1hdGguY2VpbChsYWJlbENvdW50IC8gNDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICBpZiAoIWF4aXMuaXNMYWJlbElnbm9yZWQoaSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlUmVjdCA9IHRleHRTdHlsZU1vZGVsLmdldFRleHRSZWN0KGxhYmVsc1tpXSk7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgY29uc2lkZXIgbGFiZWwgcm90YXRlXG4gICAgICAgICAgICAgICAgcmVjdCA/IHJlY3QudW5pb24oc2luZ2xlUmVjdCkgOiAocmVjdCA9IHNpbmdsZVJlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEdyaWQoZ3JpZE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbjJEPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Nvb3Jkc01hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29vcmRzTGlzdCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXhlc01hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXhlc0xpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9pbml0Q2FydGVzaWFuKGdyaWRNb2RlbCwgZWNNb2RlbCwgYXBpKTtcblxuICAgICAgICB0aGlzLl9tb2RlbCA9IGdyaWRNb2RlbDtcbiAgICB9XG5cbiAgICB2YXIgZ3JpZFByb3RvID0gR3JpZC5wcm90b3R5cGU7XG5cbiAgICBncmlkUHJvdG8udHlwZSA9ICdncmlkJztcblxuICAgIGdyaWRQcm90by5nZXRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgICB9O1xuXG4gICAgZ3JpZFByb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcblxuICAgICAgICB2YXIgYXhlc01hcCA9IHRoaXMuX2F4ZXNNYXA7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlU2NhbGUoZWNNb2RlbCwgdGhpcy5fbW9kZWwpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlmQXhpc0Nhbk5vdE9uWmVybyhvdGhlckF4aXNEaW0pIHtcbiAgICAgICAgICAgIHZhciBheGVzID0gYXhlc01hcFtvdGhlckF4aXNEaW1dO1xuICAgICAgICAgICAgZm9yICh2YXIgaWR4IGluIGF4ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhlcy5oYXNPd25Qcm9wZXJ0eShpZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzID0gYXhlc1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpcyAmJiAoYXhpcy50eXBlID09PSAnY2F0ZWdvcnknIHx8ICFpZkF4aXNDcm9zc1plcm8oYXhpcykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhY2goYXhlc01hcC54LCBmdW5jdGlvbiAoeEF4aXMpIHtcbiAgICAgICAgICAgIG5pY2VTY2FsZUV4dGVudCh4QXhpcywgeEF4aXMubW9kZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaChheGVzTWFwLnksIGZ1bmN0aW9uICh5QXhpcykge1xuICAgICAgICAgICAgbmljZVNjYWxlRXh0ZW50KHlBeGlzLCB5QXhpcy5tb2RlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGaXggY29uZmlndXJhdGlvblxuICAgICAgICBlYWNoKGF4ZXNNYXAueCwgZnVuY3Rpb24gKHhBeGlzKSB7XG4gICAgICAgICAgICAvLyBvblplcm8gY2FuIG5vdCBiZSBlbmFibGVkIGluIHRoZXNlIHR3byBzaXR1YXRpb25zXG4gICAgICAgICAgICAvLyAxLiBXaGVuIGFueSBvdGhlciBheGlzIGlzIGEgY2F0ZWdvcnkgYXhpc1xuICAgICAgICAgICAgLy8gMi4gV2hlbiBhbnkgb3RoZXIgYXhpcyBub3QgYWNyb3NzIDAgcG9pbnRcbiAgICAgICAgICAgIGlmIChpZkF4aXNDYW5Ob3RPblplcm8oJ3knKSkge1xuICAgICAgICAgICAgICAgIHhBeGlzLm9uWmVybyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWFjaChheGVzTWFwLnksIGZ1bmN0aW9uICh5QXhpcykge1xuICAgICAgICAgICAgaWYgKGlmQXhpc0Nhbk5vdE9uWmVybygneCcpKSB7XG4gICAgICAgICAgICAgICAgeUF4aXMub25aZXJvID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlc2l6ZSBhZ2FpbiBpZiBjb250YWluTGFiZWwgaXMgZW5hYmxlZFxuICAgICAgICAvLyBGSVhNRSBJdCBtYXkgY2F1c2UgZ2V0dGluZyB3cm9uZyBncmlkIHNpemUgaW4gZGF0YSBwcm9jZXNzaW5nIHN0YWdlXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMuX21vZGVsLCBhcGkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgdGhlIGdyaWRcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWx9IGdyaWRNb2RlbFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgKi9cbiAgICBncmlkUHJvdG8ucmVzaXplID0gZnVuY3Rpb24gKGdyaWRNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgdmFyIGdyaWRSZWN0ID0gbGF5b3V0LmdldExheW91dFJlY3QoXG4gICAgICAgICAgICBncmlkTW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCksIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlY3QgPSBncmlkUmVjdDtcblxuICAgICAgICB2YXIgYXhlc0xpc3QgPSB0aGlzLl9heGVzTGlzdDtcblxuICAgICAgICBhZGp1c3RBeGVzKCk7XG5cbiAgICAgICAgLy8gTWludXMgbGFiZWwgc2l6ZVxuICAgICAgICBpZiAoZ3JpZE1vZGVsLmdldCgnY29udGFpbkxhYmVsJykpIHtcbiAgICAgICAgICAgIGVhY2goYXhlc0xpc3QsIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFheGlzLm1vZGVsLmdldCgnYXhpc0xhYmVsLmluc2lkZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbFVuaW9uUmVjdCA9IGdldExhYmVsVW5pb25SZWN0KGF4aXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxVbmlvblJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaW0gPSBheGlzLmlzSG9yaXpvbnRhbCgpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmdpbiA9IGF4aXMubW9kZWwuZ2V0KCdheGlzTGFiZWwubWFyZ2luJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkUmVjdFtkaW1dIC09IGxhYmVsVW5pb25SZWN0W2RpbV0gKyBtYXJnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXhpcy5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkUmVjdC55ICs9IGxhYmVsVW5pb25SZWN0LmhlaWdodCArIG1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF4aXMucG9zaXRpb24gPT09ICdsZWZ0JykgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkUmVjdC54ICs9IGxhYmVsVW5pb25SZWN0LndpZHRoICsgbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGFkanVzdEF4ZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkanVzdEF4ZXMoKSB7XG4gICAgICAgICAgICBlYWNoKGF4ZXNMaXN0LCBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgICAgIHZhciBpc0hvcml6b250YWwgPSBheGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgICAgICAgICAgIHZhciBleHRlbnQgPSBpc0hvcml6b250YWwgPyBbMCwgZ3JpZFJlY3Qud2lkdGhdIDogWzAsIGdyaWRSZWN0LmhlaWdodF07XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGF4aXMuaW52ZXJzZSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIGF4aXMuc2V0RXh0ZW50KGV4dGVudFtpZHhdLCBleHRlbnRbMSAtIGlkeF0pO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUF4aXNUcmFuc2Zyb20oYXhpcywgaXNIb3Jpem9udGFsID8gZ3JpZFJlY3QueCA6IGdyaWRSZWN0LnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF4aXNUeXBlXG4gICAgICogQHBhcmFtIHtuZHVtYmVyfSBbYXhpc0luZGV4XVxuICAgICAqL1xuICAgIGdyaWRQcm90by5nZXRBeGlzID0gZnVuY3Rpb24gKGF4aXNUeXBlLCBheGlzSW5kZXgpIHtcbiAgICAgICAgdmFyIGF4ZXNNYXBPbkRpbSA9IHRoaXMuX2F4ZXNNYXBbYXhpc1R5cGVdO1xuICAgICAgICBpZiAoYXhlc01hcE9uRGltICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChheGlzSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgZmlyc3QgYXhpc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gYXhlc01hcE9uRGltKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChheGVzTWFwT25EaW0uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBheGVzTWFwT25EaW1bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXhlc01hcE9uRGltW2F4aXNJbmRleF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ3JpZFByb3RvLmdldENhcnRlc2lhbiA9IGZ1bmN0aW9uICh4QXhpc0luZGV4LCB5QXhpc0luZGV4KSB7XG4gICAgICAgIGlmICh4QXhpc0luZGV4ICE9IG51bGwgJiYgeUF4aXNJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gJ3gnICsgeEF4aXNJbmRleCArICd5JyArIHlBeGlzSW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29vcmRzTWFwW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXaGVuIG9ubHkgeEF4aXNJbmRleCBvciB5QXhpc0luZGV4IGdpdmVuLCBmaW5kIGl0cyBmaXJzdCBjYXJ0ZXNpYW4uXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgY29vcmRMaXN0ID0gdGhpcy5fY29vcmRzTGlzdDsgaSA8IGNvb3JkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb29yZExpc3RbaV0uZ2V0QXhpcygneCcpLmluZGV4ID09PSB4QXhpc0luZGV4XG4gICAgICAgICAgICAgICAgICAgIHx8IGNvb3JkTGlzdFtpXS5nZXRBeGlzKCd5JykuaW5kZXggPT09IHlBeGlzSW5kZXhcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkTGlzdFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGltcGxlbWVudHNcbiAgICAgKiBzZWUge21vZHVsZTplY2hhcnRzL0Nvb2RpbmF0ZVN5c3RlbX1cbiAgICAgKi9cbiAgICBncmlkUHJvdG8uY29udmVydFRvUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fZmluZENvbnZlcnRUYXJnZXQoZWNNb2RlbCwgZmluZGVyKTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0LmNhcnRlc2lhblxuICAgICAgICAgICAgPyB0YXJnZXQuY2FydGVzaWFuLmRhdGFUb1BvaW50KHZhbHVlKVxuICAgICAgICAgICAgOiB0YXJnZXQuYXhpc1xuICAgICAgICAgICAgPyB0YXJnZXQuYXhpcy50b0dsb2JhbENvb3JkKHRhcmdldC5heGlzLmRhdGFUb0Nvb3JkKHZhbHVlKSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGltcGxlbWVudHNcbiAgICAgKiBzZWUge21vZHVsZTplY2hhcnRzL0Nvb2RpbmF0ZVN5c3RlbX1cbiAgICAgKi9cbiAgICBncmlkUHJvdG8uY29udmVydEZyb21QaXhlbCA9IGZ1bmN0aW9uIChlY01vZGVsLCBmaW5kZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9maW5kQ29udmVydFRhcmdldChlY01vZGVsLCBmaW5kZXIpO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQuY2FydGVzaWFuXG4gICAgICAgICAgICA/IHRhcmdldC5jYXJ0ZXNpYW4ucG9pbnRUb0RhdGEodmFsdWUpXG4gICAgICAgICAgICA6IHRhcmdldC5heGlzXG4gICAgICAgICAgICA/IHRhcmdldC5heGlzLmNvb3JkVG9EYXRhKHRhcmdldC5heGlzLnRvTG9jYWxDb29yZCh2YWx1ZSkpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGdyaWRQcm90by5fZmluZENvbnZlcnRUYXJnZXQgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyKSB7XG4gICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGZpbmRlci5zZXJpZXNNb2RlbDtcbiAgICAgICAgdmFyIHhBeGlzTW9kZWwgPSBmaW5kZXIueEF4aXNNb2RlbFxuICAgICAgICAgICAgfHwgKHNlcmllc01vZGVsICYmIHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3hBeGlzJylbMF0pO1xuICAgICAgICB2YXIgeUF4aXNNb2RlbCA9IGZpbmRlci55QXhpc01vZGVsXG4gICAgICAgICAgICB8fCAoc2VyaWVzTW9kZWwgJiYgc2VyaWVzTW9kZWwuZ2V0UmVmZXJyaW5nQ29tcG9uZW50cygneUF4aXMnKVswXSk7XG4gICAgICAgIHZhciBncmlkTW9kZWwgPSBmaW5kZXIuZ3JpZE1vZGVsO1xuICAgICAgICB2YXIgY29vcmRzTGlzdCA9IHRoaXMuX2Nvb3Jkc0xpc3Q7XG4gICAgICAgIHZhciBjYXJ0ZXNpYW47XG4gICAgICAgIHZhciBheGlzO1xuXG4gICAgICAgIGlmIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgY2FydGVzaWFuID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHpyVXRpbC5pbmRleE9mKGNvb3Jkc0xpc3QsIGNhcnRlc2lhbikgPCAwICYmIChjYXJ0ZXNpYW4gPSBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4QXhpc01vZGVsICYmIHlBeGlzTW9kZWwpIHtcbiAgICAgICAgICAgIGNhcnRlc2lhbiA9IHRoaXMuZ2V0Q2FydGVzaWFuKHhBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgsIHlBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHhBeGlzTW9kZWwpIHtcbiAgICAgICAgICAgIGF4aXMgPSB0aGlzLmdldEF4aXMoJ3gnLCB4QXhpc01vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh5QXhpc01vZGVsKSB7XG4gICAgICAgICAgICBheGlzID0gdGhpcy5nZXRBeGlzKCd5JywgeUF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG93ZXN0IHByaW9yaXR5LlxuICAgICAgICBlbHNlIGlmIChncmlkTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBncmlkID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICBpZiAoZ3JpZCA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIGNhcnRlc2lhbiA9IHRoaXMuX2Nvb3Jkc0xpc3RbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge2NhcnRlc2lhbjogY2FydGVzaWFuLCBheGlzOiBheGlzfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGltcGxlbWVudHNcbiAgICAgKiBzZWUge21vZHVsZTplY2hhcnRzL0Nvb2RpbmF0ZVN5c3RlbX1cbiAgICAgKi9cbiAgICBncmlkUHJvdG8uY29udGFpblBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHZhciBjb29yZCA9IHRoaXMuX2Nvb3Jkc0xpc3RbMF07XG4gICAgICAgIGlmIChjb29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkLmNvbnRhaW5Qb2ludChwb2ludCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBjYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW1zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBncmlkUHJvdG8uX2luaXRDYXJ0ZXNpYW4gPSBmdW5jdGlvbiAoZ3JpZE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgdmFyIGF4aXNQb3NpdGlvblVzZWQgPSB7XG4gICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgIHJpZ2h0OiBmYWxzZSxcbiAgICAgICAgICAgIHRvcDogZmFsc2UsXG4gICAgICAgICAgICBib3R0b206IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGF4ZXNNYXAgPSB7XG4gICAgICAgICAgICB4OiB7fSxcbiAgICAgICAgICAgIHk6IHt9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBheGVzQ291bnQgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vLyBDcmVhdGUgYXhpc1xuICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ3hBeGlzJywgY3JlYXRlQXhpc0NyZWF0b3IoJ3gnKSwgdGhpcyk7XG4gICAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgneUF4aXMnLCBjcmVhdGVBeGlzQ3JlYXRvcigneScpLCB0aGlzKTtcblxuICAgICAgICBpZiAoIWF4ZXNDb3VudC54IHx8ICFheGVzQ291bnQueSkge1xuICAgICAgICAgICAgLy8gUm9sbCBiYWNrIHdoZW4gdGhlcmUgbm8gZWl0aGVyIHggb3IgeSBheGlzXG4gICAgICAgICAgICB0aGlzLl9heGVzTWFwID0ge307XG4gICAgICAgICAgICB0aGlzLl9heGVzTGlzdCA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXhlc01hcCA9IGF4ZXNNYXA7XG5cbiAgICAgICAgLy8vIENyZWF0ZSBjYXJ0ZXNpYW4yZFxuICAgICAgICBlYWNoKGF4ZXNNYXAueCwgZnVuY3Rpb24gKHhBeGlzLCB4QXhpc0luZGV4KSB7XG4gICAgICAgICAgICBlYWNoKGF4ZXNNYXAueSwgZnVuY3Rpb24gKHlBeGlzLCB5QXhpc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9ICd4JyArIHhBeGlzSW5kZXggKyAneScgKyB5QXhpc0luZGV4O1xuICAgICAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW4gPSBuZXcgQ2FydGVzaWFuMkQoa2V5KTtcblxuICAgICAgICAgICAgICAgIGNhcnRlc2lhbi5ncmlkID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvb3Jkc01hcFtrZXldID0gY2FydGVzaWFuO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvb3Jkc0xpc3QucHVzaChjYXJ0ZXNpYW4pO1xuXG4gICAgICAgICAgICAgICAgY2FydGVzaWFuLmFkZEF4aXMoeEF4aXMpO1xuICAgICAgICAgICAgICAgIGNhcnRlc2lhbi5hZGRBeGlzKHlBeGlzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVBeGlzQ3JlYXRvcihheGlzVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChheGlzTW9kZWwsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNBeGlzVXNlZEluVGhlR3JpZChheGlzTW9kZWwsIGdyaWRNb2RlbCwgZWNNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBheGlzUG9zaXRpb24gPSBheGlzTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgICAgICAgICAgICAgIGlmIChheGlzVHlwZSA9PT0gJ3gnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpc1Bvc2l0aW9uICE9PSAndG9wJyAmJiBheGlzUG9zaXRpb24gIT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGJvdHRvbSBvZiBYXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzUG9zaXRpb24gPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzUG9zaXRpb25Vc2VkW2F4aXNQb3NpdGlvbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzUG9zaXRpb24gPSBheGlzUG9zaXRpb24gPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzUG9zaXRpb24gIT09ICdsZWZ0JyAmJiBheGlzUG9zaXRpb24gIT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgbGVmdCBvZiBZXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzUG9zaXRpb24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXhpc1Bvc2l0aW9uVXNlZFtheGlzUG9zaXRpb25dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc1Bvc2l0aW9uID0gYXhpc1Bvc2l0aW9uID09PSAnbGVmdCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF4aXNQb3NpdGlvblVzZWRbYXhpc1Bvc2l0aW9uXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IG5ldyBBeGlzMkQoXG4gICAgICAgICAgICAgICAgICAgIGF4aXNUeXBlLCBheGlzSGVscGVyLmNyZWF0ZVNjYWxlQnlNb2RlbChheGlzTW9kZWwpLFxuICAgICAgICAgICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgIGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSxcbiAgICAgICAgICAgICAgICAgICAgYXhpc1Bvc2l0aW9uXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHZhciBpc0NhdGVnb3J5ID0gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknO1xuICAgICAgICAgICAgICAgIGF4aXMub25CYW5kID0gaXNDYXRlZ29yeSAmJiBheGlzTW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuICAgICAgICAgICAgICAgIGF4aXMuaW52ZXJzZSA9IGF4aXNNb2RlbC5nZXQoJ2ludmVyc2UnKTtcblxuICAgICAgICAgICAgICAgIGF4aXMub25aZXJvID0gYXhpc01vZGVsLmdldCgnYXhpc0xpbmUub25aZXJvJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBJbmplY3QgYXhpcyBpbnRvIGF4aXNNb2RlbFxuICAgICAgICAgICAgICAgIGF4aXNNb2RlbC5heGlzID0gYXhpcztcblxuICAgICAgICAgICAgICAgIC8vIEluamVjdCBheGlzTW9kZWwgaW50byBheGlzXG4gICAgICAgICAgICAgICAgYXhpcy5tb2RlbCA9IGF4aXNNb2RlbDtcblxuICAgICAgICAgICAgICAgIC8vIEluamVjdCBncmlkIGluZm8gYXhpc1xuICAgICAgICAgICAgICAgIGF4aXMuZ3JpZCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAvLyBJbmRleCBvZiBheGlzLCBjYW4gYmUgdXNlZCBhcyBrZXlcbiAgICAgICAgICAgICAgICBheGlzLmluZGV4ID0gaWR4O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fYXhlc0xpc3QucHVzaChheGlzKTtcblxuICAgICAgICAgICAgICAgIGF4ZXNNYXBbYXhpc1R5cGVdW2lkeF0gPSBheGlzO1xuICAgICAgICAgICAgICAgIGF4ZXNDb3VudFtheGlzVHlwZV0rKztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNhcnRlc2lhbiBwcm9wZXJ0aWVzIGZyb20gc2VyaWVzXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9ufSBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdyaWRQcm90by5fdXBkYXRlU2NhbGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZ3JpZE1vZGVsKSB7XG4gICAgICAgIC8vIFJlc2V0IHNjYWxlXG4gICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuX2F4ZXNMaXN0LCBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgYXhpcy5zY2FsZS5zZXRFeHRlbnQoSW5maW5pdHksIC1JbmZpbml0eSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICBpZiAoaXNDYXJ0ZXNpYW4yRChzZXJpZXNNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhlc01vZGVscyA9IGZpbmRBeGVzTW9kZWxzKHNlcmllc01vZGVsLCBlY01vZGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgeEF4aXNNb2RlbCA9IGF4ZXNNb2RlbHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIHlBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc0F4aXNVc2VkSW5UaGVHcmlkKHhBeGlzTW9kZWwsIGdyaWRNb2RlbCwgZWNNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgfHwgIWlzQXhpc1VzZWRJblRoZUdyaWQoeUF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKVxuICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW4gPSB0aGlzLmdldENhcnRlc2lhbihcbiAgICAgICAgICAgICAgICAgICAgeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCwgeUF4aXNNb2RlbC5jb21wb25lbnRJbmRleFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgdmFyIHhBeGlzID0gY2FydGVzaWFuLmdldEF4aXMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgeUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QXhpcygneScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaW9uRXh0ZW50KGRhdGEsIHhBeGlzLCBzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIHVuaW9uRXh0ZW50KGRhdGEsIHlBeGlzLCBzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBmdW5jdGlvbiB1bmlvbkV4dGVudChkYXRhLCBheGlzLCBzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgZWFjaChzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShheGlzLmRpbSksIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICAgICAgICBheGlzLnNjYWxlLnVuaW9uRXh0ZW50RnJvbURhdGEoZGF0YSwgZGltKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUF4aXNUcmFuc2Zyb20oYXhpcywgY29vcmRCYXNlKSB7XG4gICAgICAgIHZhciBheGlzRXh0ZW50ID0gYXhpcy5nZXRFeHRlbnQoKTtcbiAgICAgICAgdmFyIGF4aXNFeHRlbnRTdW0gPSBheGlzRXh0ZW50WzBdICsgYXhpc0V4dGVudFsxXTtcblxuICAgICAgICAvLyBGYXN0IHRyYW5zZm9ybVxuICAgICAgICBheGlzLnRvR2xvYmFsQ29vcmQgPSBheGlzLmRpbSA9PT0gJ3gnXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb29yZCArIGNvb3JkQmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF4aXNFeHRlbnRTdW0gLSBjb29yZCArIGNvb3JkQmFzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGF4aXMudG9Mb2NhbENvb3JkID0gYXhpcy5kaW0gPT09ICd4J1xuICAgICAgICAgICAgPyBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29vcmQgLSBjb29yZEJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBheGlzRXh0ZW50U3VtIC0gY29vcmQgKyBjb29yZEJhc2U7XG4gICAgICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBheGVzVHlwZXMgPSBbJ3hBeGlzJywgJ3lBeGlzJ107XG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEF4ZXNNb2RlbHMoc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAoYXhlc1R5cGVzLCBmdW5jdGlvbiAoYXhpc1R5cGUpIHtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKGF4aXNUeXBlKVswXTtcblxuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXhpc1R5cGUgKyAnIFwiJyArIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldChheGlzVHlwZSArICdJbmRleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KGF4aXNUeXBlICsgJ0lkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICkgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF4aXNNb2RlbDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNDYXJ0ZXNpYW4yRChzZXJpZXNNb2RlbCkge1xuICAgICAgICByZXR1cm4gc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJykgPT09ICdjYXJ0ZXNpYW4yZCc7XG4gICAgfVxuXG4gICAgR3JpZC5jcmVhdGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHZhciBncmlkcyA9IFtdO1xuICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ2dyaWQnLCBmdW5jdGlvbiAoZ3JpZE1vZGVsLCBpZHgpIHtcbiAgICAgICAgICAgIHZhciBncmlkID0gbmV3IEdyaWQoZ3JpZE1vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgZ3JpZC5uYW1lID0gJ2dyaWRfJyArIGlkeDtcbiAgICAgICAgICAgIGdyaWQucmVzaXplKGdyaWRNb2RlbCwgYXBpKTtcblxuICAgICAgICAgICAgZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSBncmlkO1xuXG4gICAgICAgICAgICBncmlkcy5wdXNoKGdyaWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJbmplY3QgdGhlIGNvb3JkaW5hdGVTeXN0ZW1zIGludG8gc2VyaWVzTW9kZWxcbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgaWYgKCFpc0NhcnRlc2lhbjJEKHNlcmllc01vZGVsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF4ZXNNb2RlbHMgPSBmaW5kQXhlc01vZGVscyhzZXJpZXNNb2RlbCwgZWNNb2RlbCk7XG4gICAgICAgICAgICB2YXIgeEF4aXNNb2RlbCA9IGF4ZXNNb2RlbHNbMF07XG4gICAgICAgICAgICB2YXIgeUF4aXNNb2RlbCA9IGF4ZXNNb2RlbHNbMV07XG5cbiAgICAgICAgICAgIHZhciBncmlkTW9kZWwgPSB4QXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKTtcblxuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWdyaWRNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAnR3JpZCBcIicgKyB6clV0aWwucmV0cmlldmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeEF4aXNNb2RlbC5nZXQoJ2dyaWRJbmRleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhBeGlzTW9kZWwuZ2V0KCdncmlkSWQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgICApICsgJ1wiIG5vdCBmb3VuZCdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHhBeGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpICE9PSB5QXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3hBeGlzIGFuZCB5QXhpcyBtdXN0IHVzZSB0aGUgc2FtZSBncmlkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICAgICAgICBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gZ3JpZC5nZXRDYXJ0ZXNpYW4oXG4gICAgICAgICAgICAgICAgeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCwgeUF4aXNNb2RlbC5jb21wb25lbnRJbmRleFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdyaWRzO1xuICAgIH07XG5cbiAgICAvLyBGb3IgZGVjaWRpbmcgd2hpY2ggZGltZW5zaW9ucyB0byB1c2Ugd2hlbiBjcmVhdGluZyBsaXN0IGRhdGFcbiAgICBHcmlkLmRpbWVuc2lvbnMgPSBDYXJ0ZXNpYW4yRC5wcm90b3R5cGUuZGltZW5zaW9ucztcblxuICAgIHJlcXVpcmUoJy4uLy4uL0Nvb3JkaW5hdGVTeXN0ZW0nKS5yZWdpc3RlcignY2FydGVzaWFuMmQnLCBHcmlkKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JpZDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEdyaWQg5piv5Zyo5pyJ55u06KeS5Z2Q5qCH57O755qE5pe25YCZ5b+F6aG76KaB5a2Y5Zyo55qEXG4vLyDmiYDku6Xov5nph4zkuZ/opoHooqsgQ2FydGVzaWFuMkQg5L6d6LWWXG5cblxuICAgIHJlcXVpcmUoJy4vQXhpc01vZGVsJyk7XG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvQ29tcG9uZW50Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudE1vZGVsLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2dyaWQnLFxuXG4gICAgICAgIGRlcGVuZGVuY2llczogWyd4QXhpcycsICd5QXhpcyddLFxuXG4gICAgICAgIGxheW91dE1vZGU6ICdib3gnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWR9XG4gICAgICAgICAqL1xuICAgICAgICBjb29yZGluYXRlU3lzdGVtOiBudWxsLFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgICAgemxldmVsOiAwLFxuICAgICAgICAgICAgejogMCxcbiAgICAgICAgICAgIGxlZnQ6ICcxMCUnLFxuICAgICAgICAgICAgdG9wOiA2MCxcbiAgICAgICAgICAgIHJpZ2h0OiAnMTAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogNjAsXG4gICAgICAgICAgICAvLyBJZiBncmlkIHNpemUgY29udGFpbiBsYWJlbFxuICAgICAgICAgICAgY29udGFpbkxhYmVsOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIHdpZHRoOiB7dG90YWxXaWR0aH0gLSBsZWZ0IC0gcmlnaHQsXG4gICAgICAgICAgICAvLyBoZWlnaHQ6IHt0b3RhbEhlaWdodH0gLSB0b3AgLSBib3R0b20sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjY2NjJ1xuICAgICAgICB9XG4gICAgfSk7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3IgYXhpc0xhYmVsSW50ZXJ2YWwgY2FsY3VsYXRpb25cbiAqL1xuXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoJy4uL2F4aXNIZWxwZXInKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gICAgICAgIHZhciBsYWJlbE1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKTtcbiAgICAgICAgdmFyIGxhYmVsSW50ZXJ2YWwgPSBsYWJlbE1vZGVsLmdldCgnaW50ZXJ2YWwnKTtcbiAgICAgICAgaWYgKCEoYXhpcy50eXBlID09PSAnY2F0ZWdvcnknICYmIGxhYmVsSW50ZXJ2YWwgPT09ICdhdXRvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbEludGVydmFsID09PSAnYXV0bycgPyAwIDogbGFiZWxJbnRlcnZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBheGlzSGVscGVyLmdldEF4aXNMYWJlbEludGVydmFsKFxuICAgICAgICAgICAgenJVdGlsLm1hcChheGlzLnNjYWxlLmdldFRpY2tzKCksIGF4aXMuZGF0YVRvQ29vcmQsIGF4aXMpLFxuICAgICAgICAgICAgYXhpc01vZGVsLmdldEZvcm1hdHRlZExhYmVscygpLFxuICAgICAgICAgICAgbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJykuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgYXhpcy5pc0hvcml6b250YWwoKVxuICAgICAgICApO1xuICAgIH07XG4iLCJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQXhpcyA9IHJlcXVpcmUoJy4uL0F4aXMnKTtcblxuICAgIGZ1bmN0aW9uIEluZGljYXRvckF4aXMoZGltLCBzY2FsZSwgcmFkaXVzRXh0ZW50KSB7XG4gICAgICAgIEF4aXMuY2FsbCh0aGlzLCBkaW0sIHNjYWxlLCByYWRpdXNFeHRlbnQpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBeGlzIHR5cGVcbiAgICAgICAgICogIC0gJ2NhdGVnb3J5J1xuICAgICAgICAgKiAgLSAndmFsdWUnXG4gICAgICAgICAqICAtICd0aW1lJ1xuICAgICAgICAgKiAgLSAnbG9nJ1xuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ3ZhbHVlJztcblxuICAgICAgICB0aGlzLmFuZ2xlID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdG9yIG5hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb2RlbDtcbiAgICB9XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoSW5kaWNhdG9yQXhpcywgQXhpcyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEluZGljYXRvckF4aXM7XG4iLCIvLyBUT0RPIGNsb2Nrd2lzZVxuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIEluZGljYXRvckF4aXMgPSByZXF1aXJlKCcuL0luZGljYXRvckF4aXMnKTtcbiAgICB2YXIgSW50ZXJ2YWxTY2FsZSA9IHJlcXVpcmUoJy4uLy4uL3NjYWxlL0ludGVydmFsJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpO1xuICAgIHZhciBheGlzSGVscGVyID0gcmVxdWlyZSgnLi4vYXhpc0hlbHBlcicpO1xuXG4gICAgZnVuY3Rpb24gUmFkYXIocmFkYXJNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgdGhpcy5fbW9kZWwgPSByYWRhck1vZGVsO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmFkYXIgZGltZW5zaW9uc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMgPSBbXTtcblxuICAgICAgICB0aGlzLl9pbmRpY2F0b3JBeGVzID0genJVdGlsLm1hcChyYWRhck1vZGVsLmdldEluZGljYXRvck1vZGVscygpLCBmdW5jdGlvbiAoaW5kaWNhdG9yTW9kZWwsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGRpbSA9ICdpbmRpY2F0b3JfJyArIGlkeDtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3JBeGlzID0gbmV3IEluZGljYXRvckF4aXMoZGltLCBuZXcgSW50ZXJ2YWxTY2FsZSgpKTtcbiAgICAgICAgICAgIGluZGljYXRvckF4aXMubmFtZSA9IGluZGljYXRvck1vZGVsLmdldCgnbmFtZScpO1xuICAgICAgICAgICAgLy8gSW5qZWN0IG1vZGVsIGFuZCBheGlzXG4gICAgICAgICAgICBpbmRpY2F0b3JBeGlzLm1vZGVsID0gaW5kaWNhdG9yTW9kZWw7XG4gICAgICAgICAgICBpbmRpY2F0b3JNb2RlbC5heGlzID0gaW5kaWNhdG9yQXhpcztcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9ucy5wdXNoKGRpbSk7XG4gICAgICAgICAgICByZXR1cm4gaW5kaWNhdG9yQXhpcztcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5yZXNpemUocmFkYXJNb2RlbCwgYXBpKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN4O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN5O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRBbmdsZTtcbiAgICB9XG5cbiAgICBSYWRhci5wcm90b3R5cGUuZ2V0SW5kaWNhdG9yQXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGljYXRvckF4ZXM7XG4gICAgfTtcblxuICAgIFJhZGFyLnByb3RvdHlwZS5kYXRhVG9Qb2ludCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kaWNhdG9ySW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGljYXRvckF4aXMgPSB0aGlzLl9pbmRpY2F0b3JBeGVzW2luZGljYXRvckluZGV4XTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb29yZFRvUG9pbnQoaW5kaWNhdG9yQXhpcy5kYXRhVG9Db29yZCh2YWx1ZSksIGluZGljYXRvckluZGV4KTtcbiAgICB9O1xuXG4gICAgUmFkYXIucHJvdG90eXBlLmNvb3JkVG9Qb2ludCA9IGZ1bmN0aW9uIChjb29yZCwgaW5kaWNhdG9ySW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGljYXRvckF4aXMgPSB0aGlzLl9pbmRpY2F0b3JBeGVzW2luZGljYXRvckluZGV4XTtcbiAgICAgICAgdmFyIGFuZ2xlID0gaW5kaWNhdG9yQXhpcy5hbmdsZTtcbiAgICAgICAgdmFyIHggPSB0aGlzLmN4ICsgY29vcmQgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHZhciB5ID0gdGhpcy5jeSAtIGNvb3JkICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH07XG5cbiAgICBSYWRhci5wcm90b3R5cGUucG9pbnRUb0RhdGEgPSBmdW5jdGlvbiAocHQpIHtcbiAgICAgICAgdmFyIGR4ID0gcHRbMF0gLSB0aGlzLmN4O1xuICAgICAgICB2YXIgZHkgPSBwdFsxXSAtIHRoaXMuY3k7XG4gICAgICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBkeCAvPSByYWRpdXM7XG4gICAgICAgIGR5IC89IHJhZGl1cztcblxuICAgICAgICB2YXIgcmFkaWFuID0gTWF0aC5hdGFuMigtZHksIGR4KTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGFuZ2xlXG4gICAgICAgIC8vIEZJWE1FIGluZGV4IGNhbiBjYWxjdWxhdGVkIGRpcmVjdGx5XG4gICAgICAgIHZhciBtaW5SYWRpYW5EaWZmID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBjbG9zZXN0QXhpcztcbiAgICAgICAgdmFyIGNsb3Nlc3RBeGlzSWR4ID0gLTE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW5kaWNhdG9yQXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGluZGljYXRvckF4aXMgPSB0aGlzLl9pbmRpY2F0b3JBeGVzW2ldO1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhyYWRpYW4gLSBpbmRpY2F0b3JBeGlzLmFuZ2xlKTtcbiAgICAgICAgICAgIGlmIChkaWZmIDwgbWluUmFkaWFuRGlmZikge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RBeGlzID0gaW5kaWNhdG9yQXhpcztcbiAgICAgICAgICAgICAgICBjbG9zZXN0QXhpc0lkeCA9IGk7XG4gICAgICAgICAgICAgICAgbWluUmFkaWFuRGlmZiA9IGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2Nsb3Nlc3RBeGlzSWR4LCArKGNsb3Nlc3RBeGlzICYmIGNsb3Nlc3RBeGlzLmNvb2RUb0RhdGEocmFkaXVzKSldO1xuICAgIH07XG5cbiAgICBSYWRhci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHJhZGFyTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgY2VudGVyID0gcmFkYXJNb2RlbC5nZXQoJ2NlbnRlcicpO1xuICAgICAgICB2YXIgdmlld1dpZHRoID0gYXBpLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciB2aWV3SGVpZ2h0ID0gYXBpLmdldEhlaWdodCgpO1xuICAgICAgICB2YXIgdmlld1NpemUgPSBNYXRoLm1pbih2aWV3V2lkdGgsIHZpZXdIZWlnaHQpIC8gMjtcbiAgICAgICAgdGhpcy5jeCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGNlbnRlclswXSwgdmlld1dpZHRoKTtcbiAgICAgICAgdGhpcy5jeSA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGNlbnRlclsxXSwgdmlld0hlaWdodCk7XG5cbiAgICAgICAgdGhpcy5zdGFydEFuZ2xlID0gcmFkYXJNb2RlbC5nZXQoJ3N0YXJ0QW5nbGUnKSAqIE1hdGguUEkgLyAxODA7XG5cbiAgICAgICAgdGhpcy5yID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQocmFkYXJNb2RlbC5nZXQoJ3JhZGl1cycpLCB2aWV3U2l6ZSk7XG5cbiAgICAgICAgenJVdGlsLmVhY2godGhpcy5faW5kaWNhdG9yQXhlcywgZnVuY3Rpb24gKGluZGljYXRvckF4aXMsIGlkeCkge1xuICAgICAgICAgICAgaW5kaWNhdG9yQXhpcy5zZXRFeHRlbnQoMCwgdGhpcy5yKTtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyBpZHggKiBNYXRoLlBJICogMiAvIHRoaXMuX2luZGljYXRvckF4ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBbLVBJLCBQSV1cbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihNYXRoLnNpbihhbmdsZSksIE1hdGguY29zKGFuZ2xlKSk7XG4gICAgICAgICAgICBpbmRpY2F0b3JBeGlzLmFuZ2xlID0gYW5nbGU7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICBSYWRhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgaW5kaWNhdG9yQXhlcyA9IHRoaXMuX2luZGljYXRvckF4ZXM7XG4gICAgICAgIHZhciByYWRhck1vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgICAgIHpyVXRpbC5lYWNoKGluZGljYXRvckF4ZXMsIGZ1bmN0aW9uIChpbmRpY2F0b3JBeGlzKSB7XG4gICAgICAgICAgICBpbmRpY2F0b3JBeGlzLnNjYWxlLnNldEV4dGVudChJbmZpbml0eSwgLUluZmluaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgncmFkYXInLCBmdW5jdGlvbiAocmFkYXJTZXJpZXMsIGlkeCkge1xuICAgICAgICAgICAgaWYgKHJhZGFyU2VyaWVzLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpICE9PSAncmFkYXInXG4gICAgICAgICAgICAgICAgfHwgZWNNb2RlbC5nZXRDb21wb25lbnQoJ3JhZGFyJywgcmFkYXJTZXJpZXMuZ2V0KCdyYWRhckluZGV4JykpICE9PSByYWRhck1vZGVsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHJhZGFyU2VyaWVzLmdldERhdGEoKTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGluZGljYXRvckF4ZXMsIGZ1bmN0aW9uIChpbmRpY2F0b3JBeGlzKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yQXhpcy5zY2FsZS51bmlvbkV4dGVudEZyb21EYXRhKGRhdGEsIGluZGljYXRvckF4aXMuZGltKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB2YXIgc3BsaXROdW1iZXIgPSByYWRhck1vZGVsLmdldCgnc3BsaXROdW1iZXInKTtcblxuICAgICAgICBmdW5jdGlvbiBpbmNyZWFzZUludGVydmFsKGludGVydmFsKSB7XG4gICAgICAgICAgICB2YXIgZXhwMTAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhpbnRlcnZhbCkgLyBNYXRoLkxOMTApKTtcbiAgICAgICAgICAgIC8vIEluY3JlYXNlIGludGVydmFsXG4gICAgICAgICAgICB2YXIgZiA9IGludGVydmFsIC8gZXhwMTA7XG4gICAgICAgICAgICBpZiAoZiA9PT0gMikge1xuICAgICAgICAgICAgICAgIGYgPSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIGYgaXMgMiBvciA1XG4gICAgICAgICAgICAgICAgZiAqPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGYgKiBleHAxMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3JjZSBhbGwgdGhlIGF4aXMgZml4aW5nIHRoZSBtYXhTcGxpdE51bWJlci5cbiAgICAgICAgenJVdGlsLmVhY2goaW5kaWNhdG9yQXhlcywgZnVuY3Rpb24gKGluZGljYXRvckF4aXMsIGlkeCkge1xuICAgICAgICAgICAgdmFyIHJhd0V4dGVudCA9IGF4aXNIZWxwZXIuZ2V0U2NhbGVFeHRlbnQoaW5kaWNhdG9yQXhpcywgaW5kaWNhdG9yQXhpcy5tb2RlbCk7XG4gICAgICAgICAgICBheGlzSGVscGVyLm5pY2VTY2FsZUV4dGVudChpbmRpY2F0b3JBeGlzLCBpbmRpY2F0b3JBeGlzLm1vZGVsKTtcblxuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGluZGljYXRvckF4aXMubW9kZWw7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBpbmRpY2F0b3JBeGlzLnNjYWxlO1xuICAgICAgICAgICAgdmFyIGZpeGVkTWluID0gYXhpc01vZGVsLmdldE1pbigpO1xuICAgICAgICAgICAgdmFyIGZpeGVkTWF4ID0gYXhpc01vZGVsLmdldE1heCgpO1xuICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2NhbGUuZ2V0SW50ZXJ2YWwoKTtcblxuICAgICAgICAgICAgaWYgKGZpeGVkTWluICE9IG51bGwgJiYgZml4ZWRNYXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFVzZXIgc2V0IG1pbiwgbWF4LCBkaXZpZGUgdG8gZ2V0IG5ldyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIC8vIEZJWE1FIHByZWNpc2lvblxuICAgICAgICAgICAgICAgIHNjYWxlLnNldEludGVydmFsKFxuICAgICAgICAgICAgICAgICAgICAoZml4ZWRNYXggLSBmaXhlZE1pbikgLyBzcGxpdE51bWJlclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaXhlZE1pbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heDtcbiAgICAgICAgICAgICAgICAvLyBVc2VyIHNldCBtaW4sIGV4cGFuZCBleHRlbnQgb24gdGhlIG90aGVyIHNpZGVcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGZpeGVkTWluICsgaW50ZXJ2YWwgKiBzcGxpdE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUuc2V0RXh0ZW50KCtmaXhlZE1pbiwgbWF4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJ2YWwgbXVzdCBiZWVuIHNldCBhZnRlciBleHRlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUuc2V0SW50ZXJ2YWwoaW50ZXJ2YWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsID0gaW5jcmVhc2VJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAobWF4IDwgcmF3RXh0ZW50WzFdICYmIGlzRmluaXRlKG1heCkgJiYgaXNGaW5pdGUocmF3RXh0ZW50WzFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaXhlZE1heCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbjtcbiAgICAgICAgICAgICAgICAvLyBVc2VyIHNldCBtaW4sIGV4cGFuZCBleHRlbnQgb24gdGhlIG90aGVyIHNpZGVcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGZpeGVkTWF4IC0gaW50ZXJ2YWwgKiBzcGxpdE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUuc2V0RXh0ZW50KG1pbiwgK2ZpeGVkTWF4KTtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUuc2V0SW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCA9IGluY3JlYXNlSW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKG1pbiA+IHJhd0V4dGVudFswXSAmJiBpc0Zpbml0ZShtaW4pICYmIGlzRmluaXRlKHJhd0V4dGVudFswXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5pY2VkU3BsaXROdW1iZXIgPSBzY2FsZS5nZXRUaWNrcygpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKG5pY2VkU3BsaXROdW1iZXIgPiBzcGxpdE51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCA9IGluY3JlYXNlSW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IE1hdGgucm91bmQoKHJhd0V4dGVudFswXSArIHJhd0V4dGVudFsxXSkgLyAyIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgdmFyIGhhbGZTcGxpdE51bWJlciA9IE1hdGgucm91bmQoc3BsaXROdW1iZXIgLyAyKTtcbiAgICAgICAgICAgICAgICBzY2FsZS5zZXRFeHRlbnQoXG4gICAgICAgICAgICAgICAgICAgIG51bWJlclV0aWwucm91bmQoY2VudGVyIC0gaGFsZlNwbGl0TnVtYmVyICogaW50ZXJ2YWwpLFxuICAgICAgICAgICAgICAgICAgICBudW1iZXJVdGlsLnJvdW5kKGNlbnRlciArIChzcGxpdE51bWJlciAtIGhhbGZTcGxpdE51bWJlcikgKiBpbnRlcnZhbClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHNjYWxlLnNldEludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJhZGFyIGRpbWVuc2lvbnMgaXMgYmFzZWQgb24gdGhlIGRhdGFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgUmFkYXIuZGltZW5zaW9ucyA9IFtdO1xuXG4gICAgUmFkYXIuY3JlYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgcmFkYXJMaXN0ID0gW107XG4gICAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgncmFkYXInLCBmdW5jdGlvbiAocmFkYXJNb2RlbCkge1xuICAgICAgICAgICAgdmFyIHJhZGFyID0gbmV3IFJhZGFyKHJhZGFyTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICByYWRhckxpc3QucHVzaChyYWRhcik7XG4gICAgICAgICAgICByYWRhck1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSByYWRhcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgncmFkYXInLCBmdW5jdGlvbiAocmFkYXJTZXJpZXMpIHtcbiAgICAgICAgICAgIGlmIChyYWRhclNlcmllcy5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKSA9PT0gJ3JhZGFyJykge1xuICAgICAgICAgICAgICAgIC8vIEluamVjdCBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgICAgICAgICAgIHJhZGFyU2VyaWVzLmNvb3JkaW5hdGVTeXN0ZW0gPSByYWRhckxpc3RbcmFkYXJTZXJpZXMuZ2V0KCdyYWRhckluZGV4JykgfHwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmFkYXJMaXN0O1xuICAgIH07XG5cbiAgICByZXF1aXJlKCcuLi8uLi9Db29yZGluYXRlU3lzdGVtJykucmVnaXN0ZXIoJ3JhZGFyJywgUmFkYXIpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gUmFkYXI7XG4iLCJcblxuXG4gICAgdmFyIGF4aXNEZWZhdWx0ID0gcmVxdWlyZSgnLi4vYXhpc0RlZmF1bHQnKTtcbiAgICB2YXIgdmFsdWVBeGlzRGVmYXVsdCA9IGF4aXNEZWZhdWx0LnZhbHVlQXhpcztcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9Nb2RlbCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBheGlzTW9kZWxDb21tb25NaXhpbiA9IHJlcXVpcmUoJy4uL2F4aXNNb2RlbENvbW1vbk1peGluJyk7XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0c1Nob3cob3B0LCBzaG93KSB7XG4gICAgICAgIHJldHVybiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgICAgc2hvdzogc2hvd1xuICAgICAgICB9LCBvcHQpO1xuICAgIH1cblxuICAgIHZhciBSYWRhck1vZGVsID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENvbXBvbmVudE1vZGVsKHtcblxuICAgICAgICB0eXBlOiAncmFkYXInLFxuXG4gICAgICAgIG9wdGlvblVwZGF0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib3VuZGFyeUdhcCA9IHRoaXMuZ2V0KCdib3VuZGFyeUdhcCcpO1xuICAgICAgICAgICAgdmFyIHNwbGl0TnVtYmVyID0gdGhpcy5nZXQoJ3NwbGl0TnVtYmVyJyk7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldCgnc2NhbGUnKTtcbiAgICAgICAgICAgIHZhciBheGlzTGluZSA9IHRoaXMuZ2V0KCdheGlzTGluZScpO1xuICAgICAgICAgICAgdmFyIGF4aXNUaWNrID0gdGhpcy5nZXQoJ2F4aXNUaWNrJyk7XG4gICAgICAgICAgICB2YXIgYXhpc0xhYmVsID0gdGhpcy5nZXQoJ2F4aXNMYWJlbCcpO1xuICAgICAgICAgICAgdmFyIG5hbWVUZXh0U3R5bGUgPSB0aGlzLmdldCgnbmFtZS50ZXh0U3R5bGUnKTtcbiAgICAgICAgICAgIHZhciBzaG93TmFtZSA9IHRoaXMuZ2V0KCduYW1lLnNob3cnKTtcbiAgICAgICAgICAgIHZhciBuYW1lRm9ybWF0dGVyID0gdGhpcy5nZXQoJ25hbWUuZm9ybWF0dGVyJyk7XG4gICAgICAgICAgICB2YXIgbmFtZUdhcCA9IHRoaXMuZ2V0KCduYW1lR2FwJyk7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlckV2ZW50ID0gdGhpcy5nZXQoJ3RyaWdnZXJFdmVudCcpO1xuXG4gICAgICAgICAgICB2YXIgaW5kaWNhdG9yTW9kZWxzID0genJVdGlsLm1hcCh0aGlzLmdldCgnaW5kaWNhdG9yJykgfHwgW10sIGZ1bmN0aW9uIChpbmRpY2F0b3JPcHQpIHtcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgaWYgKGluZGljYXRvck9wdC5tYXggIT0gbnVsbCAmJiBpbmRpY2F0b3JPcHQubWF4ID4gMCAmJiAhaW5kaWNhdG9yT3B0Lm1pbikge1xuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JPcHQubWluID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5kaWNhdG9yT3B0Lm1pbiAhPSBudWxsICYmIGluZGljYXRvck9wdC5taW4gPCAwICYmICFpbmRpY2F0b3JPcHQubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvck9wdC5tYXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVc2Ugc2FtZSBjb25maWd1cmF0aW9uXG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yT3B0ID0genJVdGlsLm1lcmdlKHpyVXRpbC5jbG9uZShpbmRpY2F0b3JPcHQpLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5R2FwOiBib3VuZGFyeUdhcCxcbiAgICAgICAgICAgICAgICAgICAgc3BsaXROdW1iZXI6IHNwbGl0TnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGF4aXNMaW5lOiBheGlzTGluZSxcbiAgICAgICAgICAgICAgICAgICAgYXhpc1RpY2s6IGF4aXNUaWNrLFxuICAgICAgICAgICAgICAgICAgICBheGlzTGFiZWw6IGF4aXNMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGV0aXRhYmxlIHdpdGggMiBhbmQgdXNlIHRleHRcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaW5kaWNhdG9yT3B0LnRleHQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVMb2NhdGlvbjogJ2VuZCcsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVHYXA6IG5hbWVHYXAsXG4gICAgICAgICAgICAgICAgICAgIC8vIG1pbjogMCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZVRleHRTdHlsZTogbmFtZVRleHRTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50OiB0cmlnZ2VyRXZlbnRcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzaG93TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JPcHQubmFtZSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5hbWVGb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmROYW1lID0gaW5kaWNhdG9yT3B0Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvck9wdC5uYW1lID0gbmFtZUZvcm1hdHRlci5yZXBsYWNlKCd7dmFsdWV9JywgaW5kTmFtZSAhPSBudWxsID8gaW5kTmFtZSA6ICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5hbWVGb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yT3B0Lm5hbWUgPSBuYW1lRm9ybWF0dGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yT3B0Lm5hbWUsIGluZGljYXRvck9wdFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbW9kZWwgPSB6clV0aWwuZXh0ZW5kKFxuICAgICAgICAgICAgICAgICAgICBuZXcgTW9kZWwoaW5kaWNhdG9yT3B0LCBudWxsLCB0aGlzLmVjTW9kZWwpLFxuICAgICAgICAgICAgICAgICAgICBheGlzTW9kZWxDb21tb25NaXhpblxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgdHJpZ2dlckV2ZW50LlxuICAgICAgICAgICAgICAgIG1vZGVsLm1haW5UeXBlID0gJ3JhZGFyJztcbiAgICAgICAgICAgICAgICBtb2RlbC5jb21wb25lbnRJbmRleCA9IHRoaXMuY29tcG9uZW50SW5kZXg7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5nZXRJbmRpY2F0b3JNb2RlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGljYXRvck1vZGVscztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuXG4gICAgICAgICAgICB6bGV2ZWw6IDAsXG5cbiAgICAgICAgICAgIHo6IDAsXG5cbiAgICAgICAgICAgIGNlbnRlcjogWyc1MCUnLCAnNTAlJ10sXG5cbiAgICAgICAgICAgIHJhZGl1czogJzc1JScsXG5cbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IDkwLFxuXG4gICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgICAgICAgICAgIC8vIGZvcm1hdHRlcjogbnVsbFxuICAgICAgICAgICAgICAgIC8vIHRleHRTdHlsZToge31cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGJvdW5kYXJ5R2FwOiBbMCwgMF0sXG5cbiAgICAgICAgICAgIHNwbGl0TnVtYmVyOiA1LFxuXG4gICAgICAgICAgICBuYW1lR2FwOiAxNSxcblxuICAgICAgICAgICAgc2NhbGU6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyBQb2x5Z29uIG9yIGNpcmNsZVxuICAgICAgICAgICAgc2hhcGU6ICdwb2x5Z29uJyxcblxuICAgICAgICAgICAgYXhpc0xpbmU6IHpyVXRpbC5tZXJnZShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjYmJiJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZUF4aXNEZWZhdWx0LmF4aXNMaW5lXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXhpc0xhYmVsOiBkZWZhdWx0c1Nob3codmFsdWVBeGlzRGVmYXVsdC5heGlzTGFiZWwsIGZhbHNlKSxcbiAgICAgICAgICAgIGF4aXNUaWNrOiBkZWZhdWx0c1Nob3codmFsdWVBeGlzRGVmYXVsdC5heGlzVGljaywgZmFsc2UpLFxuICAgICAgICAgICAgc3BsaXRMaW5lOiBkZWZhdWx0c1Nob3codmFsdWVBeGlzRGVmYXVsdC5zcGxpdExpbmUsIHRydWUpLFxuICAgICAgICAgICAgc3BsaXRBcmVhOiBkZWZhdWx0c1Nob3codmFsdWVBeGlzRGVmYXVsdC5zcGxpdEFyZWEsIHRydWUpLFxuXG4gICAgICAgICAgICAvLyB7dGV4dCwgbWluLCBtYXh9XG4gICAgICAgICAgICBpbmRpY2F0b3I6IFtdXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUmFkYXJNb2RlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEtleUdldHRlcihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERhdGFEaWZmZXIob2xkQXJyLCBuZXdBcnIsIG9sZEtleUdldHRlciwgbmV3S2V5R2V0dGVyKSB7XG4gICAgICAgIHRoaXMuX29sZCA9IG9sZEFycjtcbiAgICAgICAgdGhpcy5fbmV3ID0gbmV3QXJyO1xuXG4gICAgICAgIHRoaXMuX29sZEtleUdldHRlciA9IG9sZEtleUdldHRlciB8fCBkZWZhdWx0S2V5R2V0dGVyO1xuICAgICAgICB0aGlzLl9uZXdLZXlHZXR0ZXIgPSBuZXdLZXlHZXR0ZXIgfHwgZGVmYXVsdEtleUdldHRlcjtcbiAgICB9XG5cbiAgICBEYXRhRGlmZmVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogRGF0YURpZmZlcixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBhZGQgYSBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGQgPSBmdW5jO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdXBkYXRlIGEgZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlID0gZnVuYztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIHJlbW92ZSBhIGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZSA9IGZ1bmM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2xkQXJyID0gdGhpcy5fb2xkO1xuICAgICAgICAgICAgdmFyIG5ld0FyciA9IHRoaXMuX25ldztcbiAgICAgICAgICAgIHZhciBvbGRLZXlHZXR0ZXIgPSB0aGlzLl9vbGRLZXlHZXR0ZXI7XG4gICAgICAgICAgICB2YXIgbmV3S2V5R2V0dGVyID0gdGhpcy5fbmV3S2V5R2V0dGVyO1xuXG4gICAgICAgICAgICB2YXIgb2xkRGF0YUluZGV4TWFwID0ge307XG4gICAgICAgICAgICB2YXIgbmV3RGF0YUluZGV4TWFwID0ge307XG4gICAgICAgICAgICB2YXIgb2xkRGF0YUtleUFyciA9IFtdO1xuICAgICAgICAgICAgdmFyIG5ld0RhdGFLZXlBcnIgPSBbXTtcbiAgICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgICBpbml0SW5kZXhNYXAob2xkQXJyLCBvbGREYXRhSW5kZXhNYXAsIG9sZERhdGFLZXlBcnIsIG9sZEtleUdldHRlcik7XG4gICAgICAgICAgICBpbml0SW5kZXhNYXAobmV3QXJyLCBuZXdEYXRhSW5kZXhNYXAsIG5ld0RhdGFLZXlBcnIsIG5ld0tleUdldHRlcik7XG5cbiAgICAgICAgICAgIC8vIFRyYXZlbCBieSBpbnZlcnRlZCBvcmRlciB0byBtYWtlIHN1cmUgb3JkZXIgY29uc2lzdGVuY3lcbiAgICAgICAgICAgIC8vIHdoZW4gZHVwbGljYXRlIGtleXMgZXhpc3RzIChjb25zaWRlciBuZXdEYXRhSW5kZXgucG9wKCkgYmVsb3cpLlxuICAgICAgICAgICAgLy8gRm9yIHBlcmZvcm1hbmNlIGNvbnNpZGVyYXRpb24sIHRoZXNlIGNvZGUgYmVsb3cgZG8gbm90IGxvb2sgbmVhdC5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvbGRBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gb2xkRGF0YUtleUFycltpXTtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gbmV3RGF0YUluZGV4TWFwW2tleV07XG5cbiAgICAgICAgICAgICAgICAvLyBpZHggY2FuIG5ldmVyIGJlIGVtcHR5IGFycmF5IGhlcmUuIHNlZSAnc2V0IG51bGwnIGxvZ2ljIGJlbG93LlxuICAgICAgICAgICAgICAgIGlmIChpZHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlciB0aGVyZSBpcyBkdXBsaWNhdGUga2V5IChmb3IgZXhhbXBsZSwgdXNlIGRhdGFJdGVtLm5hbWUgYXMga2V5KS5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG1ha2Ugc3VyZSBldmVyeSBpdGVtIGluIG5ld0FyciBhbmQgb2xkQXJyIGNhbiBiZSB2aXNpdGVkLlxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gaWR4Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID09PSAxICYmIChuZXdEYXRhSW5kZXhNYXBba2V5XSA9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gaWR4LnVuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RhdGFJbmRleE1hcFtrZXldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUgJiYgdGhpcy5fdXBkYXRlKGlkeCwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmUgJiYgdGhpcy5fcmVtb3ZlKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdEYXRhS2V5QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IG5ld0RhdGFLZXlBcnJbaV07XG4gICAgICAgICAgICAgICAgaWYgKG5ld0RhdGFJbmRleE1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBuZXdEYXRhSW5kZXhNYXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZHggY2FuIG5ldmVyIGJlIGVtcHR5IGFycmF5IGhlcmUuIHNlZSAnc2V0IG51bGwnIGxvZ2ljIGFib3ZlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlkeC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZCAmJiB0aGlzLl9hZGQoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBpZHgubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGQgJiYgdGhpcy5fYWRkKGlkeFtqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW5pdEluZGV4TWFwKGFyciwgbWFwLCBrZXlBcnIsIGtleUdldHRlcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleUdldHRlcihhcnJbaV0sIGkpO1xuICAgICAgICAgICAgdmFyIGV4aXN0ZW5jZSA9IG1hcFtrZXldO1xuICAgICAgICAgICAgaWYgKGV4aXN0ZW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAga2V5QXJyLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICBtYXBba2V5XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwW2tleV0gPSBleGlzdGVuY2UgPSBbZXhpc3RlbmNlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhpc3RlbmNlLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IERhdGFEaWZmZXI7XG4iLCIvKipcbiAqIExpc3QgZm9yIGRhdGEgc3RvcmFnZVxuICogQG1vZHVsZSBlY2hhcnRzL2RhdGEvTGlzdFxuICovXG5cblxuICAgIHZhciBVTkRFRklORUQgPSAndW5kZWZpbmVkJztcbiAgICB2YXIgZ2xvYmFsT2JqID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3c7XG4gICAgdmFyIEZsb2F0NjRBcnJheSA9IHR5cGVvZiBnbG9iYWxPYmouRmxvYXQ2NEFycmF5ID09PSBVTkRFRklORURcbiAgICAgICAgPyBBcnJheSA6IGdsb2JhbE9iai5GbG9hdDY0QXJyYXk7XG4gICAgdmFyIEludDMyQXJyYXkgPSB0eXBlb2YgZ2xvYmFsT2JqLkludDMyQXJyYXkgPT09IFVOREVGSU5FRFxuICAgICAgICA/IEFycmF5IDogZ2xvYmFsT2JqLkludDMyQXJyYXk7XG5cbiAgICB2YXIgZGF0YUN0b3JzID0ge1xuICAgICAgICAnZmxvYXQnOiBGbG9hdDY0QXJyYXksXG4gICAgICAgICdpbnQnOiBJbnQzMkFycmF5LFxuICAgICAgICAvLyBPcmRpbmFsIGRhdGEgdHlwZSBjYW4gYmUgc3RyaW5nIG9yIGludFxuICAgICAgICAnb3JkaW5hbCc6IEFycmF5LFxuICAgICAgICAnbnVtYmVyJzogQXJyYXksXG4gICAgICAgICd0aW1lJzogQXJyYXlcbiAgICB9O1xuXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWwvTW9kZWwnKTtcbiAgICB2YXIgRGF0YURpZmZlciA9IHJlcXVpcmUoJy4vRGF0YURpZmZlcicpO1xuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIGlzT2JqZWN0ID0genJVdGlsLmlzT2JqZWN0O1xuXG4gICAgdmFyIFRSQU5TRkVSQUJMRV9QUk9QRVJUSUVTID0gW1xuICAgICAgICAnc3RhY2tlZE9uJywgJ2hhc0l0ZW1PcHRpb24nLCAnX25hbWVMaXN0JywgJ19pZExpc3QnLCAnX3Jhd0RhdGEnXG4gICAgXTtcblxuICAgIHZhciB0cmFuc2ZlclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB6clV0aWwuZWFjaChUUkFOU0ZFUkFCTEVfUFJPUEVSVElFUy5jb25jYXQoYi5fX3dyYXBwZWRNZXRob2RzIHx8IFtdKSwgZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhW3Byb3BOYW1lXSA9IGJbcHJvcE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhLl9fd3JhcHBlZE1ldGhvZHMgPSBiLl9fd3JhcHBlZE1ldGhvZHM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGRpbWVuc2lvbnNcbiAgICAgKiAgICAgICAgRGltZW5zaW9ucyBzaG91bGQgYmUgY29uY3JldGUgbmFtZXMgbGlrZSB4LCB5LCB6LCBsbmcsIGxhdCwgYW5nbGUsIHJhZGl1c1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGhvc3RNb2RlbFxuICAgICAqL1xuICAgIHZhciBMaXN0ID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGhvc3RNb2RlbCkge1xuXG4gICAgICAgIGRpbWVuc2lvbnMgPSBkaW1lbnNpb25zIHx8IFsneCcsICd5J107XG5cbiAgICAgICAgdmFyIGRpbWVuc2lvbkluZm9zID0ge307XG4gICAgICAgIHZhciBkaW1lbnNpb25OYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25OYW1lO1xuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbkluZm8gPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGltZW5zaW9uc1tpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25OYW1lID0gZGltZW5zaW9uc1tpXTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25JbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBkaW1lbnNpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGFja2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAvLyBUeXBlIGNhbiBiZSAnZmxvYXQnLCAnaW50JywgJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBpcyBudW1iZXIsIFByZWNpc2lvbiBvZiBmbG9hdCBtYXkgbm90IGVub3VnaFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25JbmZvID0gZGltZW5zaW9uc1tpXTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25OYW1lID0gZGltZW5zaW9uSW5mby5uYW1lO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbkluZm8udHlwZSA9IGRpbWVuc2lvbkluZm8udHlwZSB8fCAnbnVtYmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpbWVuc2lvbk5hbWVzLnB1c2goZGltZW5zaW9uTmFtZSk7XG4gICAgICAgICAgICBkaW1lbnNpb25JbmZvc1tkaW1lbnNpb25OYW1lXSA9IGRpbWVuc2lvbkluZm87XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMgPSBkaW1lbnNpb25OYW1lcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5mb21hdGlvbiBvZiBlYWNoIGRhdGEgZGltZW5zaW9uLCBsaWtlIGRhdGEgdHlwZS5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RpbWVuc2lvbkluZm9zID0gZGltZW5zaW9uSW5mb3M7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaG9zdE1vZGVsID0gaG9zdE1vZGVsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGFUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2VzIHN0b3JlcyB0aGUgaW5kaWNlcyBvZiBkYXRhIHN1YnNldCBhZnRlciBmaWx0ZXJlZC5cbiAgICAgICAgICogVGhpcyBkYXRhIHN1YnNldCB3aWxsIGJlIHVzZWQgaW4gY2hhcnQuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGljZXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YSBzdG9yYWdlXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPGtleSwgVHlwZWRBcnJheXxBcnJheT59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdG9yYWdlID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25hbWVMaXN0ID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pZExpc3QgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVscyBvZiBkYXRhIG9wdGlvbiBpcyBzdG9yZWQgc3BhcnNlIGZvciBvcHRpbWl6aW5nIG1lbW9yeSBjb3N0XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb3B0aW9uTW9kZWxzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFja2VkT24gPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHbG9iYWwgdmlzdWFsIHByb3BlcnRpZXMgYWZ0ZXIgdmlzdWFsIGNvZGluZ1xuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdmlzdWFsID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdsb2JlbCBsYXlvdXQgcHJvcGVydGllcy5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xheW91dCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVtIHZpc3VhbCBwcm9wZXJ0aWVzIGFmdGVyIHZpc3VhbCBjb2RpbmdcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXRlbVZpc3VhbHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXRlbSBsYXlvdXQgcHJvcGVydGllcyBhZnRlciBsYXlvdXRcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXRlbUxheW91dHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGhpYyBlbGVtbmVudHNcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6enJlbmRlci9FbGVtZW50Pn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dyYXBoaWNFbHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxBcnJheXxPYmplY3Q+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmF3RGF0YTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2V4dGVudDtcbiAgICB9O1xuXG4gICAgdmFyIGxpc3RQcm90byA9IExpc3QucHJvdG90eXBlO1xuXG4gICAgbGlzdFByb3RvLnR5cGUgPSAnbGlzdCc7XG4gICAgLyoqXG4gICAgICogSWYgZWFjaCBkYXRhIGl0ZW0gaGFzIGl0J3Mgb3duIG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGxpc3RQcm90by5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEdldCBkaW1lbnNpb24gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZGltXG4gICAgICogICAgICAgIERpbWVuc2lvbiBjYW4gYmUgY29uY3JldGUgbmFtZXMgbGlrZSB4LCB5LCB6LCBsbmcsIGxhdCwgYW5nbGUsIHJhZGl1c1xuICAgICAqICAgICAgICBPciBhIG9yZGluYWwgbnVtYmVyLiBGb3IgZXhhbXBsZSBnZXREaW1lbnNpb25JbmZvKDApIHdpbGwgcmV0dXJuICd4JyBvciAnbG5nJyBvciAncmFkaXVzJ1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29uY3JldGUgZGltIG5hbWUuXG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgaWYgKCFpc05hTihkaW0pKSB7XG4gICAgICAgICAgICBkaW0gPSB0aGlzLmRpbWVuc2lvbnNbZGltXSB8fCBkaW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpbTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0eXBlIGFuZCBzdGFja2FibGUgaW5mbyBvZiBwYXJ0aWN1bGFyIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZGltXG4gICAgICogICAgICAgIERpbWVuc2lvbiBjYW4gYmUgY29uY3JldGUgbmFtZXMgbGlrZSB4LCB5LCB6LCBsbmcsIGxhdCwgYW5nbGUsIHJhZGl1c1xuICAgICAqICAgICAgICBPciBhIG9yZGluYWwgbnVtYmVyLiBGb3IgZXhhbXBsZSBnZXREaW1lbnNpb25JbmZvKDApIHdpbGwgcmV0dXJuICd4JyBvciAnbG5nJyBvciAncmFkaXVzJ1xuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXREaW1lbnNpb25JbmZvID0gZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICByZXR1cm4genJVdGlsLmNsb25lKHRoaXMuX2RpbWVuc2lvbkluZm9zW3RoaXMuZ2V0RGltZW5zaW9uKGRpbSldKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBmcm9tIGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3R8bnVtYmVyfEFycmF5Pn0gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IFtuYW1lTGlzdF1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZGltVmFsdWVHZXR0ZXJdIChkYXRhSXRlbSwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkgPT4gbnVtYmVyXG4gICAgICovXG4gICAgbGlzdFByb3RvLmluaXREYXRhID0gZnVuY3Rpb24gKGRhdGEsIG5hbWVMaXN0LCBkaW1WYWx1ZUdldHRlcikge1xuICAgICAgICBkYXRhID0gZGF0YSB8fCBbXTtcblxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmF3RGF0YSA9IGRhdGE7XG5cbiAgICAgICAgLy8gQ2xlYXJcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlID0ge307XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzID0gW107XG5cbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gICAgICAgIHZhciBzaXplID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHZhciBkaW1lbnNpb25JbmZvTWFwID0gdGhpcy5fZGltZW5zaW9uSW5mb3M7XG5cbiAgICAgICAgdmFyIGlkTGlzdCA9IFtdO1xuICAgICAgICB2YXIgbmFtZVJlcGVhdENvdW50ID0ge307XG5cbiAgICAgICAgbmFtZUxpc3QgPSBuYW1lTGlzdCB8fCBbXTtcblxuICAgICAgICAvLyBJbml0IHN0b3JhZ2VcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGltSW5mbyA9IGRpbWVuc2lvbkluZm9NYXBbZGltZW5zaW9uc1tpXV07XG4gICAgICAgICAgICB2YXIgRGF0YUN0b3IgPSBkYXRhQ3RvcnNbZGltSW5mby50eXBlXTtcbiAgICAgICAgICAgIHN0b3JhZ2VbZGltZW5zaW9uc1tpXV0gPSBuZXcgRGF0YUN0b3Ioc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghZGltVmFsdWVHZXR0ZXIpIHtcbiAgICAgICAgICAgIHNlbGYuaGFzSXRlbU9wdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQgZGltIHZhbHVlIGdldHRlclxuICAgICAgICBkaW1WYWx1ZUdldHRlciA9IGRpbVZhbHVlR2V0dGVyIHx8IGZ1bmN0aW9uIChkYXRhSXRlbSwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbW9kZWxVdGlsLmdldERhdGFJdGVtVmFsdWUoZGF0YUl0ZW0pO1xuICAgICAgICAgICAgLy8gSWYgYW55IGRhdGFJdGVtIGlzIGxpa2UgeyB2YWx1ZTogMTAgfVxuICAgICAgICAgICAgaWYgKG1vZGVsVXRpbC5pc0RhdGFJdGVtT3B0aW9uKGRhdGFJdGVtKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuaGFzSXRlbU9wdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxVdGlsLmNvbnZlckRhdGFWYWx1ZShcbiAgICAgICAgICAgICAgICAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVtkaW1JbmRleF1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdmFsdWUgaXMgYSBzaW5nbGUgbnVtYmVyIG9yIHNvbWV0aGluZyBlbHNlIG5vdCBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25JbmZvTWFwW2RpbU5hbWVdXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGRhdGEubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgdmFyIGRhdGFJdGVtID0gZGF0YVtpZHhdO1xuICAgICAgICAgICAgLy8gRWFjaCBkYXRhIGl0ZW0gaXMgdmFsdWVcbiAgICAgICAgICAgIC8vIFsxLCAyXVxuICAgICAgICAgICAgLy8gMlxuICAgICAgICAgICAgLy8gQmFyIGNoYXJ0LCBsaW5lIGNoYXJ0IHdoaWNoIHVzZXMgY2F0ZWdvcnkgYXhpc1xuICAgICAgICAgICAgLy8gb25seSBnaXZlcyB0aGUgJ3knIHZhbHVlLiAneCcgdmFsdWUgaXMgdGhlIGluZGljZXMgb2YgY2F0ZW9ncnlcbiAgICAgICAgICAgIC8vIFVzZSBhIHRlbXBWYWx1ZSB0byBub3JtYWxpemUgdGhlIHZhbHVlIHRvIGJlIGEgKHgsIHkpIHZhbHVlXG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBkYXRhIGJ5IGRpbWVuc2lvbnNcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltZW5zaW9ucy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBkaW0gPSBkaW1lbnNpb25zW2tdO1xuICAgICAgICAgICAgICAgIHZhciBkaW1TdG9yYWdlID0gc3RvcmFnZVtkaW1dO1xuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgTlVMTCBpcyBlbXB0eSBvciB6ZXJvXG4gICAgICAgICAgICAgICAgZGltU3RvcmFnZVtpZHhdID0gZGltVmFsdWVHZXR0ZXIoZGF0YUl0ZW0sIGRpbSwgaWR4LCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGlkeCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgdGhlIG5hbWUgaW4gb3B0aW9uIGFuZCBjcmVhdGUgaWRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIW5hbWVMaXN0W2ldKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gJiYgZGF0YVtpXS5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUxpc3RbaV0gPSBkYXRhW2ldLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lTGlzdFtpXSB8fCAnJztcbiAgICAgICAgICAgIC8vIFRyeSB1c2luZyB0aGUgaWQgaW4gb3B0aW9uXG4gICAgICAgICAgICB2YXIgaWQgPSBkYXRhW2ldICYmIGRhdGFbaV0uaWQ7XG5cbiAgICAgICAgICAgIGlmICghaWQgJiYgbmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBuYW1lIGFzIGlkIGFuZCBhZGQgY291bnRlciB0byBhdm9pZCBzYW1lIG5hbWVcbiAgICAgICAgICAgICAgICBuYW1lUmVwZWF0Q291bnRbbmFtZV0gPSBuYW1lUmVwZWF0Q291bnRbbmFtZV0gfHwgMDtcbiAgICAgICAgICAgICAgICBpZCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVSZXBlYXRDb3VudFtuYW1lXSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgKz0gJ19fZWNfXycgKyBuYW1lUmVwZWF0Q291bnRbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hbWVSZXBlYXRDb3VudFtuYW1lXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWQgJiYgKGlkTGlzdFtpXSA9IGlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX25hbWVMaXN0ID0gbmFtZUxpc3Q7XG4gICAgICAgIHRoaXMuX2lkTGlzdCA9IGlkTGlzdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kaWNlcy5sZW5ndGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB2YWx1ZS4gUmV0dXJuIE5hTiBpZiBpZHggaXMgb3V0IG9mIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW0gRGltIG11c3QgYmUgY29uY3JldGUgbmFtZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGFja1xuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGRpbSwgaWR4LCBzdGFjaykge1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSB0aGlzLmluZGljZXNbaWR4XTtcblxuICAgICAgICAvLyBJZiB2YWx1ZSBub3QgZXhpc3RzXG4gICAgICAgIGlmIChkYXRhSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IHN0b3JhZ2VbZGltXSAmJiBzdG9yYWdlW2RpbV1bZGF0YUluZGV4XTtcbiAgICAgICAgLy8gRklYTUUgb3JkaW5hbCBkYXRhIHR5cGUgaXMgbm90IHN0YWNrYWJsZVxuICAgICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25JbmZvID0gdGhpcy5fZGltZW5zaW9uSW5mb3NbZGltXTtcbiAgICAgICAgICAgIGlmIChkaW1lbnNpb25JbmZvICYmIGRpbWVuc2lvbkluZm8uc3RhY2thYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrZWRPbiA9IHRoaXMuc3RhY2tlZE9uO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFja2VkT24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IG5vIHN0YWNrZWQgZGF0YSBvZiBzdGFja2VkIG9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFja2VkVmFsdWUgPSBzdGFja2VkT24uZ2V0KGRpbSwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXJpbmcgcG9zaXRpdmUgc3RhY2ssIG5lZ2F0aXZlIHN0YWNrIGFuZCBlbXB0eSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgPj0gMCAmJiBzdGFja2VkVmFsdWUgPiAwKSAgLy8gUG9zaXRpdmUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICh2YWx1ZSA8PSAwICYmIHN0YWNrZWRWYWx1ZSA8IDApIC8vIE5lZ2F0aXZlIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc3RhY2tlZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrZWRPbiA9IHN0YWNrZWRPbi5zdGFja2VkT247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlIGZvciBtdWx0aSBkaW1lbnNpb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IFtkaW1lbnNpb25zXSBJZiBpZ25vcmVkLCB1c2luZyBhbGwgZGltZW5zaW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGFja1xuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0VmFsdWVzID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGlkeCwgc3RhY2spIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoZGltZW5zaW9ucykpIHtcbiAgICAgICAgICAgIHN0YWNrID0gaWR4O1xuICAgICAgICAgICAgaWR4ID0gZGltZW5zaW9ucztcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGltZW5zaW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5nZXQoZGltZW5zaW9uc1tpXSwgaWR4LCBzdGFjaykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgdmFsdWUgaXMgTmFOLiBJbmxjdWRpbmcgJy0nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmhhc1ZhbHVlID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICAgICAgdmFyIGRpbWVuc2lvbkluZm9zID0gdGhpcy5fZGltZW5zaW9uSW5mb3M7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaW1lbnNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gT3JkaW5hbCB0eXBlIGNhbiBiZSBzdHJpbmcgb3IgbnVtYmVyXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uSW5mb3NbZGltZW5zaW9uc1tpXV0udHlwZSAhPT0gJ29yZGluYWwnXG4gICAgICAgICAgICAgICAgJiYgaXNOYU4odGhpcy5nZXQoZGltZW5zaW9uc1tpXSwgaWR4KSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGV4dGVudCBvZiBkYXRhIGluIG9uZSBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbHRlclxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXREYXRhRXh0ZW50ID0gZnVuY3Rpb24gKGRpbSwgc3RhY2ssIGZpbHRlcikge1xuICAgICAgICBkaW0gPSB0aGlzLmdldERpbWVuc2lvbihkaW0pO1xuICAgICAgICB2YXIgZGltRGF0YSA9IHRoaXMuX3N0b3JhZ2VbZGltXTtcbiAgICAgICAgdmFyIGRpbUluZm8gPSB0aGlzLmdldERpbWVuc2lvbkluZm8oZGltKTtcbiAgICAgICAgc3RhY2sgPSAoZGltSW5mbyAmJiBkaW1JbmZvLnN0YWNrYWJsZSkgJiYgc3RhY2s7XG4gICAgICAgIHZhciBkaW1FeHRlbnQgPSAodGhpcy5fZXh0ZW50IHx8ICh0aGlzLl9leHRlbnQgPSB7fSkpW2RpbSArICghIXN0YWNrKV07XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKGRpbUV4dGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpbUV4dGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YXIgZGltSW5mbyA9IHRoaXMuX2RpbWVuc2lvbkluZm9zW2RpbV07XG4gICAgICAgIGlmIChkaW1EYXRhKSB7XG4gICAgICAgICAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgICAgICAgICAgLy8gdmFyIGlzT3JkaW5hbCA9IGRpbUluZm8udHlwZSA9PT0gJ29yZGluYWwnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldChkaW0sIGksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIC8vIGlmIChpc09yZGluYWwgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vICAgICB2YWx1ZSA9IHpyVXRpbC5pbmRleE9mKGRpbURhdGEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKHZhbHVlLCBkaW0sIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIDwgbWluICYmIChtaW4gPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID4gbWF4ICYmIChtYXggPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9leHRlbnRbZGltICsgISFzdGFja10gPSBbbWluLCBtYXhdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHN1bSBvZiBkYXRhIGluIG9uZSBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGFja1xuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRTdW0gPSBmdW5jdGlvbiAoZGltLCBzdGFjaykge1xuICAgICAgICB2YXIgZGltRGF0YSA9IHRoaXMuX3N0b3JhZ2VbZGltXTtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGlmIChkaW1EYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChkaW0sIGksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlIHRoZSBpbmRleCB3aXRoIGdpdmVuIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICAvLyBGSVhNRSBQcmVjaXNpb24gb2YgZmxvYXQgdmFsdWVcbiAgICBsaXN0UHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIChkaW0sIHZhbHVlKSB7XG4gICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgICAgICAgdmFyIGRpbURhdGEgPSBzdG9yYWdlW2RpbV07XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuXG4gICAgICAgIGlmIChkaW1EYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByYXdJbmRleCA9IGluZGljZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRpbURhdGFbcmF3SW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyZWl2ZSB0aGUgaW5kZXggd2l0aCBnaXZlbiBuYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYW1lXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5pbmRleE9mTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuICAgICAgICB2YXIgbmFtZUxpc3QgPSB0aGlzLl9uYW1lTGlzdDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHJhd0luZGV4ID0gaW5kaWNlc1tpXTtcbiAgICAgICAgICAgIGlmIChuYW1lTGlzdFtyYXdJbmRleF0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmUgdGhlIGluZGV4IHdpdGggZ2l2ZW4gcmF3IGRhdGEgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmluZGV4T2ZSYXdJbmRleCA9IGZ1bmN0aW9uIChyYXdJbmRleCkge1xuICAgICAgICAvLyBJbmRpY2VzIGFyZSBhc2NlbmRpbmdcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG5cbiAgICAgICAgLy8gSWYgcmF3SW5kZXggPT09IGRhdGFJbmRleFxuICAgICAgICB2YXIgcmF3RGF0YUluZGV4ID0gaW5kaWNlc1tyYXdJbmRleF07XG4gICAgICAgIGlmIChyYXdEYXRhSW5kZXggIT0gbnVsbCAmJiByYXdEYXRhSW5kZXggPT09IHJhd0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3SW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVmdCA9IDA7XG4gICAgICAgIHZhciByaWdodCA9IGluZGljZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICAgICAgICAgIHZhciBtaWQgPSAobGVmdCArIHJpZ2h0KSAvIDIgfCAwO1xuICAgICAgICAgICAgaWYgKGluZGljZXNbbWlkXSA8IHJhd0luZGV4KSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmRpY2VzW21pZF0gPiByYXdJbmRleCkge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyZWl2ZSB0aGUgaW5kZXggb2YgbmVhcmVzdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrIElmIGdpdmVuIHZhbHVlIGlzIGFmdGVyIHN0YWNrZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heERpc3RhbmNlPUluZmluaXR5XVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uaW5kZXhPZk5lYXJlc3QgPSBmdW5jdGlvbiAoZGltLCB2YWx1ZSwgc3RhY2ssIG1heERpc3RhbmNlKSB7XG4gICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgICAgICAgdmFyIGRpbURhdGEgPSBzdG9yYWdlW2RpbV07XG5cbiAgICAgICAgaWYgKG1heERpc3RhbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgIG1heERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmVhcmVzdElkeCA9IC0xO1xuICAgICAgICBpZiAoZGltRGF0YSkge1xuICAgICAgICAgICAgdmFyIG1pbkRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSB2YWx1ZSAtIHRoaXMuZ2V0KGRpbSwgaSwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5hYnMoZGlmZik7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBkaWZmIDw9IG1heERpc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICYmIChkaXN0IDwgbWluRGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRoZSBjYXNlIG9mIHR3byBkYXRhIGFyZSBzYW1lIG9uIHhBeGlzLCB3aGljaCBoYXMgc2VxdWVuY2UgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3cgdGhlIG5lYXJlc3QgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvZWNoYXJ0cy9pc3N1ZXMvMjg2OVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGRpc3QgPT09IG1pbkRpc3QgJiYgZGlmZiA+IDApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RJZHggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVhcmVzdElkeDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHJhdyBkYXRhIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0UmF3SW5kZXggPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHZhciByYXdJZHggPSB0aGlzLmluZGljZXNbaWR4XTtcbiAgICAgICAgcmV0dXJuIHJhd0lkeCA9PSBudWxsID8gLTEgOiByYXdJZHg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCByYXcgZGF0YSBpdGVtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0UmF3RGF0YUl0ZW0gPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYXdEYXRhW3RoaXMuZ2V0UmF3SW5kZXgoaWR4KV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtub3REZWZhdWx0SWR4PWZhbHNlXVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0TmFtZSA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWVMaXN0W3RoaXMuaW5kaWNlc1tpZHhdXSB8fCAnJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vdERlZmF1bHRJZHg9ZmFsc2VdXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRJZCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkTGlzdFt0aGlzLmluZGljZXNbaWR4XV0gfHwgKHRoaXMuZ2V0UmF3SW5kZXgoaWR4KSArICcnKTtcbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVEaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcbiAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShkaW1lbnNpb25zKSkge1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IFtkaW1lbnNpb25zXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIGl0ZXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgbGlzdC5lYWNoKCd4JywgZnVuY3Rpb24gKHgsIGlkeCkge30pO1xuICAgICAqICBsaXN0LmVhY2goWyd4JywgJ3knXSwgZnVuY3Rpb24gKHgsIHksIGlkeCkge30pO1xuICAgICAqICBsaXN0LmVhY2goZnVuY3Rpb24gKGlkeCkge30pXG4gICAgICovXG4gICAgbGlzdFByb3RvLmVhY2ggPSBmdW5jdGlvbiAoZGltcywgY2IsIHN0YWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGltcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29udGV4dCA9IHN0YWNrO1xuICAgICAgICAgICAgc3RhY2sgPSBjYjtcbiAgICAgICAgICAgIGNiID0gZGltcztcbiAgICAgICAgICAgIGRpbXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpbXMgPSB6clV0aWwubWFwKG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltcyksIHRoaXMuZ2V0RGltZW5zaW9uLCB0aGlzKTtcblxuICAgICAgICB2YXIgdmFsdWUgPSBbXTtcbiAgICAgICAgdmFyIGRpbVNpemUgPSBkaW1zLmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG5cbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIHN3aXRjaCAoZGltU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuZ2V0KGRpbXNbMF0sIGksIHN0YWNrKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLmdldChkaW1zWzBdLCBpLCBzdGFjayksIHRoaXMuZ2V0KGRpbXNbMV0sIGksIHN0YWNrKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltU2l6ZTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHRoaXMuZ2V0KGRpbXNba10sIGksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJbmRleFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGNiLmFwcGx5KGNvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIGZpbHRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICAgICAqL1xuICAgIGxpc3RQcm90by5maWx0ZXJTZWxmID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGNiLCBzdGFjaywgY29udGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIGRpbWVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBzdGFjaztcbiAgICAgICAgICAgIHN0YWNrID0gY2I7XG4gICAgICAgICAgICBjYiA9IGRpbWVuc2lvbnM7XG4gICAgICAgICAgICBkaW1lbnNpb25zID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBkaW1lbnNpb25zID0genJVdGlsLm1hcChcbiAgICAgICAgICAgIG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucyksIHRoaXMuZ2V0RGltZW5zaW9uLCB0aGlzXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIG5ld0luZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIHZhbHVlID0gW107XG4gICAgICAgIHZhciBkaW1TaXplID0gZGltZW5zaW9ucy5sZW5ndGg7XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2VlcDtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIGlmIChkaW1TaXplID09PSAxKSB7XG4gICAgICAgICAgICAgICAga2VlcCA9IGNiLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQsIHRoaXMuZ2V0KGRpbWVuc2lvbnNbMF0sIGksIHN0YWNrKSwgaVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGRpbVNpemU7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHRoaXMuZ2V0KGRpbWVuc2lvbnNba10sIGksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVba10gPSBpO1xuICAgICAgICAgICAgICAgIGtlZXAgPSBjYi5hcHBseShjb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2VlcCkge1xuICAgICAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRpY2VzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG5ld0luZGljZXM7XG5cbiAgICAgICAgLy8gUmVzZXQgZGF0YSBleHRlbnRcbiAgICAgICAgdGhpcy5fZXh0ZW50ID0ge307XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERhdGEgbWFwcGluZyB0byBhIHBsYWluIGFycmF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtkaW1lbnNpb25zXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGxpc3RQcm90by5tYXBBcnJheSA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBjYiwgc3RhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkaW1lbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gc3RhY2s7XG4gICAgICAgICAgICBzdGFjayA9IGNiO1xuICAgICAgICAgICAgY2IgPSBkaW1lbnNpb25zO1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmVhY2goZGltZW5zaW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2IgJiYgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH0sIHN0YWNrLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xvbmVMaXN0Rm9yTWFwQW5kU2FtcGxlKG9yaWdpbmFsLCBleGNsdWRlRGltZW5zaW9ucykge1xuICAgICAgICB2YXIgYWxsRGltZW5zaW9ucyA9IG9yaWdpbmFsLmRpbWVuc2lvbnM7XG4gICAgICAgIHZhciBsaXN0ID0gbmV3IExpc3QoXG4gICAgICAgICAgICB6clV0aWwubWFwKGFsbERpbWVuc2lvbnMsIG9yaWdpbmFsLmdldERpbWVuc2lvbkluZm8sIG9yaWdpbmFsKSxcbiAgICAgICAgICAgIG9yaWdpbmFsLmhvc3RNb2RlbFxuICAgICAgICApO1xuICAgICAgICAvLyBGSVhNRSBJZiBuZWVkcyBzdGFja2VkT24sIHZhbHVlIG1heSBhbHJlYWR5IGJlZW4gc3RhY2tlZFxuICAgICAgICB0cmFuc2ZlclByb3BlcnRpZXMobGlzdCwgb3JpZ2luYWwpO1xuXG4gICAgICAgIHZhciBzdG9yYWdlID0gbGlzdC5fc3RvcmFnZSA9IHt9O1xuICAgICAgICB2YXIgb3JpZ2luYWxTdG9yYWdlID0gb3JpZ2luYWwuX3N0b3JhZ2U7XG4gICAgICAgIC8vIEluaXQgc3RvcmFnZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbERpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaW0gPSBhbGxEaW1lbnNpb25zW2ldO1xuICAgICAgICAgICAgdmFyIGRpbVN0b3JlID0gb3JpZ2luYWxTdG9yYWdlW2RpbV07XG4gICAgICAgICAgICBpZiAoenJVdGlsLmluZGV4T2YoZXhjbHVkZURpbWVuc2lvbnMsIGRpbSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VbZGltXSA9IG5ldyBkaW1TdG9yZS5jb25zdHJ1Y3RvcihcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdG9yYWdlW2RpbV0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERpcmVjdCByZWZlcmVuY2UgZm9yIG90aGVyIGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICBzdG9yYWdlW2RpbV0gPSBvcmlnaW5hbFN0b3JhZ2VbZGltXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIG1hcHBpbmcgdG8gYSBuZXcgTGlzdCB3aXRoIGdpdmVuIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGxpc3RQcm90by5tYXAgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgY2IsIHN0YWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGRpbWVuc2lvbnMgPSB6clV0aWwubWFwKFxuICAgICAgICAgICAgbm9ybWFsaXplRGltZW5zaW9ucyhkaW1lbnNpb25zKSwgdGhpcy5nZXREaW1lbnNpb24sIHRoaXNcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgbGlzdCA9IGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZSh0aGlzLCBkaW1lbnNpb25zKTtcbiAgICAgICAgLy8gRm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGFsbCBpbW11dGFibGUuXG4gICAgICAgIC8vIFNvIHdlIGNhbiByZWZlcmVuY2UgdG8gdGhlIHNhbWUgdmFsdWVcbiAgICAgICAgdmFyIGluZGljZXMgPSBsaXN0LmluZGljZXMgPSB0aGlzLmluZGljZXM7XG5cbiAgICAgICAgdmFyIHN0b3JhZ2UgPSBsaXN0Ll9zdG9yYWdlO1xuXG4gICAgICAgIHZhciB0bXBSZXRWYWx1ZSA9IFtdO1xuICAgICAgICB0aGlzLmVhY2goZGltZW5zaW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgcmV0VmFsdWUgPSBjYiAmJiBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHJldFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBhIG51bWJlclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0VmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJldFZhbHVlWzBdID0gcmV0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldFZhbHVlID0gdG1wUmV0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpbSA9IGRpbWVuc2lvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW1TdG9yZSA9IHN0b3JhZ2VbZGltXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0lkeCA9IGluZGljZXNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpbVN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1TdG9yZVtyYXdJZHhdID0gcmV0VmFsdWVbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN0YWNrLCBjb250ZXh0KTtcblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTGFyZ2UgZGF0YSBkb3duIHNhbXBsaW5nIG9uIGdpdmVuIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNhbXBsZVZhbHVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2FtcGxlSW5kZXggU2FtcGxlIGluZGV4IGZvciBuYW1lIGFuZCBpZFxuICAgICAqL1xuICAgIGxpc3RQcm90by5kb3duU2FtcGxlID0gZnVuY3Rpb24gKGRpbWVuc2lvbiwgcmF0ZSwgc2FtcGxlVmFsdWUsIHNhbXBsZUluZGV4KSB7XG4gICAgICAgIHZhciBsaXN0ID0gY2xvbmVMaXN0Rm9yTWFwQW5kU2FtcGxlKHRoaXMsIFtkaW1lbnNpb25dKTtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuICAgICAgICB2YXIgdGFyZ2V0U3RvcmFnZSA9IGxpc3QuX3N0b3JhZ2U7XG5cbiAgICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcbiAgICAgICAgdmFyIGluZGljZXMgPSBsaXN0LmluZGljZXMgPSBbXTtcblxuICAgICAgICB2YXIgZnJhbWVWYWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIGZyYW1lSW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgZnJhbWVTaXplID0gTWF0aC5mbG9vcigxIC8gcmF0ZSk7XG5cbiAgICAgICAgdmFyIGRpbVN0b3JlID0gdGFyZ2V0U3RvcmFnZVtkaW1lbnNpb25dO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5jb3VudCgpO1xuICAgICAgICAvLyBDb3B5IGRhdGEgZnJvbSBvcmlnaW5hbCBkYXRhXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmFnZVtkaW1lbnNpb25dLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0YXJnZXRTdG9yYWdlW2RpbWVuc2lvbl1baV0gPSBzdG9yYWdlW2RpbWVuc2lvbl1baV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gZnJhbWVTaXplKSB7XG4gICAgICAgICAgICAvLyBMYXN0IGZyYW1lXG4gICAgICAgICAgICBpZiAoZnJhbWVTaXplID4gbGVuIC0gaSkge1xuICAgICAgICAgICAgICAgIGZyYW1lU2l6ZSA9IGxlbiAtIGk7XG4gICAgICAgICAgICAgICAgZnJhbWVWYWx1ZXMubGVuZ3RoID0gZnJhbWVTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBmcmFtZVNpemU7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBvcmlnaW5hbEluZGljZXNbaSArIGtdO1xuICAgICAgICAgICAgICAgIGZyYW1lVmFsdWVzW2tdID0gZGltU3RvcmVbaWR4XTtcbiAgICAgICAgICAgICAgICBmcmFtZUluZGljZXNba10gPSBpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzYW1wbGVWYWx1ZShmcmFtZVZhbHVlcyk7XG4gICAgICAgICAgICB2YXIgaWR4ID0gZnJhbWVJbmRpY2VzW3NhbXBsZUluZGV4KGZyYW1lVmFsdWVzLCB2YWx1ZSkgfHwgMF07XG4gICAgICAgICAgICAvLyBPbmx5IHdyaXRlIHZhbHVlIG9uIHRoZSBmaWx0ZXJlZCBkYXRhXG4gICAgICAgICAgICBkaW1TdG9yZVtpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaWR4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbW9kZWwgb2Ygb25lIGRhdGEgaXRlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKi9cbiAgICAvLyBGSVhNRSBNb2RlbCBwcm94eSA/XG4gICAgbGlzdFByb3RvLmdldEl0ZW1Nb2RlbCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGhvc3RNb2RlbCA9IHRoaXMuaG9zdE1vZGVsO1xuICAgICAgICBpZHggPSB0aGlzLmluZGljZXNbaWR4XTtcbiAgICAgICAgcmV0dXJuIG5ldyBNb2RlbCh0aGlzLl9yYXdEYXRhW2lkeF0sIGhvc3RNb2RlbCwgaG9zdE1vZGVsICYmIGhvc3RNb2RlbC5lY01vZGVsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGF0YSBkaWZmZXJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gb3RoZXJMaXN0XG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvZGF0YS9EYXRhRGlmZmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5kaWZmID0gZnVuY3Rpb24gKG90aGVyTGlzdCkge1xuICAgICAgICB2YXIgaWRMaXN0ID0gdGhpcy5faWRMaXN0O1xuICAgICAgICB2YXIgb3RoZXJJZExpc3QgPSBvdGhlckxpc3QgJiYgb3RoZXJMaXN0Ll9pZExpc3Q7XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIC8vIFVzZSBwcmVmaXggdG8gYXZvaWQgaW5kZXggdG8gYmUgdGhlIHNhbWUgYXMgb3RoZXJJZExpc3RbaWR4XSxcbiAgICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSB3ZWlyZCB1ZHBhdGUgYW5pbWF0aW9uLlxuICAgICAgICB2YXIgcHJlZml4ID0gJ2VcXDBcXDAnO1xuXG4gICAgICAgIHJldHVybiBuZXcgRGF0YURpZmZlcihcbiAgICAgICAgICAgIG90aGVyTGlzdCA/IG90aGVyTGlzdC5pbmRpY2VzIDogW10sXG4gICAgICAgICAgICB0aGlzLmluZGljZXMsXG4gICAgICAgICAgICBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWwgPSBvdGhlcklkTGlzdFtpZHhdKSAhPSBudWxsID8gdmFsIDogcHJlZml4ICsgaWR4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbCA9IGlkTGlzdFtpZHhdKSAhPSBudWxsID8gdmFsIDogcHJlZml4ICsgaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHZpc3VhbCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldFZpc3VhbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZpc3VhbCA9IHRoaXMuX3Zpc3VhbDtcbiAgICAgICAgcmV0dXJuIHZpc3VhbCAmJiB2aXN1YWxba2V5XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHZpc3VhbCBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBzZXRWaXN1YWwoJ2NvbG9yJywgY29sb3IpO1xuICAgICAqICBzZXRWaXN1YWwoe1xuICAgICAqICAgICAgJ2NvbG9yJzogY29sb3JcbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgbGlzdFByb3RvLnNldFZpc3VhbCA9IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmlzdWFsKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc3VhbCA9IHRoaXMuX3Zpc3VhbCB8fCB7fTtcbiAgICAgICAgdGhpcy5fdmlzdWFsW2tleV0gPSB2YWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBsYXlvdXQgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbF1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uc2V0TGF5b3V0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRMYXlvdXQobmFtZSwga2V5W25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGF5b3V0W2tleV0gPSB2YWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBsYXlvdXQgcHJvcGVydHkuXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkuXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0TGF5b3V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0W2tleV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0SXRlbUxheW91dCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1MYXlvdXRzW2lkeF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGF5b3V0XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gW21lcmdlPWZhbHNlXVxuICAgICAqL1xuICAgIGxpc3RQcm90by5zZXRJdGVtTGF5b3V0ID0gZnVuY3Rpb24gKGlkeCwgbGF5b3V0LCBtZXJnZSkge1xuICAgICAgICB0aGlzLl9pdGVtTGF5b3V0c1tpZHhdID0gbWVyZ2VcbiAgICAgICAgICAgID8genJVdGlsLmV4dGVuZCh0aGlzLl9pdGVtTGF5b3V0c1tpZHhdIHx8IHt9LCBsYXlvdXQpXG4gICAgICAgICAgICA6IGxheW91dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGxheW91dCBvZiBzaW5nbGUgZGF0YSBpdGVtXG4gICAgICovXG4gICAgbGlzdFByb3RvLmNsZWFySXRlbUxheW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1MYXlvdXRzLmxlbmd0aCA9IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB2aXN1YWwgcHJvcGVydHkgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVQYXJlbnRcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0SXRlbVZpc3VhbCA9IGZ1bmN0aW9uIChpZHgsIGtleSwgaWdub3JlUGFyZW50KSB7XG4gICAgICAgIHZhciBpdGVtVmlzdWFsID0gdGhpcy5faXRlbVZpc3VhbHNbaWR4XTtcbiAgICAgICAgdmFyIHZhbCA9IGl0ZW1WaXN1YWwgJiYgaXRlbVZpc3VhbFtrZXldO1xuICAgICAgICBpZiAodmFsID09IG51bGwgJiYgIWlnbm9yZVBhcmVudCkge1xuICAgICAgICAgICAgLy8gVXNlIGdsb2JhbCB2aXN1YWwgcHJvcGVydHlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZpc3VhbChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCB2aXN1YWwgcHJvcGVydHkgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBzZXRJdGVtVmlzdWFsKDAsICdjb2xvcicsIGNvbG9yKTtcbiAgICAgKiAgc2V0SXRlbVZpc3VhbCgwLCB7XG4gICAgICogICAgICAnY29sb3InOiBjb2xvclxuICAgICAqICB9KTtcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uc2V0SXRlbVZpc3VhbCA9IGZ1bmN0aW9uIChpZHgsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGl0ZW1WaXN1YWwgPSB0aGlzLl9pdGVtVmlzdWFsc1tpZHhdIHx8IHt9O1xuICAgICAgICB0aGlzLl9pdGVtVmlzdWFsc1tpZHhdID0gaXRlbVZpc3VhbDtcblxuICAgICAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1WaXN1YWxbbmFtZV0gPSBrZXlbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW1WaXN1YWxba2V5XSA9IHZhbHVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBpdGVtVmlzdWFscyBhbmQgbGlzdCB2aXN1YWwuXG4gICAgICovXG4gICAgbGlzdFByb3RvLmNsZWFyQWxsVmlzdWFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl92aXN1YWwgPSB7fTtcbiAgICAgICAgdGhpcy5faXRlbVZpc3VhbHMgPSBbXTtcbiAgICB9O1xuXG4gICAgdmFyIHNldEl0ZW1EYXRhQW5kU2VyaWVzSW5kZXggPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuc2VyaWVzSW5kZXggPSB0aGlzLnNlcmllc0luZGV4O1xuICAgICAgICBjaGlsZC5kYXRhSW5kZXggPSB0aGlzLmRhdGFJbmRleDtcbiAgICAgICAgY2hpbGQuZGF0YVR5cGUgPSB0aGlzLmRhdGFUeXBlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGdyYXBoaWMgZWxlbWVudCByZWxhdGl2ZSB0byBkYXRhLiBJdCBjYW4gYmUgc2V0IGFzIG51bGxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBbZWxdXG4gICAgICovXG4gICAgbGlzdFByb3RvLnNldEl0ZW1HcmFwaGljRWwgPSBmdW5jdGlvbiAoaWR4LCBlbCkge1xuICAgICAgICB2YXIgaG9zdE1vZGVsID0gdGhpcy5ob3N0TW9kZWw7XG5cbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAvLyBBZGQgZGF0YSBpbmRleCBhbmQgc2VyaWVzIGluZGV4IGZvciBpbmRleGluZyB0aGUgZGF0YSBieSBlbGVtZW50XG4gICAgICAgICAgICAvLyBVc2VmdWwgaW4gdG9vbHRpcFxuICAgICAgICAgICAgZWwuZGF0YUluZGV4ID0gaWR4O1xuICAgICAgICAgICAgZWwuZGF0YVR5cGUgPSB0aGlzLmRhdGFUeXBlO1xuICAgICAgICAgICAgZWwuc2VyaWVzSW5kZXggPSBob3N0TW9kZWwgJiYgaG9zdE1vZGVsLnNlcmllc0luZGV4O1xuICAgICAgICAgICAgaWYgKGVsLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgICAgICBlbC50cmF2ZXJzZShzZXRJdGVtRGF0YUFuZFNlcmllc0luZGV4LCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ncmFwaGljRWxzW2lkeF0gPSBlbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldEl0ZW1HcmFwaGljRWwgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncmFwaGljRWxzW2lkeF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICovXG4gICAgbGlzdFByb3RvLmVhY2hJdGVtR3JhcGhpY0VsID0gZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuX2dyYXBoaWNFbHMsIGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICBjYiAmJiBjYi5jYWxsKGNvbnRleHQsIGVsLCBpZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hhbGxvdyBjbG9uZSBhIG5ldyBsaXN0IGV4Y2VwdCB2aXN1YWwgYW5kIGxheW91dCBwcm9wZXJ0aWVzLCBhbmQgZ3JhcGggZWxlbWVudHMuXG4gICAgICogTmV3IGxpc3Qgb25seSBjaGFuZ2UgdGhlIGluZGljZXMuXG4gICAgICovXG4gICAgbGlzdFByb3RvLmNsb25lU2hhbGxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbkluZm9MaXN0ID0genJVdGlsLm1hcCh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuZ2V0RGltZW5zaW9uSW5mbywgdGhpcyk7XG4gICAgICAgIHZhciBsaXN0ID0gbmV3IExpc3QoZGltZW5zaW9uSW5mb0xpc3QsIHRoaXMuaG9zdE1vZGVsKTtcblxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICBsaXN0Ll9zdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcblxuICAgICAgICB0cmFuc2ZlclByb3BlcnRpZXMobGlzdCwgdGhpcyk7XG5cblxuICAgICAgICAvLyBDbG9uZSB3aWxsIG5vdCBjaGFuZ2UgdGhlIGRhdGEgZXh0ZW50IGFuZCBpbmRpY2VzXG4gICAgICAgIGxpc3QuaW5kaWNlcyA9IHRoaXMuaW5kaWNlcy5zbGljZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9leHRlbnQpIHtcbiAgICAgICAgICAgIGxpc3QuX2V4dGVudCA9IHpyVXRpbC5leHRlbmQoe30sIHRoaXMuX2V4dGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV3JhcCBzb21lIG1ldGhvZCB0byBhZGQgbW9yZSBmZWF0dXJlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbmplY3RGdW5jdGlvblxuICAgICAqL1xuICAgIGxpc3RQcm90by53cmFwTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluamVjdEZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbE1ldGhvZCA9IHRoaXNbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxNZXRob2QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fd3JhcHBlZE1ldGhvZHMgPSB0aGlzLl9fd3JhcHBlZE1ldGhvZHMgfHwgW107XG4gICAgICAgIHRoaXMuX193cmFwcGVkTWV0aG9kcy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gaW5qZWN0RnVuY3Rpb24uYXBwbHkodGhpcywgW3Jlc10uY29uY2F0KHpyVXRpbC5zbGljZShhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIE1ldGhvZHMgdGhhdCBjcmVhdGUgYSBuZXcgbGlzdCBiYXNlZCBvbiB0aGlzIGxpc3Qgc2hvdWxkIGJlIGxpc3RlZCBoZXJlLlxuICAgIC8vIE5vdGljZSB0aGF0IHRob3NlIG1ldGhvZCBzaG91bGQgYFJFVFVSTmAgdGhlIG5ldyBsaXN0LlxuICAgIGxpc3RQcm90by5UUkFOU0ZFUkFCTEVfTUVUSE9EUyA9IFsnY2xvbmVTaGFsbG93JywgJ2Rvd25TYW1wbGUnLCAnbWFwJ107XG4gICAgLy8gTWV0aG9kcyB0aGF0IGNoYW5nZSBpbmRpY2VzIG9mIHRoaXMgbGlzdCBzaG91bGQgYmUgbGlzdGVkIGhlcmUuXG4gICAgbGlzdFByb3RvLkNIQU5HQUJMRV9NRVRIT0RTID0gWydmaWx0ZXJTZWxmJ107XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpc3Q7XG4iLCIvKipcbiAqIENvbXBsZXRlIGRpbWVuc2lvbnMgYnkgZGF0YSAoZ3Vlc3MgZGltZW5zaW9uKS5cbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZSB0aGUgZGltZW5zaW9ucyBhcnJheSBndWVzc2VkIGZyb20gdGhlIGRhdGEgc3RydWN0dXJlLlxuICAgICAqIEBwYXJhbSAge0FycmF5LjxzdHJpbmc+fSBkaW1lbnNpb25zICAgICAgTmVjZXNzYXJ5IGRpbWVuc2lvbnMsIGxpa2UgWyd4JywgJ3knXVxuICAgICAqIEBwYXJhbSAge0FycmF5fSBkYXRhICAgICAgICAgICAgICAgICAgICAgRGF0YSBsaXN0LiBbWzEsIDIsIDNdLCBbMiwgMywgNF1dXG4gICAgICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz59IFtkZWZhdWx0TmFtZXNdICAgIERlZmF1bHQgbmFtZXMgdG8gZmlsbCBub3QgbmVjZXNzYXJ5IGRpbWVuc2lvbnMsIGxpa2UgWyd2YWx1ZSddXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBbZXh0cmFQcmVmaXhdICAgICAgICAgICAgIFByZWZpeCBvZiBuYW1lIHdoZW4gZmlsbGluZyB0aGUgbGVmdCBkaW1lbnNpb25zLlxuICAgICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBsZXRlRGltZW5zaW9ucyhkaW1lbnNpb25zLCBkYXRhLCBkZWZhdWx0TmFtZXMsIGV4dHJhUHJlZml4KSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGRpbWVuc2lvbnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUwID0gcmV0cmlldmVWYWx1ZShkYXRhWzBdKTtcbiAgICAgICAgdmFyIGRpbVNpemUgPSB6clV0aWwuaXNBcnJheSh2YWx1ZTApICYmIHZhbHVlMC5sZW5ndGggfHwgMTtcblxuICAgICAgICBkZWZhdWx0TmFtZXMgPSBkZWZhdWx0TmFtZXMgfHwgW107XG4gICAgICAgIGV4dHJhUHJlZml4ID0gZXh0cmFQcmVmaXggfHwgJ2V4dHJhJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1TaXplOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZGltZW5zaW9uc1tpXSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZGVmYXVsdE5hbWVzW2ldIHx8IChleHRyYVByZWZpeCArIChpIC0gZGVmYXVsdE5hbWVzLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnNbaV0gPSBndWVzc09yZGluYWwoZGF0YSwgaSlcbiAgICAgICAgICAgICAgICAgICAgPyB7dHlwZTogJ29yZGluYWwnLCBuYW1lOiBuYW1lfVxuICAgICAgICAgICAgICAgICAgICA6IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICB9XG5cbiAgICAvLyBUaGUgcnVsZSBzaG91bGQgbm90IGJlIGNvbXBsZXgsIG90aGVyd2lzZSB1c2VyIG1pZ2h0IG5vdFxuICAgIC8vIGJlIGFibGUgdG8ga25vd24gd2hlcmUgdGhlIGRhdGEgaXMgd3JvbmcuXG4gICAgdmFyIGd1ZXNzT3JkaW5hbCA9IGNvbXBsZXRlRGltZW5zaW9ucy5ndWVzc09yZGluYWwgPSBmdW5jdGlvbiAoZGF0YSwgZGltSW5kZXgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJldHJpZXZlVmFsdWUoZGF0YVtpXSk7XG5cbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZVtkaW1JbmRleF07XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh6clV0aWwuaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlICE9PSAnLScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJldHJpZXZlVmFsdWUobykge1xuICAgICAgICByZXR1cm4genJVdGlsLmlzQXJyYXkobykgPyBvIDogenJVdGlsLmlzT2JqZWN0KG8pID8gby52YWx1ZTogbztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbXBsZXRlRGltZW5zaW9ucztcblxuIiwiLy8gRW5hYmxlIERFViBtb2RlIHdoZW4gdXNpbmcgc291cmNlIGNvZGUgd2l0aG91dCBidWlsZC4gd2hpY2ggaGFzIG5vIF9fREVWX18gdmFyaWFibGVcbi8vIEluIGJ1aWxkIHByb2Nlc3MgJ3R5cGVvZiBfX0RFVl9fJyB3aWxsIGJlIHJlcGxhY2Ugd2l0aCAnYm9vbGVhbidcbi8vIFNvIHRoaXMgY29kZSB3aWxsIGJlIHJlbW92ZWQgb3IgZGlzYWJsZWQgYW55d2F5IGFmdGVyIGJ1aWx0LlxuaWYgKHR5cGVvZiBfX0RFVl9fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEluIGJyb3dzZXJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93Ll9fREVWX18gPSB0cnVlO1xuICAgIH1cbiAgICAvLyBJbiBub2RlXG4gICAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZ2xvYmFsLl9fREVWX18gPSB0cnVlO1xuICAgIH1cbn1cblxuLyohXG4gKiBFQ2hhcnRzLCBhIGphdmFzY3JpcHQgaW50ZXJhY3RpdmUgY2hhcnQgbGlicmFyeS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJhaWR1IEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS9lY2hhcnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHNcbiAqL1xuXG5cbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcblxuICAgIHZhciBHbG9iYWxNb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWwvR2xvYmFsJyk7XG4gICAgdmFyIEV4dGVuc2lvbkFQSSA9IHJlcXVpcmUoJy4vRXh0ZW5zaW9uQVBJJyk7XG4gICAgdmFyIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyID0gcmVxdWlyZSgnLi9Db29yZGluYXRlU3lzdGVtJyk7XG4gICAgdmFyIE9wdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL21vZGVsL09wdGlvbk1hbmFnZXInKTtcblxuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWwvQ29tcG9uZW50Jyk7XG4gICAgdmFyIFNlcmllc01vZGVsID0gcmVxdWlyZSgnLi9tb2RlbC9TZXJpZXMnKTtcblxuICAgIHZhciBDb21wb25lbnRWaWV3ID0gcmVxdWlyZSgnLi92aWV3L0NvbXBvbmVudCcpO1xuICAgIHZhciBDaGFydFZpZXcgPSByZXF1aXJlKCcuL3ZpZXcvQ2hhcnQnKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciB0aHJvdHRsZSA9IHJlcXVpcmUoJy4vdXRpbC90aHJvdHRsZScpO1xuXG4gICAgdmFyIHpyZW5kZXIgPSByZXF1aXJlKCd6cmVuZGVyJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBjb2xvclRvb2wgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi90b29sL2NvbG9yJyk7XG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgdGltc29ydCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdGltc29ydCcpO1xuXG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgcGFyc2VDbGFzc1R5cGUgPSBDb21wb25lbnRNb2RlbC5wYXJzZUNsYXNzVHlwZTtcblxuICAgIHZhciBQUklPUklUWV9QUk9DRVNTT1JfRklMVEVSID0gMTAwMDtcbiAgICB2YXIgUFJJT1JJVFlfUFJPQ0VTU09SX1NUQVRJU1RJQyA9IDUwMDA7XG5cblxuICAgIHZhciBQUklPUklUWV9WSVNVQUxfTEFZT1VUID0gMTAwMDtcbiAgICB2YXIgUFJJT1JJVFlfVklTVUFMX0dMT0JBTCA9IDIwMDA7XG4gICAgdmFyIFBSSU9SSVRZX1ZJU1VBTF9DSEFSVCA9IDMwMDA7XG4gICAgdmFyIFBSSU9SSVRZX1ZJU1VBTF9DT01QT05FTlQgPSA0MDAwO1xuICAgIC8vIEZJWE1FXG4gICAgLy8gbmVjZXNzYXJ5P1xuICAgIHZhciBQUklPUklUWV9WSVNVQUxfQlJVU0ggPSA1MDAwO1xuXG4gICAgLy8gTWFpbiBwcm9jZXNzIGhhdmUgdGhyZWUgZW50cmllczogYHNldE9wdGlvbmAsIGBkaXNwYXRjaEFjdGlvbmAgYW5kIGByZXNpemVgLFxuICAgIC8vIHdoZXJlIHRoZXkgbXVzdCBub3QgYmUgaW52b2tlZCBuZXN0ZWRseSwgZXhjZXB0IHRoZSBvbmx5IGNhc2U6IGludm9rZVxuICAgIC8vIGRpc3BhdGNoQWN0aW9uIHdpdGggdXBkYXRlTWV0aG9kIFwibm9uZVwiIGluIG1haW4gcHJvY2Vzcy5cbiAgICAvLyBUaGlzIGZsYWcgaXMgdXNlZCB0byBjYXJyeSBvdXQgdGhpcyBydWxlLlxuICAgIC8vIEFsbCBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQgb3V0IHNpZGUgbWFpbiBwcm9jZXNzIChpLmUuIHdoZW4gIXRoaXNbSU5fTUFJTl9QUk9DRVNTXSkuXG4gICAgdmFyIElOX01BSU5fUFJPQ0VTUyA9ICdfX2ZsYWdJbk1haW5Qcm9jZXNzJztcbiAgICB2YXIgSEFTX0dSQURJRU5UX09SX1BBVFRFUk5fQkcgPSAnX19oYXNHcmFkaWVudE9yUGF0dGVybkJnJztcbiAgICB2YXIgT1BUSU9OX1VQREFURUQgPSAnX19vcHRpb25VcGRhdGVkJztcbiAgICB2YXIgQUNUSU9OX1JFRyA9IC9eW2EtekEtWjAtOV9dKyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICAgICAgLy8gRXZlbnQgbmFtZSBpcyBhbGwgbG93ZXJjYXNlXG4gICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUgJiYgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBFdmVudGZ1bC5wcm90b3R5cGVbbWV0aG9kXS5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlciwgY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBlY2hhcnRzfk1lc3NhZ2VDZW50ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZXNzYWdlQ2VudGVyKCkge1xuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBNZXNzYWdlQ2VudGVyLnByb3RvdHlwZS5vbiA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb24nKTtcbiAgICBNZXNzYWdlQ2VudGVyLnByb3RvdHlwZS5vZmYgPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29mZicpO1xuICAgIE1lc3NhZ2VDZW50ZXIucHJvdG90eXBlLm9uZSA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb25lJyk7XG4gICAgenJVdGlsLm1peGluKE1lc3NhZ2VDZW50ZXIsIEV2ZW50ZnVsKTtcblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgZWNoYXJ0c35FQ2hhcnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRUNoYXJ0cyAoZG9tLCB0aGVtZSwgb3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICAvLyBHZXQgdGhlbWUgYnkgbmFtZVxuICAgICAgICBpZiAodHlwZW9mIHRoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhlbWUgPSB0aGVtZVN0b3JhZ2VbdGhlbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkO1xuICAgICAgICAvKipcbiAgICAgICAgICogR3JvdXAgaWRcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SFRNTERvbUVsZW1lbnR9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kb20gPSBkb207XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB6ciA9IHRoaXMuX3pyID0genJlbmRlci5pbml0KGRvbSwge1xuICAgICAgICAgICAgcmVuZGVyZXI6IG9wdHMucmVuZGVyZXIgfHwgJ2NhbnZhcycsXG4gICAgICAgICAgICBkZXZpY2VQaXhlbFJhdGlvOiBvcHRzLmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgICAgICB3aWR0aDogb3B0cy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogb3B0cy5oZWlnaHRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cGVjdCA2MCBwZnMuXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Rocm90dGxlZFpyRmx1c2ggPSB0aHJvdHRsZS50aHJvdHRsZSh6clV0aWwuYmluZCh6ci5mbHVzaCwgenIpLCAxNyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90aGVtZSA9IHpyVXRpbC5jbG9uZSh0aGVtZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvdmlldy9DaGFydD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jaGFydHNWaWV3cyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2hhcnRzTWFwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvdmlldy9Db21wb25lbnQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29tcG9uZW50c1ZpZXdzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvdmlldy9Db21wb25lbnQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29tcG9uZW50c01hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXBpID0gbmV3IEV4dGVuc2lvbkFQSSh0aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL0Nvb3JkaW5hdGVTeXN0ZW19XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb29yZFN5c01nciA9IG5ldyBDb29yZGluYXRlU3lzdGVtTWFuYWdlcigpO1xuXG4gICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0c35NZXNzYWdlQ2VudGVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWVzc2FnZUNlbnRlciA9IG5ldyBNZXNzYWdlQ2VudGVyKCk7XG5cbiAgICAgICAgLy8gSW5pdCBtb3VzZSBldmVudHNcbiAgICAgICAgdGhpcy5faW5pdEV2ZW50cygpO1xuXG4gICAgICAgIC8vIEluIGNhc2Ugc29tZSBwZW9wbGUgd3JpdGUgYHdpbmRvdy5vbnJlc2l6ZSA9IGNoYXJ0LnJlc2l6ZWBcbiAgICAgICAgdGhpcy5yZXNpemUgPSB6clV0aWwuYmluZCh0aGlzLnJlc2l6ZSwgdGhpcyk7XG5cbiAgICAgICAgLy8gQ2FuJ3QgZGlzcGF0Y2ggYWN0aW9uIGR1cmluZyByZW5kZXJpbmcgcHJvY2VkdXJlXG4gICAgICAgIHRoaXMuX3BlbmRpbmdBY3Rpb25zID0gW107XG4gICAgICAgIC8vIFNvcnQgb24gZGVtYW5kXG4gICAgICAgIGZ1bmN0aW9uIHByaW9yaXR5U29ydEZ1bmMoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpbyAtIGIucHJpbztcbiAgICAgICAgfVxuICAgICAgICB0aW1zb3J0KHZpc3VhbEZ1bmNzLCBwcmlvcml0eVNvcnRGdW5jKTtcbiAgICAgICAgdGltc29ydChkYXRhUHJvY2Vzc29yRnVuY3MsIHByaW9yaXR5U29ydEZ1bmMpO1xuXG4gICAgICAgIHpyLmFuaW1hdGlvbi5vbignZnJhbWUnLCB0aGlzLl9vbmZyYW1lLCB0aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgZWNoYXJ0c1Byb3RvID0gRUNoYXJ0cy5wcm90b3R5cGU7XG5cbiAgICBlY2hhcnRzUHJvdG8uX29uZnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIExhenkgdXBkYXRlXG4gICAgICAgIGlmICh0aGlzW09QVElPTl9VUERBVEVEXSkge1xuICAgICAgICAgICAgdmFyIHNpbGVudCA9IHRoaXNbT1BUSU9OX1VQREFURURdLnNpbGVudDtcblxuICAgICAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gdHJ1ZTtcblxuICAgICAgICAgICAgdXBkYXRlTWV0aG9kcy5wcmVwYXJlQW5kVXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzW09QVElPTl9VUERBVEVEXSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmbHVzaFBlbmRpbmdBY3Rpb25zLmNhbGwodGhpcywgc2lsZW50KTtcblxuICAgICAgICAgICAgdHJpZ2dlclVwZGF0ZWRFdmVudC5jYWxsKHRoaXMsIHNpbGVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0hUTUxEb21FbGVtZW50fVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXREb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb207XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyflpSZW5kZXJ9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldFpyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fenI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzYWdlOlxuICAgICAqIGNoYXJ0LnNldE9wdGlvbihvcHRpb24sIG5vdE1lcmdlLCBsYXp5VXBkYXRlKTtcbiAgICAgKiBjaGFydC5zZXRPcHRpb24ob3B0aW9uLCB7XG4gICAgICogICAgIG5vdE1lcmdlOiAuLi4sXG4gICAgICogICAgIGxhenlVcGRhdGU6IC4uLixcbiAgICAgKiAgICAgc2lsZW50OiAuLi5cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdHxib29sZWFufSBbb3B0c10gb3B0cyBvciBub3RNZXJnZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLm5vdE1lcmdlPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMubGF6eVVwZGF0ZT1mYWxzZV0gVXNlZnVsIHdoZW4gc2V0T3B0aW9uIGZyZXF1ZW50bHkuXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24sIG5vdE1lcmdlLCBsYXp5VXBkYXRlKSB7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICB6clV0aWwuYXNzZXJ0KCF0aGlzW0lOX01BSU5fUFJPQ0VTU10sICdgc2V0T3B0aW9uYCBzaG91bGQgbm90IGJlIGNhbGxlZCBkdXJpbmcgbWFpbiBwcm9jZXNzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpbGVudDtcbiAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChub3RNZXJnZSkpIHtcbiAgICAgICAgICAgIGxhenlVcGRhdGUgPSBub3RNZXJnZS5sYXp5VXBkYXRlO1xuICAgICAgICAgICAgc2lsZW50ID0gbm90TWVyZ2Uuc2lsZW50O1xuICAgICAgICAgICAgbm90TWVyZ2UgPSBub3RNZXJnZS5ub3RNZXJnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb2RlbCB8fCBub3RNZXJnZSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbk1hbmFnZXIgPSBuZXcgT3B0aW9uTWFuYWdlcih0aGlzLl9hcGkpO1xuICAgICAgICAgICAgdmFyIHRoZW1lID0gdGhpcy5fdGhlbWU7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsID0gbmV3IEdsb2JhbE1vZGVsKG51bGwsIG51bGwsIHRoZW1lLCBvcHRpb25NYW5hZ2VyKTtcbiAgICAgICAgICAgIGVjTW9kZWwuaW5pdChudWxsLCBudWxsLCB0aGVtZSwgb3B0aW9uTWFuYWdlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyB1Z2x5XG4gICAgICAgIHRoaXMuX19sYXN0T25seUdyYXBoaWMgPSAhIShvcHRpb24gJiYgb3B0aW9uLmdyYXBoaWMpO1xuICAgICAgICB6clV0aWwuZWFjaChvcHRpb24sIGZ1bmN0aW9uIChvLCBtYWluVHlwZSkge1xuICAgICAgICAgICAgbWFpblR5cGUgIT09ICdncmFwaGljJyAmJiAodGhpcy5fX2xhc3RPbmx5R3JhcGhpYyA9IGZhbHNlKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fbW9kZWwuc2V0T3B0aW9uKG9wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MpO1xuXG4gICAgICAgIGlmIChsYXp5VXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzW09QVElPTl9VUERBVEVEXSA9IHtzaWxlbnQ6IHNpbGVudH07XG4gICAgICAgICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZU1ldGhvZHMucHJlcGFyZUFuZFVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLy8gRW5zdXJlIHpyIHJlZnJlc2ggc3ljaHJvbm91c2x5LCBhbmQgdGhlbiBwaXhlbCBpbiBjYW52YXMgY2FuIGJlXG4gICAgICAgICAgICAvLyBmZXRjaGVkIGFmdGVyIGBzZXRPcHRpb25gLlxuICAgICAgICAgICAgdGhpcy5fenIuZmx1c2goKTtcblxuICAgICAgICAgICAgdGhpc1tPUFRJT05fVVBEQVRFRF0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmbHVzaFBlbmRpbmdBY3Rpb25zLmNhbGwodGhpcywgc2lsZW50KTtcbiAgICAgICAgICAgIHRyaWdnZXJVcGRhdGVkRXZlbnQuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBERVBSRUNBVEVEXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLnNldFRoZW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmxvZygnRUNoYXJ0cyNzZXRUaGVtZSgpIGlzIERFUFJFQ0FURUQgaW4gRUNoYXJ0cyAzLjAnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXRNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGVsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldE9wdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGVsICYmIHRoaXMuX21vZGVsLmdldE9wdGlvbigpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fenIuZ2V0V2lkdGgoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96ci5nZXRIZWlnaHQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhbnZhcyB3aGljaCBoYXMgYWxsIHRoaW5nIHJlbmRlcmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXRSZW5kZXJlZENhbnZhcyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBvcHRzLnBpeGVsUmF0aW8gPSBvcHRzLnBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgb3B0cy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRzLmJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgfHwgdGhpcy5fbW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgdmFyIHpyID0gdGhpcy5fenI7XG4gICAgICAgIHZhciBsaXN0ID0genIuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpO1xuICAgICAgICAvLyBTdG9wIGFuaW1hdGlvbnNcbiAgICAgICAgenJVdGlsLmVhY2gobGlzdCwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBlbC5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHpyLnBhaW50ZXIuZ2V0UmVuZGVyZWRDYW52YXMob3B0cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudHlwZT0ncG5nJ11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucGl4ZWxSYXRpbz0xXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmV4Y2x1ZGVDb21wb25lbnRzXVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXREYXRhVVJMID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHZhciBleGNsdWRlQ29tcG9uZW50cyA9IG9wdHMuZXhjbHVkZUNvbXBvbmVudHM7XG4gICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgICAgIHZhciBleGNsdWRlc0NvbXBvbmVudFZpZXdzID0gW107XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBlYWNoKGV4Y2x1ZGVDb21wb25lbnRzLCBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgICAgICAgICAgICBtYWluVHlwZTogY29tcG9uZW50VHlwZVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gc2VsZi5fY29tcG9uZW50c01hcFtjb21wb25lbnQuX192aWV3SWRdO1xuICAgICAgICAgICAgICAgIGlmICghdmlldy5ncm91cC5pZ25vcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZXNDb21wb25lbnRWaWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3Lmdyb3VwLmlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB1cmwgPSB0aGlzLmdldFJlbmRlcmVkQ2FudmFzKG9wdHMpLnRvRGF0YVVSTChcbiAgICAgICAgICAgICdpbWFnZS8nICsgKG9wdHMgJiYgb3B0cy50eXBlIHx8ICdwbmcnKVxuICAgICAgICApO1xuXG4gICAgICAgIGVhY2goZXhjbHVkZXNDb21wb25lbnRWaWV3cywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgICAgIHZpZXcuZ3JvdXAuaWdub3JlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50eXBlPSdwbmcnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5waXhlbFJhdGlvPTFdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0Q29ubmVjdGVkRGF0YVVSTCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncm91cElkID0gdGhpcy5ncm91cDtcbiAgICAgICAgdmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbiAgICAgICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICAgICAgdmFyIE1BWF9OVU1CRVIgPSBJbmZpbml0eTtcbiAgICAgICAgaWYgKGNvbm5lY3RlZEdyb3Vwc1tncm91cElkXSkge1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBNQVhfTlVNQkVSO1xuICAgICAgICAgICAgdmFyIHRvcCA9IE1BWF9OVU1CRVI7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSAtTUFYX05VTUJFUjtcbiAgICAgICAgICAgIHZhciBib3R0b20gPSAtTUFYX05VTUJFUjtcbiAgICAgICAgICAgIHZhciBjYW52YXNMaXN0ID0gW107XG4gICAgICAgICAgICB2YXIgZHByID0gKG9wdHMgJiYgb3B0cy5waXhlbFJhdGlvKSB8fCAxO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChpbnN0YW5jZXMsIGZ1bmN0aW9uIChjaGFydCwgaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuZ3JvdXAgPT09IGdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGNoYXJ0LmdldFJlbmRlcmVkQ2FudmFzKFxuICAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLmNsb25lKG9wdHMpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBjaGFydC5nZXREb20oKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IG1hdGhNaW4oYm91bmRpbmdSZWN0LmxlZnQsIGxlZnQpO1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSBtYXRoTWluKGJvdW5kaW5nUmVjdC50b3AsIHRvcCk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWF0aE1heChib3VuZGluZ1JlY3QucmlnaHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gbWF0aE1heChib3VuZGluZ1JlY3QuYm90dG9tLCBib3R0b20pO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tOiBjYW52YXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBib3VuZGluZ1JlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogYm91bmRpbmdSZWN0LnRvcFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGVmdCAqPSBkcHI7XG4gICAgICAgICAgICB0b3AgKj0gZHByO1xuICAgICAgICAgICAgcmlnaHQgKj0gZHByO1xuICAgICAgICAgICAgYm90dG9tICo9IGRwcjtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Q2FudmFzID0genJVdGlsLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgICAgICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0YXJnZXRDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHpyID0genJlbmRlci5pbml0KHRhcmdldENhbnZhcyk7XG5cbiAgICAgICAgICAgIGVhY2goY2FudmFzTGlzdCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogaXRlbS5sZWZ0ICogZHByIC0gbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGl0ZW0udG9wICogZHByIC0gdG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGl0ZW0uZG9tXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB6ci5hZGQoaW1nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgenIucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRDYW52YXMudG9EYXRhVVJMKCdpbWFnZS8nICsgKG9wdHMgJiYgb3B0cy50eXBlIHx8ICdwbmcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhVVJMKG9wdHMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgZnJvbSBsb2dpY2FsIGNvb3JkaW5hdGUgc3lzdGVtIHRvIHBpeGVsIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIFNlZSBDb29yZGluYXRlU3lzdGVtI2NvbnZlcnRUb1BpeGVsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZmluZGVyXG4gICAgICogICAgICAgIElmIHN0cmluZywgZS5nLiwgJ2dlbycsIG1lYW5zIHtnZW9JbmRleDogMH0uXG4gICAgICogICAgICAgIElmIE9iamVjdCwgY291bGQgY29udGFpbiBzb21lIG9mIHRoZXNlIHByb3BlcnRpZXMgYmVsb3c6XG4gICAgICogICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgIHNlcmllc0luZGV4IC8gc2VyaWVzSWQgLyBzZXJpZXNOYW1lLFxuICAgICAqICAgICAgICAgICAgZ2VvSW5kZXggLyBnZW9JZCwgZ2VvTmFtZSxcbiAgICAgKiAgICAgICAgICAgIGJtYXBJbmRleCAvIGJtYXBJZCAvIGJtYXBOYW1lLFxuICAgICAqICAgICAgICAgICAgeEF4aXNJbmRleCAvIHhBeGlzSWQgLyB4QXhpc05hbWUsXG4gICAgICogICAgICAgICAgICB5QXhpc0luZGV4IC8geUF4aXNJZCAvIHlBeGlzTmFtZSxcbiAgICAgKiAgICAgICAgICAgIGdyaWRJbmRleCAvIGdyaWRJZCAvIGdyaWROYW1lLFxuICAgICAqICAgICAgICAgICAgLi4uIChjYW4gYmUgZXh0ZW5kZWQpXG4gICAgICogICAgICAgIH1cbiAgICAgKiBAcGFyYW0ge0FycmF5fG51bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtBcnJheXxudW1iZXJ9IHJlc3VsdFxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5jb252ZXJ0VG9QaXhlbCA9IHpyVXRpbC5jdXJyeShkb0NvbnZlcnRQaXhlbCwgJ2NvbnZlcnRUb1BpeGVsJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGZyb20gcGl4ZWwgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gbG9naWNhbCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgKiBTZWUgQ29vcmRpbmF0ZVN5c3RlbSNjb252ZXJ0RnJvbVBpeGVsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZmluZGVyXG4gICAgICogICAgICAgIElmIHN0cmluZywgZS5nLiwgJ2dlbycsIG1lYW5zIHtnZW9JbmRleDogMH0uXG4gICAgICogICAgICAgIElmIE9iamVjdCwgY291bGQgY29udGFpbiBzb21lIG9mIHRoZXNlIHByb3BlcnRpZXMgYmVsb3c6XG4gICAgICogICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgIHNlcmllc0luZGV4IC8gc2VyaWVzSWQgLyBzZXJpZXNOYW1lLFxuICAgICAqICAgICAgICAgICAgZ2VvSW5kZXggLyBnZW9JZCAvIGdlb05hbWUsXG4gICAgICogICAgICAgICAgICBibWFwSW5kZXggLyBibWFwSWQgLyBibWFwTmFtZSxcbiAgICAgKiAgICAgICAgICAgIHhBeGlzSW5kZXggLyB4QXhpc0lkIC8geEF4aXNOYW1lLFxuICAgICAqICAgICAgICAgICAgeUF4aXNJbmRleCAvIHlBeGlzSWQgLyB5QXhpc05hbWVcbiAgICAgKiAgICAgICAgICAgIGdyaWRJbmRleCAvIGdyaWRJZCAvIGdyaWROYW1lLFxuICAgICAqICAgICAgICAgICAgLi4uIChjYW4gYmUgZXh0ZW5kZWQpXG4gICAgICogICAgICAgIH1cbiAgICAgKiBAcGFyYW0ge0FycmF5fG51bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtBcnJheXxudW1iZXJ9IHJlc3VsdFxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5jb252ZXJ0RnJvbVBpeGVsID0genJVdGlsLmN1cnJ5KGRvQ29udmVydFBpeGVsLCAnY29udmVydEZyb21QaXhlbCcpO1xuXG4gICAgZnVuY3Rpb24gZG9Db252ZXJ0UGl4ZWwobWV0aG9kTmFtZSwgZmluZGVyLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgICAgICB2YXIgY29vcmRTeXNMaXN0ID0gdGhpcy5fY29vcmRTeXNNZ3IuZ2V0Q29vcmRpbmF0ZVN5c3RlbXMoKTtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBmaW5kZXIgPSBtb2RlbFV0aWwucGFyc2VGaW5kZXIoZWNNb2RlbCwgZmluZGVyKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkU3lzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gY29vcmRTeXNMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGNvb3JkU3lzW21ldGhvZE5hbWVdXG4gICAgICAgICAgICAgICAgJiYgKHJlc3VsdCA9IGNvb3JkU3lzW21ldGhvZE5hbWVdKGVjTW9kZWwsIGZpbmRlciwgdmFsdWUpKSAhPSBudWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAnTm8gY29vcmRpbmF0ZSBzeXN0ZW0gdGhhdCBzdXBwb3J0cyAnICsgbWV0aG9kTmFtZSArICcgZm91bmQgYnkgdGhlIGdpdmVuIGZpbmRlci4nXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXMgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlIHN5c3RlbXMgb3IgY29tcG9uZW50cyBjb250YWluIHRoZSBnaXZlbiBwaXhlbCBwb2ludC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZpbmRlclxuICAgICAqICAgICAgICBJZiBzdHJpbmcsIGUuZy4sICdnZW8nLCBtZWFucyB7Z2VvSW5kZXg6IDB9LlxuICAgICAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxuICAgICAqICAgICAgICB7XG4gICAgICogICAgICAgICAgICBzZXJpZXNJbmRleCAvIHNlcmllc0lkIC8gc2VyaWVzTmFtZSxcbiAgICAgKiAgICAgICAgICAgIGdlb0luZGV4IC8gZ2VvSWQgLyBnZW9OYW1lLFxuICAgICAqICAgICAgICAgICAgYm1hcEluZGV4IC8gYm1hcElkIC8gYm1hcE5hbWUsXG4gICAgICogICAgICAgICAgICB4QXhpc0luZGV4IC8geEF4aXNJZCAvIHhBeGlzTmFtZSxcbiAgICAgKiAgICAgICAgICAgIHlBeGlzSW5kZXggLyB5QXhpc0lkIC8geUF4aXNOYW1lXG4gICAgICogICAgICAgICAgICBncmlkSW5kZXggLyBncmlkSWQgLyBncmlkTmFtZSxcbiAgICAgKiAgICAgICAgICAgIC4uLiAoY2FuIGJlIGV4dGVuZGVkKVxuICAgICAqICAgICAgICB9XG4gICAgICogQHBhcmFtIHtBcnJheXxudW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gcmVzdWx0XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmNvbnRhaW5QaXhlbCA9IGZ1bmN0aW9uIChmaW5kZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgZmluZGVyID0gbW9kZWxVdGlsLnBhcnNlRmluZGVyKGVjTW9kZWwsIGZpbmRlcik7XG5cbiAgICAgICAgenJVdGlsLmVhY2goZmluZGVyLCBmdW5jdGlvbiAobW9kZWxzLCBrZXkpIHtcbiAgICAgICAgICAgIGtleS5pbmRleE9mKCdNb2RlbHMnKSA+PSAwICYmIHpyVXRpbC5lYWNoKG1vZGVscywgZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gbW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgICAgICBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMuY29udGFpblBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCB8PSAhIWNvb3JkU3lzLmNvbnRhaW5Qb2ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3Nlcmllc01vZGVscycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9jaGFydHNNYXBbbW9kZWwuX192aWV3SWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldyAmJiB2aWV3LmNvbnRhaW5Qb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IHZpZXcuY29udGFpblBvaW50KHZhbHVlLCBtb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihrZXkgKyAnOiAnICsgKHZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnVGhlIGZvdW5kIGNvbXBvbmVudCBkbyBub3Qgc3VwcG9ydCBjb250YWluUG9pbnQuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdObyB2aWV3IG1hcHBpbmcgdG8gdGhlIGZvdW5kIGNvbXBvbmVudC4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oa2V5ICsgJzogY29udGFpblBvaW50IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB2aXN1YWwgZnJvbSBzZXJpZXMgb3IgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZpbmRlclxuICAgICAqICAgICAgICBJZiBzdHJpbmcsIGUuZy4sICdzZXJpZXMnLCBtZWFucyB7c2VyaWVzSW5kZXg6IDB9LlxuICAgICAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxuICAgICAqICAgICAgICB7XG4gICAgICogICAgICAgICAgICBzZXJpZXNJbmRleCAvIHNlcmllc0lkIC8gc2VyaWVzTmFtZSxcbiAgICAgKiAgICAgICAgICAgIGRhdGFJbmRleCAvIGRhdGFJbmRleEluc2lkZVxuICAgICAqICAgICAgICB9XG4gICAgICogICAgICAgIElmIGRhdGFJbmRleCBpcyBub3Qgc3BlY2lmaWVkLCBzZXJpZXMgdmlzdWFsIHdpbGwgYmUgZmV0Y2hlZCxcbiAgICAgKiAgICAgICAgYnV0IG5vdCBkYXRhIGl0ZW0gdmlzdWFsLlxuICAgICAqICAgICAgICBJZiBhbGwgb2Ygc2VyaWVzSW5kZXgsIHNlcmllc0lkLCBzZXJpZXNOYW1lIGFyZSBub3Qgc3BlY2lmaWVkLFxuICAgICAqICAgICAgICB2aXN1YWwgd2lsbCBiZSBmZXRjaGVkIGZyb20gZmlyc3Qgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aXN1YWxUeXBlICdjb2xvcicsICdzeW1ib2wnLCAnc3ltYm9sU2l6ZSdcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0VmlzdWFsID0gZnVuY3Rpb24gKGZpbmRlciwgdmlzdWFsVHlwZSkge1xuICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gICAgICAgIGZpbmRlciA9IG1vZGVsVXRpbC5wYXJzZUZpbmRlcihlY01vZGVsLCBmaW5kZXIsIHtkZWZhdWx0TWFpblR5cGU6ICdzZXJpZXMnfSk7XG5cbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZmluZGVyLnNlcmllc01vZGVsO1xuXG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoIXNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGVyZSBpcyBubyBzcGVjaWZpZWQgc2VpcmVzIG1vZGVsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcblxuICAgICAgICB2YXIgZGF0YUluZGV4SW5zaWRlID0gZmluZGVyLmhhc093blByb3BlcnR5KCdkYXRhSW5kZXhJbnNpZGUnKVxuICAgICAgICAgICAgPyBmaW5kZXIuZGF0YUluZGV4SW5zaWRlXG4gICAgICAgICAgICA6IGZpbmRlci5oYXNPd25Qcm9wZXJ0eSgnZGF0YUluZGV4JylcbiAgICAgICAgICAgID8gZGF0YS5pbmRleE9mUmF3SW5kZXgoZmluZGVyLmRhdGFJbmRleClcbiAgICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICByZXR1cm4gZGF0YUluZGV4SW5zaWRlICE9IG51bGxcbiAgICAgICAgICAgID8gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleEluc2lkZSwgdmlzdWFsVHlwZSlcbiAgICAgICAgICAgIDogZGF0YS5nZXRWaXN1YWwodmlzdWFsVHlwZSk7XG4gICAgfTtcblxuXG4gICAgdmFyIHVwZGF0ZU1ldGhvZHMgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLnRpbWUgJiYgY29uc29sZS50aW1lKCd1cGRhdGUnKTtcblxuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgICAgICB2YXIgY29vcmRTeXNNZ3IgPSB0aGlzLl9jb29yZFN5c01ncjtcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX3pyO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGJlZm9yZSBzZXRPcHRpb25cbiAgICAgICAgICAgIGlmICghZWNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRml4bWUgRmlyc3QgdGltZSB1cGRhdGUgP1xuICAgICAgICAgICAgZWNNb2RlbC5yZXN0b3JlRGF0YSgpO1xuXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyBTYXZlIHRvdGFsIGVjTW9kZWwgaGVyZSBmb3IgdW5kby9yZWRvIChhZnRlciByZXN0b3JpbmcgZGF0YSBhbmQgYmVmb3JlIHByb2Nlc3NpbmcgZGF0YSkuXG4gICAgICAgICAgICAvLyBVbmRvIChyZXN0b3JhdGlvbiBvZiB0b3RhbCBlY01vZGVsKSBjYW4gYmUgY2FycmllZCBvdXQgaW4gJ2FjdGlvbicgb3Igb3V0c2lkZSBBUEkgY2FsbC5cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBjb29yZGluYXRlIHN5c3RlbSBlYWNoIHVwZGF0ZVxuICAgICAgICAgICAgLy8gSW4gTGluZVZpZXcgbWF5IHNhdmUgdGhlIG9sZCBjb29yZGluYXRlIHN5c3RlbSBhbmQgdXNlIGl0IHRvIGdldCB0aGUgb3JpZ25hbCBwb2ludFxuICAgICAgICAgICAgY29vcmRTeXNNZ3IuY3JlYXRlKHRoaXMuX21vZGVsLCB0aGlzLl9hcGkpO1xuXG4gICAgICAgICAgICBwcm9jZXNzRGF0YS5jYWxsKHRoaXMsIGVjTW9kZWwsIGFwaSk7XG5cbiAgICAgICAgICAgIHN0YWNrU2VyaWVzRGF0YS5jYWxsKHRoaXMsIGVjTW9kZWwpO1xuXG4gICAgICAgICAgICBjb29yZFN5c01nci51cGRhdGUoZWNNb2RlbCwgYXBpKTtcblxuICAgICAgICAgICAgZG9WaXN1YWxFbmNvZGluZy5jYWxsKHRoaXMsIGVjTW9kZWwsIHBheWxvYWQpO1xuXG4gICAgICAgICAgICBkb1JlbmRlci5jYWxsKHRoaXMsIGVjTW9kZWwsIHBheWxvYWQpO1xuXG4gICAgICAgICAgICAvLyBTZXQgYmFja2dyb3VuZFxuICAgICAgICAgICAgdmFyIGJhY2tncm91bmRDb2xvciA9IGVjTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKSB8fCAndHJhbnNwYXJlbnQnO1xuXG4gICAgICAgICAgICB2YXIgcGFpbnRlciA9IHpyLnBhaW50ZXI7XG4gICAgICAgICAgICAvLyBUT0RPIGFsbCB1c2UgY2xlYXJDb2xvciA/XG4gICAgICAgICAgICBpZiAocGFpbnRlci5pc1NpbmdsZUNhbnZhcyAmJiBwYWludGVyLmlzU2luZ2xlQ2FudmFzKCkpIHtcbiAgICAgICAgICAgICAgICB6ci5jb25maWdMYXllcigwLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gSUU4XG4gICAgICAgICAgICAgICAgaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvckFyciA9IGNvbG9yVG9vbC5wYXJzZShiYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvclRvb2wuc3RyaW5naWZ5KGNvbG9yQXJyLCAncmdiJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvckFyclszXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmFja2dyb3VuZENvbG9yLmNvbG9yU3RvcHMgfHwgYmFja2dyb3VuZENvbG9yLmltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdyYWRpZW50IGJhY2tncm91bmRcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgRml4ZWQgbGF5ZXLvvJ9cbiAgICAgICAgICAgICAgICAgICAgenIuY29uZmlnTGF5ZXIoMCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvcjogYmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzW0hBU19HUkFESUVOVF9PUl9QQVRURVJOX0JHXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9tLnN0eWxlLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbSEFTX0dSQURJRU5UX09SX1BBVFRFUk5fQkddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6ci5jb25maWdMYXllcigwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvcjogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpc1tIQVNfR1JBRElFTlRfT1JfUEFUVEVSTl9CR10gPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb20uc3R5bGUuYmFja2dyb3VuZCA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUudGltZSAmJiBjb25zb2xlLnRpbWVFbmQoJ3VwZGF0ZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlVmlldzogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBiZWZvcmUgc2V0T3B0aW9uXG4gICAgICAgICAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXREYXRhKCkuY2xlYXJBbGxWaXN1YWwoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkb1Zpc3VhbEVuY29kaW5nLmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIGludm9rZVVwZGF0ZU1ldGhvZC5jYWxsKHRoaXMsICd1cGRhdGVWaWV3JywgZWNNb2RlbCwgcGF5bG9hZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVWaXN1YWw6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuICAgICAgICAgICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmNsZWFyQWxsVmlzdWFsKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZG9WaXN1YWxFbmNvZGluZy5jYWxsKHRoaXMsIGVjTW9kZWwsIHBheWxvYWQsIHRydWUpO1xuXG4gICAgICAgICAgICBpbnZva2VVcGRhdGVNZXRob2QuY2FsbCh0aGlzLCAndXBkYXRlVmlzdWFsJywgZWNNb2RlbCwgcGF5bG9hZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuICAgICAgICAgICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb0xheW91dC5jYWxsKHRoaXMsIGVjTW9kZWwsIHBheWxvYWQpO1xuXG4gICAgICAgICAgICBpbnZva2VVcGRhdGVNZXRob2QuY2FsbCh0aGlzLCAndXBkYXRlTGF5b3V0JywgZWNNb2RlbCwgcGF5bG9hZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBwcmVwYXJlQW5kVXBkYXRlOiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcblxuICAgICAgICAgICAgcHJlcGFyZVZpZXcuY2FsbCh0aGlzLCAnY29tcG9uZW50JywgZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIHByZXBhcmVWaWV3LmNhbGwodGhpcywgJ2NoYXJ0JywgZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyB1Z2x5XG4gICAgICAgICAgICBpZiAodGhpcy5fX2xhc3RPbmx5R3JhcGhpYykge1xuICAgICAgICAgICAgICAgIGVhY2godGhpcy5fY29tcG9uZW50c1ZpZXdzLCBmdW5jdGlvbiAoY29tcG9uZW50Vmlldykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50TW9kZWwgPSBjb21wb25lbnRWaWV3Ll9fbW9kZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRNb2RlbCAmJiBjb21wb25lbnRNb2RlbC5tYWluVHlwZSA9PT0gJ2dyYXBoaWMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRWaWV3LnJlbmRlcihjb21wb25lbnRNb2RlbCwgZWNNb2RlbCwgdGhpcy5fYXBpLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVooY29tcG9uZW50TW9kZWwsIGNvbXBvbmVudFZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2xhc3RPbmx5R3JhcGhpYyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlTWV0aG9kcy51cGRhdGUuY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZURpcmVjdGx5KGVjSW5zLCBtZXRob2QsIHBheWxvYWQsIG1haW5UeXBlLCBzdWJUeXBlKSB7XG4gICAgICAgIHZhciBlY01vZGVsID0gZWNJbnMuX21vZGVsO1xuICAgICAgICB2YXIgcXVlcnkgPSB7fTtcbiAgICAgICAgcXVlcnlbbWFpblR5cGUgKyAnSWQnXSA9IHBheWxvYWRbbWFpblR5cGUgKyAnSWQnXTtcbiAgICAgICAgcXVlcnlbbWFpblR5cGUgKyAnSW5kZXgnXSA9IHBheWxvYWRbbWFpblR5cGUgKyAnSW5kZXgnXTtcbiAgICAgICAgcXVlcnlbbWFpblR5cGUgKyAnTmFtZSddID0gcGF5bG9hZFttYWluVHlwZSArICdOYW1lJ107XG5cbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHttYWluVHlwZTogbWFpblR5cGUsIHF1ZXJ5OiBxdWVyeX07XG4gICAgICAgIHN1YlR5cGUgJiYgKGNvbmRpdGlvbi5zdWJUeXBlID0gc3ViVHlwZSk7IC8vIHN1YlR5cGUgbWF5IGJlICcnIGJ5IHBhcnNlQ2xhc3NUeXBlO1xuXG4gICAgICAgIC8vIElmIGRpc3BhdGNoQWN0aW9uIGJlZm9yZSBzZXRPcHRpb24sIGRvIG5vdGhpbmcuXG4gICAgICAgIGVjTW9kZWwgJiYgZWNNb2RlbC5lYWNoQ29tcG9uZW50KGNvbmRpdGlvbiwgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBlY0luc1tcbiAgICAgICAgICAgICAgICBtYWluVHlwZSA9PT0gJ3NlcmllcycgPyAnX2NoYXJ0c01hcCcgOiAnX2NvbXBvbmVudHNNYXAnXG4gICAgICAgICAgICBdW21vZGVsLl9fdmlld0lkXTtcbiAgICAgICAgICAgIGlmICh2aWV3ICYmIHZpZXcuX19hbGl2ZSkge1xuICAgICAgICAgICAgICAgIHZpZXdbbWV0aG9kXShtb2RlbCwgZWNNb2RlbCwgZWNJbnMuX2FwaSwgcGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVjSW5zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgdGhlIGNoYXJ0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMud2lkdGhdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2lsZW50PWZhbHNlXVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5yZXNpemUgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgenJVdGlsLmFzc2VydCghdGhpc1tJTl9NQUlOX1BST0NFU1NdLCAnYHJlc2l6ZWAgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZHVyaW5nIG1haW4gcHJvY2Vzcy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fenIucmVzaXplKG9wdHMpO1xuXG4gICAgICAgIHZhciBvcHRpb25DaGFuZ2VkID0gdGhpcy5fbW9kZWwgJiYgdGhpcy5fbW9kZWwucmVzZXRPcHRpb24oJ21lZGlhJyk7XG4gICAgICAgIHZhciB1cGRhdGVNZXRob2QgPSBvcHRpb25DaGFuZ2VkID8gJ3ByZXBhcmVBbmRVcGRhdGUnIDogJ3VwZGF0ZSc7XG5cbiAgICAgICAgdXBkYXRlTWV0aG9kc1t1cGRhdGVNZXRob2RdLmNhbGwodGhpcyk7XG5cbiAgICAgICAgLy8gUmVzaXplIGxvYWRpbmcgZWZmZWN0XG4gICAgICAgIHRoaXMuX2xvYWRpbmdGWCAmJiB0aGlzLl9sb2FkaW5nRlgucmVzaXplKCk7XG5cbiAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHNpbGVudCA9IG9wdHMgJiYgb3B0cy5zaWxlbnQ7XG5cbiAgICAgICAgZmx1c2hQZW5kaW5nQWN0aW9ucy5jYWxsKHRoaXMsIHNpbGVudCk7XG5cbiAgICAgICAgdHJpZ2dlclVwZGF0ZWRFdmVudC5jYWxsKHRoaXMsIHNpbGVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNob3cgbG9hZGluZyBlZmZlY3RcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IFtuYW1lPSdkZWZhdWx0J11cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtjZmddXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLnNob3dMb2FkaW5nID0gZnVuY3Rpb24gKG5hbWUsIGNmZykge1xuICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjZmcgPSBuYW1lO1xuICAgICAgICAgICAgbmFtZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBuYW1lIHx8ICdkZWZhdWx0JztcblxuICAgICAgICB0aGlzLmhpZGVMb2FkaW5nKCk7XG4gICAgICAgIGlmICghbG9hZGluZ0VmZmVjdHNbbmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2FkaW5nIGVmZmVjdHMgJyArIG5hbWUgKyAnIG5vdCBleGlzdHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsID0gbG9hZGluZ0VmZmVjdHNbbmFtZV0odGhpcy5fYXBpLCBjZmcpO1xuICAgICAgICB2YXIgenIgPSB0aGlzLl96cjtcbiAgICAgICAgdGhpcy5fbG9hZGluZ0ZYID0gZWw7XG5cbiAgICAgICAgenIuYWRkKGVsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGlkZSBsb2FkaW5nIGVmZmVjdFxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5oaWRlTG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbG9hZGluZ0ZYICYmIHRoaXMuX3pyLnJlbW92ZSh0aGlzLl9sb2FkaW5nRlgpO1xuICAgICAgICB0aGlzLl9sb2FkaW5nRlggPSBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRPYmpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLm1ha2VBY3Rpb25Gcm9tRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRPYmopIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB6clV0aWwuZXh0ZW5kKHt9LCBldmVudE9iaik7XG4gICAgICAgIHBheWxvYWQudHlwZSA9IGV2ZW50QWN0aW9uTWFwW2V2ZW50T2JqLnR5cGVdO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHB1YmlsY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXlsb2FkLnR5cGVdIEFjdGlvbiB0eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbn0gW29wdF0gSWYgcGFzcyBib29sZWFuLCBtZWFucyBvcHQuc2lsZW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0LnNpbGVudD1mYWxzZV0gV2hldGhlciB0cmlnZ2VyIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQuZmx1c2g9dW5kZWZpbmVkXVxuICAgICAqICAgICAgICAgICAgICAgICAgdHJ1ZTogRmx1c2ggaW1tZWRpYXRlbHksIGFuZCB0aGVuIHBpeGVsIGluIGNhbnZhcyBjYW4gYmUgZmV0Y2hlZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5LiBDYXV0aW9uOiBpdCBtaWdodCBhZmZlY3QgcGVyZm9ybWFuY2UuXG4gICAgICogICAgICAgICAgICAgICAgICBmYWxzZTogTm90IG5vdCBmbHVzaC5cbiAgICAgKiAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDogQXV0byBkZWNpZGUgd2hldGhlciBwZXJmb3JtIGZsdXNoLlxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5kaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uIChwYXlsb2FkLCBvcHQpIHtcbiAgICAgICAgaWYgKCF6clV0aWwuaXNPYmplY3Qob3B0KSkge1xuICAgICAgICAgICAgb3B0ID0ge3NpbGVudDogISFvcHR9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhY3Rpb25zW3BheWxvYWQudHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIC8vICAgICB6clV0aWwuYXNzZXJ0KFxuICAgICAgICAvLyAgICAgICAgICF0aGlzW0lOX01BSU5fUFJPQ0VTU10sXG4gICAgICAgIC8vICAgICAgICAgJ2BkaXNwYXRjaEFjdGlvbmAgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZHVyaW5nIG1haW4gcHJvY2Vzcy4nXG4gICAgICAgIC8vICAgICAgICAgKyAndW5sZXNzIHVwZGF0ZU1hdGhvZCBpcyBcIm5vbmVcIi4nXG4gICAgICAgIC8vICAgICApO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gTWF5IGRpc3BhdGNoQWN0aW9uIGluIHJlbmRlcmluZyBwcm9jZWR1cmVcbiAgICAgICAgaWYgKHRoaXNbSU5fTUFJTl9QUk9DRVNTXSkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0FjdGlvbnMucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvRGlzcGF0Y2hBY3Rpb24uY2FsbCh0aGlzLCBwYXlsb2FkLCBvcHQuc2lsZW50KTtcblxuICAgICAgICBpZiAob3B0LmZsdXNoKSB7XG4gICAgICAgICAgICB0aGlzLl96ci5mbHVzaCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHQuZmx1c2ggIT09IGZhbHNlICYmIGVudi5icm93c2VyLndlQ2hhdCkge1xuICAgICAgICAgICAgLy8gSW4gV2VDaGF0IGVtYmVkZWQgYnJvd3NlciwgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYW5kIGBzZXRJbnRlcnZhbGBcbiAgICAgICAgICAgIC8vIGhhbmcgd2hlbiBzbGlkaW5nIHBhZ2UgKG9uIHRvdWNoIGV2ZW50KSwgd2hpY2ggY2F1c2UgdGhhdCB6ciBkb2VzIG5vdFxuICAgICAgICAgICAgLy8gcmVmcmVzaCB1dGlsIHVzZXIgaW50ZXJhY3Rpb24gZmluaXNoZWQsIHdoaWNoIGlzIG5vdCBleHBlY3RlZC5cbiAgICAgICAgICAgIC8vIEJ1dCBgZGlzcGF0Y2hBY3Rpb25gIG1heSBiZSBjYWxsZWQgdG9vIGZyZXF1ZW50bHkgd2hlbiBwYW4gb24gdG91Y2hcbiAgICAgICAgICAgIC8vIHNjcmVlbiwgd2hpY2ggaW1wYWN0cyBwZXJmb3JtYW5jZSBpZiBkbyBub3QgdGhyb3R0bGUgdGhlbS5cbiAgICAgICAgICAgIHRoaXMuX3Rocm90dGxlZFpyRmx1c2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsdXNoUGVuZGluZ0FjdGlvbnMuY2FsbCh0aGlzLCBvcHQuc2lsZW50KTtcblxuICAgICAgICB0cmlnZ2VyVXBkYXRlZEV2ZW50LmNhbGwodGhpcywgb3B0LnNpbGVudCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRvRGlzcGF0Y2hBY3Rpb24ocGF5bG9hZCwgc2lsZW50KSB7XG4gICAgICAgIHZhciBwYXlsb2FkVHlwZSA9IHBheWxvYWQudHlwZTtcbiAgICAgICAgdmFyIGFjdGlvbldyYXAgPSBhY3Rpb25zW3BheWxvYWRUeXBlXTtcbiAgICAgICAgdmFyIGFjdGlvbkluZm8gPSBhY3Rpb25XcmFwLmFjdGlvbkluZm87XG5cbiAgICAgICAgdmFyIGNwdFR5cGUgPSAoYWN0aW9uSW5mby51cGRhdGUgfHwgJ3VwZGF0ZScpLnNwbGl0KCc6Jyk7XG4gICAgICAgIHZhciB1cGRhdGVNZXRob2QgPSBjcHRUeXBlLnBvcCgpO1xuICAgICAgICBjcHRUeXBlID0gY3B0VHlwZVswXSAmJiBwYXJzZUNsYXNzVHlwZShjcHRUeXBlWzBdKTtcblxuICAgICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSB0cnVlO1xuXG4gICAgICAgIHZhciBwYXlsb2FkcyA9IFtwYXlsb2FkXTtcbiAgICAgICAgdmFyIGJhdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQmF0Y2ggYWN0aW9uXG4gICAgICAgIGlmIChwYXlsb2FkLmJhdGNoKSB7XG4gICAgICAgICAgICBiYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBheWxvYWRzID0genJVdGlsLm1hcChwYXlsb2FkLmJhdGNoLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB6clV0aWwuZGVmYXVsdHMoenJVdGlsLmV4dGVuZCh7fSwgaXRlbSksIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGl0ZW0uYmF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZlbnRPYmpCYXRjaCA9IFtdO1xuICAgICAgICB2YXIgZXZlbnRPYmo7XG4gICAgICAgIHZhciBpc0hpZ2hEb3duID0gcGF5bG9hZFR5cGUgPT09ICdoaWdobGlnaHQnIHx8IHBheWxvYWRUeXBlID09PSAnZG93bnBsYXknO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF5bG9hZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBiYXRjaEl0ZW0gPSBwYXlsb2Fkc1tpXTtcbiAgICAgICAgICAgIC8vIEFjdGlvbiBjYW4gc3BlY2lmeSB0aGUgZXZlbnQgYnkgcmV0dXJuIGl0LlxuICAgICAgICAgICAgZXZlbnRPYmogPSBhY3Rpb25XcmFwLmFjdGlvbihiYXRjaEl0ZW0sIHRoaXMuX21vZGVsKTtcbiAgICAgICAgICAgIC8vIEVtaXQgZXZlbnQgb3V0c2lkZVxuICAgICAgICAgICAgZXZlbnRPYmogPSBldmVudE9iaiB8fCB6clV0aWwuZXh0ZW5kKHt9LCBiYXRjaEl0ZW0pO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0eXBlIHRvIGV2ZW50VHlwZVxuICAgICAgICAgICAgZXZlbnRPYmoudHlwZSA9IGFjdGlvbkluZm8uZXZlbnQgfHwgZXZlbnRPYmoudHlwZTtcbiAgICAgICAgICAgIGV2ZW50T2JqQmF0Y2gucHVzaChldmVudE9iaik7XG5cbiAgICAgICAgICAgIC8vIGxpZ2h0IHVwZGF0ZSBkb2VzIG5vdCBwZXJmb3JtIGRhdGEgcHJvY2VzcywgbGF5b3V0IGFuZCB2aXN1YWwuXG4gICAgICAgICAgICBpZiAoaXNIaWdoRG93bikge1xuICAgICAgICAgICAgICAgIC8vIG1ldGhvZCwgcGF5bG9hZCwgbWFpblR5cGUsIHN1YlR5cGVcbiAgICAgICAgICAgICAgICB1cGRhdGVEaXJlY3RseSh0aGlzLCB1cGRhdGVNZXRob2QsIGJhdGNoSXRlbSwgJ3NlcmllcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3B0VHlwZSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZURpcmVjdGx5KHRoaXMsIHVwZGF0ZU1ldGhvZCwgYmF0Y2hJdGVtLCBjcHRUeXBlLm1haW4sIGNwdFR5cGUuc3ViKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cGRhdGVNZXRob2QgIT09ICdub25lJyAmJiAhaXNIaWdoRG93biAmJiAhY3B0VHlwZSkge1xuICAgICAgICAgICAgLy8gU3RpbGwgZGlydHlcbiAgICAgICAgICAgIGlmICh0aGlzW09QVElPTl9VUERBVEVEXSkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIFBhc3MgcGF5bG9hZCA/XG4gICAgICAgICAgICAgICAgdXBkYXRlTWV0aG9kcy5wcmVwYXJlQW5kVXBkYXRlLmNhbGwodGhpcywgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgdGhpc1tPUFRJT05fVVBEQVRFRF0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZU1ldGhvZHNbdXBkYXRlTWV0aG9kXS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9sbG93IHRoZSBydWxlIG9mIGFjdGlvbiBiYXRjaFxuICAgICAgICBpZiAoYmF0Y2hlZCkge1xuICAgICAgICAgICAgZXZlbnRPYmogPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogYWN0aW9uSW5mby5ldmVudCB8fCBwYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICBiYXRjaDogZXZlbnRPYmpCYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50T2JqID0gZXZlbnRPYmpCYXRjaFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuXG4gICAgICAgICFzaWxlbnQgJiYgdGhpcy5fbWVzc2FnZUNlbnRlci50cmlnZ2VyKGV2ZW50T2JqLnR5cGUsIGV2ZW50T2JqKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbHVzaFBlbmRpbmdBY3Rpb25zKHNpbGVudCkge1xuICAgICAgICB2YXIgcGVuZGluZ0FjdGlvbnMgPSB0aGlzLl9wZW5kaW5nQWN0aW9ucztcbiAgICAgICAgd2hpbGUgKHBlbmRpbmdBY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBwZW5kaW5nQWN0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgICAgZG9EaXNwYXRjaEFjdGlvbi5jYWxsKHRoaXMsIHBheWxvYWQsIHNpbGVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyVXBkYXRlZEV2ZW50KHNpbGVudCkge1xuICAgICAgICAhc2lsZW50ICYmIHRoaXMudHJpZ2dlcigndXBkYXRlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGV2ZW50XG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5vbiA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb24nKTtcbiAgICBlY2hhcnRzUHJvdG8ub2ZmID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvZmYnKTtcbiAgICBlY2hhcnRzUHJvdG8ub25lID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvbmUnKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZva2VVcGRhdGVNZXRob2QobWV0aG9kTmFtZSwgZWNNb2RlbCwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgY29tcG9uZW50c1xuICAgICAgICBlYWNoKHRoaXMuX2NvbXBvbmVudHNWaWV3cywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE1vZGVsID0gY29tcG9uZW50Ll9fbW9kZWw7XG4gICAgICAgICAgICBjb21wb25lbnRbbWV0aG9kTmFtZV0oY29tcG9uZW50TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIHVwZGF0ZVooY29tcG9uZW50TW9kZWwsIGNvbXBvbmVudCk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIFVwYXRlIGFsbCBjaGFydHNcbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgY2hhcnQgPSB0aGlzLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuICAgICAgICAgICAgY2hhcnRbbWV0aG9kTmFtZV0oc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIHVwZGF0ZVooc2VyaWVzTW9kZWwsIGNoYXJ0KTtcblxuICAgICAgICAgICAgdXBkYXRlUHJvZ3Jlc3NpdmVBbmRCbGVuZChzZXJpZXNNb2RlbCwgY2hhcnQpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvLyBJZiB1c2UgaG92ZXIgbGF5ZXJcbiAgICAgICAgdXBkYXRlSG92ZXJMYXllclN0YXR1cyh0aGlzLl96ciwgZWNNb2RlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB2aWV3IGluc3RhbmNlcyBvZiBjaGFydHMgYW5kIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByZXBhcmVWaWV3KHR5cGUsIGVjTW9kZWwpIHtcbiAgICAgICAgdmFyIGlzQ29tcG9uZW50ID0gdHlwZSA9PT0gJ2NvbXBvbmVudCc7XG4gICAgICAgIHZhciB2aWV3TGlzdCA9IGlzQ29tcG9uZW50ID8gdGhpcy5fY29tcG9uZW50c1ZpZXdzIDogdGhpcy5fY2hhcnRzVmlld3M7XG4gICAgICAgIHZhciB2aWV3TWFwID0gaXNDb21wb25lbnQgPyB0aGlzLl9jb21wb25lbnRzTWFwIDogdGhpcy5fY2hhcnRzTWFwO1xuICAgICAgICB2YXIgenIgPSB0aGlzLl96cjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3TGlzdFtpXS5fX2FsaXZlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBlY01vZGVsW2lzQ29tcG9uZW50ID8gJ2VhY2hDb21wb25lbnQnIDogJ2VhY2hTZXJpZXMnXShmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgbW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRUeXBlID09PSAnc2VyaWVzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBjb21wb25lbnRUeXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb25zaWRlcjogaWQgc2FtZSBhbmQgdHlwZSBjaGFuZ2VkLlxuICAgICAgICAgICAgdmFyIHZpZXdJZCA9IG1vZGVsLmlkICsgJ18nICsgbW9kZWwudHlwZTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdmlld01hcFt2aWV3SWRdO1xuICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKG1vZGVsLnR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciBDbGF6eiA9IGlzQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgID8gQ29tcG9uZW50Vmlldy5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgY2xhc3NUeXBlLnN1YilcbiAgICAgICAgICAgICAgICAgICAgOiBDaGFydFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLnN1Yik7XG4gICAgICAgICAgICAgICAgaWYgKENsYXp6KSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcgPSBuZXcgQ2xhenooKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5pbml0KGVjTW9kZWwsIHRoaXMuX2FwaSk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdNYXBbdmlld0lkXSA9IHZpZXc7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdMaXN0LnB1c2godmlldyk7XG4gICAgICAgICAgICAgICAgICAgIHpyLmFkZCh2aWV3Lmdyb3VwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVycm9yXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vZGVsLl9fdmlld0lkID0gdmlld0lkO1xuICAgICAgICAgICAgdmlldy5fX2FsaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpZXcuX19pZCA9IHZpZXdJZDtcbiAgICAgICAgICAgIHZpZXcuX19tb2RlbCA9IG1vZGVsO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdMaXN0Lmxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdmlld0xpc3RbaV07XG4gICAgICAgICAgICBpZiAoIXZpZXcuX19hbGl2ZSkge1xuICAgICAgICAgICAgICAgIHpyLnJlbW92ZSh2aWV3Lmdyb3VwKTtcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3Bvc2UoZWNNb2RlbCwgdGhpcy5fYXBpKTtcbiAgICAgICAgICAgICAgICB2aWV3TGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZpZXdNYXBbdmlldy5fX2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NvciBkYXRhIGluIGVhY2ggc2VyaWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0RhdGEoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIGVhY2goZGF0YVByb2Nlc3NvckZ1bmNzLCBmdW5jdGlvbiAocHJvY2Vzcykge1xuICAgICAgICAgICAgcHJvY2Vzcy5mdW5jKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tTZXJpZXNEYXRhKGVjTW9kZWwpIHtcbiAgICAgICAgdmFyIHN0YWNrZWREYXRhTWFwID0ge307XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBzZXJpZXMuZ2V0KCdzdGFjaycpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXMuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrICYmIGRhdGEudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzU3RhY2sgPSBzdGFja2VkRGF0YU1hcFtzdGFja107XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zdGFja2VkT24gPSBwcmV2aW91c1N0YWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFja2VkRGF0YU1hcFtzdGFja10gPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMYXlvdXQgYmVmb3JlIGVhY2ggY2hhcnQgcmVuZGVyIHRoZXJlIHNlcmllcywgc3BlY2lhbCB2aXN1YWwgZW5jb2Rpbmcgc3RhZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0xheW91dChlY01vZGVsLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgIGVhY2godmlzdWFsRnVuY3MsIGZ1bmN0aW9uICh2aXN1YWwpIHtcbiAgICAgICAgICAgIGlmICh2aXN1YWwuaXNMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB2aXN1YWwuZnVuYyhlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgdmlzdWFsIGluZm9tYXRpb24gZnJvbSBkYXRhIGFmdGVyIGRhdGEgcHJvY2Vzc2luZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbGF5b3V0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZXhjbHVkZXNMYXlvdXRdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb1Zpc3VhbEVuY29kaW5nKGVjTW9kZWwsIHBheWxvYWQsIGV4Y2x1ZGVzTGF5b3V0KSB7XG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgIGVjTW9kZWwuY2xlYXJDb2xvclBhbGV0dGUoKTtcbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgc2VyaWVzTW9kZWwuY2xlYXJDb2xvclBhbGV0dGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2godmlzdWFsRnVuY3MsIGZ1bmN0aW9uICh2aXN1YWwpIHtcbiAgICAgICAgICAgICghZXhjbHVkZXNMYXlvdXQgfHwgIXZpc3VhbC5pc0xheW91dClcbiAgICAgICAgICAgICAgICAmJiB2aXN1YWwuZnVuYyhlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZWFjaCBjaGFydCBhbmQgY29tcG9uZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb1JlbmRlcihlY01vZGVsLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgIC8vIFJlbmRlciBhbGwgY29tcG9uZW50c1xuICAgICAgICBlYWNoKHRoaXMuX2NvbXBvbmVudHNWaWV3cywgZnVuY3Rpb24gKGNvbXBvbmVudFZpZXcpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRNb2RlbCA9IGNvbXBvbmVudFZpZXcuX19tb2RlbDtcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXcucmVuZGVyKGNvbXBvbmVudE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuXG4gICAgICAgICAgICB1cGRhdGVaKGNvbXBvbmVudE1vZGVsLCBjb21wb25lbnRWaWV3KTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgZWFjaCh0aGlzLl9jaGFydHNWaWV3cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgICAgICAgICBjaGFydC5fX2FsaXZlID0gZmFsc2U7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIFJlbmRlciBhbGwgY2hhcnRzXG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGNoYXJ0VmlldyA9IHRoaXMuX2NoYXJ0c01hcFtzZXJpZXNNb2RlbC5fX3ZpZXdJZF07XG4gICAgICAgICAgICBjaGFydFZpZXcuX19hbGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBjaGFydFZpZXcucmVuZGVyKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuXG4gICAgICAgICAgICBjaGFydFZpZXcuZ3JvdXAuc2lsZW50ID0gISFzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpO1xuXG4gICAgICAgICAgICB1cGRhdGVaKHNlcmllc01vZGVsLCBjaGFydFZpZXcpO1xuXG4gICAgICAgICAgICB1cGRhdGVQcm9ncmVzc2l2ZUFuZEJsZW5kKHNlcmllc01vZGVsLCBjaGFydFZpZXcpO1xuXG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIElmIHVzZSBob3ZlciBsYXllclxuICAgICAgICB1cGRhdGVIb3ZlckxheWVyU3RhdHVzKHRoaXMuX3pyLCBlY01vZGVsKTtcblxuICAgICAgICAvLyBSZW1vdmUgZ3JvdXBzIG9mIHVucmVuZGVyZWQgY2hhcnRzXG4gICAgICAgIGVhY2godGhpcy5fY2hhcnRzVmlld3MsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICAgICAgaWYgKCFjaGFydC5fX2FsaXZlKSB7XG4gICAgICAgICAgICAgICAgY2hhcnQucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFtcbiAgICAgICAgJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLFxuICAgICAgICAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnZ2xvYmFsb3V0JywgJ2NvbnRleHRtZW51J1xuICAgIF07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uX2luaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl96ci5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5nZXRNb2RlbCgpO1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXM7XG5cbiAgICAgICAgICAgICAgICAvLyBubyBlLnRhcmdldCB3aGVuICdnbG9iYWxvdXQnLlxuICAgICAgICAgICAgICAgIGlmIChldmVOYW1lID09PSAnZ2xvYmFsb3V0Jykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZWwgJiYgZWwuZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFNb2RlbCA9IGVsLmRhdGFNb2RlbCB8fCBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoZWwuc2VyaWVzSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBkYXRhTW9kZWwgJiYgZGF0YU1vZGVsLmdldERhdGFQYXJhbXMoZWwuZGF0YUluZGV4LCBlbC5kYXRhVHlwZSkgfHwge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIGN1c3RvbSBldmVudERhdGEgb2YgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsICYmIGVsLmV2ZW50RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB6clV0aWwuZXh0ZW5kKHt9LCBlbC5ldmVudERhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBldmVOYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoZXZlTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBlYWNoKGV2ZW50QWN0aW9uTWFwLCBmdW5jdGlvbiAoYWN0aW9uVHlwZSwgZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlQ2VudGVyLm9uKGV2ZW50VHlwZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50VHlwZSwgZXZlbnQpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5pc0Rpc3Bvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbih7IHNlcmllczogW10gfSwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIGluc3RhbmNlXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0luc3RhbmNlICcgKyB0aGlzLmlkICsgJyBoYXMgYmVlbiBkaXNwb3NlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcblxuICAgICAgICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gICAgICAgIGVhY2godGhpcy5fY29tcG9uZW50c1ZpZXdzLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnQuZGlzcG9zZShlY01vZGVsLCBhcGkpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaCh0aGlzLl9jaGFydHNWaWV3cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgICAgICAgICBjaGFydC5kaXNwb3NlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERpc3Bvc2UgYWZ0ZXIgYWxsIHZpZXdzIGRpc3Bvc2VkXG4gICAgICAgIHRoaXMuX3pyLmRpc3Bvc2UoKTtcblxuICAgICAgICBkZWxldGUgaW5zdGFuY2VzW3RoaXMuaWRdO1xuICAgIH07XG5cbiAgICB6clV0aWwubWl4aW4oRUNoYXJ0cywgRXZlbnRmdWwpO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlSG92ZXJMYXllclN0YXR1cyh6ciwgZWNNb2RlbCkge1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHpyLnN0b3JhZ2U7XG4gICAgICAgIHZhciBlbENvdW50ID0gMDtcbiAgICAgICAgc3RvcmFnZS50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgICAgICAgICAgIGVsQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlbENvdW50ID4gZWNNb2RlbC5nZXQoJ2hvdmVyTGF5ZXJUaHJlc2hvbGQnKSAmJiAhZW52Lm5vZGUpIHtcbiAgICAgICAgICAgIHN0b3JhZ2UudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnVzZUhvdmVyTGF5ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjaGFydCBwcm9ncmVzc2l2ZSBhbmQgYmxlbmQuXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN8bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBtb2RlbFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvdmlldy9Db21wb25lbnR8bW9kdWxlOmVjaGFydHMvdmlldy9DaGFydH0gdmlld1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVByb2dyZXNzaXZlQW5kQmxlbmQoc2VyaWVzTW9kZWwsIGNoYXJ0Vmlldykge1xuICAgICAgICAvLyBQcm9ncmVzc2l2ZSBjb25maWd1cmF0aW9uXG4gICAgICAgIHZhciBlbENvdW50ID0gMDtcbiAgICAgICAgY2hhcnRWaWV3Lmdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsLnR5cGUgIT09ICdncm91cCcgJiYgIWVsLmlnbm9yZSkge1xuICAgICAgICAgICAgICAgIGVsQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmcmFtZURyYXdOdW0gPSArc2VyaWVzTW9kZWwuZ2V0KCdwcm9ncmVzc2l2ZScpO1xuICAgICAgICB2YXIgbmVlZFByb2dyZXNzaXZlID0gZWxDb3VudCA+IHNlcmllc01vZGVsLmdldCgncHJvZ3Jlc3NpdmVUaHJlc2hvbGQnKSAmJiBmcmFtZURyYXdOdW0gJiYgIWVudi5ub2RlO1xuICAgICAgICBpZiAobmVlZFByb2dyZXNzaXZlKSB7XG4gICAgICAgICAgICBjaGFydFZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgbWFya2VyIGFuZCBvdGhlciBjb21wb25lbnRzXG4gICAgICAgICAgICAgICAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnByb2dyZXNzaXZlID0gbmVlZFByb2dyZXNzaXZlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoZWxDb3VudCsrIC8gZnJhbWVEcmF3TnVtKSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVlZFByb2dyZXNzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCbGVuZCBjb25maWdyYXRpb25cbiAgICAgICAgdmFyIGJsZW5kTW9kZSA9IHNlcmllc01vZGVsLmdldCgnYmxlbmRNb2RlJykgfHwgbnVsbDtcbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCAmJiBibGVuZE1vZGUgJiYgYmxlbmRNb2RlICE9PSAnc291cmNlLW92ZXInKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdPbmx5IGNhbnZhcyBzdXBwb3J0IGJsZW5kTW9kZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoYXJ0Vmlldy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIG1hcmtlciBhbmQgb3RoZXIgY29tcG9uZW50c1xuICAgICAgICAgICAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0U3R5bGUoJ2JsZW5kJywgYmxlbmRNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gbW9kZWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50fG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnR9IHZpZXdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVaKG1vZGVsLCB2aWV3KSB7XG4gICAgICAgIHZhciB6ID0gbW9kZWwuZ2V0KCd6Jyk7XG4gICAgICAgIHZhciB6bGV2ZWwgPSBtb2RlbC5nZXQoJ3psZXZlbCcpO1xuICAgICAgICAvLyBTZXQgeiBhbmQgemxldmVsXG4gICAgICAgIHZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgIHogIT0gbnVsbCAmJiAoZWwueiA9IHopO1xuICAgICAgICAgICAgICAgIHpsZXZlbCAhPSBudWxsICYmIChlbC56bGV2ZWwgPSB6bGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5LjxGdW5jdGlvbj59XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIGFjdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIE1hcCBldmVudFR5cGUgdG8gYWN0aW9uVHlwZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIGV2ZW50QWN0aW9uTWFwID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIHByb2Nlc3NvciBmdW5jdGlvbnMgb2YgZWFjaCBzdGFnZVxuICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0LjxzdHJpbmcsIEZ1bmN0aW9uPj59XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIGRhdGFQcm9jZXNzb3JGdW5jcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5LjxGdW5jdGlvbj59XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBWaXN1YWwgZW5jb2RpbmcgZnVuY3Rpb25zIG9mIGVhY2ggc3RhZ2VcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdC48c3RyaW5nLCBGdW5jdGlvbj4+fVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciB2aXN1YWxGdW5jcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIFRoZW1lIHN0b3JhZ2VcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxrZXksIE9iamVjdD59XG4gICAgICovXG4gICAgdmFyIHRoZW1lU3RvcmFnZSA9IHt9O1xuICAgIC8qKlxuICAgICAqIExvYWRpbmcgZWZmZWN0c1xuICAgICAqL1xuICAgIHZhciBsb2FkaW5nRWZmZWN0cyA9IHt9O1xuXG5cbiAgICB2YXIgaW5zdGFuY2VzID0ge307XG4gICAgdmFyIGNvbm5lY3RlZEdyb3VwcyA9IHt9O1xuXG4gICAgdmFyIGlkQmFzZSA9IG5ldyBEYXRlKCkgLSAwO1xuICAgIHZhciBncm91cElkQmFzZSA9IG5ldyBEYXRlKCkgLSAwO1xuICAgIHZhciBET01fQVRUUklCVVRFX0tFWSA9ICdfZWNoYXJ0c19pbnN0YW5jZV8nO1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0c1xuICAgICAqL1xuICAgIHZhciBlY2hhcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZlcnNpb246ICczLjQuMCcsXG4gICAgICAgIGRlcGVuZGVuY2llczoge1xuICAgICAgICAgICAgenJlbmRlcjogJzMuMy4wJ1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGVuYWJsZUNvbm5lY3QoY2hhcnQpIHtcblxuICAgICAgICB2YXIgU1RBVFVTX1BFTkRJTkcgPSAwO1xuICAgICAgICB2YXIgU1RBVFVTX1VQREFUSU5HID0gMTtcbiAgICAgICAgdmFyIFNUQVRVU19VUERBVEVEID0gMjtcbiAgICAgICAgdmFyIFNUQVRVU19LRVkgPSAnX19jb25uZWN0VXBkYXRlU3RhdHVzJztcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ29ubmVjdGVkQ2hhcnRzU3RhdHVzKGNoYXJ0cywgc3RhdHVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlckNoYXJ0ID0gY2hhcnRzW2ldO1xuICAgICAgICAgICAgICAgIG90aGVyQ2hhcnRbU1RBVFVTX0tFWV0gPSBzdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgenJVdGlsLmVhY2goZXZlbnRBY3Rpb25NYXAsIGZ1bmN0aW9uIChhY3Rpb25UeXBlLCBldmVudFR5cGUpIHtcbiAgICAgICAgICAgIGNoYXJ0Ll9tZXNzYWdlQ2VudGVyLm9uKGV2ZW50VHlwZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RlZEdyb3Vwc1tjaGFydC5ncm91cF0gJiYgY2hhcnRbU1RBVFVTX0tFWV0gIT09IFNUQVRVU19QRU5ESU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBjaGFydC5tYWtlQWN0aW9uRnJvbUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyQ2hhcnRzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgenJVdGlsLmVhY2goaW5zdGFuY2VzLCBmdW5jdGlvbiAob3RoZXJDaGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyQ2hhcnQgIT09IGNoYXJ0ICYmIG90aGVyQ2hhcnQuZ3JvdXAgPT09IGNoYXJ0Lmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJDaGFydHMucHVzaChvdGhlckNoYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGVkQ2hhcnRzU3RhdHVzKG90aGVyQ2hhcnRzLCBTVEFUVVNfUEVORElORyk7XG4gICAgICAgICAgICAgICAgICAgIGVhY2gob3RoZXJDaGFydHMsIGZ1bmN0aW9uIChvdGhlckNoYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJDaGFydFtTVEFUVVNfS0VZXSAhPT0gU1RBVFVTX1VQREFUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJDaGFydC5kaXNwYXRjaEFjdGlvbihhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGVkQ2hhcnRzU3RhdHVzKG90aGVyQ2hhcnRzLCBTVEFUVVNfVVBEQVRFRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTERvbUVsZW1lbnR9IGRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdGhlbWVdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb10gVXNlIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIGJ5IGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXJdIEN1cnJlbnRseSBvbmx5ICdjYW52YXMnIGlzIHN1cHBvcnRlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMud2lkdGhdIFVzZSBjbGllbnRXaWR0aCBvZiB0aGUgaW5wdXQgYGRvbWAgYnkgZGVmYXVsdC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWlnaHRdIFVzZSBjbGllbnRIZWlnaHQgb2YgdGhlIGlucHV0IGBkb21gIGJ5IGRlZmF1bHQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICovXG4gICAgZWNoYXJ0cy5pbml0ID0gZnVuY3Rpb24gKGRvbSwgdGhlbWUsIG9wdHMpIHtcbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHZlcnNpb25cbiAgICAgICAgICAgIGlmICgoenJlbmRlci52ZXJzaW9uLnJlcGxhY2UoJy4nLCAnJykgLSAwKSA8IChlY2hhcnRzLmRlcGVuZGVuY2llcy56cmVuZGVyLnJlcGxhY2UoJy4nLCAnJykgLSAwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1pSZW5kZXIgJyArIHpyZW5kZXIudmVyc2lvblxuICAgICAgICAgICAgICAgICAgICArICcgaXMgdG9vIG9sZCBmb3IgRUNoYXJ0cyAnICsgZWNoYXJ0cy52ZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICsgJy4gQ3VycmVudCB2ZXJzaW9uIG5lZWQgWlJlbmRlciAnXG4gICAgICAgICAgICAgICAgICAgICsgZWNoYXJ0cy5kZXBlbmRlbmNpZXMuenJlbmRlciArICcrJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRvbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5pdGlhbGl6ZSBmYWlsZWQ6IGludmFsaWQgZG9tLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHpyVXRpbC5pc0RvbShkb20pICYmIGRvbS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQ0FOVkFTJyAmJiAoIWRvbS5jbGllbnRXaWR0aCB8fCAhZG9tLmNsaWVudEhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NhblxcJ3QgZ2V0IGRvbSB3aWR0aCBvciBoZWlnaHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFydCA9IG5ldyBFQ2hhcnRzKGRvbSwgdGhlbWUsIG9wdHMpO1xuICAgICAgICBjaGFydC5pZCA9ICdlY18nICsgaWRCYXNlKys7XG4gICAgICAgIGluc3RhbmNlc1tjaGFydC5pZF0gPSBjaGFydDtcblxuICAgICAgICBkb20uc2V0QXR0cmlidXRlICYmXG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKERPTV9BVFRSSUJVVEVfS0VZLCBjaGFydC5pZCk7XG5cbiAgICAgICAgZW5hYmxlQ29ubmVjdChjaGFydCk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXkuPG1vZHVsZTplY2hhcnRzfkVDaGFydHM+fSBncm91cElkXG4gICAgICovXG4gICAgZWNoYXJ0cy5jb25uZWN0ID0gZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICAgICAgLy8gSXMgYXJyYXkgb2YgY2hhcnRzXG4gICAgICAgIGlmICh6clV0aWwuaXNBcnJheShncm91cElkKSkge1xuICAgICAgICAgICAgdmFyIGNoYXJ0cyA9IGdyb3VwSWQ7XG4gICAgICAgICAgICBncm91cElkID0gbnVsbDtcbiAgICAgICAgICAgIC8vIElmIGFueSBjaGFydCBoYXMgZ3JvdXBcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGNoYXJ0cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0Lmdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZCA9IGNoYXJ0Lmdyb3VwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBJZCA9IGdyb3VwSWQgfHwgKCdnXycgKyBncm91cElkQmFzZSsrKTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGNoYXJ0cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgICAgICAgICAgICAgY2hhcnQuZ3JvdXAgPSBncm91cElkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGVkR3JvdXBzW2dyb3VwSWRdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGdyb3VwSWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gZ3JvdXBJZFxuICAgICAqL1xuICAgIGVjaGFydHMuZGlzQ29ubmVjdCA9IGZ1bmN0aW9uIChncm91cElkKSB7XG4gICAgICAgIGNvbm5lY3RlZEdyb3Vwc1tncm91cElkXSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIGEgY2hhcnQgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0c35FQ2hhcnRzfEhUTUxEb21FbGVtZW50fHN0cmluZ30gY2hhcnRcbiAgICAgKi9cbiAgICBlY2hhcnRzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICAgICAgaWYgKHpyVXRpbC5pc0RvbShjaGFydCkpIHtcbiAgICAgICAgICAgIGNoYXJ0ID0gZWNoYXJ0cy5nZXRJbnN0YW5jZUJ5RG9tKGNoYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGFydCA9IGluc3RhbmNlc1tjaGFydF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjaGFydCBpbnN0YW5jZW9mIEVDaGFydHMpICYmICFjaGFydC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgIGNoYXJ0LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtIVE1MRG9tRWxlbWVudH0gZG9tXG4gICAgICogQHJldHVybiB7ZWNoYXJ0c35FQ2hhcnRzfVxuICAgICAqL1xuICAgIGVjaGFydHMuZ2V0SW5zdGFuY2VCeURvbSA9IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgdmFyIGtleSA9IGRvbS5nZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVkpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VzW2tleV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybiB7ZWNoYXJ0c35FQ2hhcnRzfVxuICAgICAqL1xuICAgIGVjaGFydHMuZ2V0SW5zdGFuY2VCeUlkID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VzW2tleV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHRoZW1lXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlclRoZW1lID0gZnVuY3Rpb24gKG5hbWUsIHRoZW1lKSB7XG4gICAgICAgIHRoZW1lU3RvcmFnZVtuYW1lXSA9IHRoZW1lO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBvcHRpb24gcHJlcHJvY2Vzc29yXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlcHJvY2Vzc29yRnVuY1xuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJQcmVwcm9jZXNzb3IgPSBmdW5jdGlvbiAocHJlcHJvY2Vzc29yRnVuYykge1xuICAgICAgICBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcy5wdXNoKHByZXByb2Nlc3NvckZ1bmMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PTEwMDBdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvY2Vzc29yRnVuY1xuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJQcm9jZXNzb3IgPSBmdW5jdGlvbiAocHJpb3JpdHksIHByb2Nlc3NvckZ1bmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJvY2Vzc29yRnVuYyA9IHByaW9yaXR5O1xuICAgICAgICAgICAgcHJpb3JpdHkgPSBQUklPUklUWV9QUk9DRVNTT1JfRklMVEVSO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocHJpb3JpdHkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtvd24gcHJvY2Vzc29yIHByaW9yaXR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVByb2Nlc3NvckZ1bmNzLnB1c2goe1xuICAgICAgICAgICAgcHJpbzogcHJpb3JpdHksXG4gICAgICAgICAgICBmdW5jOiBwcm9jZXNzb3JGdW5jXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2FnZTpcbiAgICAgKiByZWdpc3RlckFjdGlvbignc29tZUFjdGlvbicsICdzb21lRXZlbnQnLCBmdW5jdGlvbiAoKSB7IC4uLiB9KTtcbiAgICAgKiByZWdpc3RlckFjdGlvbignc29tZUFjdGlvbicsIGZ1bmN0aW9uICgpIHsgLi4uIH0pO1xuICAgICAqIHJlZ2lzdGVyQWN0aW9uKFxuICAgICAqICAgICB7dHlwZTogJ3NvbWVBY3Rpb24nLCBldmVudDogJ3NvbWVFdmVudCcsIHVwZGF0ZTogJ3VwZGF0ZVZpZXcnfSxcbiAgICAgKiAgICAgZnVuY3Rpb24gKCkgeyAuLi4gfVxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8T2JqZWN0KX0gYWN0aW9uSW5mb1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25JbmZvLnR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FjdGlvbkluZm8uZXZlbnRdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFthY3Rpb25JbmZvLnVwZGF0ZV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2V2ZW50TmFtZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb25cbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyQWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbkluZm8sIGV2ZW50TmFtZSwgYWN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBldmVudE5hbWU7XG4gICAgICAgICAgICBldmVudE5hbWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWN0aW9uVHlwZSA9IHpyVXRpbC5pc09iamVjdChhY3Rpb25JbmZvKVxuICAgICAgICAgICAgPyBhY3Rpb25JbmZvLnR5cGVcbiAgICAgICAgICAgIDogKFthY3Rpb25JbmZvLCBhY3Rpb25JbmZvID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudE5hbWVcbiAgICAgICAgICAgIH1dWzBdKTtcblxuICAgICAgICAvLyBFdmVudCBuYW1lIGlzIGFsbCBsb3dlcmNhc2VcbiAgICAgICAgYWN0aW9uSW5mby5ldmVudCA9IChhY3Rpb25JbmZvLmV2ZW50IHx8IGFjdGlvblR5cGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGV2ZW50TmFtZSA9IGFjdGlvbkluZm8uZXZlbnQ7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgYWN0aW9uIHR5cGUgYW5kIGV2ZW50IG5hbWUuXG4gICAgICAgIHpyVXRpbC5hc3NlcnQoQUNUSU9OX1JFRy50ZXN0KGFjdGlvblR5cGUpICYmIEFDVElPTl9SRUcudGVzdChldmVudE5hbWUpKTtcblxuICAgICAgICBpZiAoIWFjdGlvbnNbYWN0aW9uVHlwZV0pIHtcbiAgICAgICAgICAgIGFjdGlvbnNbYWN0aW9uVHlwZV0gPSB7YWN0aW9uOiBhY3Rpb24sIGFjdGlvbkluZm86IGFjdGlvbkluZm99O1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50QWN0aW9uTWFwW2V2ZW50TmFtZV0gPSBhY3Rpb25UeXBlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7Kn0gQ29vcmRpbmF0ZVN5c3RlbVxuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJDb29yZGluYXRlU3lzdGVtID0gZnVuY3Rpb24gKHR5cGUsIENvb3JkaW5hdGVTeXN0ZW0pIHtcbiAgICAgICAgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIucmVnaXN0ZXIodHlwZSwgQ29vcmRpbmF0ZVN5c3RlbSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExheW91dCBpcyBhIHNwZWNpYWwgc3RhZ2Ugb2YgdmlzdWFsIGVuY29kaW5nXG4gICAgICogTW9zdCB2aXN1YWwgZW5jb2RpbmcgbGlrZSBjb2xvciBhcmUgY29tbW9uIGZvciBkaWZmZXJlbnQgY2hhcnRcbiAgICAgKiBCdXQgZWFjaCBjaGFydCBoYXMgaXQncyBvd24gbGF5b3V0IGFsZ29yaXRobVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0xMDAwXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxheW91dEZ1bmNcbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyTGF5b3V0ID0gZnVuY3Rpb24gKHByaW9yaXR5LCBsYXlvdXRGdW5jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJpb3JpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxheW91dEZ1bmMgPSBwcmlvcml0eTtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gUFJJT1JJVFlfVklTVUFMX0xBWU9VVDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHByaW9yaXR5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rb3duIGxheW91dCBwcmlvcml0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpc3VhbEZ1bmNzLnB1c2goe1xuICAgICAgICAgICAgcHJpbzogcHJpb3JpdHksXG4gICAgICAgICAgICBmdW5jOiBsYXlvdXRGdW5jLFxuICAgICAgICAgICAgaXNMYXlvdXQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9MzAwMF1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB2aXN1YWxGdW5jXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlclZpc3VhbCA9IGZ1bmN0aW9uIChwcmlvcml0eSwgdmlzdWFsRnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIHByaW9yaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2aXN1YWxGdW5jID0gcHJpb3JpdHk7XG4gICAgICAgICAgICBwcmlvcml0eSA9IFBSSU9SSVRZX1ZJU1VBTF9DSEFSVDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHByaW9yaXR5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rb3duIHZpc3VhbCBwcmlvcml0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpc3VhbEZ1bmNzLnB1c2goe1xuICAgICAgICAgICAgcHJpbzogcHJpb3JpdHksXG4gICAgICAgICAgICBmdW5jOiB2aXN1YWxGdW5jXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJMb2FkaW5nID0gZnVuY3Rpb24gKG5hbWUsIGxvYWRpbmdGeCkge1xuICAgICAgICBsb2FkaW5nRWZmZWN0c1tuYW1lXSA9IGxvYWRpbmdGeDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N1cGVyQ2xhc3NdXG4gICAgICovXG4gICAgZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCA9IGZ1bmN0aW9uIChvcHRzLyosIHN1cGVyQ2xhc3MqLykge1xuICAgICAgICAvLyB2YXIgQ2xhenogPSBDb21wb25lbnRNb2RlbDtcbiAgICAgICAgLy8gaWYgKHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgLy8gICAgIHZhciBjbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZShzdXBlckNsYXNzKTtcbiAgICAgICAgLy8gICAgIENsYXp6ID0gQ29tcG9uZW50TW9kZWwuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIGNsYXNzVHlwZS5zdWIsIHRydWUpO1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBDb21wb25lbnRNb2RlbC5leHRlbmQob3B0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdXBlckNsYXNzXVxuICAgICAqL1xuICAgIGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50VmlldyA9IGZ1bmN0aW9uIChvcHRzLyosIHN1cGVyQ2xhc3MqLykge1xuICAgICAgICAvLyB2YXIgQ2xhenogPSBDb21wb25lbnRWaWV3O1xuICAgICAgICAvLyBpZiAoc3VwZXJDbGFzcykge1xuICAgICAgICAvLyAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKHN1cGVyQ2xhc3MpO1xuICAgICAgICAvLyAgICAgQ2xhenogPSBDb21wb25lbnRWaWV3LmdldENsYXNzKGNsYXNzVHlwZS5tYWluLCBjbGFzc1R5cGUuc3ViLCB0cnVlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gQ29tcG9uZW50Vmlldy5leHRlbmQob3B0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdXBlckNsYXNzXVxuICAgICAqL1xuICAgIGVjaGFydHMuZXh0ZW5kU2VyaWVzTW9kZWwgPSBmdW5jdGlvbiAob3B0cy8qLCBzdXBlckNsYXNzKi8pIHtcbiAgICAgICAgLy8gdmFyIENsYXp6ID0gU2VyaWVzTW9kZWw7XG4gICAgICAgIC8vIGlmIChzdXBlckNsYXNzKSB7XG4gICAgICAgIC8vICAgICBzdXBlckNsYXNzID0gJ3Nlcmllcy4nICsgc3VwZXJDbGFzcy5yZXBsYWNlKCdzZXJpZXMuJywgJycpO1xuICAgICAgICAvLyAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKHN1cGVyQ2xhc3MpO1xuICAgICAgICAvLyAgICAgQ2xhenogPSBDb21wb25lbnRNb2RlbC5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgY2xhc3NUeXBlLnN1YiwgdHJ1ZSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIFNlcmllc01vZGVsLmV4dGVuZChvcHRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N1cGVyQ2xhc3NdXG4gICAgICovXG4gICAgZWNoYXJ0cy5leHRlbmRDaGFydFZpZXcgPSBmdW5jdGlvbiAob3B0cy8qLCBzdXBlckNsYXNzKi8pIHtcbiAgICAgICAgLy8gdmFyIENsYXp6ID0gQ2hhcnRWaWV3O1xuICAgICAgICAvLyBpZiAoc3VwZXJDbGFzcykge1xuICAgICAgICAvLyAgICAgc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3MucmVwbGFjZSgnc2VyaWVzLicsICcnKTtcbiAgICAgICAgLy8gICAgIHZhciBjbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZShzdXBlckNsYXNzKTtcbiAgICAgICAgLy8gICAgIENsYXp6ID0gQ2hhcnRWaWV3LmdldENsYXNzKGNsYXNzVHlwZS5tYWluLCB0cnVlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gQ2hhcnRWaWV3LmV4dGVuZChvcHRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogWlJlbmRlciBuZWVkIGEgY2FudmFzIGNvbnRleHQgdG8gZG8gbWVhc3VyZVRleHQuXG4gICAgICogQnV0IGluIG5vZGUgZW52aXJvbm1lbnQgY2FudmFzIG1heSBiZSBjcmVhdGVkIGJ5IG5vZGUtY2FudmFzLlxuICAgICAqIFNvIHdlIG5lZWQgdG8gc3BlY2lmeSBob3cgdG8gY3JlYXRlIGEgY2FudmFzIGluc3RlYWQgb2YgdXNpbmcgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgKlxuICAgICAqIEJlIGNhcmVmdWwgb2YgdXNpbmcgaXQgaW4gdGhlIGJyb3dzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjcmVhdG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgdmFyIENhbnZhcyA9IHJlcXVpcmUoJ2NhbnZhcycpO1xuICAgICAqICAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJ2VjaGFydHMnKTtcbiAgICAgKiAgICAgZWNoYXJ0cy5zZXRDYW52YXNDcmVhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgKiAgICAgICAgIC8vIFNtYWxsIHNpemUgaXMgZW5vdWdoLlxuICAgICAqICAgICAgICAgcmV0dXJuIG5ldyBDYW52YXMoMzIsIDMyKTtcbiAgICAgKiAgICAgfSk7XG4gICAgICovXG4gICAgZWNoYXJ0cy5zZXRDYW52YXNDcmVhdG9yID0gZnVuY3Rpb24gKGNyZWF0b3IpIHtcbiAgICAgICAgenJVdGlsLmNyZWF0ZUNhbnZhcyA9IGNyZWF0b3I7XG4gICAgfTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJWaXN1YWwoUFJJT1JJVFlfVklTVUFMX0dMT0JBTCwgcmVxdWlyZSgnLi92aXN1YWwvc2VyaWVzQ29sb3InKSk7XG4gICAgZWNoYXJ0cy5yZWdpc3RlclByZXByb2Nlc3NvcihyZXF1aXJlKCcuL3ByZXByb2Nlc3Nvci9iYWNrd2FyZENvbXBhdCcpKTtcbiAgICBlY2hhcnRzLnJlZ2lzdGVyTG9hZGluZygnZGVmYXVsdCcsIHJlcXVpcmUoJy4vbG9hZGluZy9kZWZhdWx0JykpO1xuXG4gICAgLy8gRGVmYXVsdCBhY3Rpb25cbiAgICBlY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ2hpZ2hsaWdodCcsXG4gICAgICAgIGV2ZW50OiAnaGlnaGxpZ2h0JyxcbiAgICAgICAgdXBkYXRlOiAnaGlnaGxpZ2h0J1xuICAgIH0sIHpyVXRpbC5ub29wKTtcbiAgICBlY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ2Rvd25wbGF5JyxcbiAgICAgICAgZXZlbnQ6ICdkb3ducGxheScsXG4gICAgICAgIHVwZGF0ZTogJ2Rvd25wbGF5J1xuICAgIH0sIHpyVXRpbC5ub29wKTtcblxuXG4gICAgLy8gLS0tLS0tLS1cbiAgICAvLyBFeHBvcnRzXG4gICAgLy8gLS0tLS0tLS1cbiAgICAvL1xuICAgIGVjaGFydHMuTGlzdCA9IHJlcXVpcmUoJy4vZGF0YS9MaXN0Jyk7XG4gICAgZWNoYXJ0cy5Nb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWwvTW9kZWwnKTtcblxuICAgIGVjaGFydHMuZ3JhcGhpYyA9IHJlcXVpcmUoJy4vdXRpbC9ncmFwaGljJyk7XG4gICAgZWNoYXJ0cy5udW1iZXIgPSByZXF1aXJlKCcuL3V0aWwvbnVtYmVyJyk7XG4gICAgZWNoYXJ0cy5mb3JtYXQgPSByZXF1aXJlKCcuL3V0aWwvZm9ybWF0Jyk7XG4gICAgZWNoYXJ0cy50aHJvdHRsZSA9IHRocm90dGxlLnRocm90dGxlO1xuICAgIGVjaGFydHMubWF0cml4ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9tYXRyaXgnKTtcbiAgICBlY2hhcnRzLnZlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XG4gICAgZWNoYXJ0cy5jb2xvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3InKTtcblxuICAgIGVjaGFydHMudXRpbCA9IHt9O1xuICAgIGVhY2goW1xuICAgICAgICAgICAgJ21hcCcsICdlYWNoJywgJ2ZpbHRlcicsICdpbmRleE9mJywgJ2luaGVyaXRzJywgJ3JlZHVjZScsICdmaWx0ZXInLFxuICAgICAgICAgICAgJ2JpbmQnLCAnY3VycnknLCAnaXNBcnJheScsICdpc1N0cmluZycsICdpc09iamVjdCcsICdpc0Z1bmN0aW9uJyxcbiAgICAgICAgICAgICdleHRlbmQnLCAnZGVmYXVsdHMnLCAnY2xvbmUnXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBlY2hhcnRzLnV0aWxbbmFtZV0gPSB6clV0aWxbbmFtZV07XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBlY2hhcnRzLlBSSU9SSVRZID0ge1xuICAgICAgICBQUk9DRVNTT1I6IHtcbiAgICAgICAgICAgIEZJTFRFUjogUFJJT1JJVFlfUFJPQ0VTU09SX0ZJTFRFUixcbiAgICAgICAgICAgIFNUQVRJU1RJQzogUFJJT1JJVFlfUFJPQ0VTU09SX1NUQVRJU1RJQ1xuICAgICAgICB9LFxuICAgICAgICBWSVNVQUw6IHtcbiAgICAgICAgICAgIExBWU9VVDogUFJJT1JJVFlfVklTVUFMX0xBWU9VVCxcbiAgICAgICAgICAgIEdMT0JBTDogUFJJT1JJVFlfVklTVUFMX0dMT0JBTCxcbiAgICAgICAgICAgIENIQVJUOiBQUklPUklUWV9WSVNVQUxfQ0hBUlQsXG4gICAgICAgICAgICBDT01QT05FTlQ6IFBSSU9SSVRZX1ZJU1VBTF9DT01QT05FTlQsXG4gICAgICAgICAgICBCUlVTSDogUFJJT1JJVFlfVklTVUFMX0JSVVNIXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlY2hhcnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL251bWJlcicpO1xuICAgIHZhciBwYXJzZVBlcmNlbnQgPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudDtcblxuICAgIGZ1bmN0aW9uIGdldFNlcmllc1N0YWNrSWQoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlcmllc01vZGVsLmdldCgnc3RhY2snKSB8fCAnX19lY19zdGFja18nICsgc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXhpc0tleShheGlzKSB7XG4gICAgICAgIHJldHVybiBheGlzLmRpbSArIGF4aXMuaW5kZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsQmFyV2lkdGhBbmRPZmZzZXQoYmFyU2VyaWVzLCBhcGkpIHtcbiAgICAgICAgLy8gQ29sdW1ucyBpbmZvIG9uIGVhY2ggY2F0ZWdvcnkgYXhpcy4gS2V5IGlzIGNhcnRlc2lhbiBuYW1lXG4gICAgICAgIHZhciBjb2x1bW5zTWFwID0ge307XG5cbiAgICAgICAgenJVdGlsLmVhY2goYmFyU2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgY2FydGVzaWFuID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAgICB2YXIgYXhpc0V4dGVudCA9IGJhc2VBeGlzLmdldEV4dGVudCgpO1xuICAgICAgICAgICAgdmFyIGJhbmRXaWR0aCA9IGJhc2VBeGlzLnR5cGUgPT09ICdjYXRlZ29yeSdcbiAgICAgICAgICAgICAgICA/IGJhc2VBeGlzLmdldEJhbmRXaWR0aCgpXG4gICAgICAgICAgICAgICAgOiAoTWF0aC5hYnMoYXhpc0V4dGVudFsxXSAtIGF4aXNFeHRlbnRbMF0pIC8gZGF0YS5jb3VudCgpKTtcblxuICAgICAgICAgICAgdmFyIGNvbHVtbnNPbkF4aXMgPSBjb2x1bW5zTWFwW2dldEF4aXNLZXkoYmFzZUF4aXMpXSB8fCB7XG4gICAgICAgICAgICAgICAgYmFuZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICAgICAgICAgICAgcmVtYWluZWRXaWR0aDogYmFuZFdpZHRoLFxuICAgICAgICAgICAgICAgIGF1dG9XaWR0aENvdW50OiAwLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5R2FwOiAnMjAlJyxcbiAgICAgICAgICAgICAgICBnYXA6ICczMCUnLFxuICAgICAgICAgICAgICAgIHN0YWNrczoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc3RhY2tzID0gY29sdW1uc09uQXhpcy5zdGFja3M7XG4gICAgICAgICAgICBjb2x1bW5zTWFwW2dldEF4aXNLZXkoYmFzZUF4aXMpXSA9IGNvbHVtbnNPbkF4aXM7XG5cbiAgICAgICAgICAgIHZhciBzdGFja0lkID0gZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCk7XG5cbiAgICAgICAgICAgIGlmICghc3RhY2tzW3N0YWNrSWRdKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uc09uQXhpcy5hdXRvV2lkdGhDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2tzW3N0YWNrSWRdID0gc3RhY2tzW3N0YWNrSWRdIHx8IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGJhcldpZHRoID0gcGFyc2VQZXJjZW50KFxuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgnYmFyV2lkdGgnKSwgYmFuZFdpZHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGJhck1heFdpZHRoID0gcGFyc2VQZXJjZW50KFxuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgnYmFyTWF4V2lkdGgnKSwgYmFuZFdpZHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGJhckdhcCA9IHNlcmllc01vZGVsLmdldCgnYmFyR2FwJyk7XG4gICAgICAgICAgICB2YXIgYmFyQ2F0ZWdvcnlHYXAgPSBzZXJpZXNNb2RlbC5nZXQoJ2JhckNhdGVnb3J5R2FwJyk7XG5cbiAgICAgICAgICAgIC8vIENhdXRpb246IEluIGEgc2luZ2xlIGNvb3JkaW5hdGUgc3lzdGVtLCB0aGVzZSBiYXJHcmlkIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgc2hhcmVkIGJ5IHNlcmllcy4gQ29uc2lkZXIgdGhhdCB0aGV5IGhhdmUgZGVmYXVsdCB2YWx1ZXMsXG4gICAgICAgICAgICAvLyBvbmx5IHRoZSBhdHRyaWJ1dGVzIHNldCBvbiB0aGUgbGFzdCBzZXJpZXMgd2lsbCB3b3JrLlxuICAgICAgICAgICAgLy8gRG8gbm90IGNoYW5nZSB0aGlzIGZhY3QgdW5sZXNzIHRoZXJlIHdpbGwgYmUgYSBicmVhayBjaGFuZ2UuXG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIGlmIChiYXJXaWR0aCAmJiAhc3RhY2tzW3N0YWNrSWRdLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgYmFyV2lkdGggPSBNYXRoLm1pbihjb2x1bW5zT25BeGlzLnJlbWFpbmVkV2lkdGgsIGJhcldpZHRoKTtcbiAgICAgICAgICAgICAgICBzdGFja3Nbc3RhY2tJZF0ud2lkdGggPSBiYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBjb2x1bW5zT25BeGlzLnJlbWFpbmVkV2lkdGggLT0gYmFyV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhck1heFdpZHRoICYmIChzdGFja3Nbc3RhY2tJZF0ubWF4V2lkdGggPSBiYXJNYXhXaWR0aCk7XG4gICAgICAgICAgICAoYmFyR2FwICE9IG51bGwpICYmIChjb2x1bW5zT25BeGlzLmdhcCA9IGJhckdhcCk7XG4gICAgICAgICAgICAoYmFyQ2F0ZWdvcnlHYXAgIT0gbnVsbCkgJiYgKGNvbHVtbnNPbkF4aXMuY2F0ZWdvcnlHYXAgPSBiYXJDYXRlZ29yeUdhcCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICB6clV0aWwuZWFjaChjb2x1bW5zTWFwLCBmdW5jdGlvbiAoY29sdW1uc09uQXhpcywgY29vcmRTeXNOYW1lKSB7XG5cbiAgICAgICAgICAgIHJlc3VsdFtjb29yZFN5c05hbWVdID0ge307XG5cbiAgICAgICAgICAgIHZhciBzdGFja3MgPSBjb2x1bW5zT25BeGlzLnN0YWNrcztcbiAgICAgICAgICAgIHZhciBiYW5kV2lkdGggPSBjb2x1bW5zT25BeGlzLmJhbmRXaWR0aDtcbiAgICAgICAgICAgIHZhciBjYXRlZ29yeUdhcCA9IHBhcnNlUGVyY2VudChjb2x1bW5zT25BeGlzLmNhdGVnb3J5R2FwLCBiYW5kV2lkdGgpO1xuICAgICAgICAgICAgdmFyIGJhckdhcFBlcmNlbnQgPSBwYXJzZVBlcmNlbnQoY29sdW1uc09uQXhpcy5nYXAsIDEpO1xuXG4gICAgICAgICAgICB2YXIgcmVtYWluZWRXaWR0aCA9IGNvbHVtbnNPbkF4aXMucmVtYWluZWRXaWR0aDtcbiAgICAgICAgICAgIHZhciBhdXRvV2lkdGhDb3VudCA9IGNvbHVtbnNPbkF4aXMuYXV0b1dpZHRoQ291bnQ7XG4gICAgICAgICAgICB2YXIgYXV0b1dpZHRoID0gKHJlbWFpbmVkV2lkdGggLSBjYXRlZ29yeUdhcClcbiAgICAgICAgICAgICAgICAvIChhdXRvV2lkdGhDb3VudCArIChhdXRvV2lkdGhDb3VudCAtIDEpICogYmFyR2FwUGVyY2VudCk7XG4gICAgICAgICAgICBhdXRvV2lkdGggPSBNYXRoLm1heChhdXRvV2lkdGgsIDApO1xuXG4gICAgICAgICAgICAvLyBGaW5kIGlmIGFueSBhdXRvIGNhbGN1bGF0ZWQgYmFyIGV4Y2VlZGVkIG1heEJhcldpZHRoXG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdGFja3MsIGZ1bmN0aW9uIChjb2x1bW4sIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gY29sdW1uLm1heFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmICghY29sdW1uLndpZHRoICYmIG1heFdpZHRoICYmIG1heFdpZHRoIDwgYXV0b1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5taW4obWF4V2lkdGgsIHJlbWFpbmVkV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICByZW1haW5lZFdpZHRoIC09IG1heFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYXV0b1dpZHRoQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgd2lkdGggYWdhaW5cbiAgICAgICAgICAgIGF1dG9XaWR0aCA9IChyZW1haW5lZFdpZHRoIC0gY2F0ZWdvcnlHYXApXG4gICAgICAgICAgICAgICAgLyAoYXV0b1dpZHRoQ291bnQgKyAoYXV0b1dpZHRoQ291bnQgLSAxKSAqIGJhckdhcFBlcmNlbnQpO1xuICAgICAgICAgICAgYXV0b1dpZHRoID0gTWF0aC5tYXgoYXV0b1dpZHRoLCAwKTtcblxuICAgICAgICAgICAgdmFyIHdpZHRoU3VtID0gMDtcbiAgICAgICAgICAgIHZhciBsYXN0Q29sdW1uO1xuICAgICAgICAgICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbHVtbi53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBhdXRvV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RDb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgd2lkdGhTdW0gKz0gY29sdW1uLndpZHRoICogKDEgKyBiYXJHYXBQZXJjZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGxhc3RDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICB3aWR0aFN1bSAtPSBsYXN0Q29sdW1uLndpZHRoICogYmFyR2FwUGVyY2VudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IC13aWR0aFN1bSAvIDI7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdGFja3MsIGZ1bmN0aW9uIChjb2x1bW4sIHN0YWNrSWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbY29vcmRTeXNOYW1lXVtzdGFja0lkXSA9IHJlc3VsdFtjb29yZFN5c05hbWVdW3N0YWNrSWRdIHx8IHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2x1bW4ud2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGNvbHVtbi53aWR0aCAqICgxICsgYmFyR2FwUGVyY2VudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWVzVHlwZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhckxheW91dEdyaWQoc2VyaWVzVHlwZSwgZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgdmFyIGJhcldpZHRoQW5kT2Zmc2V0ID0gY2FsQmFyV2lkdGhBbmRPZmZzZXQoXG4gICAgICAgICAgICB6clV0aWwuZmlsdGVyKFxuICAgICAgICAgICAgICAgIGVjTW9kZWwuZ2V0U2VyaWVzQnlUeXBlKHNlcmllc1R5cGUpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0udHlwZSA9PT0gJ2NhcnRlc2lhbjJkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGxhc3RTdGFja0Nvb3JkcyA9IHt9O1xuICAgICAgICB2YXIgbGFzdFN0YWNrQ29vcmRzT3JpZ2luID0ge307XG5cbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG5cbiAgICAgICAgICAgIHZhciBzdGFja0lkID0gZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICB2YXIgY29sdW1uTGF5b3V0SW5mbyA9IGJhcldpZHRoQW5kT2Zmc2V0W2dldEF4aXNLZXkoYmFzZUF4aXMpXVtzdGFja0lkXTtcbiAgICAgICAgICAgIHZhciBjb2x1bW5PZmZzZXQgPSBjb2x1bW5MYXlvdXRJbmZvLm9mZnNldDtcbiAgICAgICAgICAgIHZhciBjb2x1bW5XaWR0aCA9IGNvbHVtbkxheW91dEluZm8ud2lkdGg7XG4gICAgICAgICAgICB2YXIgdmFsdWVBeGlzID0gY2FydGVzaWFuLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG5cbiAgICAgICAgICAgIHZhciBiYXJNaW5IZWlnaHQgPSBzZXJpZXNNb2RlbC5nZXQoJ2Jhck1pbkhlaWdodCcpIHx8IDA7XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZUF4aXNTdGFydCA9IGJhc2VBeGlzLm9uWmVyb1xuICAgICAgICAgICAgICAgID8gdmFsdWVBeGlzLnRvR2xvYmFsQ29vcmQodmFsdWVBeGlzLmRhdGFUb0Nvb3JkKDApKVxuICAgICAgICAgICAgICAgIDogdmFsdWVBeGlzLmdldEdsb2JhbEV4dGVudCgpWzBdO1xuXG4gICAgICAgICAgICB2YXIgY29vcmRzID0gY2FydGVzaWFuLmRhdGFUb1BvaW50cyhkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXSA9IGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXSB8fCBbXTtcbiAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXSA9IGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXSB8fCBbXTsgLy8gRml4ICM0MjQzXG5cbiAgICAgICAgICAgIGRhdGEuc2V0TGF5b3V0KHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGNvbHVtbk9mZnNldCxcbiAgICAgICAgICAgICAgICBzaXplOiBjb2x1bW5XaWR0aFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRhdGEuZWFjaCh2YWx1ZUF4aXMuZGltLCBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwOiB2YWx1ZUF4aXNTdGFydCwgLy8gUG9zaXRpdmUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIG46IHZhbHVlQXhpc1N0YXJ0ICAvLyBOZWdhdGl2ZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhY2tDb29yZHNPcmlnaW5bc3RhY2tJZF1baWR4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHA6IHZhbHVlQXhpc1N0YXJ0LCAvLyBQb3NpdGl2ZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgbjogdmFsdWVBeGlzU3RhcnQgIC8vIE5lZ2F0aXZlIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzaWduID0gdmFsdWUgPj0gMCA/ICdwJyA6ICduJztcbiAgICAgICAgICAgICAgICB2YXIgY29vcmQgPSBjb29yZHNbaWR4XTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdENvb3JkID0gbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF1bc2lnbl07XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RDb29yZE9yaWdpbiA9IGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXVtpZHhdW3NpZ25dO1xuICAgICAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgICAgIHZhciB5O1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlQXhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gbGFzdENvb3JkO1xuICAgICAgICAgICAgICAgICAgICB5ID0gY29vcmRbMV0gKyBjb2x1bW5PZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gY29vcmRbMF0gLSBsYXN0Q29vcmRPcmlnaW47XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGNvbHVtbldpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXVtpZHhdW3NpZ25dICs9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMod2lkdGgpIDwgYmFyTWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9ICh3aWR0aCA8IDAgPyAtMSA6IDEpICogYmFyTWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtpZHhdW3NpZ25dICs9IHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGNvb3JkWzBdICsgY29sdW1uT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB5ID0gbGFzdENvb3JkO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbHVtbldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBjb29yZFsxXSAtIGxhc3RDb29yZE9yaWdpbjtcblxuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhY2tDb29yZHNPcmlnaW5bc3RhY2tJZF1baWR4XVtzaWduXSArPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhoZWlnaHQpIDwgYmFyTWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHplcm8gdG8gaGFzIGEgcG9zaXRpdmUgYmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSAoaGVpZ2h0IDw9IDAgPyAtMSA6IDEpICogYmFyTWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtpZHhdW3NpZ25dICs9IGhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gYmFyTGF5b3V0R3JpZDtcbiIsIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgZWNNb2RlbCkge1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoc2VyaWVzVHlwZSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICAgICAgICAgIGlmIChjb29yZFN5cykge1xuICAgICAgICAgICAgICAgIHZhciBkaW1zID0gY29vcmRTeXMuZGltZW5zaW9ucztcblxuICAgICAgICAgICAgICAgIGlmIChjb29yZFN5cy50eXBlID09PSAnc2luZ2xlQXhpcycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5lYWNoKGRpbXNbMF0sIGZ1bmN0aW9uICh4LCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsc28ge0FycmF5LjxudW1iZXI+fSwgbm90IHVuZGVmaW5lZCB0byBhdm9pZCBpZi4uLmVsc2UuLi4gc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBpc05hTih4KSA/IFtOYU4sIE5hTl0gOiBjb29yZFN5cy5kYXRhVG9Qb2ludCh4KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5lYWNoKGRpbXMsIGZ1bmN0aW9uICh4LCB5LCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsc28ge0FycmF5LjxudW1iZXI+fSwgbm90IHVuZGVmaW5lZCB0byBhdm9pZCBpZi4uLmVsc2UuLi4gc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4LCAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpID8gW05hTiwgTmFOXSA6IGNvb3JkU3lzLmRhdGFUb1BvaW50KFt4LCB5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiIsIlxuXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIFBJID0gTWF0aC5QSTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50ZXh0XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb2xvcl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudGV4dENvbG9yXVxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXBpLCBvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICB6clV0aWwuZGVmYXVsdHMob3B0cywge1xuICAgICAgICAgICAgdGV4dDogJ2xvYWRpbmcnLFxuICAgICAgICAgICAgY29sb3I6ICcjYzIzNTMxJyxcbiAgICAgICAgICAgIHRleHRDb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgbWFza0NvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpJyxcbiAgICAgICAgICAgIHpsZXZlbDogMFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1hc2sgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZmlsbDogb3B0cy5tYXNrQ29sb3JcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgICAgICAgICAgejogMTAwMDBcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhcmMgPSBuZXcgZ3JhcGhpYy5BcmMoe1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiAtUEkgLyAyLFxuICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiAtUEkgLyAyICsgMC4xLFxuICAgICAgICAgICAgICAgIHI6IDEwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBzdHJva2U6IG9wdHMuY29sb3IsXG4gICAgICAgICAgICAgICAgbGluZUNhcDogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgICAgICAgICAgejogMTAwMDFcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsYWJlbFJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHRleHQ6IG9wdHMudGV4dCxcbiAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgICAgICAgICAgdGV4dERpc3RhbmNlOiAxMCxcbiAgICAgICAgICAgICAgICB0ZXh0RmlsbDogb3B0cy50ZXh0Q29sb3JcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgICAgICAgICAgejogMTAwMDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXJjLmFuaW1hdGVTaGFwZSh0cnVlKVxuICAgICAgICAgICAgLndoZW4oMTAwMCwge1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBQSSAqIDMgLyAyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXJ0KCdjaXJjdWxhckluT3V0Jyk7XG4gICAgICAgIGFyYy5hbmltYXRlU2hhcGUodHJ1ZSlcbiAgICAgICAgICAgIC53aGVuKDEwMDAsIHtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBQSSAqIDMgLyAyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlbGF5KDMwMClcbiAgICAgICAgICAgIC5zdGFydCgnY2lyY3VsYXJJbk91dCcpO1xuXG4gICAgICAgIHZhciBncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgICAgIGdyb3VwLmFkZChhcmMpO1xuICAgICAgICBncm91cC5hZGQobGFiZWxSZWN0KTtcbiAgICAgICAgZ3JvdXAuYWRkKG1hc2spO1xuICAgICAgICAvLyBJbmplY3QgcmVzaXplXG4gICAgICAgIGdyb3VwLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjeCA9IGFwaS5nZXRXaWR0aCgpIC8gMjtcbiAgICAgICAgICAgIHZhciBjeSA9IGFwaS5nZXRIZWlnaHQoKSAvIDI7XG4gICAgICAgICAgICBhcmMuc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICBjeTogY3lcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHIgPSBhcmMuc2hhcGUucjtcbiAgICAgICAgICAgIGxhYmVsUmVjdC5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgeDogY3ggLSByLFxuICAgICAgICAgICAgICAgIHk6IGN5IC0gcixcbiAgICAgICAgICAgICAgICB3aWR0aDogciAqIDIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByICogMlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1hc2suc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBncm91cC5yZXNpemUoKTtcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH07XG4iLCIvKipcbiAqIENvbXBvbmVudCBtb2RlbFxuICpcbiAqIEBtb2R1bGUgZWNoYXJ0cy9tb2RlbC9Db21wb25lbnRcbiAqL1xuXG5cbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBhcnJheVB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbiAgICB2YXIgY29tcG9uZW50VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY29tcG9uZW50Jyk7XG4gICAgdmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhenonKTtcbiAgICB2YXIgbGF5b3V0ID0gcmVxdWlyZSgnLi4vdXRpbC9sYXlvdXQnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gcGFyZW50TW9kZWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBlY01vZGVsXG4gICAgICovXG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gTW9kZWwuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnY29tcG9uZW50JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBpZDogJycsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogJycsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgbWFpblR5cGU6ICcnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHN1YlR5cGU6ICcnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudEluZGV4OiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0T3B0aW9uOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGVjTW9kZWw6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGtleTogY29tcG9uZW50VHlwZVxuICAgICAgICAgKiB2YWx1ZTogIENvbXBvbmVudCBtb2RlbCBsaXN0LCBjYW4gbm90IGJlIG51bGwuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgQXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsPj59XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgZGVwZW5kZW50TW9kZWxzOiBbXSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB1aWQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1cHBvcnQgbWVyZ2UgbGF5b3V0IHBhcmFtcy5cbiAgICAgICAgICogT25seSBzdXBwb3J0ICdib3gnIG5vdyAobGVmdC9yaWdodC90b3AvYm90dG9tL3dpZHRoL2hlaWdodCkuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8T2JqZWN0fSBPYmplY3QgY2FuIGJlIHtpZ25vcmVTaXplOiB0cnVlfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dE1vZGU6IG51bGwsXG5cbiAgICAgICAgJGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpIHtcbiAgICAgICAgICAgIE1vZGVsLmNhbGwodGhpcywgb3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpO1xuXG4gICAgICAgICAgICB0aGlzLnVpZCA9IGNvbXBvbmVudFV0aWwuZ2V0VUlEKCdjb21wb25lbnRNb2RlbCcpO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KSB7XG4gICAgICAgICAgICB0aGlzLm1lcmdlRGVmYXVsdEFuZFRoZW1lKG9wdGlvbiwgZWNNb2RlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVyZ2VEZWZhdWx0QW5kVGhlbWU6IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgICAgICAgICAgdmFyIGlucHV0UG9zaXRpb25QYXJhbXMgPSBsYXlvdXRNb2RlXG4gICAgICAgICAgICAgICAgPyBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbikgOiB7fTtcblxuICAgICAgICAgICAgdmFyIHRoZW1lTW9kZWwgPSBlY01vZGVsLmdldFRoZW1lKCk7XG4gICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGVtZU1vZGVsLmdldCh0aGlzLm1haW5UeXBlKSk7XG4gICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGlzLmdldERlZmF1bHRPcHRpb24oKSk7XG5cbiAgICAgICAgICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW0ob3B0aW9uLCBpbnB1dFBvc2l0aW9uUGFyYW1zLCBsYXlvdXRNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbiwgZXh0cmFPcHQpIHtcbiAgICAgICAgICAgIHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgb3B0aW9uLCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIGxheW91dE1vZGUgPSB0aGlzLmxheW91dE1vZGU7XG4gICAgICAgICAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgICAgICAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKHRoaXMub3B0aW9uLCBvcHRpb24sIGxheW91dE1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEhvb2tlciBhZnRlciBpbml0IG9yIG1lcmdlT3B0aW9uXG4gICAgICAgIG9wdGlvblVwZGF0ZWQ6IGZ1bmN0aW9uIChuZXdDcHRPcHRpb24sIGlzSW5pdCkge30sXG5cbiAgICAgICAgZ2V0RGVmYXVsdE9wdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFjbGF6elV0aWwuaGFzT3duKHRoaXMsICdfX2RlZmF1bHRPcHRpb24nKSkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgdmFyIENsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdCA9IENsYXNzLnByb3RvdHlwZS5kZWZhdWx0T3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICBvcHQgJiYgb3B0TGlzdC5wdXNoKG9wdCk7XG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gQ2xhc3Muc3VwZXJDbGFzcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBvcHRMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb24gPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbiwgb3B0TGlzdFtpXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYXp6VXRpbC5zZXQodGhpcywgJ19fZGVmYXVsdE9wdGlvbicsIGRlZmF1bHRPcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsYXp6VXRpbC5nZXQodGhpcywgJ19fZGVmYXVsdE9wdGlvbicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFJlZmVycmluZ0NvbXBvbmVudHM6IGZ1bmN0aW9uIChtYWluVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICAgICAgICAgIG1haW5UeXBlOiBtYWluVHlwZSxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5nZXQobWFpblR5cGUgKyAnSW5kZXgnLCB0cnVlKSxcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5nZXQobWFpblR5cGUgKyAnSWQnLCB0cnVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8gUmVzZXQgQ29tcG9uZW50TW9kZWwuZXh0ZW5kLCBhZGQgcHJlQ29uc3RydWN0LlxuICAgIC8vIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChcbiAgICAvLyAgICAgQ29tcG9uZW50TW9kZWwsXG4gICAgLy8gICAgIGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuICAgIC8vICAgICAgICAgLy8gU2V0IGRlcGVuZGVudE1vZGVscywgY29tcG9uZW50SW5kZXgsIG5hbWUsIGlkLCBtYWluVHlwZSwgc3ViVHlwZS5cbiAgICAvLyAgICAgICAgIHpyVXRpbC5leHRlbmQodGhpcywgZXh0cmFPcHQpO1xuXG4gICAgLy8gICAgICAgICB0aGlzLnVpZCA9IGNvbXBvbmVudFV0aWwuZ2V0VUlEKCdjb21wb25lbnRNb2RlbCcpO1xuXG4gICAgLy8gICAgICAgICAvLyB0aGlzLnNldFJlYWRPbmx5KFtcbiAgICAvLyAgICAgICAgIC8vICAgICAndHlwZScsICdpZCcsICd1aWQnLCAnbmFtZScsICdtYWluVHlwZScsICdzdWJUeXBlJyxcbiAgICAvLyAgICAgICAgIC8vICAgICAnZGVwZW5kZW50TW9kZWxzJywgJ2NvbXBvbmVudEluZGV4J1xuICAgIC8vICAgICAgICAgLy8gXSk7XG4gICAgLy8gICAgIH1cbiAgICAvLyApO1xuXG4gICAgLy8gQWRkIGNhcGFiaWxpdHkgb2YgcmVnaXN0ZXJDbGFzcywgZ2V0Q2xhc3MsIGhhc0NsYXNzLCByZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgYW5kIHNvIG9uLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoXG4gICAgICAgIENvbXBvbmVudE1vZGVsLCB7cmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlfVxuICAgICk7XG4gICAgY29tcG9uZW50VXRpbC5lbmFibGVTdWJUeXBlRGVmYXVsdGVyKENvbXBvbmVudE1vZGVsKTtcblxuICAgIC8vIEFkZCBjYXBhYmlsaXR5IG9mIENvbXBvbmVudE1vZGVsLnRvcG9sb2dpY2FsVHJhdmVsLlxuICAgIGNvbXBvbmVudFV0aWwuZW5hYmxlVG9wb2xvZ2ljYWxUcmF2ZWwoQ29tcG9uZW50TW9kZWwsIGdldERlcGVuZGVuY2llcyk7XG5cbiAgICBmdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMoY29tcG9uZW50VHlwZSkge1xuICAgICAgICB2YXIgZGVwcyA9IFtdO1xuICAgICAgICB6clV0aWwuZWFjaChDb21wb25lbnRNb2RlbC5nZXRDbGFzc2VzQnlNYWluVHlwZShjb21wb25lbnRUeXBlKSwgZnVuY3Rpb24gKENsYXp6KSB7XG4gICAgICAgICAgICBhcnJheVB1c2guYXBwbHkoZGVwcywgQ2xhenoucHJvdG90eXBlLmRlcGVuZGVuY2llcyB8fCBbXSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBFbnN1cmUgbWFpbiB0eXBlXG4gICAgICAgIHJldHVybiB6clV0aWwubWFwKGRlcHMsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhenpVdGlsLnBhcnNlQ2xhc3NUeXBlKHR5cGUpLm1haW47XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHpyVXRpbC5taXhpbihDb21wb25lbnRNb2RlbCwgcmVxdWlyZSgnLi9taXhpbi9ib3hMYXlvdXQnKSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudE1vZGVsO1xuIiwiLyoqXG4gKiBFQ2hhcnRzIGdsb2JhbCBtb2RlbFxuICpcbiAqIEBtb2R1bGUge2VjaGFydHMvbW9kZWwvR2xvYmFsfVxuICovXG5cblxuXG4gICAgLyoqXG4gICAgICogQ2F1dGlvbjogSWYgdGhlIG1lY2hhbmlzbSBzaG91bGQgYmUgY2hhbmdlZCBzb21lIGRheSwgdGhlc2UgY2FzZXNcbiAgICAgKiBzaG91bGQgYmUgY29uc2lkZXJlZDpcbiAgICAgKlxuICAgICAqICgxKSBJbiBgbWVyZ2Ugb3B0aW9uYCBtb2RlLCBpZiB1c2luZyB0aGUgc2FtZSBvcHRpb24gdG8gY2FsbCBgc2V0T3B0aW9uYFxuICAgICAqIG1hbnkgdGltZXMsIHRoZSByZXN1bHQgc2hvdWxkIGJlIHRoZSBzYW1lICh0cnkgb3VyIGJlc3QgdG8gZW5zdXJlIHRoYXQpLlxuICAgICAqICgyKSBJbiBgbWVyZ2Ugb3B0aW9uYCBtb2RlLCBpZiBhIGNvbXBvbmVudCBoYXMgbm8gaWQvbmFtZSBzcGVjaWZpZWQsIGl0XG4gICAgICogd2lsbCBiZSBtZXJnZWQgYnkgaW5kZXgsIGFuZCB0aGUgcmVzdWx0IHNlcXVlbmNlIG9mIHRoZSBjb21wb25lbnRzIGlzXG4gICAgICogY29uc2lzdGVudCB0byB0aGUgb3JpZ2luYWwgc2VxdWVuY2UuXG4gICAgICogKDMpIGByZXNldGAgZmVhdHVyZSAoaW4gdG9vbGJveCkuIEZpbmQgZGV0YWlsZWQgaW5mbyBpbiBjb21tZW50cyBhYm91dFxuICAgICAqIGBtZXJnZU9wdGlvbmAgaW4gbW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlci5cbiAgICAgKi9cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBmaWx0ZXIgPSB6clV0aWwuZmlsdGVyO1xuICAgIHZhciBtYXAgPSB6clV0aWwubWFwO1xuICAgIHZhciBpc0FycmF5ID0genJVdGlsLmlzQXJyYXk7XG4gICAgdmFyIGluZGV4T2YgPSB6clV0aWwuaW5kZXhPZjtcbiAgICB2YXIgaXNPYmplY3QgPSB6clV0aWwuaXNPYmplY3Q7XG5cbiAgICB2YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKCcuL0NvbXBvbmVudCcpO1xuXG4gICAgdmFyIGdsb2JhbERlZmF1bHQgPSByZXF1aXJlKCcuL2dsb2JhbERlZmF1bHQnKTtcblxuICAgIHZhciBPUFRJT05fSU5ORVJfS0VZID0gJ1xcMF9lY19pbm5lcic7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gcGFyZW50TW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhlbWVcbiAgICAgKi9cbiAgICB2YXIgR2xvYmFsTW9kZWwgPSBNb2RlbC5leHRlbmQoe1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHbG9iYWxNb2RlbCxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgdGhlbWUsIG9wdGlvbk1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoZW1lID0gdGhlbWUgfHwge307XG5cbiAgICAgICAgICAgIHRoaXMub3B0aW9uID0gbnVsbDsgLy8gTWFyayBhcyBub3QgaW5pdGlhbGl6ZWQuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fdGhlbWUgPSBuZXcgTW9kZWwodGhlbWUpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9PcHRpb25NYW5hZ2VyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25NYW5hZ2VyID0gb3B0aW9uTWFuYWdlcjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRPcHRpb246IGZ1bmN0aW9uIChvcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKSB7XG4gICAgICAgICAgICB6clV0aWwuYXNzZXJ0KFxuICAgICAgICAgICAgICAgICEoT1BUSU9OX0lOTkVSX0tFWSBpbiBvcHRpb24pLFxuICAgICAgICAgICAgICAgICdwbGVhc2UgdXNlIGNoYXJ0LmdldE9wdGlvbigpJ1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5fb3B0aW9uTWFuYWdlci5zZXRPcHRpb24ob3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcyk7XG5cbiAgICAgICAgICAgIHRoaXMucmVzZXRPcHRpb24oKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgbnVsbC91bmRlZmluZWQ6IHJlc2V0IGFsbC5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgJ3JlY3JlYXRlJzogZm9yY2UgcmVjcmVhdGUgYWxsLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAndGltZWxpbmUnOiBvbmx5IHJlc2V0IHRpbWVsaW5lIG9wdGlvblxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAnbWVkaWEnOiBvbmx5IHJlc2V0IG1lZGlhIHF1ZXJ5IG9wdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9wdGlvbiBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzZXRPcHRpb246IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIG9wdGlvbk1hbmFnZXIgPSB0aGlzLl9vcHRpb25NYW5hZ2VyO1xuXG4gICAgICAgICAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3JlY3JlYXRlJykge1xuICAgICAgICAgICAgICAgIHZhciBiYXNlT3B0aW9uID0gb3B0aW9uTWFuYWdlci5tb3VudE9wdGlvbih0eXBlID09PSAncmVjcmVhdGUnKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb24gfHwgdHlwZSA9PT0gJ3JlY3JlYXRlJykge1xuICAgICAgICAgICAgICAgICAgICBpbml0QmFzZS5jYWxsKHRoaXMsIGJhc2VPcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKGJhc2VPcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICd0aW1lbGluZScgfHwgdHlwZSA9PT0gJ21lZGlhJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZURhdGEoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICdyZWNyZWF0ZScgfHwgdHlwZSA9PT0gJ3RpbWVsaW5lJykge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZU9wdGlvbiA9IG9wdGlvbk1hbmFnZXIuZ2V0VGltZWxpbmVPcHRpb24odGhpcyk7XG4gICAgICAgICAgICAgICAgdGltZWxpbmVPcHRpb24gJiYgKHRoaXMubWVyZ2VPcHRpb24odGltZWxpbmVPcHRpb24pLCBvcHRpb25DaGFuZ2VkID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAncmVjcmVhdGUnIHx8IHR5cGUgPT09ICdtZWRpYScpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVkaWFPcHRpb25zID0gb3B0aW9uTWFuYWdlci5nZXRNZWRpYU9wdGlvbih0aGlzLCB0aGlzLl9hcGkpO1xuICAgICAgICAgICAgICAgIGlmIChtZWRpYU9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVhY2gobWVkaWFPcHRpb25zLCBmdW5jdGlvbiAobWVkaWFPcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VPcHRpb24obWVkaWFPcHRpb24sIG9wdGlvbkNoYW5nZWQgPSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uQ2hhbmdlZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHRpb24pIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzTWFwID0gdGhpcy5fY29tcG9uZW50c01hcDtcbiAgICAgICAgICAgIHZhciBuZXdDcHRUeXBlcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyDlpoLmnpzkuI3lrZjlnKjlr7nlupTnmoQgY29tcG9uZW50IG1vZGVsIOWImeebtOaOpSBtZXJnZVxuICAgICAgICAgICAgZWFjaChuZXdPcHRpb24sIGZ1bmN0aW9uIChjb21wb25lbnRPcHRpb24sIG1haW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudE9wdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIUNvbXBvbmVudE1vZGVsLmhhc0NsYXNzKG1haW5UeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25bbWFpblR5cGVdID0gb3B0aW9uW21haW5UeXBlXSA9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHpyVXRpbC5jbG9uZShjb21wb25lbnRPcHRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHpyVXRpbC5tZXJnZShvcHRpb25bbWFpblR5cGVdLCBjb21wb25lbnRPcHRpb24sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q3B0VHlwZXMucHVzaChtYWluVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FIE9QVElPTiDlkIzmraXmmK/lkKbopoHmlLnlm57ljp/mnaXnmoRcbiAgICAgICAgICAgIENvbXBvbmVudE1vZGVsLnRvcG9sb2dpY2FsVHJhdmVsKFxuICAgICAgICAgICAgICAgIG5ld0NwdFR5cGVzLCBDb21wb25lbnRNb2RlbC5nZXRBbGxDbGFzc01haW5UeXBlcygpLCB2aXNpdENvbXBvbmVudCwgdGhpc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IHRoaXMuX3Nlcmllc0luZGljZXMgfHwgW107XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHZpc2l0Q29tcG9uZW50KG1haW5UeXBlLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q3B0T3B0aW9uTGlzdCA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG5ld09wdGlvblttYWluVHlwZV0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1hcFJlc3VsdCA9IG1vZGVsVXRpbC5tYXBwaW5nVG9FeGlzdHMoXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHNNYXBbbWFpblR5cGVdLCBuZXdDcHRPcHRpb25MaXN0XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIG1vZGVsVXRpbC5tYWtlSWRBbmROYW1lKG1hcFJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgbWFpblR5cGUgYW5kIGNvbXBsZXRlIHN1YlR5cGUuXG4gICAgICAgICAgICAgICAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0ID0gaXRlbS5vcHRpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChvcHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmtleUluZm8ubWFpblR5cGUgPSBtYWluVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ua2V5SW5mby5zdWJUeXBlID0gZGV0ZXJtaW5lU3ViVHlwZShtYWluVHlwZSwgb3B0LCBpdGVtLmV4aXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVudE1vZGVscyA9IGdldENvbXBvbmVudHNCeVR5cGVzKFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzTWFwLCBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9uW21haW5UeXBlXSA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNNYXBbbWFpblR5cGVdID0gW107XG5cbiAgICAgICAgICAgICAgICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKHJlc3VsdEl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRNb2RlbCA9IHJlc3VsdEl0ZW0uZXhpc3Q7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDcHRPcHRpb24gPSByZXN1bHRJdGVtLm9wdGlvbjtcblxuICAgICAgICAgICAgICAgICAgICB6clV0aWwuYXNzZXJ0KFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QobmV3Q3B0T3B0aW9uKSB8fCBjb21wb25lbnRNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFbXB0eSBjb21wb25lbnQgZGVmaW5pdGlvbidcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlciB3aGVyZSBpcyBubyBuZXcgb3B0aW9uIGFuZCBzaG91bGQgYmUgbWVyZ2VkIHVzaW5nIHt9LFxuICAgICAgICAgICAgICAgICAgICAvLyBzZWUgcmVtb3ZlRWRnZUFuZEFkZCBpbiB0b3BvbG9naWNhbFRyYXZlbCBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcG9uZW50TW9kZWwuZ2V0QWxsQ2xhc3NNYWluVHlwZXMuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3Q3B0T3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5tZXJnZU9wdGlvbih7fSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5vcHRpb25VcGRhdGVkKHt9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgQ29tcG9uZW50TW9kZWxDbGFzcyA9IENvbXBvbmVudE1vZGVsLmdldENsYXNzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5UeXBlLCByZXN1bHRJdGVtLmtleUluZm8uc3ViVHlwZSwgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudE1vZGVsICYmIGNvbXBvbmVudE1vZGVsIGluc3RhbmNlb2YgQ29tcG9uZW50TW9kZWxDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm5hbWUgPSByZXN1bHRJdGVtLmtleUluZm8ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5tZXJnZU9wdGlvbihuZXdDcHRPcHRpb24sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm9wdGlvblVwZGF0ZWQobmV3Q3B0T3B0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIEdsb2JhbCBhcyBwYXJlbnQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHRyYU9wdCA9IHpyVXRpbC5leHRlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVudE1vZGVsczogZGVwZW5kZW50TW9kZWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEl0ZW0ua2V5SW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwgPSBuZXcgQ29tcG9uZW50TW9kZWxDbGFzcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q3B0T3B0aW9uLCB0aGlzLCB0aGlzLCBleHRyYU9wdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLmV4dGVuZChjb21wb25lbnRNb2RlbCwgZXh0cmFPcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLmluaXQobmV3Q3B0T3B0aW9uLCB0aGlzLCB0aGlzLCBleHRyYU9wdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBvcHRpb25VcGRhdGVkIGFmdGVyIGluaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV3Q3B0T3B0aW9uIGhhcyBiZWVuIHVzZWQgYXMgY29tcG9uZW50TW9kZWwub3B0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG1heSBiZSBtZXJnZWQgd2l0aCB0aGVtZSBhbmQgZGVmYXVsdCwgc28gcGFzcyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgY29uZnVzaW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm9wdGlvblVwZGF0ZWQobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzTWFwW21haW5UeXBlXVtpbmRleF0gPSBjb21wb25lbnRNb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uW21haW5UeXBlXVtpbmRleF0gPSBjb21wb25lbnRNb2RlbC5vcHRpb247XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBCYWNrdXAgc2VyaWVzIGZvciBmaWx0ZXJpbmcuXG4gICAgICAgICAgICAgICAgaWYgKG1haW5UeXBlID09PSAnc2VyaWVzJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXJpZXNJbmRpY2VzID0gY3JlYXRlU2VyaWVzSW5kaWNlcyhjb21wb25lbnRzTWFwLnNlcmllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgb3B0aW9uIGZvciBvdXRwdXQgKGNsb25lZCBvcHRpb24gYW5kIGlubmVyIGluZm8gcmVtb3ZlZClcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRPcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB6clV0aWwuY2xvbmUodGhpcy5vcHRpb24pO1xuXG4gICAgICAgICAgICBlYWNoKG9wdGlvbiwgZnVuY3Rpb24gKG9wdHMsIG1haW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKENvbXBvbmVudE1vZGVsLmhhc0NsYXNzKG1haW5UeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb3B0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9wdGlvbnMgd2l0aCBpbm5lciBpZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbFV0aWwuaXNJZElubmVyKG9wdHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uW21haW5UeXBlXSA9IG9wdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25bT1BUSU9OX0lOTkVSX0tFWV07XG5cbiAgICAgICAgICAgIHJldHVybiBvcHRpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGhlbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aGVtZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1haW5UeXBlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaWR4PTBdXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH1cbiAgICAgICAgICovXG4gICAgICAgIGdldENvbXBvbmVudDogZnVuY3Rpb24gKG1haW5UeXBlLCBpZHgpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50c01hcFttYWluVHlwZV07XG4gICAgICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0W2lkeCB8fCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbm9uZSBvZiBpbmRleCBhbmQgaWQgYW5kIG5hbWUgdXNlZCwgcmV0dXJuIGFsbCBjb21wb25lbnRzIHdpdGggbWFpblR5cGUuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25kaXRpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmRpdGlvbi5tYWluVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmRpdGlvbi5zdWJUeXBlXSBJZiBpZ25vcmUsIG9ubHkgcXVlcnkgYnkgbWFpblR5cGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtjb25kaXRpb24uaW5kZXhdIEVpdGhlciBpbnB1dCBpbmRleCBvciBpZCBvciBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2NvbmRpdGlvbi5pZF0gRWl0aGVyIGlucHV0IGluZGV4IG9yIGlkIG9yIG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbY29uZGl0aW9uLm5hbWVdIEVpdGhlciBpbnB1dCBpbmRleCBvciBpZCBvciBuYW1lLlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50Pn1cbiAgICAgICAgICovXG4gICAgICAgIHF1ZXJ5Q29tcG9uZW50czogZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgdmFyIG1haW5UeXBlID0gY29uZGl0aW9uLm1haW5UeXBlO1xuICAgICAgICAgICAgaWYgKCFtYWluVHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gY29uZGl0aW9uLmluZGV4O1xuICAgICAgICAgICAgdmFyIGlkID0gY29uZGl0aW9uLmlkO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBjb25kaXRpb24ubmFtZTtcblxuICAgICAgICAgICAgdmFyIGNwdHMgPSB0aGlzLl9jb21wb25lbnRzTWFwW21haW5UeXBlXTtcblxuICAgICAgICAgICAgaWYgKCFjcHRzIHx8ICFjcHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyKG1hcChpbmRleCwgZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3B0c1tpZHhdO1xuICAgICAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNJZEFycmF5ID0gaXNBcnJheShpZCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyKGNwdHMsIGZ1bmN0aW9uIChjcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpc0lkQXJyYXkgJiYgaW5kZXhPZihpZCwgY3B0LmlkKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKCFpc0lkQXJyYXkgJiYgY3B0LmlkID09PSBpZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNOYW1lQXJyYXkgPSBpc0FycmF5KG5hbWUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlcihjcHRzLCBmdW5jdGlvbiAoY3B0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXNOYW1lQXJyYXkgJiYgaW5kZXhPZihuYW1lLCBjcHQubmFtZSkgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICghaXNOYW1lQXJyYXkgJiYgY3B0Lm5hbWUgPT09IG5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFsbCBjb21wb25lbnRzIHdpdGggbWFpblR5cGVcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjcHRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyQnlTdWJUeXBlKHJlc3VsdCwgY29uZGl0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGludGVyZmFjZSBpcyBkaWZmZXJlbnQgZnJvbSBxdWVyeUNvbXBvbmVudHMsXG4gICAgICAgICAqIHdoaWNoIGlzIGNvbnZlbmllbnQgZm9yIGlubmVyIHVzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdXNhZ2VcbiAgICAgICAgICogdmFyIHJlc3VsdCA9IGZpbmRDb21wb25lbnRzKFxuICAgICAgICAgKiAgICAge21haW5UeXBlOiAnZGF0YVpvb20nLCBxdWVyeToge2RhdGFab29tSWQ6ICdhYmMnfX1cbiAgICAgICAgICogKTtcbiAgICAgICAgICogdmFyIHJlc3VsdCA9IGZpbmRDb21wb25lbnRzKFxuICAgICAgICAgKiAgICAge21haW5UeXBlOiAnc2VyaWVzJywgc3ViVHlwZTogJ3BpZScsIHF1ZXJ5OiB7c2VyaWVzTmFtZTogJ3Vpbyd9fVxuICAgICAgICAgKiApO1xuICAgICAgICAgKiB2YXIgcmVzdWx0ID0gZmluZENvbXBvbmVudHMoXG4gICAgICAgICAqICAgICB7bWFpblR5cGU6ICdzZXJpZXMnfSxcbiAgICAgICAgICogICAgIGZ1bmN0aW9uIChtb2RlbCwgaW5kZXgpIHsuLi59XG4gICAgICAgICAqICk7XG4gICAgICAgICAqIC8vIHJlc3VsdCBsaWtlIFtjb21wb25lbnQwLCBjb21wb25uZXQxLCAuLi5dXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25kaXRpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmRpdGlvbi5tYWluVHlwZSBNYW5kYXRvcnkuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZGl0aW9uLnN1YlR5cGVdIE9wdGlvbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmRpdGlvbi5xdWVyeV0gbGlrZSB7eHh4SW5kZXgsIHh4eElkLCB4eHhOYW1lfSxcbiAgICAgICAgICogICAgICAgIHdoZXJlIHh4eCBpcyBtYWluVHlwZS5cbiAgICAgICAgICogICAgICAgIElmIHF1ZXJ5IGF0dHJpYnV0ZSBpcyBudWxsL3VuZGVmaW5lZCBvciBoYXMgbm8gaW5kZXgvaWQvbmFtZSxcbiAgICAgICAgICogICAgICAgIGRvIG5vdCBmaWx0ZXJpbmcgYnkgcXVlcnkgY29uZGl0aW9ucywgd2hpY2ggaXMgY29udmVuaWVudCBmb3JcbiAgICAgICAgICogICAgICAgIG5vLXBheWxvYWQgc2l0dWF0aW9ucyBvciB3aGVuIHRhcmdldCBvZiBhY3Rpb24gaXMgZ2xvYmFsLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZGl0aW9uLmZpbHRlcl0gcGFyYW1ldGVyOiBjb21wb25lbnQsIHJldHVybiBib29sZWFuLlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50Pn1cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRDb21wb25lbnRzOiBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBjb25kaXRpb24ucXVlcnk7XG4gICAgICAgICAgICB2YXIgbWFpblR5cGUgPSBjb25kaXRpb24ubWFpblR5cGU7XG5cbiAgICAgICAgICAgIHZhciBxdWVyeUNvbmQgPSBnZXRRdWVyeUNvbmQocXVlcnkpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHF1ZXJ5Q29uZFxuICAgICAgICAgICAgICAgID8gdGhpcy5xdWVyeUNvbXBvbmVudHMocXVlcnlDb25kKVxuICAgICAgICAgICAgICAgIDogdGhpcy5fY29tcG9uZW50c01hcFttYWluVHlwZV07XG5cbiAgICAgICAgICAgIHJldHVybiBkb0ZpbHRlcihmaWx0ZXJCeVN1YlR5cGUocmVzdWx0LCBjb25kaXRpb24pKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UXVlcnlDb25kKHEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhBdHRyID0gbWFpblR5cGUgKyAnSW5kZXgnO1xuICAgICAgICAgICAgICAgIHZhciBpZEF0dHIgPSBtYWluVHlwZSArICdJZCc7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVBdHRyID0gbWFpblR5cGUgKyAnTmFtZSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgcVtpbmRleEF0dHJdICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IHFbaWRBdHRyXSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBxW25hbWVBdHRyXSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluVHlwZTogbWFpblR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWJUeXBlIHdpbGwgYmUgZmlsdGVyZWQgZmluYWxseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBxW2luZGV4QXR0cl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcVtpZEF0dHJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcVtuYW1lQXR0cl1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvRmlsdGVyKHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25kaXRpb24uZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICA/IGZpbHRlcihyZXMsIGNvbmRpdGlvbi5maWx0ZXIpXG4gICAgICAgICAgICAgICAgICAgICA6IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHVzYWdlXG4gICAgICAgICAqIGVhY2hDb21wb25lbnQoJ2xlZ2VuZCcsIGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgICogICAgIC4uLlxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogZWFjaENvbXBvbmVudChmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgbW9kZWwsIGluZGV4KSB7XG4gICAgICAgICAqICAgICAvLyBjb21wb25lbnRUeXBlIGRvZXMgbm90IGluY2x1ZGUgc3ViVHlwZVxuICAgICAgICAgKiAgICAgLy8gKGNvbXBvbmVudFR5cGUgaXMgJ3h4eCcgYnV0IG5vdCAneHh4LmFhJylcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGVhY2hDb21wb25lbnQoXG4gICAgICAgICAqICAgICB7bWFpblR5cGU6ICdkYXRhWm9vbScsIHF1ZXJ5OiB7ZGF0YVpvb21JZDogJ2FiYyd9fSxcbiAgICAgICAgICogICAgIGZ1bmN0aW9uIChtb2RlbCwgaW5kZXgpIHsuLi59XG4gICAgICAgICAqICk7XG4gICAgICAgICAqIGVhY2hDb21wb25lbnQoXG4gICAgICAgICAqICAgICB7bWFpblR5cGU6ICdzZXJpZXMnLCBzdWJUeXBlOiAncGllJywgcXVlcnk6IHtzZXJpZXNOYW1lOiAndWlvJ319LFxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkgey4uLn1cbiAgICAgICAgICogKTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0PX0gbWFpblR5cGUgV2hlbiBtYWluVHlwZSBpcyBvYmplY3QsIHRoZSBkZWZpbml0aW9uXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRoZSBzYW1lIGFzIHRoZSBtZXRob2QgJ2ZpbmRDb21wb25lbnRzJy5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBlYWNoQ29tcG9uZW50OiBmdW5jdGlvbiAobWFpblR5cGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50c01hcCA9IHRoaXMuX2NvbXBvbmVudHNNYXA7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWFpblR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2I7XG4gICAgICAgICAgICAgICAgY2IgPSBtYWluVHlwZTtcbiAgICAgICAgICAgICAgICBlYWNoKGNvbXBvbmVudHNNYXAsIGZ1bmN0aW9uIChjb21wb25lbnRzLCBjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVhY2goY29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY29tcG9uZW50VHlwZSwgY29tcG9uZW50LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoenJVdGlsLmlzU3RyaW5nKG1haW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIGVhY2goY29tcG9uZW50c01hcFttYWluVHlwZV0sIGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KG1haW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeVJlc3VsdCA9IHRoaXMuZmluZENvbXBvbmVudHMobWFpblR5cGUpO1xuICAgICAgICAgICAgICAgIGVhY2gocXVlcnlSZXN1bHQsIGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZXJpZXNCeU5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5zZXJpZXM7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyKHNlcmllcywgZnVuY3Rpb24gKG9uZVNlcmllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbmVTZXJpZXMubmFtZSA9PT0gbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2VyaWVzSW5kZXhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VyaWVzQnlJbmRleDogZnVuY3Rpb24gKHNlcmllc0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c01hcC5zZXJpZXNbc2VyaWVzSW5kZXhdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViVHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFNlcmllc0J5VHlwZTogZnVuY3Rpb24gKHN1YlR5cGUpIHtcbiAgICAgICAgICAgIHZhciBzZXJpZXMgPSB0aGlzLl9jb21wb25lbnRzTWFwLnNlcmllcztcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIoc2VyaWVzLCBmdW5jdGlvbiAob25lU2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uZVNlcmllcy5zdWJUeXBlID09PSBzdWJUeXBlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXM+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VyaWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c01hcC5zZXJpZXMuc2xpY2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWZ0ZXIgZmlsdGVyaW5nLCBzZXJpZXMgbWF5IGJlIGRpZmZlcmVudFxuICAgICAgICAgKiBmcm9tZSByYXcgc2VyaWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGVhY2hTZXJpZXM6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQodGhpcyk7XG4gICAgICAgICAgICBlYWNoKHRoaXMuX3Nlcmllc0luZGljZXMsIGZ1bmN0aW9uIChyYXdTZXJpZXNJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXMgPSB0aGlzLl9jb21wb25lbnRzTWFwLnNlcmllc1tyYXdTZXJpZXNJbmRleF07XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBzZXJpZXMsIHJhd1Nlcmllc0luZGV4KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlIHJhdyBzZXJpZXMgYmVmb3JlIGZpbHRlcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGVhY2hSYXdTZXJpZXM6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgZWFjaCh0aGlzLl9jb21wb25lbnRzTWFwLnNlcmllcywgY2IsIGNvbnRleHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZnRlciBmaWx0ZXJpbmcsIHNlcmllcyBtYXkgYmUgZGlmZmVyZW50LlxuICAgICAgICAgKiBmcm9tZSByYXcgc2VyaWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFybWEge3N0cmluZ30gc3ViVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGVhY2hTZXJpZXNCeVR5cGU6IGZ1bmN0aW9uIChzdWJUeXBlLCBjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQodGhpcyk7XG4gICAgICAgICAgICBlYWNoKHRoaXMuX3Nlcmllc0luZGljZXMsIGZ1bmN0aW9uIChyYXdTZXJpZXNJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXMgPSB0aGlzLl9jb21wb25lbnRzTWFwLnNlcmllc1tyYXdTZXJpZXNJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHNlcmllcy5zdWJUeXBlID09PSBzdWJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgc2VyaWVzLCByYXdTZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgcmF3IHNlcmllcyBiZWZvcmUgZmlsdGVyZWQgb2YgZ2l2ZW4gdHlwZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcm1hIHtzdHJpbmd9IHN1YlR5cGVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBlYWNoUmF3U2VyaWVzQnlUeXBlOiBmdW5jdGlvbiAoc3ViVHlwZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBlYWNoKHRoaXMuZ2V0U2VyaWVzQnlUeXBlKHN1YlR5cGUpLCBjYiwgY29udGV4dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgICAgICAgKi9cbiAgICAgICAgaXNTZXJpZXNGaWx0ZXJlZDogZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB6clV0aWwuaW5kZXhPZih0aGlzLl9zZXJpZXNJbmRpY2VzLCBzZXJpZXNNb2RlbC5jb21wb25lbnRJbmRleCkgPCAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlclNlcmllczogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZFNlcmllcyA9IGZpbHRlcihcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzTWFwLnNlcmllcywgY2IsIGNvbnRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9zZXJpZXNJbmRpY2VzID0gY3JlYXRlU2VyaWVzSW5kaWNlcyhmaWx0ZXJlZFNlcmllcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzdG9yZURhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzTWFwID0gdGhpcy5fY29tcG9uZW50c01hcDtcblxuICAgICAgICAgICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IGNyZWF0ZVNlcmllc0luZGljZXMoY29tcG9uZW50c01hcC5zZXJpZXMpO1xuXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50VHlwZXMgPSBbXTtcbiAgICAgICAgICAgIGVhY2goY29tcG9uZW50c01hcCwgZnVuY3Rpb24gKGNvbXBvbmVudHMsIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlcy5wdXNoKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIENvbXBvbmVudE1vZGVsLnRvcG9sb2dpY2FsVHJhdmVsKFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGVzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudE1vZGVsLmdldEFsbENsYXNzTWFpblR5cGVzKCksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgICAgICBlYWNoKGNvbXBvbmVudHNNYXBbY29tcG9uZW50VHlwZV0sIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5yZXN0b3JlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlVGhlbWUob3B0aW9uLCB0aGVtZSkge1xuICAgICAgICB6clV0aWwuZWFjaCh0aGVtZSwgZnVuY3Rpb24gKHRoZW1lSXRlbSwgbmFtZSkge1xuICAgICAgICAgICAgLy8g5aaC5p6c5pyJIGNvbXBvbmVudCBtb2RlbCDliJnmiorlhbfkvZPnmoQgbWVyZ2Ug6YC76L6R5Lqk57uZ6K+lIG1vZGVsIOWkhOeQhlxuICAgICAgICAgICAgaWYgKCFDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhlbWVJdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25bbmFtZV0gPSAhb3B0aW9uW25hbWVdXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHpyVXRpbC5jbG9uZSh0aGVtZUl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHpyVXRpbC5tZXJnZShvcHRpb25bbmFtZV0sIHRoZW1lSXRlbSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbltuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25bbmFtZV0gPSB0aGVtZUl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRCYXNlKGJhc2VPcHRpb24pIHtcbiAgICAgICAgYmFzZU9wdGlvbiA9IGJhc2VPcHRpb247XG5cbiAgICAgICAgLy8gVXNpbmcgT1BUSU9OX0lOTkVSX0tFWSB0byBtYXJrIHRoYXQgdGhpcyBvcHRpb24gY2FuIG5vdCBiZSB1c2VkIG91dHNpZGUsXG4gICAgICAgIC8vIGkuZS4gYGNoYXJ0LnNldE9wdGlvbihjaGFydC5nZXRNb2RlbCgpLm9wdGlvbik7YCBpcyBmb3JiaWRlbi5cbiAgICAgICAgdGhpcy5vcHRpb24gPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25bT1BUSU9OX0lOTkVSX0tFWV0gPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIEFycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD4+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29tcG9uZW50c01hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBwaW5nIGJldHdlZW4gZmlsdGVyZWQgc2VyaWVzIGxpc3QgYW5kIHJhdyBzZXJpZXMgbGlzdC5cbiAgICAgICAgICoga2V5OiBmaWx0ZXJlZCBzZXJpZXMgaW5kaWNlcywgdmFsdWU6IHJhdyBzZXJpZXMgaW5kaWNlcy5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudWJtZXI+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IG51bGw7XG5cbiAgICAgICAgbWVyZ2VUaGVtZShiYXNlT3B0aW9uLCB0aGlzLl90aGVtZS5vcHRpb24pO1xuXG4gICAgICAgIC8vIFRPRE8gTmVlZHMgY2xvbmUgd2hlbiBtZXJnaW5nIHRvIHRoZSB1bmV4aXN0ZWQgcHJvcGVydHlcbiAgICAgICAgenJVdGlsLm1lcmdlKGJhc2VPcHRpb24sIGdsb2JhbERlZmF1bHQsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKGJhc2VPcHRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSB0eXBlcyBtb2RlbCB0eXBlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0ga2V5OiB7c3RyaW5nfSB0eXBlLCB2YWx1ZToge0FycmF5LjxPYmplY3Q+fSBtb2RlbHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnRzQnlUeXBlcyhjb21wb25lbnRzTWFwLCB0eXBlcykge1xuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHR5cGVzKSkge1xuICAgICAgICAgICAgdHlwZXMgPSB0eXBlcyA/IFt0eXBlc10gOiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgZWFjaCh0eXBlcywgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldFt0eXBlXSA9IChjb21wb25lbnRzTWFwW3R5cGVdIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG5ld0NwdE9wdGlvbiwgZXhpc3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIHN1YlR5cGUgPSBuZXdDcHRPcHRpb24udHlwZVxuICAgICAgICAgICAgPyBuZXdDcHRPcHRpb24udHlwZVxuICAgICAgICAgICAgOiBleGlzdENvbXBvbmVudFxuICAgICAgICAgICAgPyBleGlzdENvbXBvbmVudC5zdWJUeXBlXG4gICAgICAgICAgICAvLyBVc2UgZGV0ZXJtaW5lU3ViVHlwZSBvbmx5IHdoZW4gdGhlcmUgaXMgbm8gZXhpc3RDb21wb25lbnQuXG4gICAgICAgICAgICA6IENvbXBvbmVudE1vZGVsLmRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG5ld0NwdE9wdGlvbik7XG5cbiAgICAgICAgLy8gdG9vbHRpcCwgbWFya2xpbmUsIG1hcmtwb2ludCBtYXkgYWx3YXlzIGhhcyBubyBzdWJUeXBlXG4gICAgICAgIHJldHVybiBzdWJUeXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVNlcmllc0luZGljZXMoc2VyaWVzTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiBtYXAoc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzLmNvbXBvbmVudEluZGV4O1xuICAgICAgICB9KSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXJCeVN1YlR5cGUoY29tcG9uZW50cywgY29uZGl0aW9uKSB7XG4gICAgICAgIC8vIFVzaW5nIGhhc093blByb3BlcnR5IGZvciByZXN0cmljdC4gQ29uc2lkZXJcbiAgICAgICAgLy8gc3ViVHlwZSBpcyB1bmRlZmluZWQgaW4gdXNlciBwYXlsb2FkLlxuICAgICAgICByZXR1cm4gY29uZGl0aW9uLmhhc093blByb3BlcnR5KCdzdWJUeXBlJylcbiAgICAgICAgICAgID8gZmlsdGVyKGNvbXBvbmVudHMsIGZ1bmN0aW9uIChjcHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3B0LnN1YlR5cGUgPT09IGNvbmRpdGlvbi5zdWJUeXBlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogY29tcG9uZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnRTZXJpZXNJbml0aWFsaXplZChlY01vZGVsKSB7XG4gICAgICAgIC8vIENvbXBvbmVudHMgdGhhdCB1c2UgX3Nlcmllc0luZGljZXMgc2hvdWxkIGRlcGVuZHMgb24gc2VyaWVzIGNvbXBvbmVudCxcbiAgICAgICAgLy8gd2hpY2ggbWFrZSBzdXJlIHRoYXQgdGhlaXIgaW5pdGlhbGl6YXRpb24gaXMgYWZ0ZXIgc2VyaWVzLlxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKCFlY01vZGVsLl9zZXJpZXNJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJpZXMgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHpyVXRpbC5taXhpbihHbG9iYWxNb2RlbCwgcmVxdWlyZSgnLi9taXhpbi9jb2xvclBhbGV0dGUnKSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdsb2JhbE1vZGVsO1xuIiwiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvbW9kZWwvTW9kZWxcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhenonKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbcGFyZW50TW9kZWxdXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IFtlY01vZGVsXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1vZGVsKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcmVudE1vZGVsID0gcGFyZW50TW9kZWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb24gPSBvcHRpb247XG5cbiAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxuICAgICAgICAvLyBpZiAodGhpcy5pbml0KSB7XG4gICAgICAgIC8vICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSA0KSB7XG4gICAgICAgIC8vICAgICAgICAgdGhpcy5pbml0KG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIGVsc2Uge1xuICAgICAgICAvLyAgICAgICAgIHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgfVxuXG4gICAgTW9kZWwucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBNb2RlbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWwg55qE5Yid5aeL5YyW5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS7juaWsOeahCBPcHRpb24gbWVyZ2VcbiAgICAgICAgICovXG4gICAgICAgIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICB6clV0aWwubWVyZ2UodGhpcy5vcHRpb24sIG9wdGlvbiwgdHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZVBhcmVudD1mYWxzZV1cbiAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKHBhdGgsIGlnbm9yZVBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRvR2V0KFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uLFxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VQYXRoKHBhdGgpLFxuICAgICAgICAgICAgICAgICFpZ25vcmVQYXJlbnQgJiYgZ2V0UGFyZW50KHRoaXMsIHBhdGgpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZVBhcmVudD1mYWxzZV1cbiAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFNoYWxsb3c6IGZ1bmN0aW9uIChrZXksIGlnbm9yZVBhcmVudCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuXG4gICAgICAgICAgICB2YXIgdmFsID0gb3B0aW9uID09IG51bGwgPyBvcHRpb24gOiBvcHRpb25ba2V5XTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRNb2RlbCA9ICFpZ25vcmVQYXJlbnQgJiYgZ2V0UGFyZW50KHRoaXMsIGtleSk7XG4gICAgICAgICAgICBpZiAodmFsID09IG51bGwgJiYgcGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBwYXJlbnRNb2RlbC5nZXRTaGFsbG93KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gcGF0aFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbcGFyZW50TW9kZWxdXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TW9kZWw6IGZ1bmN0aW9uIChwYXRoLCBwYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHBhdGggPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gdGhpcy5vcHRpb25cbiAgICAgICAgICAgICAgICA6IGRvR2V0KHRoaXMub3B0aW9uLCBwYXRoID0gdGhpcy5wYXJzZVBhdGgocGF0aCkpO1xuXG4gICAgICAgICAgICB2YXIgdGhpc1BhcmVudE1vZGVsO1xuICAgICAgICAgICAgcGFyZW50TW9kZWwgPSBwYXJlbnRNb2RlbCB8fCAoXG4gICAgICAgICAgICAgICAgKHRoaXNQYXJlbnRNb2RlbCA9IGdldFBhcmVudCh0aGlzLCBwYXRoKSlcbiAgICAgICAgICAgICAgICAgICAgJiYgdGhpc1BhcmVudE1vZGVsLmdldE1vZGVsKHBhdGgpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZGVsKG9iaiwgcGFyZW50TW9kZWwsIHRoaXMuZWNNb2RlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG1vZGVsIGhhcyBvcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbiA9PSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgICAgICAvLyBQZW5kaW5nXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgQ3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoenJVdGlsLmNsb25lKHRoaXMub3B0aW9uKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0UmVhZE9ubHk6IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBjbGF6elV0aWwuc2V0UmVhZE9ubHkodGhpcywgcHJvcGVydGllcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSWYgcGF0aCBpcyBudWxsL3VuZGVmaW5lZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICAgICAgICBwYXJzZVBhdGg6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGdldFBhcmVudE1ldGhvZFxuICAgICAgICAgKiAgICAgICAgcGFyYW0ge0FycmF5LjxzdHJpbmc+fHN0cmluZ30gcGF0aFxuICAgICAgICAgKiAgICAgICAgcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgICAgICovXG4gICAgICAgIGN1c3RvbWl6ZUdldFBhcmVudDogZnVuY3Rpb24gKGdldFBhcmVudE1ldGhvZCkge1xuICAgICAgICAgICAgY2xhenpVdGlsLnNldCh0aGlzLCAnZ2V0UGFyZW50JywgZ2V0UGFyZW50TWV0aG9kKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0FuaW1hdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghZW52Lm5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb24uYW5pbWF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5vcHRpb24uYW5pbWF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudE1vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkb0dldChvYmosIHBhdGhBcnIsIHBhcmVudE1vZGVsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gSWdub3JlIGVtcHR5XG4gICAgICAgICAgICBpZiAoIXBhdGhBcnJbaV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9iaiBjb3VsZCBiZSBudW1iZXIvc3RyaW5nLy4uLiAobGlrZSAwKVxuICAgICAgICAgICAgb2JqID0gKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JykgPyBvYmpbcGF0aEFycltpXV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iaiA9PSBudWxsICYmIHBhcmVudE1vZGVsKSB7XG4gICAgICAgICAgICBvYmogPSBwYXJlbnRNb2RlbC5nZXQocGF0aEFycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJlbnQobW9kZWwsIHBhdGgpIHtcbiAgICAgICAgdmFyIGdldFBhcmVudE1ldGhvZCA9IGNsYXp6VXRpbC5nZXQobW9kZWwsICdnZXRQYXJlbnQnKTtcbiAgICAgICAgcmV0dXJuIGdldFBhcmVudE1ldGhvZCA/IGdldFBhcmVudE1ldGhvZC5jYWxsKG1vZGVsLCBwYXRoKSA6IG1vZGVsLnBhcmVudE1vZGVsO1xuICAgIH1cblxuICAgIC8vIEVuYWJsZSBNb2RlbC5leHRlbmQuXG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKE1vZGVsKTtcblxuICAgIHZhciBtaXhpbiA9IHpyVXRpbC5taXhpbjtcbiAgICBtaXhpbihNb2RlbCwgcmVxdWlyZSgnLi9taXhpbi9saW5lU3R5bGUnKSk7XG4gICAgbWl4aW4oTW9kZWwsIHJlcXVpcmUoJy4vbWl4aW4vYXJlYVN0eWxlJykpO1xuICAgIG1peGluKE1vZGVsLCByZXF1aXJlKCcuL21peGluL3RleHRTdHlsZScpKTtcbiAgICBtaXhpbihNb2RlbCwgcmVxdWlyZSgnLi9taXhpbi9pdGVtU3R5bGUnKSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xuIiwiLyoqXG4gKiBFQ2hhcnRzIG9wdGlvbiBtYW5hZ2VyXG4gKlxuICogQG1vZHVsZSB7ZWNoYXJ0cy9tb2RlbC9PcHRpb25NYW5hZ2VyfVxuICovXG5cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBjbG9uZSA9IHpyVXRpbC5jbG9uZTtcbiAgICB2YXIgbWFwID0genJVdGlsLm1hcDtcbiAgICB2YXIgbWVyZ2UgPSB6clV0aWwubWVyZ2U7XG5cbiAgICB2YXIgUVVFUllfUkVHID0gL14obWlufG1heCk/KC4rKSQvO1xuXG4gICAgLyoqXG4gICAgICogVEVSTSBFWFBMQU5BVElPTlM6XG4gICAgICpcbiAgICAgKiBbb3B0aW9uXTpcbiAgICAgKlxuICAgICAqICAgICBBbiBvYmplY3QgdGhhdCBjb250YWlucyBkZWZpbml0aW9ucyBvZiBjb21wb25lbnRzLiBGb3IgZXhhbXBsZTpcbiAgICAgKiAgICAgdmFyIG9wdGlvbiA9IHtcbiAgICAgKiAgICAgICAgIHRpdGxlOiB7Li4ufSxcbiAgICAgKiAgICAgICAgIGxlZ2VuZDogey4uLn0sXG4gICAgICogICAgICAgICB2aXN1YWxNYXA6IHsuLi59LFxuICAgICAqICAgICAgICAgc2VyaWVzOiBbXG4gICAgICogICAgICAgICAgICAge2RhdGE6IFsuLi5dfSxcbiAgICAgKiAgICAgICAgICAgICB7ZGF0YTogWy4uLl19LFxuICAgICAqICAgICAgICAgICAgIC4uLlxuICAgICAqICAgICAgICAgXVxuICAgICAqICAgICB9O1xuICAgICAqXG4gICAgICogW3Jhd09wdGlvbl06XG4gICAgICpcbiAgICAgKiAgICAgQW4gb2JqZWN0IGlucHV0IHRvIGVjaGFydHMuc2V0T3B0aW9uLiAncmF3T3B0aW9uJyBtYXkgYmUgYW5cbiAgICAgKiAgICAgJ29wdGlvbicsIG9yIG1heSBiZSBhbiBvYmplY3QgY29udGFpbnMgbXVsdGktb3B0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAgICogICAgIHZhciBvcHRpb24gPSB7XG4gICAgICogICAgICAgICBiYXNlT3B0aW9uOiB7XG4gICAgICogICAgICAgICAgICAgdGl0bGU6IHsuLi59LFxuICAgICAqICAgICAgICAgICAgIGxlZ2VuZDogey4uLn0sXG4gICAgICogICAgICAgICAgICAgc2VyaWVzOiBbXG4gICAgICogICAgICAgICAgICAgICAgIHtkYXRhOiBbLi4uXX0sXG4gICAgICogICAgICAgICAgICAgICAgIHtkYXRhOiBbLi4uXX0sXG4gICAgICogICAgICAgICAgICAgICAgIC4uLlxuICAgICAqICAgICAgICAgICAgIF1cbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgICB0aW1lbGluZTogey4uLn0sXG4gICAgICogICAgICAgICBvcHRpb25zOiBbXG4gICAgICogICAgICAgICAgICAge3RpdGxlOiB7Li4ufSwgc2VyaWVzOiB7ZGF0YTogWy4uLl19fSxcbiAgICAgKiAgICAgICAgICAgICB7dGl0bGU6IHsuLi59LCBzZXJpZXM6IHtkYXRhOiBbLi4uXX19LFxuICAgICAqICAgICAgICAgICAgIC4uLlxuICAgICAqICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgIG1lZGlhOiBbXG4gICAgICogICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICBxdWVyeToge21heFdpZHRoOiAzMjB9LFxuICAgICAqICAgICAgICAgICAgICAgICBvcHRpb246IHtzZXJpZXM6IHt4OiAyMH0sIHZpc3VhbE1hcDoge3Nob3c6IGZhbHNlfX1cbiAgICAgKiAgICAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgcXVlcnk6IHttaW5XaWR0aDogMzIwLCBtYXhXaWR0aDogNzIwfSxcbiAgICAgKiAgICAgICAgICAgICAgICAgb3B0aW9uOiB7c2VyaWVzOiB7eDogNTAwfSwgdmlzdWFsTWFwOiB7c2hvdzogdHJ1ZX19XG4gICAgICogICAgICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbjoge3Nlcmllczoge3g6IDEyMDB9LCB2aXN1YWxNYXA6IHtzaG93OiB0cnVlfX1cbiAgICAgKiAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICBdXG4gICAgICogICAgIH07XG4gICAgICpcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPcHRpb25NYW5hZ2VyKGFwaSkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXBpID0gYXBpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90aW1lbGluZU9wdGlvbnMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWVkaWFMaXN0ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tZWRpYURlZmF1bHQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIC0xLCBtZWFucyBkZWZhdWx0LlxuICAgICAgICAgKiBlbXB0eSBtZWFucyBubyBtZWRpYS5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3VycmVudE1lZGlhSW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb3B0aW9uQmFja3VwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmV3QmFzZU9wdGlvbjtcbiAgICB9XG5cbiAgICAvLyB0aW1lbGluZS5ub3RNZXJnZSBpcyBub3Qgc3VwcG9ydGVkIGluIGVjMy4gRmlyc3RseSB0aGVyZSBpcyByZWFybHlcbiAgICAvLyBjYXNlIHRoYXQgbm90TWVyZ2UgaXMgbmVlZGVkLiBTZWNvbmRseSBzdXBwb3J0aW5nICdub3RNZXJnZScgcmVxdWlyZXNcbiAgICAvLyByYXdPcHRpb24gY2xvbmVkIGFuZCBiYWNrdXBlZCB3aGVuIHRpbWVsaW5lIGNoYW5nZWQsIHdoaWNoIGRvZXMgbm9cbiAgICAvLyBnb29kIHRvIHBlcmZvcm1hbmNlLiBXaGF0J3MgbW9yZSwgdGhhdCBib3RoIHRpbWVsaW5lIGFuZCBzZXRPcHRpb25cbiAgICAvLyBtZXRob2Qgc3VwcGx5ICdub3RNZXJnZScgYnJpbmdzIGNvbXBsZXggYW5kIHNvbWUgcHJvYmxlbXMuXG4gICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOlxuICAgIC8vIChzdGVwMSkgY2hhcnQuc2V0T3B0aW9uKHt0aW1lbGluZToge25vdE1lcmdlOiBmYWxzZX0sIC4uLn0sIGZhbHNlKTtcbiAgICAvLyAoc3RlcDIpIGNoYXJ0LnNldE9wdGlvbih7dGltZWxpbmU6IHtub3RNZXJnZTogdHJ1ZX0sIC4uLn0sIGZhbHNlKTtcblxuICAgIE9wdGlvbk1hbmFnZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBPcHRpb25NYW5hZ2VyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByYXdPcHRpb24gUmF3IG9wdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48RnVuY3Rpb24+fSBvcHRpb25QcmVwcm9jZXNzb3JGdW5jc1xuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEluaXQgb3B0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzZXRPcHRpb246IGZ1bmN0aW9uIChyYXdPcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKSB7XG4gICAgICAgICAgICByYXdPcHRpb24gPSBjbG9uZShyYXdPcHRpb24sIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8g5aaC5p6cIHRpbWVsaW5lIG9wdGlvbnMg5oiW6ICFIG1lZGlhIOS4reiuvue9ruS6huafkOS4quWxnuaAp++8jOiAjGJhc2VPcHRpb27kuK3msqHmnInorr7nva7vvIzliJnov5vooYzorablkYrjgIJcblxuICAgICAgICAgICAgdmFyIG9sZE9wdGlvbkJhY2t1cCA9IHRoaXMuX29wdGlvbkJhY2t1cDtcbiAgICAgICAgICAgIHZhciBuZXdQYXJzZWRPcHRpb24gPSBwYXJzZVJhd09wdGlvbi5jYWxsKFxuICAgICAgICAgICAgICAgIHRoaXMsIHJhd09wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MsICFvbGRPcHRpb25CYWNrdXBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9uZXdCYXNlT3B0aW9uID0gbmV3UGFyc2VkT3B0aW9uLmJhc2VPcHRpb247XG5cbiAgICAgICAgICAgIC8vIEZvciBzZXRPcHRpb24gYXQgc2Vjb25kIHRpbWUgKHVzaW5nIG1lcmdlIG1vZGUpO1xuICAgICAgICAgICAgaWYgKG9sZE9wdGlvbkJhY2t1cCkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYmFzZU9wdGlvbiBjYW4gYmUgbWVyZ2VkLlxuICAgICAgICAgICAgICAgIG1lcmdlT3B0aW9uKG9sZE9wdGlvbkJhY2t1cC5iYXNlT3B0aW9uLCBuZXdQYXJzZWRPcHRpb24uYmFzZU9wdGlvbik7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgdGltZWxpbmUgb3B0aW9ucyBhbmQgbWVkaWEgb3B0aW9ucyBkbyBub3Qgc3VwcG9ydCBtZXJnZSxcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGlzLCBpZiB5b3UgYHNldE9wdGlvbmAgdHdpY2UgYW5kIGJvdGggaGFzIHRpbWVsaW5lIG9wdGlvbnMsIHRoZSBsYXR0ZXJcbiAgICAgICAgICAgICAgICAvLyB0aW1lbGluZSBvcGl0b25zIHdpbGwgbm90IGJlIG1lcmdlZCB0byB0aGUgZm9ybWVycywgYnV0IGp1c3Qgc3Vic3RpdHVkZSB0aGVtLlxuICAgICAgICAgICAgICAgIGlmIChuZXdQYXJzZWRPcHRpb24udGltZWxpbmVPcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRPcHRpb25CYWNrdXAudGltZWxpbmVPcHRpb25zID0gbmV3UGFyc2VkT3B0aW9uLnRpbWVsaW5lT3B0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld1BhcnNlZE9wdGlvbi5tZWRpYUxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZE9wdGlvbkJhY2t1cC5tZWRpYUxpc3QgPSBuZXdQYXJzZWRPcHRpb24ubWVkaWFMaXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3UGFyc2VkT3B0aW9uLm1lZGlhRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRPcHRpb25CYWNrdXAubWVkaWFEZWZhdWx0ID0gbmV3UGFyc2VkT3B0aW9uLm1lZGlhRGVmYXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25CYWNrdXAgPSBuZXdQYXJzZWRPcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSZWNyZWF0ZVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBtb3VudE9wdGlvbjogZnVuY3Rpb24gKGlzUmVjcmVhdGUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25CYWNrdXAgPSB0aGlzLl9vcHRpb25CYWNrdXA7XG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIC8vIOWmguaenOayoeaciXJlc2V05Yqf6IO95YiZ5LiNY2xvbmXjgIJcblxuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVPcHRpb25zID0gbWFwKG9wdGlvbkJhY2t1cC50aW1lbGluZU9wdGlvbnMsIGNsb25lKTtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhTGlzdCA9IG1hcChvcHRpb25CYWNrdXAubWVkaWFMaXN0LCBjbG9uZSk7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYURlZmF1bHQgPSBjbG9uZShvcHRpb25CYWNrdXAubWVkaWFEZWZhdWx0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMgPSBbXTtcblxuICAgICAgICAgICAgcmV0dXJuIGNsb25lKGlzUmVjcmVhdGVcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9vcHRpb25CYWNrdXAuYmFzZU9wdGlvbiwgd2hpY2ggaXMgY3JlYXRlZCBhdCB0aGUgZmlyc3QgYHNldE9wdGlvbmBcbiAgICAgICAgICAgICAgICAvLyBjYWxsZWQsIGFuZCBpcyBtZXJnZWQgaW50byBldmVyeSBuZXcgb3B0aW9uIGJ5IGlubmVyIG1ldGhvZCBgbWVyZ2VPcHRpb25gXG4gICAgICAgICAgICAgICAgLy8gZWFjaCB0aW1lIGBzZXRPcHRpb25gIGNhbGxlZCwgY2FuIGJlIG9ubHkgdXNlZCBpbiBgaXNSZWNyZWF0ZWAsIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBpdHMgcmVsaWFiaWxpdHkgaXMgdW5kZXIgc3VzcGljaW9uLiBJbiBvdGhlciBjYXNlcyBvcHRpb24gbWVyZ2UgaXNcbiAgICAgICAgICAgICAgICAvLyBwZXJmb3JtZWQgYnkgYG1vZGVsLm1lcmdlT3B0aW9uYC5cbiAgICAgICAgICAgICAgICA/IG9wdGlvbkJhY2t1cC5iYXNlT3B0aW9uIDogdGhpcy5fbmV3QmFzZU9wdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGltZWxpbmVPcHRpb246IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uO1xuICAgICAgICAgICAgdmFyIHRpbWVsaW5lT3B0aW9ucyA9IHRoaXMuX3RpbWVsaW5lT3B0aW9ucztcblxuICAgICAgICAgICAgaWYgKHRpbWVsaW5lT3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXRUaW1lbGluZU9wdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgZWNNb2RlbCBpbml0ZWQsXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgY2FuIGdldCBjdXJyZW50SW5kZXggZnJvbSB0aW1lbGluZU1vZGVsLlxuICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZU1vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3RpbWVsaW5lJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gY2xvbmUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZU9wdGlvbnNbdGltZWxpbmVNb2RlbC5nZXRDdXJyZW50SW5kZXgoKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIGdldE1lZGlhT3B0aW9uOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGVjV2lkdGggPSB0aGlzLl9hcGkuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHZhciBlY0hlaWdodCA9IHRoaXMuX2FwaS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIHZhciBtZWRpYUxpc3QgPSB0aGlzLl9tZWRpYUxpc3Q7XG4gICAgICAgICAgICB2YXIgbWVkaWFEZWZhdWx0ID0gdGhpcy5fbWVkaWFEZWZhdWx0O1xuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgLy8gTm8gbWVkaWEgZGVmaW5lZC5cbiAgICAgICAgICAgIGlmICghbWVkaWFMaXN0Lmxlbmd0aCAmJiAhbWVkaWFEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTXVsdGkgbWVkaWEgbWF5IGJlIGFwcGxpZWQsIHRoZSBsYXR0ZXIgZGVmaW5lZCBtZWRpYSBoYXMgaGlnaGVyIHByaW9yaXR5LlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1lZGlhTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcHBseU1lZGlhUXVlcnkobWVkaWFMaXN0W2ldLnF1ZXJ5LCBlY1dpZHRoLCBlY0hlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIC8vIOaYr+WQpm1lZGlhRGVmYXVsdOW6lOivpeW8uuWItueUqOaIt+iuvue9ru+8jOWQpuWImeWPr+iDveS/ruaUueS4jeiDveWbnuW9kuOAglxuICAgICAgICAgICAgaWYgKCFpbmRpY2VzLmxlbmd0aCAmJiBtZWRpYURlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzID0gWy0xXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoICYmICFpbmRpY2VzRXF1YWxzKGluZGljZXMsIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWFwKGluZGljZXMsIGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmUoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9PT0gLTEgPyBtZWRpYURlZmF1bHQub3B0aW9uIDogbWVkaWFMaXN0W2luZGV4XS5vcHRpb25cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gbm90aGluZy5cblxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE1lZGlhSW5kaWNlcyA9IGluZGljZXM7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VSYXdPcHRpb24ocmF3T3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcywgaXNOZXcpIHtcbiAgICAgICAgdmFyIHRpbWVsaW5lT3B0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgbWVkaWFMaXN0ID0gW107XG4gICAgICAgIHZhciBtZWRpYURlZmF1bHQ7XG4gICAgICAgIHZhciBiYXNlT3B0aW9uO1xuXG4gICAgICAgIC8vIENvbXBhdGlibGUgd2l0aCBlYzIuXG4gICAgICAgIHZhciB0aW1lbGluZU9wdCA9IHJhd09wdGlvbi50aW1lbGluZTtcblxuICAgICAgICBpZiAocmF3T3B0aW9uLmJhc2VPcHRpb24pIHtcbiAgICAgICAgICAgIGJhc2VPcHRpb24gPSByYXdPcHRpb24uYmFzZU9wdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciB0aW1lbGluZVxuICAgICAgICBpZiAodGltZWxpbmVPcHQgfHwgcmF3T3B0aW9uLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGJhc2VPcHRpb24gPSBiYXNlT3B0aW9uIHx8IHt9O1xuICAgICAgICAgICAgdGltZWxpbmVPcHRpb25zID0gKHJhd09wdGlvbi5vcHRpb25zIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIG1lZGlhIHF1ZXJ5XG4gICAgICAgIGlmIChyYXdPcHRpb24ubWVkaWEpIHtcbiAgICAgICAgICAgIGJhc2VPcHRpb24gPSBiYXNlT3B0aW9uIHx8IHt9O1xuICAgICAgICAgICAgdmFyIG1lZGlhID0gcmF3T3B0aW9uLm1lZGlhO1xuICAgICAgICAgICAgZWFjaChtZWRpYSwgZnVuY3Rpb24gKHNpbmdsZU1lZGlhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZU1lZGlhICYmIHNpbmdsZU1lZGlhLm9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlTWVkaWEucXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhTGlzdC5wdXNoKHNpbmdsZU1lZGlhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghbWVkaWFEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IG1lZGlhIGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYURlZmF1bHQgPSBzaW5nbGVNZWRpYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIG5vcm1hbCBvcHRpb25cbiAgICAgICAgaWYgKCFiYXNlT3B0aW9uKSB7XG4gICAgICAgICAgICBiYXNlT3B0aW9uID0gcmF3T3B0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRpbWVsaW5lT3B0IHRvIGJhc2VPcHRpb24gaW4gZWMzLFxuICAgICAgICAvLyB3aGljaCBpcyBjb252ZW5pZW50IGZvciBtZXJnZSBvcHRpb24uXG4gICAgICAgIGlmICghYmFzZU9wdGlvbi50aW1lbGluZSkge1xuICAgICAgICAgICAgYmFzZU9wdGlvbi50aW1lbGluZSA9IHRpbWVsaW5lT3B0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJlcHJvY2Vzcy5cbiAgICAgICAgZWFjaChbYmFzZU9wdGlvbl0uY29uY2F0KHRpbWVsaW5lT3B0aW9ucylcbiAgICAgICAgICAgIC5jb25jYXQoenJVdGlsLm1hcChtZWRpYUxpc3QsIGZ1bmN0aW9uIChtZWRpYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYS5vcHRpb247XG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgZWFjaChvcHRpb25QcmVwcm9jZXNzb3JGdW5jcywgZnVuY3Rpb24gKHByZVByb2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlUHJvY2VzcyhvcHRpb24sIGlzTmV3KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFzZU9wdGlvbjogYmFzZU9wdGlvbixcbiAgICAgICAgICAgIHRpbWVsaW5lT3B0aW9uczogdGltZWxpbmVPcHRpb25zLFxuICAgICAgICAgICAgbWVkaWFEZWZhdWx0OiBtZWRpYURlZmF1bHQsXG4gICAgICAgICAgICBtZWRpYUxpc3Q6IG1lZGlhTGlzdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtbWVkaWFxdWVyaWVzLyNtZWRpYTE+XG4gICAgICogU3VwcG9ydDogd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW9cbiAgICAgKiBDYW4gdXNlIG1heCBvciBtaW4gYXMgcHJlZml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFwcGx5TWVkaWFRdWVyeShxdWVyeSwgZWNXaWR0aCwgZWNIZWlnaHQpIHtcbiAgICAgICAgdmFyIHJlYWxNYXAgPSB7XG4gICAgICAgICAgICB3aWR0aDogZWNXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZWNIZWlnaHQsXG4gICAgICAgICAgICBhc3BlY3RyYXRpbzogZWNXaWR0aCAvIGVjSGVpZ2h0IC8vIGxvd3NlciBjYXNlIGZvciBjb252ZW5pZW50Y2UuXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFwcGxpY2F0YWJsZSA9IHRydWU7XG5cbiAgICAgICAgenJVdGlsLmVhY2gocXVlcnksIGZ1bmN0aW9uICh2YWx1ZSwgYXR0cikge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBhdHRyLm1hdGNoKFFVRVJZX1JFRyk7XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2hlZCB8fCAhbWF0Y2hlZFsxXSB8fCAhbWF0Y2hlZFsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gbWF0Y2hlZFsxXTtcbiAgICAgICAgICAgIHZhciByZWFsQXR0ciA9IG1hdGNoZWRbMl0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKCFjb21wYXJlKHJlYWxNYXBbcmVhbEF0dHJdLCB2YWx1ZSwgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgYXBwbGljYXRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcHBsaWNhdGFibGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGFyZShyZWFsLCBleHBlY3QsIG9wZXJhdG9yKSB7XG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ21pbicpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFsID49IGV4cGVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ21heCcpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFsIDw9IGV4cGVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gRXF1YWxzXG4gICAgICAgICAgICByZXR1cm4gcmVhbCA9PT0gZXhwZWN0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kaWNlc0VxdWFscyhpbmRpY2VzMSwgaW5kaWNlczIpIHtcbiAgICAgICAgLy8gaW5kaWNlcyBpcyBhbHdheXMgb3JkZXIgYnkgYXNjIGFuZCBoYXMgb25seSBmaW5pdGUgbnVtYmVyLlxuICAgICAgICByZXR1cm4gaW5kaWNlczEuam9pbignLCcpID09PSBpbmRpY2VzMi5qb2luKCcsJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc2lkZXIgY2FzZTpcbiAgICAgKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDEpO2BcbiAgICAgKiBUaGVuIHVzZXIgZG8gc29tZSBpbnRlcmFjdGlvbiBsaWtlIGRhdGFab29tLCBkYXRhVmlldyBjaGFuZ2luZy5cbiAgICAgKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDIpO2BcbiAgICAgKiBUaGVuIHVzZXIgcHJlc3MgJ3Jlc2V0IGJ1dHRvbicgaW4gdG9vbGJveC5cbiAgICAgKlxuICAgICAqIEFmdGVyIGRvaW5nIHRoYXQgYWxsIG9mIHRoZSBpbnRlcmFjdGlvbiBlZmZlY3RzIHNob3VsZCBiZSByZXNldCwgdGhlXG4gICAgICogY2hhcnQgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSByZXN1bHQgb2YgaW52b2tlXG4gICAgICogYGNoYXJ0LnNldE9wdGlvbihvcHQxKTsgY2hhcnQuc2V0T3B0aW9uKG9wdDIpO2AuXG4gICAgICpcbiAgICAgKiBBbHRob3VnaCBpdCBpcyBub3QgYWJsZSBlbnN1cmUgdGhhdFxuICAgICAqIGBjaGFydC5zZXRPcHRpb24ob3B0MSk7IGNoYXJ0LnNldE9wdGlvbihvcHQyKTtgIGlzIGVxdWl2YWxlbnRzIHRvXG4gICAgICogYGNoYXJ0LnNldE9wdGlvbihtZXJnZShvcHQxLCBvcHQyKSk7YCBleGFjdGx5LFxuICAgICAqIHRoaXMgbWlnaHQgYmUgdGhlIG9ubHkgc2ltcGxlIHdheSB0byBpbXBsZW1lbnQgdGhhdCBmZWF0dXJlLlxuICAgICAqXG4gICAgICogTUVNTzogV2UndmUgY29uc2lkZXJlZCBzb21lIG90aGVyIGFwcHJvYWNoZXM6XG4gICAgICogMS4gRWFjaCBtb2RlbCBoYW5kbGUgaXRzIHNlbGYgcmVzdG9yYXRpb24gYnV0IG5vdCB1bmlmb3JtIHRyZWF0bWVudC5cbiAgICAgKiAgICAgKFRvbyBjb21wbGV4IGluIGxvZ2ljIGFuZCBlcnJvci1wcm9uZSlcbiAgICAgKiAyLiBVc2UgYSBzaGFkb3cgZWNNb2RlbC4gKFBlcmZvcm1hY2UgZXhwZW5zaXZlKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlT3B0aW9uKG9sZE9wdGlvbiwgbmV3T3B0aW9uKSB7XG4gICAgICAgIG5ld09wdGlvbiA9IG5ld09wdGlvbiB8fCB7fTtcblxuICAgICAgICBlYWNoKG5ld09wdGlvbiwgZnVuY3Rpb24gKG5ld0NwdE9wdCwgbWFpblR5cGUpIHtcbiAgICAgICAgICAgIGlmIChuZXdDcHRPcHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9sZENwdE9wdCA9IG9sZE9wdGlvblttYWluVHlwZV07XG5cbiAgICAgICAgICAgIGlmICghQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3MobWFpblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgb2xkT3B0aW9uW21haW5UeXBlXSA9IG1lcmdlKG9sZENwdE9wdCwgbmV3Q3B0T3B0LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0NwdE9wdCA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG5ld0NwdE9wdCk7XG4gICAgICAgICAgICAgICAgb2xkQ3B0T3B0ID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkob2xkQ3B0T3B0KTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXBSZXN1bHQgPSBtb2RlbFV0aWwubWFwcGluZ1RvRXhpc3RzKG9sZENwdE9wdCwgbmV3Q3B0T3B0KTtcblxuICAgICAgICAgICAgICAgIG9sZE9wdGlvblttYWluVHlwZV0gPSBtYXAobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGl0ZW0ub3B0aW9uICYmIGl0ZW0uZXhpc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1lcmdlKGl0ZW0uZXhpc3QsIGl0ZW0ub3B0aW9uLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoaXRlbS5leGlzdCB8fCBpdGVtLm9wdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gT3B0aW9uTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9mb3JtYXQnKTtcbiAgICB2YXIgY2xhc3NVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9jbGF6eicpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcbiAgICB2YXIgY29sb3JQYWxldHRlTWl4aW4gPSByZXF1aXJlKCcuL21peGluL2NvbG9yUGFsZXR0ZScpO1xuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xuICAgIHZhciBsYXlvdXQgPSByZXF1aXJlKCcuLi91dGlsL2xheW91dCcpO1xuXG4gICAgdmFyIHNldCA9IGNsYXNzVXRpbC5zZXQ7XG4gICAgdmFyIGdldCA9IGNsYXNzVXRpbC5nZXQ7XG4gICAgdmFyIGVuY29kZUhUTUwgPSBmb3JtYXRVdGlsLmVuY29kZUhUTUw7XG4gICAgdmFyIGFkZENvbW1hcyA9IGZvcm1hdFV0aWwuYWRkQ29tbWFzO1xuXG4gICAgdmFyIFNlcmllc01vZGVsID0gQ29tcG9uZW50TW9kZWwuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnc2VyaWVzLl9fYmFzZV9fJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBzZXJpZXNJbmRleDogMCxcblxuICAgICAgICAvLyBjb29kaW5hdGVTeXN0ZW0gd2lsbCBiZSBpbmplY3RlZCBpbiB0aGUgZWNoYXJ0cy9Db29yZGluYXRlU3lzdGVtXG4gICAgICAgIGNvb3JkaW5hdGVTeXN0ZW06IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRPcHRpb246IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGEgcHJvdmlkZWQgZm9yIGxlZ2VuZFxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgIGxlZ2VuZERhdGFQcm92aWRlcjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWNjZXNzIHBhdGggb2YgY29sb3IgZm9yIHZpc3VhbFxuICAgICAgICAgKi9cbiAgICAgICAgdmlzdWFsQ29sb3JBY2Nlc3NQYXRoOiAnaXRlbVN0eWxlLm5vcm1hbC5jb2xvcicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1cHBvcnQgbWVyZ2UgbGF5b3V0IHBhcmFtcy5cbiAgICAgICAgICogT25seSBzdXBwb3J0ICdib3gnIG5vdyAobGVmdC9yaWdodC90b3AvYm90dG9tL3dpZHRoL2hlaWdodCkuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8T2JqZWN0fSBPYmplY3QgY2FuIGJlIHtpZ25vcmVTaXplOiB0cnVlfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dE1vZGU6IG51bGwsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnNlcmllc0luZGV4ID0gdGhpcy5jb21wb25lbnRJbmRleDtcblxuICAgICAgICAgICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R8bW9kdWxlOmVjaGFydHMvZGF0YS9UcmVlfG1vZHVsZTplY2hhcnRzL2RhdGEvR3JhcGh9XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXQodGhpcywgJ2RhdGFCZWZvcmVQcm9jZXNzZWQnLCB0aGlzLmdldEluaXRpYWxEYXRhKG9wdGlvbiwgZWNNb2RlbCkpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSByZXZlcnNlIHRoZSBvcmRlciAobWFrZSBkYXRhIGZpcnN0bHksIGFuZCB0aGVuIG1ha2VcbiAgICAgICAgICAgIC8vIGRhdGFCZWZvcmVQcm9jZXNzZWQgYnkgY2xvbmVTaGFsbG93KSwgY2xvbmVTaGFsbG93IHdpbGxcbiAgICAgICAgICAgIC8vIGNhdXNlIGRhdGEuZ3JhcGguZGF0YSAhPT0gZGF0YSB3aGVuIHVzaW5nXG4gICAgICAgICAgICAvLyBtb2R1bGU6ZWNoYXJ0cy9kYXRhL0dyYXBoIG9yIG1vZHVsZTplY2hhcnRzL2RhdGEvVHJlZS5cbiAgICAgICAgICAgIC8vIFNlZSBtb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9saW5rTGlzdFxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlRGF0YSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVdGlsIGZvciBtZXJnZSBkZWZhdWx0IGFuZCB0aGVtZSB0byBvcHRpb25cbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25cbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqL1xuICAgICAgICBtZXJnZURlZmF1bHRBbmRUaGVtZTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGxheW91dE1vZGUgPSB0aGlzLmxheW91dE1vZGU7XG4gICAgICAgICAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGxheW91dE1vZGVcbiAgICAgICAgICAgICAgICA/IGxheW91dC5nZXRMYXlvdXRQYXJhbXMob3B0aW9uKSA6IHt9O1xuXG4gICAgICAgICAgICB6clV0aWwubWVyZ2UoXG4gICAgICAgICAgICAgICAgb3B0aW9uLFxuICAgICAgICAgICAgICAgIGVjTW9kZWwuZ2V0VGhlbWUoKS5nZXQodGhpcy5zdWJUeXBlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCBsYWJlbCBlbXBoYXNpcyBgcG9zaXRpb25gIGFuZCBgc2hvd2BcbiAgICAgICAgICAgIC8vIEZJWE1FIFNldCBsYWJlbCBpbiBtZXJnZU9wdGlvblxuICAgICAgICAgICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyhvcHRpb24ubGFiZWwsIG1vZGVsVXRpbC5MQUJFTF9PUFRJT05TKTtcblxuICAgICAgICAgICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShvcHRpb24uZGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW0ob3B0aW9uLCBpbnB1dFBvc2l0aW9uUGFyYW1zLCBsYXlvdXRNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld1Nlcmllc09wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICAgICAgbmV3U2VyaWVzT3B0aW9uID0genJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBuZXdTZXJpZXNPcHRpb24sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShuZXdTZXJpZXNPcHRpb24uZGF0YSk7XG5cbiAgICAgICAgICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgICAgICAgICAgaWYgKGxheW91dE1vZGUpIHtcbiAgICAgICAgICAgICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbSh0aGlzLm9wdGlvbiwgbmV3U2VyaWVzT3B0aW9uLCBsYXlvdXRNb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldEluaXRpYWxEYXRhKG5ld1Nlcmllc09wdGlvbiwgZWNNb2RlbCk7XG4gICAgICAgICAgICAvLyBUT0RPIE1lcmdlIGRhdGE/XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHNldCh0aGlzLCAnZGF0YScsIGRhdGEpO1xuICAgICAgICAgICAgICAgIHNldCh0aGlzLCAnZGF0YUJlZm9yZVByb2Nlc3NlZCcsIGRhdGEuY2xvbmVTaGFsbG93KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZpbGxEYXRhVGV4dFN0eWxlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBkYXRhIGxhYmVsIGVtcGhhc2lzIGBwb3NpdGlvbmAgYW5kIGBzaG93YFxuICAgICAgICAgICAgLy8gRklYTUUgVHJlZSBzdHJ1Y3R1cmUgZGF0YSA/XG4gICAgICAgICAgICAvLyBGSVhNRSBQZXJmb3JtYW5jZSA/XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSAmJiBkYXRhW2ldLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFV0aWwuZGVmYXVsdEVtcGhhc2lzKGRhdGFbaV0ubGFiZWwsIG1vZGVsVXRpbC5MQUJFTF9PUFRJT05TKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdCBhIGRhdGEgc3RydWN0dXJlIGZyb20gZGF0YSByZWxhdGVkIG9wdGlvbiBpbiBzZXJpZXNcbiAgICAgICAgICogTXVzdCBiZSBvdmVyd3JpdHRlblxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SW5pdGlhbERhdGE6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGFUeXBlXVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXREYXRhOiBmdW5jdGlvbiAoZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZ2V0KHRoaXMsICdkYXRhJyk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVR5cGUgPT0gbnVsbCA/IGRhdGEgOiBkYXRhLmdldExpbmtlZERhdGEoZGF0YVR5cGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHNldCh0aGlzLCAnZGF0YScsIGRhdGEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZGF0YSBiZWZvcmUgcHJvY2Vzc2VkXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFJhd0RhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgJ2RhdGFCZWZvcmVQcm9jZXNzZWQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29vcmQgZGltZW5zaW9uIHRvIGRhdGEgZGltZW5zaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0IHRoZSByZXN1bHQgaXMgdGhlIHNhbWUgYXMgZGltZW5zaW9ucyBvZiBzZXJpZXMgZGF0YS5cbiAgICAgICAgICogQnV0IGluIHNvbWUgc2VyaWVzIGRhdGEgZGltZW5zaW9ucyBhcmUgZGlmZmVyZW50IGZyb20gY29vcmQgZGltZW5zaW9ucyAoaS5lLlxuICAgICAgICAgKiBjYW5kbGVzdGljayBhbmQgYm94cGxvdCkuIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGhhbmRsZSB0aG9zZSBjYXNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29vcmQgZGltZW5zaW9uIHRvIGRhdGEgZGltZW5zaW9uIGNhbiBiZSBvbmUtdG8tbWFueVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29vcmREaW1cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IGRpbWVuc2lvbnMgb24gdGhlIGF4aXMuXG4gICAgICAgICAqL1xuICAgICAgICBjb29yZERpbVRvRGF0YURpbTogZnVuY3Rpb24gKGNvb3JkRGltKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Nvb3JkRGltXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCBkYXRhIGRpbWVuc2lvbiB0byBjb29yZCBkaW1lbnNpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZGF0YURpbVxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBkYXRhRGltVG9Db29yZERpbTogZnVuY3Rpb24gKGRhdGFEaW0pIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhRGltO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYmFzZSBheGlzIGlmIGhhcyBjb29yZGluYXRlIHN5c3RlbSBhbmQgaGFzIGF4aXMuXG4gICAgICAgICAqIEJ5IGRlZmF1bHQgdXNlIGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAqIENhbiBiZSBvdmVycmlkZWQgZm9yIHNvbWUgY2hhcnQuXG4gICAgICAgICAqIEByZXR1cm4ge3R5cGV9IGRlc2NyaXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRCYXNlQXhpczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gdGhpcy5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkU3lzICYmIGNvb3JkU3lzLmdldEJhc2VBeGlzICYmIGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgdG9vbHRpcCBmb3JtYXR0ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttdWx0aXBsZVNlcmllcz1mYWxzZV1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhVHlwZV1cbiAgICAgICAgICovXG4gICAgICAgIGZvcm1hdFRvb2x0aXA6IGZ1bmN0aW9uIChkYXRhSW5kZXgsIG11bHRpcGxlU2VyaWVzLCBkYXRhVHlwZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZm9ybWF0QXJyYXlWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKHZhbHVlLCBmdW5jdGlvbiAodmFsLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpbUluZm8gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpbVR5cGUgPSBkaW1JbmZvICYmIGRpbUluZm8udHlwZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbFN0cjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGltVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxTdHIgPSB2YWwgKyAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkaW1UeXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbFN0ciA9IG11bHRpcGxlU2VyaWVzID8gJycgOiBmb3JtYXRVdGlsLmZvcm1hdFRpbWUoJ3l5eXkvTU0vZGQgaGg6bW06c3MnLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsU3RyID0gYWRkQ29tbWFzKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWxTdHIgJiYgcmVzdWx0LnB1c2godmFsU3RyKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignLCAnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBnZXQodGhpcywgJ2RhdGEnKTtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRSYXdWYWx1ZShkYXRhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gZW5jb2RlSFRNTChcbiAgICAgICAgICAgICAgICB6clV0aWwuaXNBcnJheSh2YWx1ZSkgPyBmb3JtYXRBcnJheVZhbHVlKHZhbHVlKSA6IGFkZENvbW1hcyh2YWx1ZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGRhdGEuZ2V0TmFtZShkYXRhSW5kZXgpO1xuXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnY29sb3InKTtcbiAgICAgICAgICAgIGlmICh6clV0aWwuaXNPYmplY3QoY29sb3IpICYmIGNvbG9yLmNvbG9yU3RvcHMpIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IChjb2xvci5jb2xvclN0b3BzWzBdIHx8IHt9KS5jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbG9yID0gY29sb3IgfHwgJ3RyYW5zcGFyZW50JztcblxuICAgICAgICAgICAgdmFyIGNvbG9yRWwgPSAnPHNwYW4gc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tcmlnaHQ6NXB4OydcbiAgICAgICAgICAgICAgICArICdib3JkZXItcmFkaXVzOjEwcHg7d2lkdGg6OXB4O2hlaWdodDo5cHg7YmFja2dyb3VuZC1jb2xvcjonICsgZW5jb2RlSFRNTChjb2xvcikgKyAnXCI+PC9zcGFuPic7XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXNOYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGlmIChzZXJpZXNOYW1lID09PSAnXFwwLScpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3Qgc2hvdyAnLSdcbiAgICAgICAgICAgICAgICBzZXJpZXNOYW1lID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIW11bHRpcGxlU2VyaWVzXG4gICAgICAgICAgICAgICAgPyAoKHNlcmllc05hbWUgJiYgZW5jb2RlSFRNTChzZXJpZXNOYW1lKSArICc8YnIgLz4nKSArIGNvbG9yRWxcbiAgICAgICAgICAgICAgICAgICAgKyAobmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBlbmNvZGVIVE1MKG5hbWUpICsgJyA6ICcgKyBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiAoY29sb3JFbCArIGVuY29kZUhUTUwodGhpcy5uYW1lKSArICcgOiAnICsgZm9ybWF0dGVkVmFsdWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNBbmltYXRpb25FbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRpb25FbmFibGVkID0gdGhpcy5nZXRTaGFsbG93KCdhbmltYXRpb24nKTtcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25FbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0RGF0YSgpLmNvdW50KCkgPiB0aGlzLmdldFNoYWxsb3coJ2FuaW1hdGlvblRocmVzaG9sZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uRW5hYmxlZDtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0KHRoaXMsICdkYXRhJywgZ2V0KHRoaXMsICdkYXRhQmVmb3JlUHJvY2Vzc2VkJykuY2xvbmVTaGFsbG93KCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbG9yRnJvbVBhbGV0dGU6IGZ1bmN0aW9uIChuYW1lLCBzY29wZSkge1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjb2xvclBhbGV0dGVNaXhpbi5nZXRDb2xvckZyb21QYWxldHRlLmNhbGwodGhpcywgbmFtZSwgc2NvcGUpO1xuICAgICAgICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gZWNNb2RlbC5nZXRDb2xvckZyb21QYWxldHRlKG5hbWUsIHNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGRhdGEgaW5kaWNlcyBmb3Igc2hvdyB0b29sdGlwIGNvbnRlbnQuIFNlZSB0b29sdGlwLlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPnxzdHJpbmd9IGRpbVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL3NpbmdsZS9TaW5nbGVBeGlzfSBiYXNlQXhpc1xuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gZGF0YSBpbmRpY2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhpc1Rvb2x0aXBEYXRhSW5kZXg6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSB0b29sdGlwLlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gUG9pbnQgb2YgdG9vbHRpcC4gbnVsbC91bmRlZmluZWQgY2FuIGJlIHJldHVybmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VG9vbHRpcFBvc2l0aW9uOiBudWxsXG4gICAgfSk7XG5cbiAgICB6clV0aWwubWl4aW4oU2VyaWVzTW9kZWwsIG1vZGVsVXRpbC5kYXRhRm9ybWF0TWl4aW4pO1xuICAgIHpyVXRpbC5taXhpbihTZXJpZXNNb2RlbCwgY29sb3JQYWxldHRlTWl4aW4pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTZXJpZXNNb2RlbDtcbiIsIlxuICAgIHZhciBwbGF0Zm9ybSA9ICcnO1xuICAgIC8vIE5hdmlnYXRvciBub3QgZXhpc3RzIGluIG5vZGVcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm0gfHwgJyc7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvLyDlhajlm77pu5jorqTog4zmma9cbiAgICAgICAgLy8gYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG5cbiAgICAgICAgLy8gaHR0cHM6Ly9kcmliYmJsZS5jb20vc2hvdHMvMTA2NTk2MC1JbmZvZ3JhcGhpYy1QaWUtY2hhcnQtdmlzdWFsaXphdGlvblxuICAgICAgICAvLyBjb2xvcjogWycjNTc5M2YzJywgJyNkMTRhNjEnLCAnI2ZkOWMzNScsICcjNjc1YmJhJywgJyNmZWM0MmMnLCAnI2RkNDQ0NCcsICcjZDRkZjVhJywgJyNjZDQ4NzAnXSxcbiAgICAgICAgLy8g5rWF6ImyXG4gICAgICAgIC8vIGNvbG9yOiBbJyNiY2QzYmInLCAnI2U4OGY3MCcsICcjZWRjMWE1JywgJyM5ZGM1YzgnLCAnI2UxZThjOCcsICcjN2I3YzY4JywgJyNlNWI1YjUnLCAnI2YwYjQ4OScsICcjOTI4ZWE4JywgJyNiZGEyOWEnXSxcbiAgICAgICAgLy8gY29sb3I6IFsnI2NjNTY2NCcsICcjOWJkNmVjJywgJyNlYTk0NmUnLCAnIzhhY2FhYScsICcjZjFlYzY0JywgJyNlZTg2ODYnLCAnI2E0OGRjMScsICcjNWRhNmJjJywgJyNiOWRjYWUnXSxcbiAgICAgICAgLy8g5rex6ImyXG4gICAgICAgIGNvbG9yOiBbJyNjMjM1MzEnLCcjMmY0NTU0JywgJyM2MWEwYTgnLCAnI2Q0ODI2NScsICcjOTFjN2FlJywnIzc0OWY4MycsICAnI2NhODYyMicsICcjYmRhMjlhJywnIzZlNzA3NCcsICcjNTQ2NTcwJywgJyNjNGNjZDMnXSxcblxuICAgICAgICAvLyDpu5jorqTpnIDopoEgR3JpZCDphY3nva7poblcbiAgICAgICAgLy8gZ3JpZDoge30sXG4gICAgICAgIC8vIOS4u+mimO+8jOS4u+mimFxuICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICAgIC8vIGNvbG9yOiAnIzAwMCcsXG4gICAgICAgICAgICAvLyBkZWNvcmF0aW9uOiAnbm9uZScsXG4gICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICBmb250RmFtaWx5OiBwbGF0Zm9ybS5tYXRjaCgvXldpbi8pID8gJ01pY3Jvc29mdCBZYUhlaScgOiAnc2Fucy1zZXJpZicsXG4gICAgICAgICAgICAvLyBmb250RmFtaWx5OiAnQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWYnLFxuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgZm9udFN0eWxlOiAnbm9ybWFsJyxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaHR0cDovL2Jsb2dzLmFkb2JlLmNvbS93ZWJwbGF0Zm9ybS8yMDE0LzAyLzI0L3VzaW5nLWJsZW5kLW1vZGVzLWluLWh0bWwtY2FudmFzL1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgICAgICAvLyBEZWZhdWx0IGlzIHNvdXJjZS1vdmVyXG4gICAgICAgIGJsZW5kTW9kZTogbnVsbCxcblxuICAgICAgICBhbmltYXRpb246IHRydWUsXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAxMDAwLFxuICAgICAgICBhbmltYXRpb25EdXJhdGlvblVwZGF0ZTogMzAwLFxuICAgICAgICBhbmltYXRpb25FYXNpbmc6ICdleHBvbmVudGlhbE91dCcsXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZ1VwZGF0ZTogJ2N1YmljT3V0JyxcblxuICAgICAgICBhbmltYXRpb25UaHJlc2hvbGQ6IDIwMDAsXG4gICAgICAgIC8vIENvbmZpZ3VyYXRpb24gZm9yIHByb2dyZXNzaXZlL2luY3JlbWVudGFsIHJlbmRlcmluZ1xuICAgICAgICBwcm9ncmVzc2l2ZVRocmVzaG9sZDogMzAwMCxcbiAgICAgICAgcHJvZ3Jlc3NpdmU6IDQwMCxcblxuICAgICAgICAvLyBUaHJlc2hvbGQgb2YgaWYgdXNlIHNpbmdsZSBob3ZlciBsYXllciB0byBvcHRpbWl6ZS5cbiAgICAgICAgLy8gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCBgaG92ZXJMYXllclRocmVzaG9sZGAgaXMgZXF1aXZhbGVudCB0byBvciBsZXNzIHRoYW5cbiAgICAgICAgLy8gYHByb2dyZXNzaXZlVGhyZXNob2xkYCwgb3RoZXJ3aXNlIGhvdmVyIHdpbGwgY2F1c2UgcmVzdGFydCBvZiBwcm9ncmVzc2l2ZSxcbiAgICAgICAgLy8gd2hpY2ggaXMgdW5leHBlY3RlZC5cbiAgICAgICAgLy8gc2VlIGV4YW1wbGUgPGVjaGFydHMvdGVzdC9oZWF0bWFwLWxhcmdlLmh0bWw+LlxuICAgICAgICBob3ZlckxheWVyVGhyZXNob2xkOiAzMDAwXG4gICAgfTtcbiIsIlxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBnZXRBcmVhU3R5bGU6IHJlcXVpcmUoJy4vbWFrZVN0eWxlTWFwcGVyJykoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgWydmaWxsJywgJ2NvbG9yJ10sXG4gICAgICAgICAgICAgICAgWydzaGFkb3dCbHVyJ10sXG4gICAgICAgICAgICAgICAgWydzaGFkb3dPZmZzZXRYJ10sXG4gICAgICAgICAgICAgICAgWydzaGFkb3dPZmZzZXRZJ10sXG4gICAgICAgICAgICAgICAgWydvcGFjaXR5J10sXG4gICAgICAgICAgICAgICAgWydzaGFkb3dDb2xvciddXG4gICAgICAgICAgICBdXG4gICAgICAgIClcbiAgICB9O1xuIiwiXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZ2V0Qm94TGF5b3V0UGFyYW1zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuZ2V0KCdsZWZ0JyksXG4gICAgICAgICAgICAgICAgdG9wOiB0aGlzLmdldCgndG9wJyksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRoaXMuZ2V0KCdyaWdodCcpLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogdGhpcy5nZXQoJ2JvdHRvbScpLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmdldCgnd2lkdGgnKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuZ2V0KCdoZWlnaHQnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4iLCJcblxuICAgIHZhciBjbGFzc1V0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NsYXp6Jyk7XG4gICAgdmFyIHNldCA9IGNsYXNzVXRpbC5zZXQ7XG4gICAgdmFyIGdldCA9IGNsYXNzVXRpbC5nZXQ7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgY2xlYXJDb2xvclBhbGV0dGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldCh0aGlzLCAnY29sb3JJZHgnLCAwKTtcbiAgICAgICAgICAgIHNldCh0aGlzLCAnY29sb3JOYW1lTWFwJywge30pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbG9yRnJvbVBhbGV0dGU6IGZ1bmN0aW9uIChuYW1lLCBzY29wZSkge1xuICAgICAgICAgICAgc2NvcGUgPSBzY29wZSB8fCB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbG9ySWR4ID0gZ2V0KHNjb3BlLCAnY29sb3JJZHgnKSB8fCAwO1xuICAgICAgICAgICAgdmFyIGNvbG9yTmFtZU1hcCA9IGdldChzY29wZSwgJ2NvbG9yTmFtZU1hcCcpIHx8IHNldChzY29wZSwgJ2NvbG9yTmFtZU1hcCcsIHt9KTtcbiAgICAgICAgICAgIGlmIChjb2xvck5hbWVNYXBbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JOYW1lTWFwW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbG9yUGFsZXR0ZSA9IHRoaXMuZ2V0KCdjb2xvcicsIHRydWUpIHx8IFtdO1xuICAgICAgICAgICAgaWYgKCFjb2xvclBhbGV0dGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjb2xvclBhbGV0dGVbY29sb3JJZHhdO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb2xvck5hbWVNYXBbbmFtZV0gPSBjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldChzY29wZSwgJ2NvbG9ySWR4JywgKGNvbG9ySWR4ICsgMSkgJSBjb2xvclBhbGV0dGUubGVuZ3RoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICB9XG4gICAgfTtcbiIsIlxuICAgIHZhciBnZXRJdGVtU3R5bGUgPSByZXF1aXJlKCcuL21ha2VTdHlsZU1hcHBlcicpKFxuICAgICAgICBbXG4gICAgICAgICAgICBbJ2ZpbGwnLCAnY29sb3InXSxcbiAgICAgICAgICAgIFsnc3Ryb2tlJywgJ2JvcmRlckNvbG9yJ10sXG4gICAgICAgICAgICBbJ2xpbmVXaWR0aCcsICdib3JkZXJXaWR0aCddLFxuICAgICAgICAgICAgWydvcGFjaXR5J10sXG4gICAgICAgICAgICBbJ3NoYWRvd0JsdXInXSxcbiAgICAgICAgICAgIFsnc2hhZG93T2Zmc2V0WCddLFxuICAgICAgICAgICAgWydzaGFkb3dPZmZzZXRZJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd0NvbG9yJ10sXG4gICAgICAgICAgICBbJ3RleHRQb3NpdGlvbiddLFxuICAgICAgICAgICAgWyd0ZXh0QWxpZ24nXVxuICAgICAgICBdXG4gICAgKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZ2V0SXRlbVN0eWxlOiBmdW5jdGlvbiAoZXhjbHVkZXMpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldEl0ZW1TdHlsZS5jYWxsKHRoaXMsIGV4Y2x1ZGVzKTtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuZ2V0Qm9yZGVyTGluZURhc2goKTtcbiAgICAgICAgICAgIGxpbmVEYXNoICYmIChzdHlsZS5saW5lRGFzaCA9IGxpbmVEYXNoKTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3JkZXJMaW5lRGFzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxpbmVUeXBlID0gdGhpcy5nZXQoJ2JvcmRlclR5cGUnKTtcbiAgICAgICAgICAgIHJldHVybiAobGluZVR5cGUgPT09ICdzb2xpZCcgfHwgbGluZVR5cGUgPT0gbnVsbCkgPyBudWxsXG4gICAgICAgICAgICAgICAgOiAobGluZVR5cGUgPT09ICdkYXNoZWQnID8gWzUsIDVdIDogWzEsIDFdKTtcbiAgICAgICAgfVxuICAgIH07XG4iLCJcbiAgICB2YXIgZ2V0TGluZVN0eWxlID0gcmVxdWlyZSgnLi9tYWtlU3R5bGVNYXBwZXInKShcbiAgICAgICAgW1xuICAgICAgICAgICAgWydsaW5lV2lkdGgnLCAnd2lkdGgnXSxcbiAgICAgICAgICAgIFsnc3Ryb2tlJywgJ2NvbG9yJ10sXG4gICAgICAgICAgICBbJ29wYWNpdHknXSxcbiAgICAgICAgICAgIFsnc2hhZG93Qmx1ciddLFxuICAgICAgICAgICAgWydzaGFkb3dPZmZzZXRYJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd09mZnNldFknXSxcbiAgICAgICAgICAgIFsnc2hhZG93Q29sb3InXVxuICAgICAgICBdXG4gICAgKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZ2V0TGluZVN0eWxlOiBmdW5jdGlvbiAoZXhjbHVkZXMpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldExpbmVTdHlsZS5jYWxsKHRoaXMsIGV4Y2x1ZGVzKTtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuZ2V0TGluZURhc2goc3R5bGUubGluZVdpZHRoKTtcbiAgICAgICAgICAgIGxpbmVEYXNoICYmIChzdHlsZS5saW5lRGFzaCA9IGxpbmVEYXNoKTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRMaW5lRGFzaDogZnVuY3Rpb24gKGxpbmVXaWR0aCkge1xuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaW5lVHlwZSA9IHRoaXMuZ2V0KCd0eXBlJyk7XG4gICAgICAgICAgICB2YXIgZG90U2l6ZSA9IE1hdGgubWF4KGxpbmVXaWR0aCwgMik7XG4gICAgICAgICAgICB2YXIgZGFzaFNpemUgPSBsaW5lV2lkdGggKiA0O1xuICAgICAgICAgICAgcmV0dXJuIChsaW5lVHlwZSA9PT0gJ3NvbGlkJyB8fCBsaW5lVHlwZSA9PSBudWxsKSA/IG51bGxcbiAgICAgICAgICAgICAgICA6IChsaW5lVHlwZSA9PT0gJ2Rhc2hlZCcgPyBbZGFzaFNpemUsIGRhc2hTaXplXSA6IFtkb3RTaXplLCBkb3RTaXplXSk7XG4gICAgICAgIH1cbiAgICB9O1xuIiwiLy8gVE9ETyBQYXJzZSBzaGFkb3cgc3R5bGVcbi8vIFRPRE8gT25seSBzaGFsbG93IHBhdGggc3VwcG9ydFxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAvLyBOb3JtYWxpemVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BlcnRpZXNbaV1bMV0pIHtcbiAgICAgICAgICAgICAgIHByb3BlcnRpZXNbaV1bMV0gPSBwcm9wZXJ0aWVzW2ldWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXhjbHVkZXMpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydGllc1tpXVsxXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZXMgJiYgenJVdGlsLmluZGV4T2YoZXhjbHVkZXMsIHByb3BOYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5nZXRTaGFsbG93KHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVbcHJvcGVydGllc1tpXVswXV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9O1xuICAgIH07XG4iLCJcblxuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xuXG4gICAgZnVuY3Rpb24gZ2V0U2hhbGxvdyhtb2RlbCwgcGF0aCkge1xuICAgICAgICByZXR1cm4gbW9kZWwgJiYgbW9kZWwuZ2V0U2hhbGxvdyhwYXRoKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjb2xvciBwcm9wZXJ0eSBvciBnZXQgY29sb3IgZnJvbSBvcHRpb24udGV4dFN0eWxlLmNvbG9yXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldFRleHRDb2xvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTaGFsbG93KCdjb2xvcicpXG4gICAgICAgICAgICAgICAgfHwgKGVjTW9kZWwgJiYgZWNNb2RlbC5nZXQoJ3RleHRTdHlsZS5jb2xvcicpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGZvbnQgc3RyaW5nIGZyb20gZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseVxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGb250OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICAgICAgICAgIHZhciBnVGV4dFN0eWxlTW9kZWwgPSBlY01vZGVsICYmIGVjTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBpbiBub2RlLWNhbnZhcyBmb250V2VpZ2h0IGlzIGJlZm9yZSBmb250U3R5bGVcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNoYWxsb3coJ2ZvbnRTdHlsZScpIHx8IGdldFNoYWxsb3coZ1RleHRTdHlsZU1vZGVsLCAnZm9udFN0eWxlJyksXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRTaGFsbG93KCdmb250V2VpZ2h0JykgfHwgZ2V0U2hhbGxvdyhnVGV4dFN0eWxlTW9kZWwsICdmb250V2VpZ2h0JyksXG4gICAgICAgICAgICAgICAgKHRoaXMuZ2V0U2hhbGxvdygnZm9udFNpemUnKSB8fCBnZXRTaGFsbG93KGdUZXh0U3R5bGVNb2RlbCwgJ2ZvbnRTaXplJykgfHwgMTIpICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNoYWxsb3coJ2ZvbnRGYW1pbHknKSB8fCBnZXRTaGFsbG93KGdUZXh0U3R5bGVNb2RlbCwgJ2ZvbnRGYW1pbHknKSB8fCAnc2Fucy1zZXJpZidcbiAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFRleHRSZWN0OiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2hhbGxvdygnYWxpZ24nKSxcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNoYWxsb3coJ2Jhc2VsaW5lJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJ1bmNhdGVUZXh0OiBmdW5jdGlvbiAodGV4dCwgY29udGFpbmVyV2lkdGgsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dENvbnRhaW4udHJ1bmNhdGVUZXh0KFxuICAgICAgICAgICAgICAgIHRleHQsIGNvbnRhaW5lcldpZHRoLCB0aGlzLmdldEZvbnQoKSwgZWxsaXBzaXMsIG9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuIiwiLy8gQ29tcGF0aXRhYmxlIHdpdGggMi4wXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgY29tcGF0U3R5bGUgPSByZXF1aXJlKCcuL2hlbHBlci9jb21wYXRTdHlsZScpO1xuXG4gICAgZnVuY3Rpb24gZ2V0KG9wdCwgcGF0aCkge1xuICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLCcpO1xuICAgICAgICB2YXIgb2JqID0gb3B0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9iaiA9IG9iaiAmJiBvYmpbcGF0aFtpXV07XG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldChvcHQsIHBhdGgsIHZhbCwgb3ZlcndyaXRlKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcsJyk7XG4gICAgICAgIHZhciBvYmogPSBvcHQ7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGtleSA9IHBhdGhbaV07XG4gICAgICAgICAgICBpZiAob2JqW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcndyaXRlIHx8IG9ialtwYXRoW2ldXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBvYmpbcGF0aFtpXV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wYXRMYXlvdXRQcm9wZXJ0aWVzKG9wdGlvbikge1xuICAgICAgICBlYWNoKExBWU9VVF9QUk9QRVJUSUVTLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKHByb3BbMF0gaW4gb3B0aW9uICYmICEocHJvcFsxXSBpbiBvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uW3Byb3BbMV1dID0gb3B0aW9uW3Byb3BbMF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgTEFZT1VUX1BST1BFUlRJRVMgPSBbXG4gICAgICAgIFsneCcsICdsZWZ0J10sIFsneScsICd0b3AnXSwgWyd4MicsICdyaWdodCddLCBbJ3kyJywgJ2JvdHRvbSddXG4gICAgXTtcblxuICAgIHZhciBDT01QQVRJVEFCTEVfQ09NUE9ORU5UUyA9IFtcbiAgICAgICAgJ2dyaWQnLCAnZ2VvJywgJ3BhcmFsbGVsJywgJ2xlZ2VuZCcsICd0b29sYm94JywgJ3RpdGxlJywgJ3Zpc3VhbE1hcCcsICdkYXRhWm9vbScsICd0aW1lbGluZSdcbiAgICBdO1xuXG4gICAgdmFyIENPTVBBVElUQUJMRV9TRVJJRVMgPSBbXG4gICAgICAgICdiYXInLCAnYm94cGxvdCcsICdjYW5kbGVzdGljaycsICdjaG9yZCcsICdlZmZlY3RTY2F0dGVyJyxcbiAgICAgICAgJ2Z1bm5lbCcsICdnYXVnZScsICdsaW5lcycsICdncmFwaCcsICdoZWF0bWFwJywgJ2xpbmUnLCAnbWFwJywgJ3BhcmFsbGVsJyxcbiAgICAgICAgJ3BpZScsICdyYWRhcicsICdzYW5rZXknLCAnc2NhdHRlcicsICd0cmVlbWFwJ1xuICAgIF07XG5cbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIGVhY2gob3B0aW9uLnNlcmllcywgZnVuY3Rpb24gKHNlcmllc09wdCkge1xuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNPYmplY3Qoc2VyaWVzT3B0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlcmllc1R5cGUgPSBzZXJpZXNPcHQudHlwZTtcblxuICAgICAgICAgICAgY29tcGF0U3R5bGUoc2VyaWVzT3B0KTtcblxuICAgICAgICAgICAgaWYgKHNlcmllc1R5cGUgPT09ICdwaWUnIHx8IHNlcmllc1R5cGUgPT09ICdnYXVnZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWVzT3B0LmNsb2NrV2lzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllc09wdC5jbG9ja3dpc2UgPSBzZXJpZXNPcHQuY2xvY2tXaXNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXJpZXNUeXBlID09PSAnZ2F1Z2UnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ZXJDb2xvciA9IGdldChzZXJpZXNPcHQsICdwb2ludGVyLmNvbG9yJyk7XG4gICAgICAgICAgICAgICAgcG9pbnRlckNvbG9yICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgJiYgc2V0KHNlcmllc09wdCwgJ2l0ZW1TdHlsZS5ub3JtYWwuY29sb3InLCBwb2ludGVyQ29sb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IENPTVBBVElUQUJMRV9TRVJJRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoQ09NUEFUSVRBQkxFX1NFUklFU1tpXSA9PT0gc2VyaWVzT3B0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGF0TGF5b3V0UHJvcGVydGllcyhzZXJpZXNPcHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGRhdGFSYW5nZSBoYXMgY2hhbmdlZCB0byB2aXN1YWxNYXBcbiAgICAgICAgaWYgKG9wdGlvbi5kYXRhUmFuZ2UpIHtcbiAgICAgICAgICAgIG9wdGlvbi52aXN1YWxNYXAgPSBvcHRpb24uZGF0YVJhbmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFjaChDT01QQVRJVEFCTEVfQ09NUE9ORU5UUywgZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gb3B0aW9uW2NvbXBvbmVudE5hbWVdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBbb3B0aW9uc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVhY2gob3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb21wYXRMYXlvdXRQcm9wZXJ0aWVzKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4iLCJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBQT1NTSUJMRV9TVFlMRVMgPSBbXG4gICAgICAgICdhcmVhU3R5bGUnLCAnbGluZVN0eWxlJywgJ25vZGVTdHlsZScsICdsaW5rU3R5bGUnLFxuICAgICAgICAnY2hvcmRTdHlsZScsICdsYWJlbCcsICdsYWJlbExpbmUnXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGNvbXBhdEl0ZW1TdHlsZShvcHQpIHtcbiAgICAgICAgdmFyIGl0ZW1TdHlsZU9wdCA9IG9wdCAmJiBvcHQuaXRlbVN0eWxlO1xuICAgICAgICBpZiAoaXRlbVN0eWxlT3B0KSB7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChQT1NTSUJMRV9TVFlMRVMsIGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsSXRlbVN0eWxlT3B0ID0gaXRlbVN0eWxlT3B0Lm5vcm1hbDtcbiAgICAgICAgICAgICAgICB2YXIgZW1waGFzaXNJdGVtU3R5bGVPcHQgPSBpdGVtU3R5bGVPcHQuZW1waGFzaXM7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbEl0ZW1TdHlsZU9wdCAmJiBub3JtYWxJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRbc3R5bGVOYW1lXSA9IG9wdFtzdHlsZU5hbWVdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdFtzdHlsZU5hbWVdLm5vcm1hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0W3N0eWxlTmFtZV0ubm9ybWFsID0gbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0W3N0eWxlTmFtZV0ubm9ybWFsLCBub3JtYWxJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW1waGFzaXNJdGVtU3R5bGVPcHQgJiYgZW1waGFzaXNJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRbc3R5bGVOYW1lXSA9IG9wdFtzdHlsZU5hbWVdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdFtzdHlsZU5hbWVdLmVtcGhhc2lzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRbc3R5bGVOYW1lXS5lbXBoYXNpcyA9IGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0W3N0eWxlTmFtZV0uZW1waGFzaXMsIGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VyaWVzT3B0KSB7XG4gICAgICAgIGlmICghc2VyaWVzT3B0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29tcGF0SXRlbVN0eWxlKHNlcmllc09wdCk7XG4gICAgICAgIGNvbXBhdEl0ZW1TdHlsZShzZXJpZXNPcHQubWFya1BvaW50KTtcbiAgICAgICAgY29tcGF0SXRlbVN0eWxlKHNlcmllc09wdC5tYXJrTGluZSk7XG4gICAgICAgIHZhciBkYXRhID0gc2VyaWVzT3B0LmRhdGE7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb21wYXRJdGVtU3R5bGUoZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXJrIHBvaW50IGRhdGFcbiAgICAgICAgICAgIHZhciBtYXJrUG9pbnQgPSBzZXJpZXNPcHQubWFya1BvaW50O1xuICAgICAgICAgICAgaWYgKG1hcmtQb2ludCAmJiBtYXJrUG9pbnQuZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBtcERhdGEgPSBtYXJrUG9pbnQuZGF0YTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1wRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb21wYXRJdGVtU3R5bGUobXBEYXRhW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXJrIGxpbmUgZGF0YVxuICAgICAgICAgICAgdmFyIG1hcmtMaW5lID0gc2VyaWVzT3B0Lm1hcmtMaW5lO1xuICAgICAgICAgICAgaWYgKG1hcmtMaW5lICYmIG1hcmtMaW5lLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWxEYXRhID0gbWFya0xpbmUuZGF0YTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXkobWxEYXRhW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGF0SXRlbVN0eWxlKG1sRGF0YVtpXVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wYXRJdGVtU3R5bGUobWxEYXRhW2ldWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhdEl0ZW1TdHlsZShtbERhdGFbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiIsIlxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlcmllc1R5cGUsIGVjTW9kZWwpIHtcbiAgICAgICAgdmFyIGxlZ2VuZE1vZGVscyA9IGVjTW9kZWwuZmluZENvbXBvbmVudHMoe1xuICAgICAgICAgICAgbWFpblR5cGU6ICdsZWdlbmQnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWxlZ2VuZE1vZGVscyB8fCAhbGVnZW5kTW9kZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllcy5nZXREYXRhKCk7XG4gICAgICAgICAgICBkYXRhLmZpbHRlclNlbGYoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGlkeCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgaW4gYW55IGxlZ2VuZCBjb21wb25lbnQgdGhlIHN0YXR1cyBpcyBub3Qgc2VsZWN0ZWQuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWdlbmRNb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWdlbmRNb2RlbHNbaV0uaXNTZWxlY3RlZChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4iLCJcbiAgICB2YXIgc2FtcGxlcnMgPSB7XG4gICAgICAgIGF2ZXJhZ2U6IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oZnJhbWVbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBmcmFtZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGNvdW50IGlzIDBcbiAgICAgICAgICAgIHJldHVybiBjb3VudCA9PT0gMCA/IE5hTiA6IHN1bSAvIGNvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzdW06IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIE5hTlxuICAgICAgICAgICAgICAgIHN1bSArPSBmcmFtZVtpXSB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfSxcbiAgICAgICAgbWF4OiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVbaV0gPiBtYXggJiYgKG1heCA9IGZyYW1lW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXg7XG4gICAgICAgIH0sXG4gICAgICAgIG1pbjogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVbaV0gPCBtaW4gJiYgKG1pbiA9IGZyYW1lW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gTWVkaWFuXG4gICAgICAgIG5lYXJlc3Q6IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZyYW1lWzBdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBpbmRleFNhbXBsZXIgPSBmdW5jdGlvbiAoZnJhbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGZyYW1lLmxlbmd0aCAvIDIpO1xuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIHNhbXBsaW5nID0gc2VyaWVzTW9kZWwuZ2V0KCdzYW1wbGluZycpO1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIC8vIE9ubHkgY2FydGVzaWFuMmQgc3VwcG9ydCBkb3duIHNhbXBsaW5nXG4gICAgICAgICAgICBpZiAoY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJyAmJiBzYW1wbGluZykge1xuICAgICAgICAgICAgICAgIHZhciBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIGV4dGVudCA9IGJhc2VBeGlzLmdldEV4dGVudCgpO1xuICAgICAgICAgICAgICAgIC8vIENvb3JkaW5zdGUgc3lzdGVtIGhhcyBiZWVuIHJlc2l6ZWRcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICAgICAgICAgICAgICB2YXIgcmF0ZSA9IE1hdGgucm91bmQoZGF0YS5jb3VudCgpIC8gc2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJhdGUgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYW1wbGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNhbXBsaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlciA9IHNhbXBsZXJzW3NhbXBsaW5nXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2FtcGxpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZXIgPSBzYW1wbGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2FtcGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuZG93blNhbXBsZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUF4aXMuZGltLCAxIC8gcmF0ZSwgc2FtcGxlciwgaW5kZXhTYW1wbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuc2V0RGF0YShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiIsIi8qKlxuICogSW50ZXJ2YWwgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9zY2FsZS9JbnRlcnZhbFxuICovXG5cblxuXG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL251bWJlcicpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9mb3JtYXQnKTtcbiAgICB2YXIgU2NhbGUgPSByZXF1aXJlKCcuL1NjYWxlJyk7XG5cbiAgICB2YXIgbWF0aEZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgbWF0aENlaWwgPSBNYXRoLmNlaWw7XG5cbiAgICB2YXIgZ2V0UHJlY2lzaW9uU2FmZSA9IG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uU2FmZTtcbiAgICB2YXIgcm91bmRpbmdFcnJvckZpeCA9IG51bWJlclV0aWwucm91bmQ7XG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2Nvb3JkL3NjYWxlL0ludGVydmFsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEludGVydmFsU2NhbGUgPSBTY2FsZS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdpbnRlcnZhbCcsXG5cbiAgICAgICAgX2ludGVydmFsOiAwLFxuXG4gICAgICAgIHNldEV4dGVudDogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0aGlzRXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgLy9zdGFydCxlbmQgbWF5IGJlIGEgTnVtYmVyIGxpa2UgJzI1Jyxzby4uLlxuICAgICAgICAgICAgaWYgKCFpc05hTihzdGFydCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzRXh0ZW50WzBdID0gcGFyc2VGbG9hdChzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGVuZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzRXh0ZW50WzFdID0gcGFyc2VGbG9hdChlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuaW9uRXh0ZW50OiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICBvdGhlclswXSA8IGV4dGVudFswXSAmJiAoZXh0ZW50WzBdID0gb3RoZXJbMF0pO1xuICAgICAgICAgICAgb3RoZXJbMV0gPiBleHRlbnRbMV0gJiYgKGV4dGVudFsxXSA9IG90aGVyWzFdKTtcblxuICAgICAgICAgICAgLy8gdW5pb25FeHRlbnQgbWF5IGNhbGxlZCBieSBpdCdzIHN1YiBjbGFzc2VzXG4gICAgICAgICAgICBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZS5zZXRFeHRlbnQuY2FsbCh0aGlzLCBleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgaW50ZXJ2YWxcbiAgICAgICAgICovXG4gICAgICAgIGdldEludGVydmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uaWNlVGlja3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcnZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGludGVydmFsXG4gICAgICAgICAqL1xuICAgICAgICBzZXRJbnRlcnZhbDogZnVuY3Rpb24gKGludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICAgICAgLy8gRHJvcHBlZCBhdXRvIGNhbGN1bGF0ZWQgbmljZUV4dGVudCBhbmQgdXNlIHVzZXIgc2V0dGVkIGV4dGVudFxuICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHVzZXIgd2FuJ3QgdG8gc2V0IGJvdGggaW50ZXJ2YWwsIG1pbiwgbWF4IHRvIGdldCBhIGJldHRlciByZXN1bHRcbiAgICAgICAgICAgIHRoaXMuX25pY2VFeHRlbnQgPSB0aGlzLl9leHRlbnQuc2xpY2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaWNrczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmljZVRpY2tzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbDtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgdGlja3MgPSBbXTtcblxuICAgICAgICAgICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiB1c2luZyBkYXRhWm9vbSB0b29sYm94LCB6b29tIGFuZCB6b29tLlxuICAgICAgICAgICAgdmFyIHNhZmVMaW1pdCA9IDEwMDAwO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmljZUV4dGVudCA9IHRoaXMuX25pY2VFeHRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHByZWNpc2lvbiA9IGdldFByZWNpc2lvblNhZmUoaW50ZXJ2YWwpICsgMjtcblxuICAgICAgICAgICAgICAgIGlmIChleHRlbnRbMF0gPCBuaWNlRXh0ZW50WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2tzLnB1c2goZXh0ZW50WzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRpY2sgPSBuaWNlRXh0ZW50WzBdO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRpY2sgPD0gbmljZUV4dGVudFsxXSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrcy5wdXNoKHRpY2spO1xuICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCByb3VuZGluZyBlcnJvclxuICAgICAgICAgICAgICAgICAgICB0aWNrID0gcm91bmRpbmdFcnJvckZpeCh0aWNrICsgaW50ZXJ2YWwsIHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aWNrcy5sZW5ndGggPiBzYWZlTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciB0aGlzIGNhc2U6IHRoZSBsYXN0IGl0ZW0gb2YgdGlja3MgaXMgc21hbGxlclxuICAgICAgICAgICAgICAgIC8vIHRoYW4gbmljZUV4dGVudFsxXSBhbmQgbmljZUV4dGVudFsxXSA9PT0gZXh0ZW50WzFdLlxuICAgICAgICAgICAgICAgIGlmIChleHRlbnRbMV0gPiAodGlja3MubGVuZ3RoID8gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0gOiBuaWNlRXh0ZW50WzFdKSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrcy5wdXNoKGV4dGVudFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGlja3NMYWJlbHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbHMgPSBbXTtcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsYWJlbHMucHVzaCh0aGlzLmdldExhYmVsKHRpY2tzW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gblxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYWJlbDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRVdGlsLmFkZENvbW1hcyhkYXRhKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGludGVydmFsIGFuZCBleHRlbnQgb2YgaW50ZXJ2YWxzIGZvciBuaWNlIHRpY2tzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3BsaXROdW1iZXIgPSA1XSBEZXNpcmVkIG51bWJlciBvZiB0aWNrc1xuICAgICAgICAgKi9cbiAgICAgICAgbmljZVRpY2tzOiBmdW5jdGlvbiAoc3BsaXROdW1iZXIpIHtcbiAgICAgICAgICAgIHNwbGl0TnVtYmVyID0gc3BsaXROdW1iZXIgfHwgNTtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUoc3BhbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2VyIG1heSBzZXQgYXhpcyBtaW4gMCBhbmQgZGF0YSBhcmUgYWxsIG5lZ2F0aXZlXG4gICAgICAgICAgICAvLyBGSVhNRSBJZiBpdCBuZWVkcyB0byByZXZlcnNlID9cbiAgICAgICAgICAgIGlmIChzcGFuIDwgMCkge1xuICAgICAgICAgICAgICAgIHNwYW4gPSAtc3BhbjtcbiAgICAgICAgICAgICAgICBleHRlbnQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGcm9tIFwiTmljZSBOdW1iZXJzIGZvciBHcmFwaCBMYWJlbHNcIiBvZiBHcmFwaGljIEdlbXNcbiAgICAgICAgICAgIC8vIHZhciBuaWNlU3BhbiA9IG51bWJlclV0aWwubmljZShzcGFuLCBmYWxzZSk7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IHJvdW5kaW5nRXJyb3JGaXgoXG4gICAgICAgICAgICAgICAgbnVtYmVyVXRpbC5uaWNlKHNwYW4gLyBzcGxpdE51bWJlciwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgIGdldFByZWNpc2lvblNhZmUoZXh0ZW50WzBdKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0UHJlY2lzaW9uU2FmZShleHRlbnRbMV0pXG4gICAgICAgICAgICAgICAgLy8gZXh0ZW50IG1heSBiZSBbMCwgMV0sIGFuZCBzdGVwIHNob3VsZCBoYXZlIDEgbW9yZSBkaWdpdHMuXG4gICAgICAgICAgICAgICAgLy8gVG8gbWFrZSBpdCBzYWZlIHdlIGFkZCAyIG1vcmUgZGlnaXRzXG4gICAgICAgICAgICAgICAgKSArIDJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBwcmVjaXNpb24gPSBnZXRQcmVjaXNpb25TYWZlKHN0ZXApICsgMjtcbiAgICAgICAgICAgIC8vIE5pY2VkIGV4dGVudCBpbnNpZGUgb3JpZ2luYWwgZXh0ZW50XG4gICAgICAgICAgICB2YXIgbmljZUV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICByb3VuZGluZ0Vycm9yRml4KG1hdGhDZWlsKGV4dGVudFswXSAvIHN0ZXApICogc3RlcCwgcHJlY2lzaW9uKSxcbiAgICAgICAgICAgICAgICByb3VuZGluZ0Vycm9yRml4KG1hdGhGbG9vcihleHRlbnRbMV0gLyBzdGVwKSAqIHN0ZXAsIHByZWNpc2lvbilcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHRoaXMuX2ludGVydmFsID0gc3RlcDtcbiAgICAgICAgICAgIHRoaXMuX25pY2VFeHRlbnQgPSBuaWNlRXh0ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOaWNlIGV4dGVudC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzcGxpdE51bWJlciA9IDVdIEdpdmVuIGFwcHJveCB0aWNrIG51bWJlclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmaXhNaW49ZmFsc2VdXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZpeE1heD1mYWxzZV1cbiAgICAgICAgICovXG4gICAgICAgIG5pY2VFeHRlbnQ6IGZ1bmN0aW9uIChzcGxpdE51bWJlciwgZml4TWluLCBmaXhNYXgpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICAvLyBJZiBleHRlbnQgc3RhcnQgYW5kIGVuZCBhcmUgc2FtZSwgZXhwYW5kIHRoZW1cbiAgICAgICAgICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgICAgICAgICAgIGlmIChleHRlbnRbMF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwYW5kIGV4dGVudFxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwYW5kU2l6ZSA9IGV4dGVudFswXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIGZvd2xsb3dpbmcgY2FzZVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIEF4aXMgaGFzIGJlZW4gZml4ZWQgbWF4IDEwMFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIFBsdXMgZGF0YSBhcmUgYWxsIDEwMCBhbmQgYXhpcyBleHRlbnQgYXJlIFsxMDAsIDEwMF0uXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dGVuZCB0byB0aGUgYm90aCBzaWRlIHdpbGwgY2F1c2UgZXhwYW5kZWQgbWF4IGlzIGxhcmdlciB0aGFuIGZpeGVkIG1heC5cbiAgICAgICAgICAgICAgICAgICAgLy8gU28gb25seSBleHBhbmQgdG8gdGhlIHNtYWxsZXIgc2lkZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXhNYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudFsxXSArPSBleHBhbmRTaXplIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudFswXSAtPSBleHBhbmRTaXplIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudFswXSAtPSBleHBhbmRTaXplIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50WzFdID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBkYXRhIGFuZCBleHRlbnQgYXJlIFtJbmZpbml0eSwgLUluZmluaXR5XVxuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShzcGFuKSkge1xuICAgICAgICAgICAgICAgIGV4dGVudFswXSA9IDA7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzFdID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5uaWNlVGlja3Moc3BsaXROdW1iZXIpO1xuXG4gICAgICAgICAgICAvLyB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIGludGVydmFsID0gdGhpcy5faW50ZXJ2YWw7XG5cbiAgICAgICAgICAgIGlmICghZml4TWluKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzBdID0gcm91bmRpbmdFcnJvckZpeChtYXRoRmxvb3IoZXh0ZW50WzBdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmaXhNYXgpIHtcbiAgICAgICAgICAgICAgICBleHRlbnRbMV0gPSByb3VuZGluZ0Vycm9yRml4KG1hdGhDZWlsKGV4dGVudFsxXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZX1cbiAgICAgKi9cbiAgICBJbnRlcnZhbFNjYWxlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSW50ZXJ2YWxTY2FsZTtcblxuIiwiLyoqXG4gKiBMb2cgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9zY2FsZS9Mb2dcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIFNjYWxlID0gcmVxdWlyZSgnLi9TY2FsZScpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9udW1iZXInKTtcblxuICAgIC8vIFVzZSBzb21lIG1ldGhvZCBvZiBJbnRlcnZhbFNjYWxlXG4gICAgdmFyIEludGVydmFsU2NhbGUgPSByZXF1aXJlKCcuL0ludGVydmFsJyk7XG5cbiAgICB2YXIgc2NhbGVQcm90byA9IFNjYWxlLnByb3RvdHlwZTtcbiAgICB2YXIgaW50ZXJ2YWxTY2FsZVByb3RvID0gSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGU7XG5cbiAgICB2YXIgZ2V0UHJlY2lzaW9uU2FmZSA9IG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uU2FmZTtcbiAgICB2YXIgcm91bmRpbmdFcnJvckZpeCA9IG51bWJlclV0aWwucm91bmQ7XG5cbiAgICB2YXIgbWF0aEZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgbWF0aENlaWwgPSBNYXRoLmNlaWw7XG4gICAgdmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcblxuICAgIHZhciBtYXRoTG9nID0gTWF0aC5sb2c7XG5cbiAgICB2YXIgTG9nU2NhbGUgPSBTY2FsZS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdsb2cnLFxuXG4gICAgICAgIGJhc2U6IDEwLFxuXG4gICAgICAgICRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgU2NhbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsU2NhbGUgPSBuZXcgSW50ZXJ2YWxTY2FsZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRpY2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxTY2FsZSA9IHRoaXMuX29yaWdpbmFsU2NhbGU7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXh0ZW50ID0gb3JpZ2luYWxTY2FsZS5nZXRFeHRlbnQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAoaW50ZXJ2YWxTY2FsZVByb3RvLmdldFRpY2tzLmNhbGwodGhpcyksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG93VmFsID0gbnVtYmVyVXRpbC5yb3VuZChtYXRoUG93KHRoaXMuYmFzZSwgdmFsKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXggIzQxNThcbiAgICAgICAgICAgICAgICBwb3dWYWwgPSAodmFsID09PSBleHRlbnRbMF0gJiYgb3JpZ2luYWxTY2FsZS5fX2ZpeE1pbilcbiAgICAgICAgICAgICAgICAgICAgPyBmaXhSb3VuZGluZ0Vycm9yKHBvd1ZhbCwgb3JpZ2luYWxFeHRlbnRbMF0pXG4gICAgICAgICAgICAgICAgICAgIDogcG93VmFsO1xuICAgICAgICAgICAgICAgIHBvd1ZhbCA9ICh2YWwgPT09IGV4dGVudFsxXSAmJiBvcmlnaW5hbFNjYWxlLl9fZml4TWF4KVxuICAgICAgICAgICAgICAgICAgICA/IGZpeFJvdW5kaW5nRXJyb3IocG93VmFsLCBvcmlnaW5hbEV4dGVudFsxXSlcbiAgICAgICAgICAgICAgICAgICAgOiBwb3dWYWw7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcG93VmFsO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGFiZWw6IGludGVydmFsU2NhbGVQcm90by5nZXRMYWJlbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHZhbCA9IHNjYWxlUHJvdG8uc2NhbGUuY2FsbCh0aGlzLCB2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGhQb3codGhpcy5iYXNlLCB2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RXh0ZW50OiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgICAgICAgICBzdGFydCA9IG1hdGhMb2coc3RhcnQpIC8gbWF0aExvZyhiYXNlKTtcbiAgICAgICAgICAgIGVuZCA9IG1hdGhMb2coZW5kKSAvIG1hdGhMb2coYmFzZSk7XG4gICAgICAgICAgICBpbnRlcnZhbFNjYWxlUHJvdG8uc2V0RXh0ZW50LmNhbGwodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gZW5kXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFeHRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHNjYWxlUHJvdG8uZ2V0RXh0ZW50LmNhbGwodGhpcyk7XG4gICAgICAgICAgICBleHRlbnRbMF0gPSBtYXRoUG93KGJhc2UsIGV4dGVudFswXSk7XG4gICAgICAgICAgICBleHRlbnRbMV0gPSBtYXRoUG93KGJhc2UsIGV4dGVudFsxXSk7XG5cbiAgICAgICAgICAgIC8vIEZpeCAjNDE1OFxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsU2NhbGUgPSB0aGlzLl9vcmlnaW5hbFNjYWxlO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXh0ZW50ID0gb3JpZ2luYWxTY2FsZS5nZXRFeHRlbnQoKTtcbiAgICAgICAgICAgIG9yaWdpbmFsU2NhbGUuX19maXhNaW4gJiYgKGV4dGVudFswXSA9IGZpeFJvdW5kaW5nRXJyb3IoZXh0ZW50WzBdLCBvcmlnaW5hbEV4dGVudFswXSkpO1xuICAgICAgICAgICAgb3JpZ2luYWxTY2FsZS5fX2ZpeE1heCAmJiAoZXh0ZW50WzFdID0gZml4Um91bmRpbmdFcnJvcihleHRlbnRbMV0sIG9yaWdpbmFsRXh0ZW50WzFdKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBleHRlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBleHRlbnRcbiAgICAgICAgICovXG4gICAgICAgIHVuaW9uRXh0ZW50OiBmdW5jdGlvbiAoZXh0ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFNjYWxlLnVuaW9uRXh0ZW50KGV4dGVudCk7XG5cbiAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgICAgICAgICAgZXh0ZW50WzBdID0gbWF0aExvZyhleHRlbnRbMF0pIC8gbWF0aExvZyhiYXNlKTtcbiAgICAgICAgICAgIGV4dGVudFsxXSA9IG1hdGhMb2coZXh0ZW50WzFdKSAvIG1hdGhMb2coYmFzZSk7XG4gICAgICAgICAgICBzY2FsZVByb3RvLnVuaW9uRXh0ZW50LmNhbGwodGhpcywgZXh0ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICB1bmlvbkV4dGVudEZyb21EYXRhOiBmdW5jdGlvbiAoZGF0YSwgZGltKSB7XG4gICAgICAgICAgICB0aGlzLnVuaW9uRXh0ZW50KGRhdGEuZ2V0RGF0YUV4dGVudChkaW0sIHRydWUsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsID4gMDtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGludGVydmFsIGFuZCBleHRlbnQgb2YgaW50ZXJ2YWxzIGZvciBuaWNlIHRpY2tzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gW2FwcHJveFRpY2tOdW0gPSAxMF0gR2l2ZW4gYXBwcm94IHRpY2sgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBuaWNlVGlja3M6IGZ1bmN0aW9uIChhcHByb3hUaWNrTnVtKSB7XG4gICAgICAgICAgICBhcHByb3hUaWNrTnVtID0gYXBwcm94VGlja051bSB8fCAxMDtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICAgICAgICAgIGlmIChzcGFuID09PSBJbmZpbml0eSB8fCBzcGFuIDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IG51bWJlclV0aWwucXVhbnRpdHkoc3Bhbik7XG4gICAgICAgICAgICB2YXIgZXJyID0gYXBwcm94VGlja051bSAvIHNwYW4gKiBpbnRlcnZhbDtcblxuICAgICAgICAgICAgLy8gRmlsdGVyIHRpY2tzIHRvIGdldCBjbG9zZXIgdG8gdGhlIGRlc2lyZWQgY291bnQuXG4gICAgICAgICAgICBpZiAoZXJyIDw9IDAuNSkge1xuICAgICAgICAgICAgICAgIGludGVydmFsICo9IDEwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbnRlcnZhbCBzaG91bGQgYmUgaW50ZWdlclxuICAgICAgICAgICAgd2hpbGUgKCFpc05hTihpbnRlcnZhbCkgJiYgTWF0aC5hYnMoaW50ZXJ2YWwpIDwgMSAmJiBNYXRoLmFicyhpbnRlcnZhbCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMTA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuaWNlRXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgIG51bWJlclV0aWwucm91bmQobWF0aENlaWwoZXh0ZW50WzBdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpLFxuICAgICAgICAgICAgICAgIG51bWJlclV0aWwucm91bmQobWF0aEZsb29yKGV4dGVudFsxXSAvIGludGVydmFsKSAqIGludGVydmFsKVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICAgICAgICAgIHRoaXMuX25pY2VFeHRlbnQgPSBuaWNlRXh0ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOaWNlIGV4dGVudC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFthcHByb3hUaWNrTnVtID0gMTBdIEdpdmVuIGFwcHJveCB0aWNrIG51bWJlclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmaXhNaW49ZmFsc2VdXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZpeE1heD1mYWxzZV1cbiAgICAgICAgICovXG4gICAgICAgIG5pY2VFeHRlbnQ6IGZ1bmN0aW9uIChzcGxpdE51bWJlciwgZml4TWluLCBmaXhNYXgpIHtcbiAgICAgICAgICAgIGludGVydmFsU2NhbGVQcm90by5uaWNlRXh0ZW50LmNhbGwodGhpcywgc3BsaXROdW1iZXIsIGZpeE1pbiwgZml4TWF4KTtcblxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsU2NhbGUgPSB0aGlzLl9vcmlnaW5hbFNjYWxlO1xuICAgICAgICAgICAgb3JpZ2luYWxTY2FsZS5fX2ZpeE1pbiA9IGZpeE1pbjtcbiAgICAgICAgICAgIG9yaWdpbmFsU2NhbGUuX19maXhNYXggPSBmaXhNYXg7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgenJVdGlsLmVhY2goWydjb250YWluJywgJ25vcm1hbGl6ZSddLCBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgICBMb2dTY2FsZS5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YWwgPSBtYXRoTG9nKHZhbCkgLyBtYXRoTG9nKHRoaXMuYmFzZSk7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVQcm90b1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIHZhbCk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMb2dTY2FsZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nU2NhbGUoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZml4Um91bmRpbmdFcnJvcih2YWwsIG9yaWdpbmFsVmFsKSB7XG4gICAgICAgIHJldHVybiByb3VuZGluZ0Vycm9yRml4KHZhbCwgZ2V0UHJlY2lzaW9uU2FmZShvcmlnaW5hbFZhbCkpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gTG9nU2NhbGU7XG4iLCIvKipcbiAqIExpbmVhciBjb250aW51b3VzIHNjYWxlXG4gKiBAbW9kdWxlIGVjaGFydHMvY29vcmQvc2NhbGUvT3JkaW5hbFxuICpcbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV2ZWxfb2ZfbWVhc3VyZW1lbnRcbiAqL1xuXG4vLyBGSVhNRSBvbmx5IG9uZSBkYXRhXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgU2NhbGUgPSByZXF1aXJlKCcuL1NjYWxlJyk7XG5cbiAgICB2YXIgc2NhbGVQcm90byA9IFNjYWxlLnByb3RvdHlwZTtcblxuICAgIHZhciBPcmRpbmFsU2NhbGUgPSBTY2FsZS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdvcmRpbmFsJyxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoZGF0YSwgZXh0ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMuX2V4dGVudCA9IGV4dGVudCB8fCBbMCwgZGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyB6clV0aWwuaW5kZXhPZih0aGlzLl9kYXRhLCB2YWwpXG4gICAgICAgICAgICAgICAgLy8gdmFsIG1pZ2h0IGJlIGZsb2F0LlxuICAgICAgICAgICAgICAgIDogTWF0aC5yb3VuZCh2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uIChyYW5rKSB7XG4gICAgICAgICAgICByYW5rID0gdGhpcy5wYXJzZShyYW5rKTtcbiAgICAgICAgICAgIHJldHVybiBzY2FsZVByb3RvLmNvbnRhaW4uY2FsbCh0aGlzLCByYW5rKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuX2RhdGFbcmFua10gIT0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm9ybWFsaXplIGdpdmVuIHJhbmsgb3IgbmFtZSB0byBsaW5lYXIgWzAsIDFdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3ZhbF1cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbm9ybWFsaXplOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVQcm90by5ub3JtYWxpemUuY2FsbCh0aGlzLCB0aGlzLnBhcnNlKHZhbCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNjYWxlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChzY2FsZVByb3RvLnNjYWxlLmNhbGwodGhpcywgdmFsKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGlja3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIHZhciByYW5rID0gZXh0ZW50WzBdO1xuXG4gICAgICAgICAgICB3aGlsZSAocmFuayA8PSBleHRlbnRbMV0pIHtcbiAgICAgICAgICAgICAgICB0aWNrcy5wdXNoKHJhbmspO1xuICAgICAgICAgICAgICAgIHJhbmsrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRpY2tzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgaXRlbSBvbiByYW5rIG5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5cbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGFiZWw6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtuXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgY291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHRlbnRbMV0gLSB0aGlzLl9leHRlbnRbMF0gKyAxO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHVuaW9uRXh0ZW50RnJvbURhdGE6IGZ1bmN0aW9uIChkYXRhLCBkaW0pIHtcbiAgICAgICAgICAgIHRoaXMudW5pb25FeHRlbnQoZGF0YS5nZXREYXRhRXh0ZW50KGRpbSwgZmFsc2UpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBuaWNlVGlja3M6IHpyVXRpbC5ub29wLFxuICAgICAgICBuaWNlRXh0ZW50OiB6clV0aWwubm9vcFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZX1cbiAgICAgKi9cbiAgICBPcmRpbmFsU2NhbGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE9yZGluYWxTY2FsZSgpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IE9yZGluYWxTY2FsZTtcbiIsIi8qKlxuICogLy8gU2NhbGUgY2xhc3MgbWFuYWdlbWVudFxuICogQG1vZHVsZSBlY2hhcnRzL3NjYWxlL1NjYWxlXG4gKi9cblxuXG4gICAgdmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhenonKTtcblxuICAgIGZ1bmN0aW9uIFNjYWxlKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRXh0ZW50XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZXh0ZW50ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGVwIGlzIGNhbGN1bGF0ZWQgaW4gYWRqdXN0RXh0ZW50XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSAwO1xuXG4gICAgICAgIHRoaXMuaW5pdCAmJiB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgc2NhbGVQcm90byA9IFNjYWxlLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGlucHV0IHZhbCB0byB2YWxpZCBpbm5lciBudW1iZXIuXG4gICAgICogQHBhcmFtIHsqfSB2YWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2NhbGVQcm90by5wYXJzZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgLy8gTm90aWNlOiBUaGlzIHdvdWxkIGJlIGEgdHJhcCBoZXJlLCBJZiB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgICAgLy8gb2YgdGhpcyBtZXRob2QgZGVwZW5kcyBvbiBleHRlbnQsIGFuZCB0aGlzIG1ldGhvZCBpcyB1c2VkXG4gICAgICAgIC8vIGJlZm9yZSBleHRlbnQgc2V0IChsaWtlIGluIGRhdGFab29tKSwgaXQgd291bGQgYmUgd3JvbmcuXG4gICAgICAgIC8vIE5ldmVydGhlbGVzcywgcGFyc2UgZG9lcyBub3QgZGVwZW5kIG9uIGV4dGVudCBnZW5lcmFsbHkuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIHNjYWxlUHJvdG8uY29udGFpbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgcmV0dXJuIHZhbCA+PSBleHRlbnRbMF0gJiYgdmFsIDw9IGV4dGVudFsxXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIHZhbHVlIHRvIGxpbmVhciBbMCwgMV0sIHJldHVybiAwLjUgaWYgZXh0ZW50IHNwYW4gaXMgMFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2NhbGVQcm90by5ub3JtYWxpemUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgIGlmIChleHRlbnRbMV0gPT09IGV4dGVudFswXSkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHZhbCAtIGV4dGVudFswXSkgLyAoZXh0ZW50WzFdIC0gZXh0ZW50WzBdKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NhbGUgbm9ybWFsaXplZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2NhbGVQcm90by5zY2FsZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgcmV0dXJuIHZhbCAqIChleHRlbnRbMV0gLSBleHRlbnRbMF0pICsgZXh0ZW50WzBdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgZXh0ZW50IGZyb20gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG90aGVyXG4gICAgICovXG4gICAgc2NhbGVQcm90by51bmlvbkV4dGVudCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICBvdGhlclswXSA8IGV4dGVudFswXSAmJiAoZXh0ZW50WzBdID0gb3RoZXJbMF0pO1xuICAgICAgICBvdGhlclsxXSA+IGV4dGVudFsxXSAmJiAoZXh0ZW50WzFdID0gb3RoZXJbMV0pO1xuICAgICAgICAvLyBub3Qgc2V0RXh0ZW50IGJlY2F1c2UgaW4gbG9nIGF4aXMgaXQgbWF5IHRyYW5zZm9ybWVkIHRvIHBvd2VyXG4gICAgICAgIC8vIHRoaXMuc2V0RXh0ZW50KGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGV4dGVudCBmcm9tIGRhdGFcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAgICAgKi9cbiAgICBzY2FsZVByb3RvLnVuaW9uRXh0ZW50RnJvbURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgZGltKSB7XG4gICAgICAgIHRoaXMudW5pb25FeHRlbnQoZGF0YS5nZXREYXRhRXh0ZW50KGRpbSwgdHJ1ZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZXh0ZW50XG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgc2NhbGVQcm90by5nZXRFeHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRlbnQuc2xpY2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGV4dGVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAgICAgKi9cbiAgICBzY2FsZVByb3RvLnNldEV4dGVudCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciB0aGlzRXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICBpZiAoIWlzTmFOKHN0YXJ0KSkge1xuICAgICAgICAgICAgdGhpc0V4dGVudFswXSA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOYU4oZW5kKSkge1xuICAgICAgICAgICAgdGhpc0V4dGVudFsxXSA9IGVuZDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBzY2FsZVByb3RvLmdldFRpY2tzTGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFiZWxzID0gW107XG4gICAgICAgIHZhciB0aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGFiZWxzLnB1c2godGhpcy5nZXRMYWJlbCh0aWNrc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfTtcblxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChTY2FsZSk7XG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzTWFuYWdlbWVudChTY2FsZSwge1xuICAgICAgICByZWdpc3RlcldoZW5FeHRlbmQ6IHRydWVcbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU2NhbGU7XG4iLCIvKipcbiAqIEludGVydmFsIHNjYWxlXG4gKiBAbW9kdWxlIGVjaGFydHMvY29vcmQvc2NhbGUvVGltZVxuICovXG5cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvZm9ybWF0Jyk7XG5cbiAgICB2YXIgSW50ZXJ2YWxTY2FsZSA9IHJlcXVpcmUoJy4vSW50ZXJ2YWwnKTtcblxuICAgIHZhciBpbnRlcnZhbFNjYWxlUHJvdG8gPSBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZTtcblxuICAgIHZhciBtYXRoQ2VpbCA9IE1hdGguY2VpbDtcbiAgICB2YXIgbWF0aEZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgT05FX1NFQ09ORCA9IDEwMDA7XG4gICAgdmFyIE9ORV9NSU5VVEUgPSBPTkVfU0VDT05EICogNjA7XG4gICAgdmFyIE9ORV9IT1VSID0gT05FX01JTlVURSAqIDYwO1xuICAgIHZhciBPTkVfREFZID0gT05FX0hPVVIgKiAyNDtcblxuICAgIC8vIEZJWE1FIOWFrOeUqO+8n1xuICAgIHZhciBiaXNlY3QgPSBmdW5jdGlvbiAoYSwgeCwgbG8sIGhpKSB7XG4gICAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgICAgIGlmIChhW21pZF1bMl0gPCB4KSB7XG4gICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGkgID0gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsbztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2Nvb3JkL3NjYWxlL1RpbWVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgVGltZVNjYWxlID0gSW50ZXJ2YWxTY2FsZS5leHRlbmQoe1xuICAgICAgICB0eXBlOiAndGltZScsXG5cbiAgICAgICAgLy8gT3ZlcndyaXRlXG4gICAgICAgIGdldExhYmVsOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YXIgc3RlcEx2bCA9IHRoaXMuX3N0ZXBMdmw7XG5cbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUodmFsKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFV0aWwuZm9ybWF0VGltZShzdGVwTHZsWzBdLCBkYXRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPdmVyd3JpdGVcbiAgICAgICAgbmljZUV4dGVudDogZnVuY3Rpb24gKGFwcHJveFRpY2tOdW0sIGZpeE1pbiwgZml4TWF4KSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgLy8gSWYgZXh0ZW50IHN0YXJ0IGFuZCBlbmQgYXJlIHNhbWUsIGV4cGFuZCB0aGVtXG4gICAgICAgICAgICBpZiAoZXh0ZW50WzBdID09PSBleHRlbnRbMV0pIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgZXh0ZW50XG4gICAgICAgICAgICAgICAgZXh0ZW50WzBdIC09IE9ORV9EQVk7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzFdICs9IE9ORV9EQVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZGF0YSBhbmQgZXh0ZW50IGFyZSBbSW5maW5pdHksIC1JbmZpbml0eV1cbiAgICAgICAgICAgIGlmIChleHRlbnRbMV0gPT09IC1JbmZpbml0eSAmJiBleHRlbnRbMF0gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGV4dGVudFsxXSA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSk7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzBdID0gZXh0ZW50WzFdIC0gT05FX0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5uaWNlVGlja3MoYXBwcm94VGlja051bSk7XG5cbiAgICAgICAgICAgIC8vIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbDtcblxuICAgICAgICAgICAgaWYgKCFmaXhNaW4pIHtcbiAgICAgICAgICAgICAgICBleHRlbnRbMF0gPSBudW1iZXJVdGlsLnJvdW5kKG1hdGhGbG9vcihleHRlbnRbMF0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZpeE1heCkge1xuICAgICAgICAgICAgICAgIGV4dGVudFsxXSA9IG51bWJlclV0aWwucm91bmQobWF0aENlaWwoZXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZVxuICAgICAgICBuaWNlVGlja3M6IGZ1bmN0aW9uIChhcHByb3hUaWNrTnVtKSB7XG4gICAgICAgICAgICBhcHByb3hUaWNrTnVtID0gYXBwcm94VGlja051bSB8fCAxMDtcblxuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgICAgICAgICAgdmFyIGFwcHJveEludGVydmFsID0gc3BhbiAvIGFwcHJveFRpY2tOdW07XG4gICAgICAgICAgICB2YXIgc2NhbGVMZXZlbHNMZW4gPSBzY2FsZUxldmVscy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaWR4ID0gYmlzZWN0KHNjYWxlTGV2ZWxzLCBhcHByb3hJbnRlcnZhbCwgMCwgc2NhbGVMZXZlbHNMZW4pO1xuXG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBzY2FsZUxldmVsc1tNYXRoLm1pbihpZHgsIHNjYWxlTGV2ZWxzTGVuIC0gMSldO1xuICAgICAgICAgICAgdmFyIGludGVydmFsID0gbGV2ZWxbMl07XG4gICAgICAgICAgICAvLyBTYW1lIHdpdGggaW50ZXJ2YWwgc2NhbGUgaWYgc3BhbiBpcyBtdWNoIGxhcmdlciB0aGFuIDEgeWVhclxuICAgICAgICAgICAgaWYgKGxldmVsWzBdID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICB2YXIgeWVhclNwYW4gPSBzcGFuIC8gaW50ZXJ2YWw7XG5cbiAgICAgICAgICAgICAgICAvLyBGcm9tIFwiTmljZSBOdW1iZXJzIGZvciBHcmFwaCBMYWJlbHNcIiBvZiBHcmFwaGljIEdlbXNcbiAgICAgICAgICAgICAgICAvLyB2YXIgbmljZVllYXJTcGFuID0gbnVtYmVyVXRpbC5uaWNlKHllYXJTcGFuLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdmFyIHllYXJTdGVwID0gbnVtYmVyVXRpbC5uaWNlKHllYXJTcGFuIC8gYXBwcm94VGlja051bSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpbnRlcnZhbCAqPSB5ZWFyU3RlcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5pY2VFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgbWF0aENlaWwoZXh0ZW50WzBdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgbWF0aEZsb29yKGV4dGVudFsxXSAvIGludGVydmFsKSAqIGludGVydmFsXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICB0aGlzLl9zdGVwTHZsID0gbGV2ZWw7XG4gICAgICAgICAgICAvLyBJbnRlcnZhbCB3aWxsIGJlIHVzZWQgaW4gZ2V0VGlja3NcbiAgICAgICAgICAgIHRoaXMuX2ludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgICAgICB0aGlzLl9uaWNlRXh0ZW50ID0gbmljZUV4dGVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgLy8gdmFsIG1pZ2h0IGJlIGZsb2F0LlxuICAgICAgICAgICAgcmV0dXJuICtudW1iZXJVdGlsLnBhcnNlRGF0ZSh2YWwpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB6clV0aWwuZWFjaChbJ2NvbnRhaW4nLCAnbm9ybWFsaXplJ10sIGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgICAgIFRpbWVTY2FsZS5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWxTY2FsZVByb3RvW21ldGhvZE5hbWVdLmNhbGwodGhpcywgdGhpcy5wYXJzZSh2YWwpKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIFN0ZXBzIGZyb20gZDNcbiAgICB2YXIgc2NhbGVMZXZlbHMgPSBbXG4gICAgICAgIC8vIEZvcm1hdCAgICAgICBzdGVwICAgIGludGVydmFsXG4gICAgICAgIFsnaGg6bW06c3MnLCAgICAxLCAgICAgIE9ORV9TRUNPTkRdLCAgICAgICAgICAgLy8gMXNcbiAgICAgICAgWydoaDptbTpzcycsICAgIDUsICAgICAgT05FX1NFQ09ORCAqIDVdLCAgICAgICAvLyA1c1xuICAgICAgICBbJ2hoOm1tOnNzJywgICAgMTAsICAgICBPTkVfU0VDT05EICogMTBdLCAgICAgIC8vIDEwc1xuICAgICAgICBbJ2hoOm1tOnNzJywgICAgMTUsICAgICBPTkVfU0VDT05EICogMTVdLCAgICAgIC8vIDE1c1xuICAgICAgICBbJ2hoOm1tOnNzJywgICAgMzAsICAgICBPTkVfU0VDT05EICogMzBdLCAgICAgIC8vIDMwc1xuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDEsICAgICAgT05FX01JTlVURV0sICAgICAgICAgIC8vIDFtXG4gICAgICAgIFsnaGg6bW1cXG5NTS1kZCcsNSwgICAgICBPTkVfTUlOVVRFICogNV0sICAgICAgLy8gNW1cbiAgICAgICAgWydoaDptbVxcbk1NLWRkJywxMCwgICAgIE9ORV9NSU5VVEUgKiAxMF0sICAgICAvLyAxMG1cbiAgICAgICAgWydoaDptbVxcbk1NLWRkJywxNSwgICAgIE9ORV9NSU5VVEUgKiAxNV0sICAgICAvLyAxNW1cbiAgICAgICAgWydoaDptbVxcbk1NLWRkJywzMCwgICAgIE9ORV9NSU5VVEUgKiAzMF0sICAgICAvLyAzMG1cbiAgICAgICAgWydoaDptbVxcbk1NLWRkJywxLCAgICAgIE9ORV9IT1VSXSwgICAgICAgIC8vIDFoXG4gICAgICAgIFsnaGg6bW1cXG5NTS1kZCcsMiwgICAgICBPTkVfSE9VUiAqIDJdLCAgICAvLyAyaFxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDYsICAgICAgT05FX0hPVVIgKiA2XSwgICAgLy8gNmhcbiAgICAgICAgWydoaDptbVxcbk1NLWRkJywxMiwgICAgIE9ORV9IT1VSICogMTJdLCAgIC8vIDEyaFxuICAgICAgICBbJ01NLWRkXFxueXl5eScsIDEsICAgICAgT05FX0RBWV0sICAgLy8gMWRcbiAgICAgICAgWyd3ZWVrJywgICAgICAgIDcsICAgICAgT05FX0RBWSAqIDddLCAgICAgICAgLy8gN2RcbiAgICAgICAgWydtb250aCcsICAgICAgIDEsICAgICAgT05FX0RBWSAqIDMxXSwgICAgICAgLy8gMU1cbiAgICAgICAgWydxdWFydGVyJywgICAgIDMsICAgICAgT05FX0RBWSAqIDM4MCAvIDRdLCAgLy8gM01cbiAgICAgICAgWydoYWxmLXllYXInLCAgIDYsICAgICAgT05FX0RBWSAqIDM4MCAvIDJdLCAgLy8gNk1cbiAgICAgICAgWyd5ZWFyJywgICAgICAgIDEsICAgICAgT05FX0RBWSAqIDM4MF0gICAgICAgLy8gMVlcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZX1cbiAgICAgKi9cbiAgICBUaW1lU2NhbGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVTY2FsZSgpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRpbWVTY2FsZTtcbiIsIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIGNsYXp6ID0ge307XG5cbiAgICB2YXIgVFlQRV9ERUxJTUlURVIgPSAnLic7XG4gICAgdmFyIElTX0NPTlRBSU5FUiA9ICdfX19FQ19fQ09NUE9ORU5UX19DT05UQUlORVJfX18nO1xuICAgIHZhciBNRU1CRVJfUFJJRklYID0gJ1xcMGVjX1xcMCc7XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHByaXZhdGUgY2xhc3MgbWVtYmVyLlxuICAgICAqIFRoZSBzYW1lIGJlaGF2aW9yIGFzIGBob3N0W25hbWVdID0gdmFsdWU7YCAoY2FuIGJlIHJpZ2h0LXZhbHVlKVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGF6ei5zZXQgPSBmdW5jdGlvbiAoaG9zdCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChob3N0W01FTUJFUl9QUklGSVggKyBuYW1lXSA9IHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGlkZSBwcml2YXRlIGNsYXNzIG1lbWJlci5cbiAgICAgKiBUaGUgc2FtZSBiZWhhdmlvciBhcyBgaG9zdFtuYW1lXTtgXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXp6LmdldCA9IGZ1bmN0aW9uIChob3N0LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBob3N0W01FTUJFUl9QUklGSVggKyBuYW1lXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRm9yIGhpZGRlbiBwcml2YXRlIGNsYXNzIG1lbWJlci5cbiAgICAgKiBUaGUgc2FtZSBiZWhhdmlvciBhcyBgaG9zdC5oYXNPd25Qcm9wZXJ0eShuYW1lKTtgXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXp6Lmhhc093biA9IGZ1bmN0aW9uIChob3N0LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBob3N0Lmhhc093blByb3BlcnR5KE1FTUJFUl9QUklGSVggKyBuYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHZhciBwYXJzZUNsYXNzVHlwZSA9IGNsYXp6LnBhcnNlQ2xhc3NUeXBlID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgdmFyIHJldCA9IHttYWluOiAnJywgc3ViOiAnJ307XG4gICAgICAgIGlmIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZS5zcGxpdChUWVBFX0RFTElNSVRFUik7XG4gICAgICAgICAgICByZXQubWFpbiA9IGNvbXBvbmVudFR5cGVbMF0gfHwgJyc7XG4gICAgICAgICAgICByZXQuc3ViID0gY29tcG9uZW50VHlwZVsxXSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tDbGFzc1R5cGUoY29tcG9uZW50VHlwZSkge1xuICAgICAgICB6clV0aWwuYXNzZXJ0KFxuICAgICAgICAgICAgL15bYS16QS1aMC05X10rKFsuXVthLXpBLVowLTlfXSspPyQvLnRlc3QoY29tcG9uZW50VHlwZSksXG4gICAgICAgICAgICAnY29tcG9uZW50VHlwZSBcIicgKyBjb21wb25lbnRUeXBlICsgJ1wiIGlsbGVnYWwnXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXp6LmVuYWJsZUNsYXNzRXh0ZW5kID0gZnVuY3Rpb24gKFJvb3RDbGFzcywgbWFuZGF0b3J5TWV0aG9kcykge1xuXG4gICAgICAgIFJvb3RDbGFzcy4kY29uc3RydWN0b3IgPSBSb290Q2xhc3M7XG4gICAgICAgIFJvb3RDbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvdG8pIHtcblxuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChtYW5kYXRvcnlNZXRob2RzLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvdG9bbWV0aG9kXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdNZXRob2QgYCcgKyBtZXRob2QgKyAnYCBzaG91bGQgYmUgaW1wbGVtZW50ZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAocHJvdG8udHlwZSA/ICcgaW4gJyArIHByb3RvLnR5cGUgOiAnJykgKyAnLidcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1cGVyQ2xhc3MgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIEV4dGVuZGVkQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm90by4kY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8uJGNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgenJVdGlsLmV4dGVuZChFeHRlbmRlZENsYXNzLnByb3RvdHlwZSwgcHJvdG8pO1xuXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLmV4dGVuZCA9IHRoaXMuZXh0ZW5kO1xuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNhbGwgPSBzdXBlckNhbGw7XG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLnN1cGVyQXBwbHkgPSBzdXBlckFwcGx5O1xuICAgICAgICAgICAgenJVdGlsLmluaGVyaXRzKEV4dGVuZGVkQ2xhc3MsIHRoaXMpO1xuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNsYXNzID0gc3VwZXJDbGFzcztcblxuICAgICAgICAgICAgcmV0dXJuIEV4dGVuZGVkQ2xhc3M7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIHN1cGVyQ2FsbCBzaG91bGQgaGF2ZSBjbGFzcyBpbmZvLCB3aGljaCBjYW4gbm90IGJlIGZldGNoIGZyb20gJ3RoaXMnLlxuICAgIC8vIENvbnNpZGVyIHRoaXMgY2FzZTpcbiAgICAvLyBjbGFzcyBBIGhhcyBtZXRob2QgZixcbiAgICAvLyBjbGFzcyBCIGluaGVyaXRzIGNsYXNzIEEsIG92ZXJyaWRlcyBtZXRob2QgZiwgZiBjYWxsIHN1cGVyQXBwbHkoJ2YnKSxcbiAgICAvLyBjbGFzcyBDIGluaGVyaXRzIGNsYXNzIEIsIGRvIG5vdCBvdmVycmlkZXMgbWV0aG9kIGYsXG4gICAgLy8gdGhlbiB3aGVuIG1ldGhvZCBvZiBjbGFzcyBDIGlzIGNhbGxlZCwgZGVhZCBsb29wIG9jY3VyZWQuXG4gICAgZnVuY3Rpb24gc3VwZXJDYWxsKGNvbnRleHQsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSB6clV0aWwuc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VwZXJBcHBseShjb250ZXh0LCBtZXRob2ROYW1lLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kXVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGF6ei5lbmFibGVDbGFzc01hbmFnZW1lbnQgPSBmdW5jdGlvbiAoZW50aXR5LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb25lbnQgbW9kZWwgY2xhc3Nlc1xuICAgICAgICAgKiBrZXk6IGNvbXBvbmVudFR5cGUsXG4gICAgICAgICAqIHZhbHVlOlxuICAgICAgICAgKiAgICAgY29tcG9uZW50Q2xhc3MsIHdoZW4gY29tcG9uZW50VHlwZSBpcyAneHh4J1xuICAgICAgICAgKiAgICAgb3IgT2JqZWN0LjxzdWJLZXksIGNvbXBvbmVudENsYXNzPiwgd2hlbiBjb21wb25lbnRUeXBlIGlzICd4eHgueXknXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHt9O1xuXG4gICAgICAgIGVudGl0eS5yZWdpc3RlckNsYXNzID0gZnVuY3Rpb24gKENsYXp6LCBjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIGNoZWNrQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcblxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50VHlwZS5zdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oY29tcG9uZW50VHlwZS5tYWluICsgJyBleGlzdHMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0gQ2xheno7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudFR5cGUuc3ViICE9PSBJU19DT05UQUlORVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG1ha2VDb250YWluZXIoY29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcltjb21wb25lbnRUeXBlLnN1Yl0gPSBDbGF6ejtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ2xheno7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50aXR5LmdldENsYXNzID0gZnVuY3Rpb24gKGNvbXBvbmVudE1haW5UeXBlLCBzdWJUeXBlLCB0aHJvd1doZW5Ob3RGb3VuZCkge1xuICAgICAgICAgICAgdmFyIENsYXp6ID0gc3RvcmFnZVtjb21wb25lbnRNYWluVHlwZV07XG5cbiAgICAgICAgICAgIGlmIChDbGF6eiAmJiBDbGF6eltJU19DT05UQUlORVJdKSB7XG4gICAgICAgICAgICAgICAgQ2xhenogPSBzdWJUeXBlID8gQ2xhenpbc3ViVHlwZV0gOiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhyb3dXaGVuTm90Rm91bmQgJiYgIUNsYXp6KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAhc3ViVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb21wb25lbnRNYWluVHlwZSArICcuJyArICd0eXBlIHNob3VsZCBiZSBzcGVjaWZpZWQuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAnQ29tcG9uZW50ICcgKyBjb21wb25lbnRNYWluVHlwZSArICcuJyArIChzdWJUeXBlIHx8ICcnKSArICcgbm90IGV4aXN0cy4gTG9hZCBpdCBmaXJzdC4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIENsYXp6O1xuICAgICAgICB9O1xuXG4gICAgICAgIGVudGl0eS5nZXRDbGFzc2VzQnlNYWluVHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHZhciBvYmogPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XG5cbiAgICAgICAgICAgIGlmIChvYmogJiYgb2JqW0lTX0NPTlRBSU5FUl0pIHtcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChvYmosIGZ1bmN0aW9uIChvLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgIT09IElTX0NPTlRBSU5FUiAmJiByZXN1bHQucHVzaChvKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iaik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50aXR5Lmhhc0NsYXNzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIC8vIEp1c3QgY29uc2lkZXIgY29tcG9uZW50VHlwZS5tYWluLlxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuICEhc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gTGlrZSBbJ2FhJywgJ2JiJ10sIGJ1dCBjYW4gbm90IGJlIFsnYWEueHgnXVxuICAgICAgICAgKi9cbiAgICAgICAgZW50aXR5LmdldEFsbENsYXNzTWFpblR5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHR5cGVzID0gW107XG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdG9yYWdlLCBmdW5jdGlvbiAob2JqLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhIG1haW4gdHlwZSBpcyBjb250YWluZXIgYW5kIGhhcyBzdWIgdHlwZXNcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSAgbWFpblR5cGVcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGVudGl0eS5oYXNTdWJUeXBlcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmpbSVNfQ09OVEFJTkVSXTtcbiAgICAgICAgfTtcblxuICAgICAgICBlbnRpdHkucGFyc2VDbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyW0lTX0NPTlRBSU5FUl0pIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl0gPSB7fTtcbiAgICAgICAgICAgICAgICBjb250YWluZXJbSVNfQ09OVEFJTkVSXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxFeHRlbmQgPSBlbnRpdHkuZXh0ZW5kO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgZW50aXR5LmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgRXh0ZW5kZWRDbGFzcyA9IG9yaWdpbmFsRXh0ZW5kLmNhbGwodGhpcywgcHJvdG8pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50aXR5LnJlZ2lzdGVyQ2xhc3MoRXh0ZW5kZWRDbGFzcywgcHJvdG8udHlwZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgY2xhenouc2V0UmVhZE9ubHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIC8vIEZJWE1FIEl0IHNlZW1zIGJyb2tlbiBpbiBJRTggc2ltdWxhdGlvbiBvZiBJRTExXG4gICAgICAgIC8vIGlmICghenJVdGlsLmlzQXJyYXkocHJvcGVydGllcykpIHtcbiAgICAgICAgLy8gICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzICE9IG51bGwgPyBbcHJvcGVydGllc10gOiBbXTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB6clV0aWwuZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAvLyAgICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuXG4gICAgICAgIC8vICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgICAgICAgLy8gICAgICAgICAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgICAgIC8vICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSwgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIC8vICAgICAgICAgfSk7XG4gICAgICAgIC8vICAgICB6clV0aWwuaXNBcnJheShvYmpbcHJvcF0pXG4gICAgICAgIC8vICAgICAgICAgJiYgT2JqZWN0LmZyZWV6ZVxuICAgICAgICAvLyAgICAgICAgICYmIE9iamVjdC5mcmVlemUob2JqW3Byb3BdKTtcbiAgICAgICAgLy8gfSk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gY2xheno7XG4iLCJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgY2xhenogPSByZXF1aXJlKCcuL2NsYXp6Jyk7XG5cbiAgICB2YXIgcGFyc2VDbGFzc1R5cGUgPSBjbGF6ei5wYXJzZUNsYXNzVHlwZTtcblxuICAgIHZhciBiYXNlID0gMDtcblxuICAgIHZhciBjb21wb25lbnRVdGlsID0ge307XG5cbiAgICB2YXIgREVMSU1JVEVSID0gJ18nO1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNvbXBvbmVudFV0aWwuZ2V0VUlEID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgLy8gQ29uc2lkZXJpbmcgdGhlIGNhc2Ugb2YgY3Jvc3NpbmcganMgY29udGV4dCxcbiAgICAgICAgLy8gdXNlIE1hdGgucmFuZG9tIHRvIG1ha2UgaWQgYXMgdW5pcXVlIGFzIHBvc3NpYmxlLlxuICAgICAgICByZXR1cm4gWyh0eXBlIHx8ICcnKSwgYmFzZSsrLCBNYXRoLnJhbmRvbSgpXS5qb2luKERFTElNSVRFUik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGNvbXBvbmVudFV0aWwuZW5hYmxlU3ViVHlwZURlZmF1bHRlciA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcblxuICAgICAgICB2YXIgc3ViVHlwZURlZmF1bHRlcnMgPSB7fTtcblxuICAgICAgICBlbnRpdHkucmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIGRlZmF1bHRlcikge1xuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgc3ViVHlwZURlZmF1bHRlcnNbY29tcG9uZW50VHlwZS5tYWluXSA9IGRlZmF1bHRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICBlbnRpdHkuZGV0ZXJtaW5lU3ViVHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBvcHRpb24pIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gb3B0aW9uLnR5cGU7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50VHlwZU1haW4gPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKS5tYWluO1xuICAgICAgICAgICAgICAgIGlmIChlbnRpdHkuaGFzU3ViVHlwZXMoY29tcG9uZW50VHlwZSkgJiYgc3ViVHlwZURlZmF1bHRlcnNbY29tcG9uZW50VHlwZU1haW5dKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBzdWJUeXBlRGVmYXVsdGVyc1tjb21wb25lbnRUeXBlTWFpbl0ob3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUb3BvbG9naWNhbCB0cmF2ZWwgb24gQWN0aXZpdHkgTmV0d29yayAoQWN0aXZpdHkgT24gVmVydGljZXMpLlxuICAgICAqIERlcGVuZGVuY2llcyBpcyBkZWZpbmVkIGluIE1vZGVsLnByb3RvdHlwZS5kZXBlbmRlbmNpZXMsIGxpa2UgWyd4QXhpcycsICd5QXhpcyddLlxuICAgICAqXG4gICAgICogSWYgJ3hBeGlzJyBvciAneUF4aXMnIGlzIGFic2VudCBpbiBjb21wb25lbnRUeXBlTGlzdCwganVzdCBpZ25vcmUgaXQgaW4gdG9wb2xvZ3kuXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBpcyBjaXJjbGUgZGVwZW5kZW5jZXksIEVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqXG4gICAgICovXG4gICAgY29tcG9uZW50VXRpbC5lbmFibGVUb3BvbG9naWNhbFRyYXZlbCA9IGZ1bmN0aW9uIChlbnRpdHksIGRlcGVuZGVuY3lHZXR0ZXIpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSB0YXJnZXROYW1lTGlzdCBUYXJnZXQgQ29tcG9uZW50IHR5cGUgbGlzdC5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlIFsnYWEnLCAnYmInLCAnYWEueHgnXVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBmdWxsTmFtZUxpc3QgQnkgd2hpY2ggd2UgY2FuIGJ1aWxkIGRlcGVuZGVuY3kgZ3JhcGguXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFBhcmFtczogY29tcG9uZW50VHlwZSwgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBTY29wZSBvZiBjYWxsYmFjay5cbiAgICAgICAgICovXG4gICAgICAgIGVudGl0eS50b3BvbG9naWNhbFRyYXZlbCA9IGZ1bmN0aW9uICh0YXJnZXROYW1lTGlzdCwgZnVsbE5hbWVMaXN0LCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKCF0YXJnZXROYW1lTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtYWtlRGVwbmRlbmN5R3JhcGgoZnVsbE5hbWVMaXN0KTtcbiAgICAgICAgICAgIHZhciBncmFwaCA9IHJlc3VsdC5ncmFwaDtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IHJlc3VsdC5ub0VudHJ5TGlzdDtcblxuICAgICAgICAgICAgdmFyIHRhcmdldE5hbWVTZXQgPSB7fTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRhcmdldE5hbWVMaXN0LCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldE5hbWVTZXRbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyckNvbXBvbmVudFR5cGUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclZlcnRleCA9IGdyYXBoW2N1cnJDb21wb25lbnRUeXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgaXNJblRhcmdldE5hbWVTZXQgPSAhIXRhcmdldE5hbWVTZXRbY3VyckNvbXBvbmVudFR5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChpc0luVGFyZ2V0TmFtZVNldCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGN1cnJDb21wb25lbnRUeXBlLCBjdXJyVmVydGV4Lm9yaWdpbmFsRGVwcy5zbGljZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldE5hbWVTZXRbY3VyckNvbXBvbmVudFR5cGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChcbiAgICAgICAgICAgICAgICAgICAgY3VyclZlcnRleC5zdWNjZXNzb3IsXG4gICAgICAgICAgICAgICAgICAgIGlzSW5UYXJnZXROYW1lU2V0ID8gcmVtb3ZlRWRnZUFuZEFkZCA6IHJlbW92ZUVkZ2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6clV0aWwuZWFjaCh0YXJnZXROYW1lU2V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgZGVwZW5kZW5jeSBtYXkgZXhpc3RzJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRWRnZShzdWNjQ29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIGdyYXBoW3N1Y2NDb21wb25lbnRUeXBlXS5lbnRyeUNvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKGdyYXBoW3N1Y2NDb21wb25lbnRUeXBlXS5lbnRyeUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goc3VjY0NvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiBsZWdlbmQgZGVwZW5kcyBvbiBzZXJpZXMsIGFuZCB3ZSBjYWxsXG4gICAgICAgICAgICAvLyBjaGFydC5zZXRPcHRpb24oe3NlcmllczogWy4uLl19KSwgd2hlcmUgb25seSBzZXJpZXMgaXMgaW4gb3B0aW9uLlxuICAgICAgICAgICAgLy8gSWYgd2UgZG8gbm90IGhhdmUgJ3JlbW92ZUVkZ2VBbmRBZGQnLCBsZWdlbmRNb2RlbC5tZXJnZU9wdGlvbiB3aWxsXG4gICAgICAgICAgICAvLyBub3QgYmUgY2FsbGVkLCBidXQgb25seSBzZXJlaXMubWVyZ2VPcHRpb24gaXMgY2FsbGVkLiBUaHVzIGxlZ2VuZFxuICAgICAgICAgICAgLy8gaGF2ZSBubyBjaGFuY2UgdG8gdXBkYXRlIGl0cyBsb2NhbCByZWNvcmQgYWJvdXQgc2VyaWVzIChsaWtlIHdoaWNoXG4gICAgICAgICAgICAvLyBuYW1lIG9mIHNlcmllcyBpcyBhdmFpbGFibGUgaW4gbGVnZW5kKS5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZUVkZ2VBbmRBZGQoc3VjY0NvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXROYW1lU2V0W3N1Y2NDb21wb25lbnRUeXBlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRWRnZShzdWNjQ29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlcG5kZW5jeUdyYXBoOiB7T2JqZWN0fVxuICAgICAgICAgKiBrZXk6IGNvbnBvbmVudFR5cGUsXG4gICAgICAgICAqIHZhbHVlOiB7XG4gICAgICAgICAqICAgICBzdWNjZXNzb3I6IFtjb25wb25lbnRUeXBlcy4uLl0sXG4gICAgICAgICAqICAgICBvcmlnaW5hbERlcHM6IFtjb25wb25lbnRUeXBlcy4uLl0sXG4gICAgICAgICAqICAgICBlbnRyeUNvdW50OiB7bnVtYmVyfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBtYWtlRGVwbmRlbmN5R3JhcGgoZnVsbE5hbWVMaXN0KSB7XG4gICAgICAgICAgICB2YXIgZ3JhcGggPSB7fTtcbiAgICAgICAgICAgIHZhciBub0VudHJ5TGlzdCA9IFtdO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChmdWxsTmFtZUxpc3QsIGZ1bmN0aW9uIChuYW1lKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGhpc0l0ZW0gPSBjcmVhdGVEZXBlbmRlbmN5R3JhcGhJdGVtKGdyYXBoLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxEZXBzID0gdGhpc0l0ZW0ub3JpZ2luYWxEZXBzID0gZGVwZW5kZW5jeUdldHRlcihuYW1lKTtcblxuICAgICAgICAgICAgICAgIHZhciBhdmFpbGFibGVEZXBzID0gZ2V0QXZhaWxhYmxlRGVwZW5kZW5jaWVzKG9yaWdpbmFsRGVwcywgZnVsbE5hbWVMaXN0KTtcbiAgICAgICAgICAgICAgICB0aGlzSXRlbS5lbnRyeUNvdW50ID0gYXZhaWxhYmxlRGVwcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNJdGVtLmVudHJ5Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9FbnRyeUxpc3QucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChhdmFpbGFibGVEZXBzLCBmdW5jdGlvbiAoZGVwZW5kZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoenJVdGlsLmluZGV4T2YodGhpc0l0ZW0ucHJlZGVjZXNzb3IsIGRlcGVuZGVudE5hbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0l0ZW0ucHJlZGVjZXNzb3IucHVzaChkZXBlbmRlbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdEl0ZW0gPSBjcmVhdGVEZXBlbmRlbmN5R3JhcGhJdGVtKGdyYXBoLCBkZXBlbmRlbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKHRoYXRJdGVtLnN1Y2Nlc3NvciwgZGVwZW5kZW50TmFtZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0SXRlbS5zdWNjZXNzb3IucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7Z3JhcGg6IGdyYXBoLCBub0VudHJ5TGlzdDogbm9FbnRyeUxpc3R9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRGVwZW5kZW5jeUdyYXBoSXRlbShncmFwaCwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKCFncmFwaFtuYW1lXSkge1xuICAgICAgICAgICAgICAgIGdyYXBoW25hbWVdID0ge3ByZWRlY2Vzc29yOiBbXSwgc3VjY2Vzc29yOiBbXX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ3JhcGhbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRBdmFpbGFibGVEZXBlbmRlbmNpZXMob3JpZ2luYWxEZXBzLCBmdWxsTmFtZUxpc3QpIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVEZXBzID0gW107XG4gICAgICAgICAgICB6clV0aWwuZWFjaChvcmlnaW5hbERlcHMsIGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgICAgICB6clV0aWwuaW5kZXhPZihmdWxsTmFtZUxpc3QsIGRlcCkgPj0gMCAmJiBhdmFpbGFibGVEZXBzLnB1c2goZGVwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZURlcHM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb21wb25lbnRVdGlsO1xuIiwiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuL251bWJlcicpO1xuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xuXG4gICAgdmFyIGZvcm1hdFV0aWwgPSB7fTtcbiAgICAvKipcbiAgICAgKiDmr4/kuInkvY3pu5jorqTliqAs5qC85byP5YyWXG4gICAgICogQHR5cGUge3N0cmluZ3xudW1iZXJ9IHhcbiAgICAgKi9cbiAgICBmb3JtYXRVdGlsLmFkZENvbW1hcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmIChpc05hTih4KSkge1xuICAgICAgICAgICAgcmV0dXJuICctJztcbiAgICAgICAgfVxuICAgICAgICB4ID0gKHggKyAnJykuc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHhbMF0ucmVwbGFjZSgvKFxcZHsxLDN9KSg/PSg/OlxcZHszfSkrKD8hXFxkKSkvZywnJDEsJylcbiAgICAgICAgICAgICAgICsgKHgubGVuZ3RoID4gMSA/ICgnLicgKyB4WzFdKSA6ICcnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwcGVyQ2FzZUZpcnN0PWZhbHNlXVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAgICovXG4gICAgZm9ybWF0VXRpbC50b0NhbWVsQ2FzZSA9IGZ1bmN0aW9uIChzdHIsIHVwcGVyQ2FzZUZpcnN0KSB7XG4gICAgICAgIHN0ciA9IChzdHIgfHwgJycpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbihtYXRjaCwgZ3JvdXAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAxLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh1cHBlckNhc2VGaXJzdCAmJiBzdHIpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBjc3MgbGlrZWQgYXJyYXkgY29uZmlndXJhdGlvblxuICAgICAqIGUuZy5cbiAgICAgKiAgMyA9PiBbMywgMywgMywgM11cbiAgICAgKiAgWzQsIDJdID0+IFs0LCAyLCA0LCAyXVxuICAgICAqICBbNCwgMywgMl0gPT4gWzQsIDMsIDIsIDNdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHZhbFxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mICh2YWwpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsLCB2YWxdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICAgICAgLy8gdmVydGljYWwgfCBob3Jpem9udGFsXG4gICAgICAgICAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMF0sIHZhbFsxXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID09PSAzKSB7XG4gICAgICAgICAgICAvLyB0b3AgfCBob3Jpem9udGFsIHwgYm90dG9tXG4gICAgICAgICAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMl0sIHZhbFsxXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgdmFyIGVuY29kZUhUTUwgPSBmb3JtYXRVdGlsLmVuY29kZUhUTUwgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoc291cmNlKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpO1xuICAgIH07XG5cbiAgICB2YXIgVFBMX1ZBUl9BTElBUyA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZyddO1xuXG4gICAgdmFyIHdyYXBWYXIgPSBmdW5jdGlvbiAodmFyTmFtZSwgc2VyaWVzSWR4KSB7XG4gICAgICAgIHJldHVybiAneycgKyB2YXJOYW1lICsgKHNlcmllc0lkeCA9PSBudWxsID8gJycgOiBzZXJpZXNJZHgpICsgJ30nO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZW1wbGF0ZSBmb3JtYXR0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHBsXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0PnxPYmplY3R9IHBhcmFtc0xpc3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmNvZGU9ZmFsc2VdXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwuZm9ybWF0VHBsID0gZnVuY3Rpb24gKHRwbCwgcGFyYW1zTGlzdCwgZW5jb2RlKSB7XG4gICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkocGFyYW1zTGlzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtc0xpc3QgPSBbcGFyYW1zTGlzdF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlcmllc0xlbiA9IHBhcmFtc0xpc3QubGVuZ3RoO1xuICAgICAgICBpZiAoIXNlcmllc0xlbikge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyICR2YXJzID0gcGFyYW1zTGlzdFswXS4kdmFycyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAkdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFsaWFzID0gVFBMX1ZBUl9BTElBU1tpXTtcbiAgICAgICAgICAgIHZhciB2YWwgPSB3cmFwVmFyKGFsaWFzLCAwKTtcbiAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKHdyYXBWYXIoYWxpYXMpLCBlbmNvZGUgPyBlbmNvZGVIVE1MKHZhbCkgOiB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHNlcmllc0lkeCA9IDA7IHNlcmllc0lkeCA8IHNlcmllc0xlbjsgc2VyaWVzSWR4KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgJHZhcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gcGFyYW1zTGlzdFtzZXJpZXNJZHhdWyR2YXJzW2tdXTtcbiAgICAgICAgICAgICAgICB0cGwgPSB0cGwucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgd3JhcFZhcihUUExfVkFSX0FMSUFTW2tdLCBzZXJpZXNJZHgpLFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGUgPyBlbmNvZGVIVE1MKHZhbCkgOiB2YWxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRwbDtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBzMmQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIgPCAxMCA/ICgnMCcgKyBzdHIpIDogc3RyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJU08gRGF0ZSBmb3JtYXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHBsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZm9ybWF0VXRpbC5mb3JtYXRUaW1lID0gZnVuY3Rpb24gKHRwbCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRwbCA9PT0gJ3dlZWsnXG4gICAgICAgICAgICB8fCB0cGwgPT09ICdtb250aCdcbiAgICAgICAgICAgIHx8IHRwbCA9PT0gJ3F1YXJ0ZXInXG4gICAgICAgICAgICB8fCB0cGwgPT09ICdoYWxmLXllYXInXG4gICAgICAgICAgICB8fCB0cGwgPT09ICd5ZWFyJ1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHRwbCA9ICdNTS1kZFxcbnl5eXknO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGUgPSBudW1iZXJVdGlsLnBhcnNlRGF0ZSh2YWx1ZSk7XG4gICAgICAgIHZhciB5ID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICB2YXIgTSA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICAgIHZhciBkID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICAgIHZhciBoID0gZGF0ZS5nZXRIb3VycygpO1xuICAgICAgICB2YXIgbSA9IGRhdGUuZ2V0TWludXRlcygpO1xuICAgICAgICB2YXIgcyA9IGRhdGUuZ2V0U2Vjb25kcygpO1xuXG4gICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKCdNTScsIHMyZChNKSlcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAucmVwbGFjZSgneXl5eScsIHkpXG4gICAgICAgICAgICAucmVwbGFjZSgneXknLCB5ICUgMTAwKVxuICAgICAgICAgICAgLnJlcGxhY2UoJ2RkJywgczJkKGQpKVxuICAgICAgICAgICAgLnJlcGxhY2UoJ2QnLCBkKVxuICAgICAgICAgICAgLnJlcGxhY2UoJ2hoJywgczJkKGgpKVxuICAgICAgICAgICAgLnJlcGxhY2UoJ2gnLCBoKVxuICAgICAgICAgICAgLnJlcGxhY2UoJ21tJywgczJkKG0pKVxuICAgICAgICAgICAgLnJlcGxhY2UoJ20nLCBtKVxuICAgICAgICAgICAgLnJlcGxhY2UoJ3NzJywgczJkKHMpKVxuICAgICAgICAgICAgLnJlcGxhY2UoJ3MnLCBzKTtcblxuICAgICAgICByZXR1cm4gdHBsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYXBpdGFsIGZpcnN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBmb3JtYXRVdGlsLmNhcGl0YWxGaXJzdCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ciA/IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHIoMSkgOiBzdHI7XG4gICAgfTtcblxuICAgIGZvcm1hdFV0aWwudHJ1bmNhdGVUZXh0ID0gdGV4dENvbnRhaW4udHJ1bmNhdGVUZXh0O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmb3JtYXRVdGlsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgcGF0aFRvb2wgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi90b29sL3BhdGgnKTtcbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoJyk7XG4gICAgdmFyIGNvbG9yVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3InKTtcbiAgICB2YXIgbWF0cml4ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9tYXRyaXgnKTtcbiAgICB2YXIgdmVjdG9yID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcblxuICAgIHZhciBncmFwaGljID0ge307XG5cbiAgICBncmFwaGljLkdyb3VwID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwJyk7XG5cbiAgICBncmFwaGljLkltYWdlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZScpO1xuXG4gICAgZ3JhcGhpYy5UZXh0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0Jyk7XG5cbiAgICBncmFwaGljLkNpcmNsZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlJyk7XG5cbiAgICBncmFwaGljLlNlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yJyk7XG5cbiAgICBncmFwaGljLlJpbmcgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcnKTtcblxuICAgIGdyYXBoaWMuUG9seWdvbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbicpO1xuXG4gICAgZ3JhcGhpYy5Qb2x5bGluZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUnKTtcblxuICAgIGdyYXBoaWMuUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdCcpO1xuXG4gICAgZ3JhcGhpYy5MaW5lID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lJyk7XG5cbiAgICBncmFwaGljLkJlemllckN1cnZlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZScpO1xuXG4gICAgZ3JhcGhpYy5BcmMgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYycpO1xuXG4gICAgZ3JhcGhpYy5Db21wb3VuZFBhdGggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0NvbXBvdW5kUGF0aCcpO1xuXG4gICAgZ3JhcGhpYy5MaW5lYXJHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQnKTtcblxuICAgIGdyYXBoaWMuUmFkaWFsR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50Jyk7XG5cbiAgICBncmFwaGljLkJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgc2hhcGUgd2l0aCBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgZ3JhcGhpYy5leHRlbmRTaGFwZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIHJldHVybiBQYXRoLmV4dGVuZChvcHRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIHBhdGhcbiAgICAgKi9cbiAgICBncmFwaGljLmV4dGVuZFBhdGggPSBmdW5jdGlvbiAocGF0aERhdGEsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhUb29sLmV4dGVuZEZyb21TdHJpbmcocGF0aERhdGEsIG9wdHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBwYXRoIGVsZW1lbnQgZnJvbSBwYXRoIGRhdGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhEYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYXlvdXQ9Y292ZXJdICdjZW50ZXInIG9yICdjb3ZlcidcbiAgICAgKi9cbiAgICBncmFwaGljLm1ha2VQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBvcHRzLCByZWN0LCBsYXlvdXQpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoVG9vbC5jcmVhdGVGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICB2YXIgYXNwZWN0ID0gYm91bmRpbmdSZWN0LndpZHRoIC8gYm91bmRpbmdSZWN0LmhlaWdodDtcblxuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgcmVjdCB0byBjZW50ZXIsIGtlZXAgd2lkdGggLyBoZWlnaHQgcmF0aW8uXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVjdC5oZWlnaHQgKiBhc3BlY3Q7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPD0gcmVjdC53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjeCA9IHJlY3QueCArIHJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHZhciBjeSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgICAgIHJlY3QueCA9IGN4IC0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHJlY3QueSA9IGN5IC0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICByZWN0LndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyYXBoaWMucmVzaXplUGF0aChwYXRoLCByZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuXG4gICAgZ3JhcGhpYy5tZXJnZVBhdGggPSBwYXRoVG9vbC5tZXJnZVBhdGgsXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgYSBwYXRoIHRvIGZpdCB0aGUgcmVjdFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcbiAgICAgKi9cbiAgICBncmFwaGljLnJlc2l6ZVBhdGggPSBmdW5jdGlvbiAocGF0aCwgcmVjdCkge1xuICAgICAgICBpZiAoIXBhdGguYXBwbHlUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXRoUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG5cbiAgICAgICAgdmFyIG0gPSBwYXRoUmVjdC5jYWxjdWxhdGVUcmFuc2Zvcm0ocmVjdCk7XG5cbiAgICAgICAgcGF0aC5hcHBseVRyYW5zZm9ybShtKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIGxpbmUgZm9yIGNhbnZhc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zaGFwZV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngxXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueTFdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54Ml1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnkyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zdHlsZS5saW5lV2lkdGhdXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBNb2RpZmllZCBwYXJhbVxuICAgICAqL1xuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgdmFyIHN1YlBpeGVsT3B0aW1pemUgPSBncmFwaGljLnN1YlBpeGVsT3B0aW1pemU7XG4gICAgICAgIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xuICAgICAgICB2YXIgbGluZVdpZHRoID0gcGFyYW0uc3R5bGUubGluZVdpZHRoO1xuXG4gICAgICAgIGlmIChyb3VuZChzaGFwZS54MSAqIDIpID09PSByb3VuZChzaGFwZS54MiAqIDIpKSB7XG4gICAgICAgICAgICBzaGFwZS54MSA9IHNoYXBlLngyID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS54MSwgbGluZVdpZHRoLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91bmQoc2hhcGUueTEgKiAyKSA9PT0gcm91bmQoc2hhcGUueTIgKiAyKSkge1xuICAgICAgICAgICAgc2hhcGUueTEgPSBzaGFwZS55MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueTEsIGxpbmVXaWR0aCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdWIgcGl4ZWwgb3B0aW1pemUgcmVjdCBmb3IgY2FudmFzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnldXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS53aWR0aF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnN0eWxlXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cbiAgICAgKi9cbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVSZWN0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHZhciBzdWJQaXhlbE9wdGltaXplID0gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplO1xuICAgICAgICB2YXIgc2hhcGUgPSBwYXJhbS5zaGFwZTtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHBhcmFtLnN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIG9yaWdpblggPSBzaGFwZS54O1xuICAgICAgICB2YXIgb3JpZ2luWSA9IHNoYXBlLnk7XG4gICAgICAgIHZhciBvcmlnaW5XaWR0aCA9IHNoYXBlLndpZHRoO1xuICAgICAgICB2YXIgb3JpZ2luSGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICAgICAgICBzaGFwZS54ID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS54LCBsaW5lV2lkdGgsIHRydWUpO1xuICAgICAgICBzaGFwZS55ID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS55LCBsaW5lV2lkdGgsIHRydWUpO1xuICAgICAgICBzaGFwZS53aWR0aCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5YICsgb3JpZ2luV2lkdGgsIGxpbmVXaWR0aCwgZmFsc2UpIC0gc2hhcGUueCxcbiAgICAgICAgICAgIG9yaWdpbldpZHRoID09PSAwID8gMCA6IDFcbiAgICAgICAgKTtcbiAgICAgICAgc2hhcGUuaGVpZ2h0ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICBzdWJQaXhlbE9wdGltaXplKG9yaWdpblkgKyBvcmlnaW5IZWlnaHQsIGxpbmVXaWR0aCwgZmFsc2UpIC0gc2hhcGUueSxcbiAgICAgICAgICAgIG9yaWdpbkhlaWdodCA9PT0gMCA/IDAgOiAxXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIGZvciBjYW52YXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBDb29yZGluYXRlLCBzdWNoIGFzIHgsIHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFNob3VsZCBiZSBub25uZWdhdGl2ZSBpbnRlZ2VyLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHBvc2l0aXZlT3JOZWdhdGl2ZSBEZWZhdWx0IGZhbHNlIChuZWdhdGl2ZSkuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBPcHRpbWl6ZWQgcG9zaXRpb24uXG4gICAgICovXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBsaW5lV2lkdGgsIHBvc2l0aXZlT3JOZWdhdGl2ZSkge1xuICAgICAgICAvLyBBc3N1cmUgdGhhdCAocG9zaXRpb24gKyBsaW5lV2lkdGggLyAyKSBpcyBuZWFyIGludGVnZXIgZWRnZSxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGxpbmUgd2lsbCBiZSBmdXp6eSBpbiBjYW52YXMuXG4gICAgICAgIHZhciBkb3VibGVkUG9zaXRpb24gPSByb3VuZChwb3NpdGlvbiAqIDIpO1xuICAgICAgICByZXR1cm4gKGRvdWJsZWRQb3NpdGlvbiArIHJvdW5kKGxpbmVXaWR0aCkpICUgMiA9PT0gMFxuICAgICAgICAgICAgPyBkb3VibGVkUG9zaXRpb24gLyAyXG4gICAgICAgICAgICA6IChkb3VibGVkUG9zaXRpb24gKyAocG9zaXRpdmVPck5lZ2F0aXZlID8gMSA6IC0xKSkgLyAyO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYXNGaWxsT3JTdHJva2UoZmlsbE9yU3Ryb2tlKSB7XG4gICAgICAgIHJldHVybiBmaWxsT3JTdHJva2UgIT0gbnVsbCAmJiBmaWxsT3JTdHJva2UgIT0gJ25vbmUnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpZnRDb2xvcihjb2xvcikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyA/IGNvbG9yVG9vbC5saWZ0KGNvbG9yLCAtMC4xKSA6IGNvbG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FjaGVFbGVtZW50U3RsKGVsKSB7XG4gICAgICAgIGlmIChlbC5fX2hvdmVyU3RsRGlydHkpIHtcbiAgICAgICAgICAgIHZhciBzdHJva2UgPSBlbC5zdHlsZS5zdHJva2U7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IGVsLnN0eWxlLmZpbGw7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBob3ZlclN0eWxlIG9uIG1vdXNlb3ZlclxuICAgICAgICAgICAgdmFyIGhvdmVyU3R5bGUgPSBlbC5fX2hvdmVyU3RsO1xuICAgICAgICAgICAgaG92ZXJTdHlsZS5maWxsID0gaG92ZXJTdHlsZS5maWxsXG4gICAgICAgICAgICAgICAgfHwgKGhhc0ZpbGxPclN0cm9rZShmaWxsKSA/IGxpZnRDb2xvcihmaWxsKSA6IG51bGwpO1xuICAgICAgICAgICAgaG92ZXJTdHlsZS5zdHJva2UgPSBob3ZlclN0eWxlLnN0cm9rZVxuICAgICAgICAgICAgICAgIHx8IChoYXNGaWxsT3JTdHJva2Uoc3Ryb2tlKSA/IGxpZnRDb2xvcihzdHJva2UpIDogbnVsbCk7XG5cbiAgICAgICAgICAgIHZhciBub3JtYWxTdHlsZSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBob3ZlclN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyU3R5bGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsU3R5bGVbbmFtZV0gPSBlbC5zdHlsZVtuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLl9fbm9ybWFsU3RsID0gbm9ybWFsU3R5bGU7XG5cbiAgICAgICAgICAgIGVsLl9faG92ZXJTdGxEaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb1NpbmdsZUVudGVySG92ZXIoZWwpIHtcbiAgICAgICAgaWYgKGVsLl9faXNIb3Zlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FjaGVFbGVtZW50U3RsKGVsKTtcblxuICAgICAgICBpZiAoZWwudXNlSG92ZXJMYXllcikge1xuICAgICAgICAgICAgZWwuX196ciAmJiBlbC5fX3pyLmFkZEhvdmVyKGVsLCBlbC5fX2hvdmVyU3RsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnNldFN0eWxlKGVsLl9faG92ZXJTdGwpO1xuICAgICAgICAgICAgZWwuejIgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLl9faXNIb3ZlciA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKSB7XG4gICAgICAgIGlmICghZWwuX19pc0hvdmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9ybWFsU3RsID0gZWwuX19ub3JtYWxTdGw7XG4gICAgICAgIGlmIChlbC51c2VIb3ZlckxheWVyKSB7XG4gICAgICAgICAgICBlbC5fX3pyICYmIGVsLl9fenIucmVtb3ZlSG92ZXIoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9ybWFsU3RsICYmIGVsLnNldFN0eWxlKG5vcm1hbFN0bCk7XG4gICAgICAgICAgICBlbC56MiAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuX19pc0hvdmVyID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9FbnRlckhvdmVyKGVsKSB7XG4gICAgICAgIGVsLnR5cGUgPT09ICdncm91cCdcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09ICdncm91cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9TaW5nbGVFbnRlckhvdmVyKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBkb1NpbmdsZUVudGVySG92ZXIoZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvTGVhdmVIb3ZlcihlbCkge1xuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXG4gICAgICAgICAgICA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvU2luZ2xlTGVhdmVIb3ZlcihjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRFbGVtZW50SG92ZXJTdGwoZWwsIGhvdmVyU3RsKSB7XG4gICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIHNlcGNpZmllZCBob3ZlclN0eWxlLCB0aGVuIHVzZSBpdCBpbnN0ZWFkIG9mIGdpdmVuIGhvdmVyU3R5bGVcbiAgICAgICAgLy8gT2Z0ZW4gdXNlZCB3aGVuIGl0ZW0gZ3JvdXAgaGFzIGEgbGFiZWwgZWxlbWVudCBhbmQgaXQncyBob3ZlclN0eWxlIGlzIGRpZmZlcmVudFxuICAgICAgICBlbC5fX2hvdmVyU3RsID0gZWwuaG92ZXJTdHlsZSB8fCBob3ZlclN0bCB8fCB7fTtcbiAgICAgICAgZWwuX19ob3ZlclN0bERpcnR5ID0gdHJ1ZTtcblxuICAgICAgICBpZiAoZWwuX19pc0hvdmVyKSB7XG4gICAgICAgICAgICBjYWNoZUVsZW1lbnRTdGwoZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdmVyKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX19ob3ZlclNpbGVudE9uVG91Y2ggJiYgZS56ckJ5VG91Y2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgaWYgZWxlbWVudCBpcyBub3QgaW4gZW1waGFzaXMgc3RhdHVzXG4gICAgICAgICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0VudGVySG92ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdXQoZSkge1xuICAgICAgICBpZiAodGhpcy5fX2hvdmVyU2lsZW50T25Ub3VjaCAmJiBlLnpyQnlUb3VjaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBpZiBlbGVtZW50IGlzIG5vdCBpbiBlbXBoYXNpcyBzdGF0dXNcbiAgICAgICAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvTGVhdmVIb3Zlcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbnRlckVtcGhhc2lzKCkge1xuICAgICAgICB0aGlzLl9faXNFbXBoYXNpcyA9IHRydWU7XG4gICAgICAgIGRvRW50ZXJIb3Zlcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZWF2ZUVtcGhhc2lzKCkge1xuICAgICAgICB0aGlzLl9faXNFbXBoYXNpcyA9IGZhbHNlO1xuICAgICAgICBkb0xlYXZlSG92ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGhvdmVyIHN0eWxlIG9mIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtob3ZlclN0eWxlXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5ob3ZlclNpbGVudE9uVG91Y2g9ZmFsc2VdXG4gICAgICogICAgICAgIEluIHRvdWNoIGRldmljZSwgbW91c2VvdmVyIGV2ZW50IHdpbGwgYmUgdHJpZ2dlciBvbiB0b3VjaHN0YXJ0IGV2ZW50XG4gICAgICogICAgICAgIChzZWUgbW9kdWxlOnpyZW5kZXIvZG9tL0hhbmRsZXJQcm94eSkuIEJ5IHRoaXMgbWVjaGFuaXNtLCB3ZSBjYW5cbiAgICAgKiAgICAgICAgY29udmluaWVudGx5IHVzZSBob3ZlclN0eWxlIHdoZW4gdGFwIG9uIHRvdWNoIHNjcmVlbiB3aXRob3V0IGFkZGl0aW9uYWxcbiAgICAgKiAgICAgICAgY29kZSBmb3IgY29tcGF0aWJpbGl0eS5cbiAgICAgKiAgICAgICAgQnV0IGlmIHRoZSBjaGFydC9jb21wb25lbnQgaGFzIHNlbGVjdCBmZWF0dXJlLCB3aGljaCB1c3VhbGx5IGFsc28gdXNlXG4gICAgICogICAgICAgIGhvdmVyU3R5bGUsIHRoZXJlIG1pZ2h0IGJlIGNvbmZsaWN0IGJldHdlZW4gJ3NlbGVjdC1oaWdobGlnaHQnIGFuZFxuICAgICAqICAgICAgICAnaG92ZXItaGlnaGxpZ2h0JyBlc3BlY2lhbGx5IHdoZW4gcm9hbSBpcyBlbmFibGVkIChzZWUgZ2VvIGZvciBleGFtcGxlKS5cbiAgICAgKiAgICAgICAgSW4gdGhpcyBjYXNlLCBob3ZlclNpbGVudE9uVG91Y2ggc2hvdWxkIGJlIHVzZWQgdG8gZGlzYWJsZSBob3Zlci1oaWdobGlnaHRcbiAgICAgKiAgICAgICAgb24gdG91Y2ggZGV2aWNlLlxuICAgICAqL1xuICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZSA9IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSwgb3B0KSB7XG4gICAgICAgIGVsLl9faG92ZXJTaWxlbnRPblRvdWNoID0gb3B0ICYmIG9wdC5ob3ZlclNpbGVudE9uVG91Y2g7XG5cbiAgICAgICAgZWwudHlwZSA9PT0gJ2dyb3VwJ1xuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50SG92ZXJTdGwoY2hpbGQsIGhvdmVyU3R5bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IHNldEVsZW1lbnRIb3ZlclN0bChlbCwgaG92ZXJTdHlsZSk7XG5cbiAgICAgICAgLy8gRHVwbGljYXRlZCBmdW5jdGlvbiB3aWxsIGJlIGF1dG8taWdub3JlZCwgc2VlIEV2ZW50ZnVsLmpzLlxuICAgICAgICBlbC5vbignbW91c2VvdmVyJywgb25FbGVtZW50TW91c2VPdmVyKVxuICAgICAgICAgIC5vbignbW91c2VvdXQnLCBvbkVsZW1lbnRNb3VzZU91dCk7XG5cbiAgICAgICAgLy8gRW1waGFzaXMsIG5vcm1hbCBjYW4gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5XG4gICAgICAgIGVsLm9uKCdlbXBoYXNpcycsIGVudGVyRW1waGFzaXMpXG4gICAgICAgICAgLm9uKCdub3JtYWwnLCBsZWF2ZUVtcGhhc2lzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRleHQgb3B0aW9uIGluIHRoZSBzdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXh0U3R5bGVcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBsYWJlbE1vZGVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICovXG4gICAgZ3JhcGhpYy5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHRTdHlsZSwgbGFiZWxNb2RlbCwgY29sb3IpIHtcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Bvc2l0aW9uJykgfHwgJ2luc2lkZSc7XG4gICAgICAgIHZhciBsYWJlbE9mZnNldCA9IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnb2Zmc2V0Jyk7XG4gICAgICAgIHZhciBsYWJlbENvbG9yID0gbGFiZWxQb3NpdGlvbi5pbmRleE9mKCdpbnNpZGUnKSA+PSAwID8gJ3doaXRlJyA6IGNvbG9yO1xuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICAgICAgenJVdGlsLmV4dGVuZCh0ZXh0U3R5bGUsIHtcbiAgICAgICAgICAgIHRleHREaXN0YW5jZTogbGFiZWxNb2RlbC5nZXRTaGFsbG93KCdkaXN0YW5jZScpIHx8IDUsXG4gICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgdGV4dFBvc2l0aW9uOiBsYWJlbFBvc2l0aW9uLFxuICAgICAgICAgICAgdGV4dE9mZnNldDogbGFiZWxPZmZzZXQsXG4gICAgICAgICAgICB0ZXh0RmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCkgfHwgbGFiZWxDb2xvclxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYW5pbWF0ZU9yU2V0UHJvcHMoaXNVcGRhdGUsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGRhdGFJbmRleDtcbiAgICAgICAgICAgIGRhdGFJbmRleCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IGNoZWNrICdhbmltYXRpb24nIHByb3BlcnR5IGRpcmVjdGx5IGhlcmUuIENvbnNpZGVyIHRoaXMgY2FzZTpcbiAgICAgICAgLy8gYW5pbWF0aW9uIG1vZGVsIGlzIGFuIGBpdGVtTW9kZWxgLCB3aG9zZSBkb2VzIG5vdCBoYXZlIGBpc0FuaW1hdGlvbkVuYWJsZWRgXG4gICAgICAgIC8vIGJ1dCBpdHMgcGFyZW50IG1vZGVsIChgc2VyaWVzTW9kZWxgKSBkb2VzLlxuICAgICAgICB2YXIgYW5pbWF0aW9uRW5hYmxlZCA9IGFuaW1hdGFibGVNb2RlbCAmJiBhbmltYXRhYmxlTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCk7XG5cbiAgICAgICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciBwb3N0Zml4ID0gaXNVcGRhdGUgPyAnVXBkYXRlJyA6ICcnO1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkR1cmF0aW9uJyArIHBvc3RmaXgpO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkVhc2luZyA9IGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25FYXNpbmcnICsgcG9zdGZpeCk7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uRGVsYXkgPSBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uRGVsYXknICsgcG9zdGZpeCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFuaW1hdGlvbkRlbGF5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRGVsYXkgPSBhbmltYXRpb25EZWxheShcbiAgICAgICAgICAgICAgICAgICAgZGF0YUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRhYmxlTW9kZWwuZ2V0QW5pbWF0aW9uRGVsYXlQYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYW5pbWF0YWJsZU1vZGVsLmdldEFuaW1hdGlvbkRlbGF5UGFyYW1zKGVsLCBkYXRhSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24oZGF0YUluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHVyYXRpb24gPiAwXG4gICAgICAgICAgICAgICAgPyBlbC5hbmltYXRlVG8ocHJvcHMsIGR1cmF0aW9uLCBhbmltYXRpb25EZWxheSB8fCAwLCBhbmltYXRpb25FYXNpbmcsIGNiKVxuICAgICAgICAgICAgICAgIDogKGVsLmF0dHIocHJvcHMpLCBjYiAmJiBjYigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLmF0dHIocHJvcHMpO1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBncmFwaGljIGVsZW1lbnQgcHJvcGVydGllcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGFjY29yZGluZyB0byB0aGUgY29uZmlndXJhdGlvbiBpbiBzZXJpZXNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2FuaW1hdGFibGVNb2RlbF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICAgICAqICAgICAgICAgcG9zaXRpb246IFsxMDAsIDEwMF1cbiAgICAgKiAgICAgfSwgc2VyaWVzTW9kZWwsIGRhdGFJbmRleCwgZnVuY3Rpb24gKCkgeyBjb25zb2xlLmxvZygnQW5pbWF0aW9uIGRvbmUhJyk7IH0pO1xuICAgICAqICAgICAvLyBPclxuICAgICAqICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCB7XG4gICAgICogICAgICAgICBwb3NpdGlvbjogWzEwMCwgMTAwXVxuICAgICAqICAgICB9LCBzZXJpZXNNb2RlbCwgZnVuY3Rpb24gKCkgeyBjb25zb2xlLmxvZygnQW5pbWF0aW9uIGRvbmUhJyk7IH0pO1xuICAgICAqL1xuICAgIGdyYXBoaWMudXBkYXRlUHJvcHMgPSBmdW5jdGlvbiAoZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpIHtcbiAgICAgICAgYW5pbWF0ZU9yU2V0UHJvcHModHJ1ZSwgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0IGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YUluZGV4XVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICovXG4gICAgZ3JhcGhpYy5pbml0UHJvcHMgPSBmdW5jdGlvbiAoZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpIHtcbiAgICAgICAgYW5pbWF0ZU9yU2V0UHJvcHMoZmFsc2UsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRyYW5zZm9ybSBtYXRyaXggb2YgdGFyZ2V0IChwYXJhbSB0YXJnZXQpLFxuICAgICAqIGluIGNvb3JkaW5hdGUgb2YgaXRzIGFuY2VzdG9yIChwYXJhbSBhbmNlc3RvcilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSBbYW5jZXN0b3JdXG4gICAgICovXG4gICAgZ3JhcGhpYy5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodGFyZ2V0LCBhbmNlc3Rvcikge1xuICAgICAgICB2YXIgbWF0ID0gbWF0cml4LmlkZW50aXR5KFtdKTtcblxuICAgICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIG1hdHJpeC5tdWwobWF0LCB0YXJnZXQuZ2V0TG9jYWxUcmFuc2Zvcm0oKSwgbWF0KTtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0cmFuc2Zvcm0gdG8gYW4gdmVydGV4LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZlcnRleCBbeCwgeV1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnZlcnQgV2hldGhlciB1c2UgaW52ZXJ0IG1hdHJpeC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gW3gsIHldXG4gICAgICovXG4gICAgZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJ0KSB7XG4gICAgICAgIGlmIChpbnZlcnQpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5pbnZlcnQoW10sIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseVRyYW5zZm9ybShbXSwgdmVydGV4LCB0cmFuc2Zvcm0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdHJhbnNmb3JtIFRyYW5zZm9ybSBtYXRyaXg6IGxpa2UgWzEsIDAsIDAsIDEsIDAsIDBdXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaW52ZXJ0IFdoZXRoZXIgdXNlIGludmVydCBtYXRyaXguXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUcmFuc2Zvcm1lZCBkaXJlY3Rpb24uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXG4gICAgICovXG4gICAgZ3JhcGhpYy50cmFuc2Zvcm1EaXJlY3Rpb24gPSBmdW5jdGlvbiAoZGlyZWN0aW9uLCB0cmFuc2Zvcm0sIGludmVydCkge1xuXG4gICAgICAgIC8vIFBpY2sgYSBiYXNlLCBlbnN1cmUgdGhhdCB0cmFuc2Zvcm0gcmVzdWx0IHdpbGwgbm90IGJlICgwLCAwKS5cbiAgICAgICAgdmFyIGhCYXNlID0gKHRyYW5zZm9ybVs0XSA9PT0gMCB8fCB0cmFuc2Zvcm1bNV0gPT09IDAgfHwgdHJhbnNmb3JtWzBdID09PSAwKVxuICAgICAgICAgICAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVswXSk7XG4gICAgICAgIHZhciB2QmFzZSA9ICh0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVsyXSA9PT0gMClcbiAgICAgICAgICAgID8gMSA6IE1hdGguYWJzKDIgKiB0cmFuc2Zvcm1bNF0gLyB0cmFuc2Zvcm1bMl0pO1xuXG4gICAgICAgIHZhciB2ZXJ0ZXggPSBbXG4gICAgICAgICAgICBkaXJlY3Rpb24gPT09ICdsZWZ0JyA/IC1oQmFzZSA6IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IGhCYXNlIDogMCxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3RvcCcgPyAtdkJhc2UgOiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gdkJhc2UgOiAwXG4gICAgICAgIF07XG5cbiAgICAgICAgdmVydGV4ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJ0KTtcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnModmVydGV4WzBdKSA+IE1hdGguYWJzKHZlcnRleFsxXSlcbiAgICAgICAgICAgID8gKHZlcnRleFswXSA+IDAgPyAncmlnaHQnIDogJ2xlZnQnKVxuICAgICAgICAgICAgOiAodmVydGV4WzFdID4gMCA/ICdib3R0b20nIDogJ3RvcCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBncm91cCB0cmFuc2l0aW9uIGFuaW1hdGlvbiBmcm9tIGcxIHRvIGcyXG4gICAgICovXG4gICAgZ3JhcGhpYy5ncm91cFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoZzEsIGcyLCBhbmltYXRhYmxlTW9kZWwsIGNiKSB7XG4gICAgICAgIGlmICghZzEgfHwgIWcyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRFbE1hcChnKSB7XG4gICAgICAgICAgICB2YXIgZWxNYXAgPSB7fTtcbiAgICAgICAgICAgIGcudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbC5pc0dyb3VwICYmIGVsLmFuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxNYXBbZWwuYW5pZF0gPSBlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBlbE1hcDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRBbmltYXRhYmxlUHJvcHMoZWwpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHZlY3Rvci5jbG9uZShlbC5wb3NpdGlvbiksXG4gICAgICAgICAgICAgICAgcm90YXRpb246IGVsLnJvdGF0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVsLnNoYXBlKSB7XG4gICAgICAgICAgICAgICAgb2JqLnNoYXBlID0genJVdGlsLmV4dGVuZCh7fSwgZWwuc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxNYXAxID0gZ2V0RWxNYXAoZzEpO1xuXG4gICAgICAgIGcyLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKCFlbC5pc0dyb3VwICYmIGVsLmFuaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkRWwgPSBlbE1hcDFbZWwuYW5pZF07XG4gICAgICAgICAgICAgICAgaWYgKG9sZEVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdQcm9wID0gZ2V0QW5pbWF0YWJsZVByb3BzKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXR0cihnZXRBbmltYXRhYmxlUHJvcHMob2xkRWwpKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwgbmV3UHJvcCwgYW5pbWF0YWJsZU1vZGVsLCBlbC5kYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKGVsLnByZXZpb3VzUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHNcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZ3JhcGhpYztcblxuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gTGF5b3V0IGhlbHBlcnMgZm9yIGVhY2ggY29tcG9uZW50IHBvc2l0aW9uaW5nXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4vbnVtYmVyJyk7XG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xuICAgIHZhciBwYXJzZVBlcmNlbnQgPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudDtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuXG4gICAgdmFyIGxheW91dCA9IHt9O1xuXG4gICAgdmFyIExPQ0FUSU9OX1BBUkFNUyA9IGxheW91dC5MT0NBVElPTl9QQVJBTVMgPSBbXG4gICAgICAgICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nLCAnd2lkdGgnLCAnaGVpZ2h0J1xuICAgIF07XG5cbiAgICBmdW5jdGlvbiBib3hMYXlvdXQob3JpZW50LCBncm91cCwgZ2FwLCBtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XG4gICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICBpZiAobWF4V2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgbWF4V2lkdGggPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4SGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgIG1heEhlaWdodCA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50TGluZU1heFNpemUgPSAwO1xuICAgICAgICBncm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkLCBpZHgpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGNoaWxkLnBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBjaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hpbGQgPSBncm91cC5jaGlsZEF0KGlkeCArIDEpO1xuICAgICAgICAgICAgdmFyIG5leHRDaGlsZFJlY3QgPSBuZXh0Q2hpbGQgJiYgbmV4dENoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgdmFyIG5leHRYO1xuICAgICAgICAgICAgdmFyIG5leHRZO1xuICAgICAgICAgICAgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vdmVYID0gcmVjdC53aWR0aCArIChuZXh0Q2hpbGRSZWN0ID8gKC1uZXh0Q2hpbGRSZWN0LnggKyByZWN0LngpIDogMCk7XG4gICAgICAgICAgICAgICAgbmV4dFggPSB4ICsgbW92ZVg7XG4gICAgICAgICAgICAgICAgLy8gV3JhcCB3aGVuIHdpZHRoIGV4Y2VlZHMgbWF4V2lkdGggb3IgbWVldCBhIGBuZXdsaW5lYCBncm91cFxuICAgICAgICAgICAgICAgIGlmIChuZXh0WCA+IG1heFdpZHRoIHx8IGNoaWxkLm5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG5leHRYID0gbW92ZVg7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gY3VycmVudExpbmVNYXhTaXplICsgZ2FwO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZU1heFNpemUgPSByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRMaW5lTWF4U2l6ZSwgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtb3ZlWSA9IHJlY3QuaGVpZ2h0ICsgKG5leHRDaGlsZFJlY3QgPyAoLW5leHRDaGlsZFJlY3QueSArIHJlY3QueSkgOiAwKTtcbiAgICAgICAgICAgICAgICBuZXh0WSA9IHkgKyBtb3ZlWTtcbiAgICAgICAgICAgICAgICAvLyBXcmFwIHdoZW4gd2lkdGggZXhjZWVkcyBtYXhIZWlnaHQgb3IgbWVldCBhIGBuZXdsaW5lYCBncm91cFxuICAgICAgICAgICAgICAgIGlmIChuZXh0WSA+IG1heEhlaWdodCB8fCBjaGlsZC5uZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gY3VycmVudExpbmVNYXhTaXplICsgZ2FwO1xuICAgICAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFkgPSBtb3ZlWTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRMaW5lTWF4U2l6ZSwgcmVjdC53aWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hpbGQubmV3bGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9zaXRpb25bMF0gPSB4O1xuICAgICAgICAgICAgcG9zaXRpb25bMV0gPSB5O1xuXG4gICAgICAgICAgICBvcmllbnQgPT09ICdob3Jpem9udGFsJ1xuICAgICAgICAgICAgICAgID8gKHggPSBuZXh0WCArIGdhcClcbiAgICAgICAgICAgICAgICA6ICh5ID0gbmV4dFkgKyBnYXApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWQm94IG9yIEhCb3ggbGF5b3V0aW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWVudFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfSBncm91cFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnYXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPUluZmluaXR5XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PUluZmluaXR5XVxuICAgICAqL1xuICAgIGxheW91dC5ib3ggPSBib3hMYXlvdXQ7XG5cbiAgICAvKipcbiAgICAgKiBWQm94IGxheW91dGluZ1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfSBncm91cFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnYXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPUluZmluaXR5XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PUluZmluaXR5XVxuICAgICAqL1xuICAgIGxheW91dC52Ym94ID0genJVdGlsLmN1cnJ5KGJveExheW91dCwgJ3ZlcnRpY2FsJyk7XG5cbiAgICAvKipcbiAgICAgKiBIQm94IGxheW91dGluZ1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfSBncm91cFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnYXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPUluZmluaXR5XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PUluZmluaXR5XVxuICAgICAqL1xuICAgIGxheW91dC5oYm94ID0genJVdGlsLmN1cnJ5KGJveExheW91dCwgJ2hvcml6b250YWwnKTtcblxuICAgIC8qKlxuICAgICAqIElmIHggb3IgeDIgaXMgbm90IHNwZWNpZmllZCBvciAnY2VudGVyJyAnbGVmdCcgJ3JpZ2h0JyxcbiAgICAgKiB0aGUgd2lkdGggd291bGQgYmUgYXMgbG9uZyBhcyBwb3NzaWJsZS5cbiAgICAgKiBJZiB5IG9yIHkyIGlzIG5vdCBzcGVjaWZpZWQgb3IgJ21pZGRsZScgJ3RvcCcgJ2JvdHRvbScsXG4gICAgICogdGhlIGhlaWdodCB3b3VsZCBiZSBhcyBsb25nIGFzIHBvc3NpYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uSW5mb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby54XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby55XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby54Ml1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueTJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lclJlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG1hcmdpblxuICAgICAqIEByZXR1cm4ge09iamVjdH0ge3dpZHRoLCBoZWlnaHR9XG4gICAgICovXG4gICAgbGF5b3V0LmdldEF2YWlsYWJsZVNpemUgPSBmdW5jdGlvbiAocG9zaXRpb25JbmZvLCBjb250YWluZXJSZWN0LCBtYXJnaW4pIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyUmVjdC53aWR0aDtcbiAgICAgICAgdmFyIGNvbnRhaW5lckhlaWdodCA9IGNvbnRhaW5lclJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIHZhciB4ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby54LCBjb250YWluZXJXaWR0aCk7XG4gICAgICAgIHZhciB5ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby55LCBjb250YWluZXJIZWlnaHQpO1xuICAgICAgICB2YXIgeDIgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLngyLCBjb250YWluZXJXaWR0aCk7XG4gICAgICAgIHZhciB5MiA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ueTIsIGNvbnRhaW5lckhlaWdodCk7XG5cbiAgICAgICAgKGlzTmFOKHgpIHx8IGlzTmFOKHBhcnNlRmxvYXQocG9zaXRpb25JbmZvLngpKSkgJiYgKHggPSAwKTtcbiAgICAgICAgKGlzTmFOKHgyKSB8fCBpc05hTihwYXJzZUZsb2F0KHBvc2l0aW9uSW5mby54MikpKSAmJiAoeDIgPSBjb250YWluZXJXaWR0aCk7XG4gICAgICAgIChpc05hTih5KSB8fCBpc05hTihwYXJzZUZsb2F0KHBvc2l0aW9uSW5mby55KSkpICYmICh5ID0gMCk7XG4gICAgICAgIChpc05hTih5MikgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueTIpKSkgJiYgKHkyID0gY29udGFpbmVySGVpZ2h0KTtcblxuICAgICAgICBtYXJnaW4gPSBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KG1hcmdpbiB8fCAwKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KHgyIC0geCAtIG1hcmdpblsxXSAtIG1hcmdpblszXSwgMCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KHkyIC0geSAtIG1hcmdpblswXSAtIG1hcmdpblsyXSwgMClcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2UgcG9zaXRpb24gaW5mby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbkluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ubGVmdF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8udG9wXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5yaWdodF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uYm90dG9tXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby53aWR0aF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5hc3BlY3RdIEFzcGVjdCBpcyB3aWR0aCAvIGhlaWdodFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJSZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbbWFyZ2luXVxuICAgICAqXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICovXG4gICAgbGF5b3V0LmdldExheW91dFJlY3QgPSBmdW5jdGlvbiAoXG4gICAgICAgIHBvc2l0aW9uSW5mbywgY29udGFpbmVyUmVjdCwgbWFyZ2luXG4gICAgKSB7XG4gICAgICAgIG1hcmdpbiA9IGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkobWFyZ2luIHx8IDApO1xuXG4gICAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lclJlY3Qud2lkdGg7XG4gICAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXJSZWN0LmhlaWdodDtcblxuICAgICAgICB2YXIgbGVmdCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ubGVmdCwgY29udGFpbmVyV2lkdGgpO1xuICAgICAgICB2YXIgdG9wID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby50b3AsIGNvbnRhaW5lckhlaWdodCk7XG4gICAgICAgIHZhciByaWdodCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ucmlnaHQsIGNvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgdmFyIGJvdHRvbSA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8uYm90dG9tLCBjb250YWluZXJIZWlnaHQpO1xuICAgICAgICB2YXIgd2lkdGggPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLndpZHRoLCBjb250YWluZXJXaWR0aCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmhlaWdodCwgY29udGFpbmVySGVpZ2h0KTtcblxuICAgICAgICB2YXIgdmVydGljYWxNYXJnaW4gPSBtYXJnaW5bMl0gKyBtYXJnaW5bMF07XG4gICAgICAgIHZhciBob3Jpem9udGFsTWFyZ2luID0gbWFyZ2luWzFdICsgbWFyZ2luWzNdO1xuICAgICAgICB2YXIgYXNwZWN0ID0gcG9zaXRpb25JbmZvLmFzcGVjdDtcblxuICAgICAgICAvLyBJZiB3aWR0aCBpcyBub3Qgc3BlY2lmaWVkLCBjYWxjdWxhdGUgd2lkdGggZnJvbSBsZWZ0IGFuZCByaWdodFxuICAgICAgICBpZiAoaXNOYU4od2lkdGgpKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gcmlnaHQgLSBob3Jpem9udGFsTWFyZ2luIC0gbGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYU4oaGVpZ2h0KSkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0IC0gYm90dG9tIC0gdmVydGljYWxNYXJnaW4gLSB0b3A7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBub3QgZ2l2ZW5cbiAgICAgICAgLy8gMS4gR3JhcGggc2hvdWxkIG5vdCBleGNlZWRzIHRoZSBjb250YWluZXJcbiAgICAgICAgLy8gMi4gQXNwZWN0IG11c3QgYmUga2VlcGVkXG4gICAgICAgIC8vIDMuIEdyYXBoIHNob3VsZCB0YWtlIHRoZSBzcGFjZSBhcyBtb3JlIGFzIHBvc3NpYmxlXG4gICAgICAgIGlmIChpc05hTih3aWR0aCkgJiYgaXNOYU4oaGVpZ2h0KSkge1xuICAgICAgICAgICAgaWYgKGFzcGVjdCA+IGNvbnRhaW5lcldpZHRoIC8gY29udGFpbmVySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAqIDAuODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckhlaWdodCAqIDAuODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhc3BlY3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHdpZHRoIG9yIGhlaWdodCB3aXRoIGdpdmVuIGFzcGVjdFxuICAgICAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSkge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gYXNwZWN0ICogaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmFOKGhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGxlZnQgaXMgbm90IHNwZWNpZmllZCwgY2FsY3VsYXRlIGxlZnQgZnJvbSByaWdodCBhbmQgd2lkdGhcbiAgICAgICAgaWYgKGlzTmFOKGxlZnQpKSB7XG4gICAgICAgICAgICBsZWZ0ID0gY29udGFpbmVyV2lkdGggLSByaWdodCAtIHdpZHRoIC0gaG9yaXpvbnRhbE1hcmdpbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYU4odG9wKSkge1xuICAgICAgICAgICAgdG9wID0gY29udGFpbmVySGVpZ2h0IC0gYm90dG9tIC0gaGVpZ2h0IC0gdmVydGljYWxNYXJnaW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGlnbiBsZWZ0IGFuZCB0b3BcbiAgICAgICAgc3dpdGNoIChwb3NpdGlvbkluZm8ubGVmdCB8fCBwb3NpdGlvbkluZm8ucmlnaHQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgbGVmdCA9IGNvbnRhaW5lcldpZHRoIC8gMiAtIHdpZHRoIC8gMiAtIG1hcmdpblszXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBsZWZ0ID0gY29udGFpbmVyV2lkdGggLSB3aWR0aCAtIGhvcml6b250YWxNYXJnaW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwb3NpdGlvbkluZm8udG9wIHx8IHBvc2l0aW9uSW5mby5ib3R0b20pIHtcbiAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIHRvcCA9IGNvbnRhaW5lckhlaWdodCAvIDIgLSBoZWlnaHQgLyAyIC0gbWFyZ2luWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLSBoZWlnaHQgLSB2ZXJ0aWNhbE1hcmdpbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBzb21ldGhpbmcgaXMgd3JvbmcgYW5kIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCBhcmUgY2FsY3VsYXRlZCBhcyBOYU5cbiAgICAgICAgbGVmdCA9IGxlZnQgfHwgMDtcbiAgICAgICAgdG9wID0gdG9wIHx8IDA7XG4gICAgICAgIGlmIChpc05hTih3aWR0aCkpIHtcbiAgICAgICAgICAgIC8vIFdpZHRoIG1heSBiZSBOYU4gaWYgb25seSBvbmUgdmFsdWUgaXMgZ2l2ZW4gZXhjZXB0IHdpZHRoXG4gICAgICAgICAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gbGVmdCAtIChyaWdodCB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYU4oaGVpZ2h0KSkge1xuICAgICAgICAgICAgLy8gSGVpZ2h0IG1heSBiZSBOYU4gaWYgb25seSBvbmUgdmFsdWUgaXMgZ2l2ZW4gZXhjZXB0IGhlaWdodFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0IC0gdG9wIC0gKGJvdHRvbSB8fCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChsZWZ0ICsgbWFyZ2luWzNdLCB0b3AgKyBtYXJnaW5bMF0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZWN0Lm1hcmdpbiA9IG1hcmdpbjtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gYSB6ciBlbGVtZW50IGluIHZpZXdwb3J0XG4gICAgICogIEdyb3VwIHBvc2l0aW9uIGlzIHNwZWNpZmllZCBieSBlaXRoZXJcbiAgICAgKiAge2xlZnQsIHRvcH0sIHtyaWdodCwgYm90dG9tfVxuICAgICAqICBJZiBhbGwgcHJvcGVydGllcyBleGlzdHMsIHJpZ2h0IGFuZCBib3R0b20gd2lsbCBiZSBpZ29ucmVkLlxuICAgICAqXG4gICAgICogTG9naWM6XG4gICAgICogICAgIDEuIFNjYWxlIChhZ2FpbnN0IG9yaWdpbiBwb2ludCBpbiBwYXJlbnQgY29vcmQpXG4gICAgICogICAgIDIuIFJvdGF0ZSAoYWdhaW5zdCBvcmlnaW4gcG9pbnQgaW4gcGFyZW50IGNvb3JkKVxuICAgICAqICAgICAzLiBUcmFzbGF0ZSAod2l0aCBlbC5wb3NpdGlvbiBieSB0aGlzIG1ldGhvZClcbiAgICAgKiBTbyB0aGlzIG1ldGhvZCBvbmx5IGZpeGVzIHRoZSBsYXN0IHN0ZXAgJ1RyYXNsYXRlJywgd2hpY2ggZG9lcyBub3QgYWZmZWN0XG4gICAgICogc2NhbGluZyBhbmQgcm90YXRpbmcuXG4gICAgICpcbiAgICAgKiBJZiBiZSBjYWxsZWQgcmVwZWF0bHkgd2l0aCB0aGUgc2FtZSBpbnB1dCBlbCwgdGhlIHNhbWUgcmVzdWx0IHdpbGwgYmUgZ290dGVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbCBTaG91bGQgaGF2ZSBgZ2V0Qm91bmRpbmdSZWN0YCBtZXRob2QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uSW5mb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5sZWZ0XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby50b3BdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnJpZ2h0XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5ib3R0b21dXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lclJlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG1hcmdpblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvcHQuaHY9WzEsMV1dIE9ubHkgaG9yaXpvbnRhbCBvciBvbmx5IHZlcnRpY2FsLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvcHQuYm91bmRpbmdNb2RlPSdhbGwnXVxuICAgICAqICAgICAgICBTcGVjaWZ5IGhvdyB0byBjYWxjdWxhdGUgYm91bmRpbmdSZWN0IHdoZW4gbG9jYXRpbmcuXG4gICAgICogICAgICAgICdhbGwnOiBQb3NpdGlvbiB0aGUgYm91bmRpbmdSZWN0IHRoYXQgaXMgdHJhbnNmb3JtZWQgYW5kIHVpb25lZFxuICAgICAqICAgICAgICAgICAgICAgYm90aCBpdHNlbGYgYW5kIGl0cyBkZXNjZW5kYW50cy5cbiAgICAgKiAgICAgICAgICAgICAgIFRoaXMgbW9kZSBzaW1wbGllcyBjb25maW5lIHRoZSBlbGVtZW50cyBpbiB0aGUgYm91bmRpbmdcbiAgICAgKiAgICAgICAgICAgICAgIG9mIHRoZWlyIGNvbnRhaW5lciAoZS5nLiwgdXNpbmcgJ3JpZ2h0OiAwJykuXG4gICAgICogICAgICAgICdyYXcnOiBQb3NpdGlvbiB0aGUgYm91bmRpbmdSZWN0IHRoYXQgaXMgbm90IHRyYW5zZm9ybWVkIGFuZCBvbmx5IGl0c2VsZi5cbiAgICAgKiAgICAgICAgICAgICAgIFRoaXMgbW9kZSBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCBhIGVsZW1lbnQgY2FuIG92ZXJmbG93IGl0c1xuICAgICAqICAgICAgICAgICAgICAgY29udGFpbmVyLiAoQ29uc2lkZXIgYSByb3RhdGVkIGNpcmNsZSBuZWVkcyB0byBiZSBsb2NhdGVkIGluIGEgY29ybmVyLilcbiAgICAgKiAgICAgICAgICAgICAgIEluIHRoaXMgbW9kZSBwb3NpdGlvbkluZm8ud2lkdGgvaGVpZ2h0IGNhbiBvbmx5IGJlIG51bWJlci5cbiAgICAgKi9cbiAgICBsYXlvdXQucG9zaXRpb25FbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbiwgb3B0KSB7XG4gICAgICAgIHZhciBoID0gIW9wdCB8fCAhb3B0Lmh2IHx8IG9wdC5odlswXTtcbiAgICAgICAgdmFyIHYgPSAhb3B0IHx8ICFvcHQuaHYgfHwgb3B0Lmh2WzFdO1xuICAgICAgICB2YXIgYm91bmRpbmdNb2RlID0gb3B0ICYmIG9wdC5ib3VuZGluZ01vZGUgfHwgJ2FsbCc7XG5cbiAgICAgICAgaWYgKCFoICYmICF2KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdDtcbiAgICAgICAgaWYgKGJvdW5kaW5nTW9kZSA9PT0gJ3JhdycpIHtcbiAgICAgICAgICAgIHJlY3QgPSBlbC50eXBlID09PSAnZ3JvdXAnXG4gICAgICAgICAgICAgICAgPyBuZXcgQm91bmRpbmdSZWN0KDAsIDAsICtwb3NpdGlvbkluZm8ud2lkdGggfHwgMCwgK3Bvc2l0aW9uSW5mby5oZWlnaHQgfHwgMClcbiAgICAgICAgICAgICAgICA6IGVsLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVjdCA9IGVsLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgaWYgKGVsLm5lZWRMb2NhbFRyYW5zZm9ybSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGVsLmdldExvY2FsVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICAgICAgLy8gTm90aWNlOiByYXcgcmVjdCBtYXkgYmUgaW5uZXIgb2JqZWN0IG9mIGVsLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHNob3VsZCBub3QgYmUgbW9kaWZpZWQuXG4gICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICByZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwb3NpdGlvbkluZm8gPSBsYXlvdXQuZ2V0TGF5b3V0UmVjdChcbiAgICAgICAgICAgIHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgICAgICB7d2lkdGg6IHJlY3Qud2lkdGgsIGhlaWdodDogcmVjdC5oZWlnaHR9LFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uSW5mb1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNvbnRhaW5lclJlY3QsXG4gICAgICAgICAgICBtYXJnaW5cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCZWNhdXNlICd0cmFubGF0ZScgaXMgdGhlIGxhc3Qgc3RlcCBpbiB0cmFuc2Zvcm1cbiAgICAgICAgLy8gKHNlZSB6cmVuZGVyL2NvcmUvVHJhbnNmb3JtYWJsZSNnZXRMb2NhbFRyYW5zZnJvbSksXG4gICAgICAgIC8vIHdlIGNhbiBqdXN0IG9ubHkgbW9kaWZ5IGVsLnBvc2l0aW9uIHRvIGdldCBmaW5hbCByZXN1bHQuXG4gICAgICAgIHZhciBlbFBvcyA9IGVsLnBvc2l0aW9uO1xuICAgICAgICB2YXIgZHggPSBoID8gcG9zaXRpb25JbmZvLnggLSByZWN0LnggOiAwO1xuICAgICAgICB2YXIgZHkgPSB2ID8gcG9zaXRpb25JbmZvLnkgLSByZWN0LnkgOiAwO1xuXG4gICAgICAgIGVsLmF0dHIoJ3Bvc2l0aW9uJywgYm91bmRpbmdNb2RlID09PSAncmF3JyA/IFtkeCwgZHldIDogW2VsUG9zWzBdICsgZHgsIGVsUG9zWzFdICsgZHldKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29uc2lkZXIgQ2FzZTpcbiAgICAgKiBXaGVuIGRlZnVsYXQgb3B0aW9uIGhhcyB7bGVmdDogMCwgd2lkdGg6IDEwMH0sIGFuZCB3ZSBzZXQge3JpZ2h0OiAwfVxuICAgICAqIHRocm91Z2ggc2V0T3B0aW9uIG9yIG1lZGlhIHF1ZXJ5LCB1c2luZyBub3JtYWwgenJVdGlsLm1lcmdlIHdpbGwgY2F1c2VcbiAgICAgKiB7cmlnaHQ6IDB9IGRvZXMgbm90IHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBDb21wb25lbnRNb2RlbC5leHRlbmQoe1xuICAgICAqICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgICAgICAuLi5cbiAgICAgKiAgICAgICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gbGF5b3V0LmdldExheW91dFBhcmFtcyhvcHRpb24pO1xuICAgICAqICAgICAgICAgdGhpcy5tZXJnZU9wdGlvbihpbnB1dFBvc2l0aW9uUGFyYW1zKTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHRpb24pIHtcbiAgICAgKiAgICAgICAgIG5ld09wdGlvbiAmJiB6clV0aWwubWVyZ2UodGhpc09wdGlvbiwgbmV3T3B0aW9uLCB0cnVlKTtcbiAgICAgKiAgICAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKHRoaXNPcHRpb24sIG5ld09wdGlvbik7XG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRPcHRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3T3B0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0XVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5pZ25vcmVTaXplPWZhbHNlXSBTb21lIGNvbXBvbmVudCBtdXN0IGhhcyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtID0gZnVuY3Rpb24gKHRhcmdldE9wdGlvbiwgbmV3T3B0aW9uLCBvcHQpIHtcbiAgICAgICAgIXpyVXRpbC5pc09iamVjdChvcHQpICYmIChvcHQgPSB7fSk7XG4gICAgICAgIHZhciBoTmFtZXMgPSBbJ3dpZHRoJywgJ2xlZnQnLCAncmlnaHQnXTsgLy8gT3JkZXIgYnkgcHJpb3JpdHkuXG4gICAgICAgIHZhciB2TmFtZXMgPSBbJ2hlaWdodCcsICd0b3AnLCAnYm90dG9tJ107IC8vIE9yZGVyIGJ5IHByaW9yaXR5LlxuICAgICAgICB2YXIgaFJlc3VsdCA9IG1lcmdlKGhOYW1lcyk7XG4gICAgICAgIHZhciB2UmVzdWx0ID0gbWVyZ2Uodk5hbWVzKTtcblxuICAgICAgICBjb3B5KGhOYW1lcywgdGFyZ2V0T3B0aW9uLCBoUmVzdWx0KTtcbiAgICAgICAgY29weSh2TmFtZXMsIHRhcmdldE9wdGlvbiwgdlJlc3VsdCk7XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2UobmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBuZXdQYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBtZXJnZWQgPSB7fTtcbiAgICAgICAgICAgIHZhciBtZXJnZWRWYWx1ZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBlbm91Z2hQYXJhbU51bWJlciA9IG9wdC5pZ25vcmVTaXplID8gMSA6IDI7XG5cbiAgICAgICAgICAgIGVhY2gobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW25hbWVdID0gdGFyZ2V0T3B0aW9uW25hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIGNhc2U6IG5ld09wdGlvbi53aWR0aCBpcyBudWxsLCB3aGljaCBpc1xuICAgICAgICAgICAgICAgIC8vIHNldCBieSB1c2VyIGZvciByZW1vdmluZyB3aWR0aCBzZXR0aW5nLlxuICAgICAgICAgICAgICAgIGhhc1Byb3AobmV3T3B0aW9uLCBuYW1lKSAmJiAobmV3UGFyYW1zW25hbWVdID0gbWVyZ2VkW25hbWVdID0gbmV3T3B0aW9uW25hbWVdKTtcbiAgICAgICAgICAgICAgICBoYXNWYWx1ZShuZXdQYXJhbXMsIG5hbWUpICYmIG5ld1ZhbHVlQ291bnQrKztcbiAgICAgICAgICAgICAgICBoYXNWYWx1ZShtZXJnZWQsIG5hbWUpICYmIG1lcmdlZFZhbHVlQ291bnQrKztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDYXNlOiBuZXdPcHRpb246IHt3aWR0aDogLi4uLCByaWdodDogLi4ufSxcbiAgICAgICAgICAgIC8vIG9yIHRhcmdldE9wdGlvbjoge3JpZ2h0OiAuLi59IGFuZCBuZXdPcHRpb246IHt3aWR0aDogLi4ufSxcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGNvbmZsaWN0IHdoZW4gbWVyZ2VkIG9ubHkgaGFzIHBhcmFtcyBjb3VudFxuICAgICAgICAgICAgLy8gbGl0dGxlIHRoYW4gZW5vdWdoUGFyYW1OdW1iZXIuXG4gICAgICAgICAgICBpZiAobWVyZ2VkVmFsdWVDb3VudCA9PT0gZW5vdWdoUGFyYW1OdW1iZXIgfHwgIW5ld1ZhbHVlQ291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FzZTogbmV3T3B0aW9uOiB7d2lkdGg6IC4uLiwgcmlnaHQ6IC4uLn0sXG4gICAgICAgICAgICAvLyBUaGFuIHdlIGNhbiBtYWtlIHN1cmUgdXNlciBvbmx5IHdhbnQgdGhvc2UgdHdvLCBhbmQgaWdub3JlXG4gICAgICAgICAgICAvLyBhbGwgb3JpZ2luIHBhcmFtcyBpbiB0YXJnZXRPcHRpb24uXG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZUNvdW50ID49IGVub3VnaFBhcmFtTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENob3NlIGFub3RoZXIgcGFyYW0gZnJvbSB0YXJnZXRPcHRpb24gYnkgcHJpb3JpdHkuXG4gICAgICAgICAgICAgICAgLy8gV2hlbiAnaWdub3JlU2l6ZScsIGVub3VnaFBhcmFtTnVtYmVyIGlzIDEgYW5kIHRob3NlIHdpbGwgbm90IGhhcHBlbi5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzUHJvcChuZXdQYXJhbXMsIG5hbWUpICYmIGhhc1Byb3AodGFyZ2V0T3B0aW9uLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW1zW25hbWVdID0gdGFyZ2V0T3B0aW9uW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhc1Byb3Aob2JqLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFzVmFsdWUob2JqLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW25hbWVdICE9IG51bGwgJiYgb2JqW25hbWVdICE9PSAnYXV0byc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb3B5KG5hbWVzLCB0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICAgICAgZWFjaChuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBzb3VyY2VbbmFtZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSAnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJywgJ3dpZHRoJywgJ2hlaWdodCcgZnJvbSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmVzdWx0IGNvbnRhaW5zIHRob3NlIHByb3BzLlxuICAgICAqL1xuICAgIGxheW91dC5nZXRMYXlvdXRQYXJhbXMgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBsYXlvdXQuY29weUxheW91dFBhcmFtcyh7fSwgc291cmNlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbScsICd3aWR0aCcsICdoZWlnaHQnIGZyb20gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJlc3VsdCBjb250YWlucyB0aG9zZSBwcm9wcy5cbiAgICAgKi9cbiAgICBsYXlvdXQuY29weUxheW91dFBhcmFtcyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgJiYgdGFyZ2V0ICYmIGVhY2goTE9DQVRJT05fUEFSQU1TLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgc291cmNlLmhhc093blByb3BlcnR5KG5hbWUpICYmICh0YXJnZXRbbmFtZV0gPSBzb3VyY2VbbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBsYXlvdXQ7XG4iLCJcblxuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcbiAgICB2YXIgbnVibWVyVXRpbCA9IHJlcXVpcmUoJy4vbnVtYmVyJyk7XG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWwvTW9kZWwnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgaXNPYmplY3QgPSB6clV0aWwuaXNPYmplY3Q7XG5cbiAgICB2YXIgbW9kZWxVdGlsID0ge307XG5cbiAgICAvKipcbiAgICAgKiBJZiB2YWx1ZSBpcyBub3QgYXJyYXksIHRoZW4gdHJhbnNsYXRlIGl0IHRvIGFycmF5LlxuICAgICAqIEBwYXJhbSAgeyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7QXJyYXl9IFt2YWx1ZV0gb3IgdmFsdWVcbiAgICAgKi9cbiAgICBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgOiB2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICA6IFt2YWx1ZV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN5bmMgZGVmYXVsdCBvcHRpb24gYmV0d2VlbiBub3JtYWwgYW5kIGVtcGhhc2lzIGxpa2UgYHBvc2l0aW9uYCBhbmQgYHNob3dgXG4gICAgICogSW4gY2FzZSBzb21lIG9uZSB3aWxsIHdyaXRlIGNvZGUgbGlrZVxuICAgICAqICAgICBsYWJlbDoge1xuICAgICAqICAgICAgICAgbm9ybWFsOiB7XG4gICAgICogICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICogICAgICAgICAgICAgcG9zaXRpb246ICdvdXRzaWRlJyxcbiAgICAgKiAgICAgICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgZm9udFNpemU6IDE4XG4gICAgICogICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgIGVtcGhhc2lzOiB7XG4gICAgICogICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHN1Yk9wdHNcbiAgICAgKi9cbiAgICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyA9IGZ1bmN0aW9uIChvcHQsIHN1Yk9wdHMpIHtcbiAgICAgICAgaWYgKG9wdCkge1xuICAgICAgICAgICAgdmFyIGVtcGhhc2lzT3B0ID0gb3B0LmVtcGhhc2lzID0gb3B0LmVtcGhhc2lzIHx8IHt9O1xuICAgICAgICAgICAgdmFyIG5vcm1hbE9wdCA9IG9wdC5ub3JtYWwgPSBvcHQubm9ybWFsIHx8IHt9O1xuXG4gICAgICAgICAgICAvLyBEZWZhdWx0IGVtcGhhc2lzIG9wdGlvbiBmcm9tIG5vcm1hbFxuICAgICAgICAgICAgZWFjaChzdWJPcHRzLCBmdW5jdGlvbiAoc3ViT3B0TmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB6clV0aWwucmV0cmlldmUoZW1waGFzaXNPcHRbc3ViT3B0TmFtZV0sIG5vcm1hbE9wdFtzdWJPcHROYW1lXSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtcGhhc2lzT3B0W3N1Yk9wdE5hbWVdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZGVsVXRpbC5MQUJFTF9PUFRJT05TID0gWydwb3NpdGlvbicsICdvZmZzZXQnLCAnc2hvdycsICd0ZXh0U3R5bGUnLCAnZGlzdGFuY2UnLCAnZm9ybWF0dGVyJ107XG5cbiAgICAvKipcbiAgICAgKiBkYXRhIGNvdWxkIGJlIFsxMiwgMjMyMywge3ZhbHVlOiAyMjN9LCBbMTIyMSwgMjNdLCB7dmFsdWU6IFsyLCAyM119XVxuICAgICAqIFRoaXMgaGVscGVyIG1ldGhvZCByZXRpZXZlcyB2YWx1ZSBmcm9tIGRhdGEuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfERhdGV8QXJyYXl8T2JqZWN0fSBkYXRhSXRlbVxuICAgICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd8RGF0ZXxBcnJheS48bnVtYmVyfHN0cmluZ3xEYXRlPn1cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwuZ2V0RGF0YUl0ZW1WYWx1ZSA9IGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICAvLyBQZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gICAgICAgIHJldHVybiBkYXRhSXRlbSAmJiAoZGF0YUl0ZW0udmFsdWUgPT0gbnVsbCA/IGRhdGFJdGVtIDogZGF0YUl0ZW0udmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkYXRhIGNvdWxkIGJlIFsxMiwgMjMyMywge3ZhbHVlOiAyMjN9LCBbMTIyMSwgMjNdLCB7dmFsdWU6IFsyLCAyM119XVxuICAgICAqIFRoaXMgaGVscGVyIG1ldGhvZCBkZXRlcm1pbmUgaWYgZGF0YUl0ZW0gaGFzIGV4dHJhIG9wdGlvbiBiZXNpZGVzIHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfERhdGV8QXJyYXl8T2JqZWN0fSBkYXRhSXRlbVxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5pc0RhdGFJdGVtT3B0aW9uID0gZnVuY3Rpb24gKGRhdGFJdGVtKSB7XG4gICAgICAgIHJldHVybiBpc09iamVjdChkYXRhSXRlbSlcbiAgICAgICAgICAgICYmICEoZGF0YUl0ZW0gaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICAgICAgICAvLyAvLyBtYXJrTGluZSBkYXRhIGNhbiBiZSBhcnJheVxuICAgICAgICAgICAgLy8gJiYgIShkYXRhSXRlbVswXSAmJiBpc09iamVjdChkYXRhSXRlbVswXSkgJiYgIShkYXRhSXRlbVswXSBpbnN0YW5jZW9mIEFycmF5KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaGVscGVyIG1ldGhvZCBjb252ZXJ0IHZhbHVlIGluIGRhdGEuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfERhdGV9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbZGltSW5mb10gSWYgc3RyaW5nIChsaWtlICd4JyksIGRpbVR5cGUgZGVmYXVsdHMgJ251bWJlcicuXG4gICAgICovXG4gICAgbW9kZWxVdGlsLmNvbnZlckRhdGFWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGltSW5mbykge1xuICAgICAgICAvLyBQZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gICAgICAgIHZhciBkaW1UeXBlID0gZGltSW5mbyAmJiBkaW1JbmZvLnR5cGU7XG4gICAgICAgIGlmIChkaW1UeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaW1UeXBlID09PSAndGltZScgJiYgIWlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnLScpIHtcbiAgICAgICAgICAgIHZhbHVlID0gK251Ym1lclV0aWwucGFyc2VEYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRpbVR5cGUgZGVmYXVsdHMgJ251bWJlcicuXG4gICAgICAgIC8vIElmIGRpbVR5cGUgaXMgbm90IG9yZGluYWwgYW5kIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIE5hTiBvciAnLScsXG4gICAgICAgIC8vIHBhcnNlIHRvIE5hTi5cbiAgICAgICAgcmV0dXJuICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSAnJylcbiAgICAgICAgICAgID8gTmFOIDogK3ZhbHVlOyAvLyBJZiBzdHJpbmcgKGxpa2UgJy0nKSwgdXNpbmcgJysnIHBhcnNlIHRvIE5hTlxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBtb2RlbCBwcm94eSB0byBiZSB1c2VkIGluIHRvb2x0aXAgZm9yIGVkZ2UgZGF0YSwgbWFya0xpbmUgZGF0YSwgbWFya1BvaW50IGRhdGEuXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuc2VyaWVzSW5kZXhdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHQubmFtZV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdC5tYWluVHlwZV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdC5zdWJUeXBlXVxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5jcmVhdGVEYXRhRm9ybWF0TW9kZWwgPSBmdW5jdGlvbiAoZGF0YSwgb3B0KSB7XG4gICAgICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbCgpO1xuICAgICAgICB6clV0aWwubWl4aW4obW9kZWwsIG1vZGVsVXRpbC5kYXRhRm9ybWF0TWl4aW4pO1xuICAgICAgICBtb2RlbC5zZXJpZXNJbmRleCA9IG9wdC5zZXJpZXNJbmRleDtcbiAgICAgICAgbW9kZWwubmFtZSA9IG9wdC5uYW1lIHx8ICcnO1xuICAgICAgICBtb2RlbC5tYWluVHlwZSA9IG9wdC5tYWluVHlwZTtcbiAgICAgICAgbW9kZWwuc3ViVHlwZSA9IG9wdC5zdWJUeXBlO1xuXG4gICAgICAgIG1vZGVsLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH07XG5cbiAgICAvLyBQRU5ESU5HIEEgbGl0dGxlIHVnbHlcbiAgICBtb2RlbFV0aWwuZGF0YUZvcm1hdE1peGluID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBhcmFtcyBmb3IgZm9ybWF0dGVyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhVHlwZV1cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RGF0YVBhcmFtczogZnVuY3Rpb24gKGRhdGFJbmRleCwgZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKGRhdGFUeXBlKTtcblxuICAgICAgICAgICAgdmFyIHNlcmllc0luZGV4ID0gdGhpcy5zZXJpZXNJbmRleDtcbiAgICAgICAgICAgIHZhciBzZXJpZXNOYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgICAgICAgICB2YXIgcmF3VmFsdWUgPSB0aGlzLmdldFJhd1ZhbHVlKGRhdGFJbmRleCwgZGF0YVR5cGUpO1xuICAgICAgICAgICAgdmFyIHJhd0RhdGFJbmRleCA9IGRhdGEuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgaXRlbU9wdCA9IGRhdGEuZ2V0UmF3RGF0YUl0ZW0oZGF0YUluZGV4KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlOiB0aGlzLm1haW5UeXBlLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFN1YlR5cGU6IHRoaXMuc3ViVHlwZSxcbiAgICAgICAgICAgICAgICBzZXJpZXNUeXBlOiB0aGlzLm1haW5UeXBlID09PSAnc2VyaWVzJyA/IHRoaXMuc3ViVHlwZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgIHNlcmllc05hbWU6IHNlcmllc05hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBkYXRhSW5kZXg6IHJhd0RhdGFJbmRleCxcbiAgICAgICAgICAgICAgICBkYXRhOiBpdGVtT3B0LFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBkYXRhVHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmF3VmFsdWUsXG4gICAgICAgICAgICAgICAgY29sb3I6IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdjb2xvcicpLFxuXG4gICAgICAgICAgICAgICAgLy8gUGFyYW0gbmFtZSBsaXN0IGZvciBtYXBwaW5nIGBhYCwgYGJgLCBgY2AsIGBkYCwgYGVgXG4gICAgICAgICAgICAgICAgJHZhcnM6IFsnc2VyaWVzTmFtZScsICduYW1lJywgJ3ZhbHVlJ11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcm1hdCBsYWJlbFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RhdHVzPSdub3JtYWwnXSAnbm9ybWFsJyBvciAnZW1waGFzaXMnXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YVR5cGVdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGltSW5kZXhdXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldEZvcm1hdHRlZExhYmVsOiBmdW5jdGlvbiAoZGF0YUluZGV4LCBzdGF0dXMsIGRhdGFUeXBlLCBkaW1JbmRleCkge1xuICAgICAgICAgICAgc3RhdHVzID0gc3RhdHVzIHx8ICdub3JtYWwnO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZGF0YVR5cGUpO1xuICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG5cbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmdldERhdGFQYXJhbXMoZGF0YUluZGV4LCBkYXRhVHlwZSk7XG4gICAgICAgICAgICBpZiAoZGltSW5kZXggIT0gbnVsbCAmJiAocGFyYW1zLnZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnZhbHVlID0gcGFyYW1zLnZhbHVlW2RpbUluZGV4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlciA9IGl0ZW1Nb2RlbC5nZXQoWydsYWJlbCcsIHN0YXR1cywgJ2Zvcm1hdHRlciddKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFV0aWwuZm9ybWF0VHBsKGZvcm1hdHRlciwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHJhdyB2YWx1ZSBpbiBvcHRpb25cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGFUeXBlXVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRSYXdWYWx1ZTogZnVuY3Rpb24gKGlkeCwgZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKGRhdGFUeXBlKTtcbiAgICAgICAgICAgIHZhciBkYXRhSXRlbSA9IGRhdGEuZ2V0UmF3RGF0YUl0ZW0oaWR4KTtcbiAgICAgICAgICAgIGlmIChkYXRhSXRlbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc09iamVjdChkYXRhSXRlbSkgJiYgIShkYXRhSXRlbSBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICAgICAgICAgICAgICAgICAgPyBkYXRhSXRlbS52YWx1ZSA6IGRhdGFJdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgYmUgaW1wbGVtZW50ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbbXVsdGlwbGVTZXJpZXM9ZmFsc2VdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YVR5cGVdXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gdG9vbHRpcCBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGZvcm1hdFRvb2x0aXA6IHpyVXRpbC5ub29wXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1hcHBpbmcgdG8gZXhpc3RzIGZvciBtZXJnZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fEFycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnQ+fSBleGlzdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheS48T2JqZWN0Pn0gbmV3Q3B0T3B0aW9uc1xuICAgICAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBSZXN1bHQsIGxpa2UgW3tleGlzdDogLi4uLCBvcHRpb246IC4uLn0sIHt9XSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggb2Ygd2hpY2ggaXMgdGhlIHNhbWUgYXMgZXhpc3RzLlxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5tYXBwaW5nVG9FeGlzdHMgPSBmdW5jdGlvbiAoZXhpc3RzLCBuZXdDcHRPcHRpb25zKSB7XG4gICAgICAgIC8vIE1hcHBpbmcgYnkgdGhlIG9yZGVyIGJ5IG9yaWdpbmFsIG9wdGlvbiAoYnV0IG5vdCBvcmRlciBvZlxuICAgICAgICAvLyBuZXcgb3B0aW9uKSBpbiBtZXJnZSBtb2RlLiBCZWNhdXNlIHdlIHNob3VsZCBlbnN1cmVcbiAgICAgICAgLy8gc29tZSBzcGVjaWZpZWQgaW5kZXggKGxpa2UgeEF4aXNJbmRleCkgaXMgY29uc2lzdGVudCB3aXRoXG4gICAgICAgIC8vIG9yaWdpbmFsIG9wdGlvbiwgd2hpY2ggaXMgZWFzeSB0byB1bmRlcnN0YW5kLCBlc3BhdGlhbGx5IGluXG4gICAgICAgIC8vIG1lZGlhIHF1ZXJ5LiBBbmQgaW4gbW9zdCBjYXNlLCBtZXJnZSBvcHRpb24gaXMgdXNlZCB0b1xuICAgICAgICAvLyB1cGRhdGUgcGFydGlhbCBvcHRpb24gYnV0IG5vdCBiZSBleHBlY3RlZCB0byBjaGFuZ2Ugb3JkZXIuXG4gICAgICAgIG5ld0NwdE9wdGlvbnMgPSAobmV3Q3B0T3B0aW9ucyB8fCBbXSkuc2xpY2UoKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0genJVdGlsLm1hcChleGlzdHMgfHwgW10sIGZ1bmN0aW9uIChvYmosIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4ge2V4aXN0OiBvYmp9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBNYXBwaW5nIGJ5IGlkIG9yIG5hbWUgaWYgc3BlY2lmaWVkLlxuICAgICAgICBlYWNoKG5ld0NwdE9wdGlvbnMsIGZ1bmN0aW9uIChjcHRPcHRpb24sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGNwdE9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlkIGhhcyBoaWdoZXN0IHByaW9yaXR5LlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdFtpXS5vcHRpb24gLy8gQ29uc2lkZXIgbmFtZTogdHdvIG1hcCB0byBvbmUuXG4gICAgICAgICAgICAgICAgICAgICYmIGNwdE9wdGlvbi5pZCAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICYmIHJlc3VsdFtpXS5leGlzdC5pZCA9PT0gY3B0T3B0aW9uLmlkICsgJydcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLm9wdGlvbiA9IGNwdE9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q3B0T3B0aW9uc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdCA9IHJlc3VsdFtpXS5leGlzdDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdFtpXS5vcHRpb24gLy8gQ29uc2lkZXIgbmFtZTogdHdvIG1hcCB0byBvbmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbiBub3QgbWF0Y2ggd2hlbiBib3RoIGlkcyBleGlzdCBidXQgZGlmZmVyZW50LlxuICAgICAgICAgICAgICAgICAgICAmJiAoZXhpc3QuaWQgPT0gbnVsbCB8fCBjcHRPcHRpb24uaWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgJiYgY3B0T3B0aW9uLm5hbWUgIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAmJiAhbW9kZWxVdGlsLmlzSWRJbm5lcihjcHRPcHRpb24pXG4gICAgICAgICAgICAgICAgICAgICYmICFtb2RlbFV0aWwuaXNJZElubmVyKGV4aXN0KVxuICAgICAgICAgICAgICAgICAgICAmJiBleGlzdC5uYW1lID09PSBjcHRPcHRpb24ubmFtZSArICcnXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS5vcHRpb24gPSBjcHRPcHRpb247XG4gICAgICAgICAgICAgICAgICAgIG5ld0NwdE9wdGlvbnNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIG1hcHBpbmcgYnkgaW5kZXguXG4gICAgICAgIGVhY2gobmV3Q3B0T3B0aW9ucywgZnVuY3Rpb24gKGNwdE9wdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3QoY3B0T3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3QgPSByZXN1bHRbaV0uZXhpc3Q7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRbaV0ub3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4aXN0aW5nIG1vZGVsIHRoYXQgYWxyZWFkeSBoYXMgaWQgc2hvdWxkIGJlIGFibGUgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gbWFwcGVkIHRvIChiZWNhdXNlIGFmdGVyIG1hcHBpbmcgcGVyZm9ybWVkIG1vZGVsIG1heVxuICAgICAgICAgICAgICAgICAgICAvLyBiZSBhc3NpZ25lZCB3aXRoIGEgaWQsIHdoaXNoIHNob3VsZCBub3QgYWZmZWN0IG5leHRcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFwcGluZyksIGV4Y2VwdCB0aG9zZSBoYXMgaW5uZXIgaWQuXG4gICAgICAgICAgICAgICAgICAgICYmICFtb2RlbFV0aWwuaXNJZElubmVyKGV4aXN0KVxuICAgICAgICAgICAgICAgICAgICAvLyBDYXV0aW9uOlxuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3Qgb3ZlcndyaXRlIGlkLiBCdXQgbmFtZSBjYW4gYmUgb3ZlcndyaXR0ZW4sXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgYXhpcyB1c2UgbmFtZSBhcyAnc2hvdyBsYWJlbCB0ZXh0Jy5cbiAgICAgICAgICAgICAgICAgICAgLy8gJ2V4aXN0JyBhbHdheXMgaGFzIGlkIGFuZCBuYW1lIGFuZCB3ZSBkb250XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gY2hlY2sgaXQuXG4gICAgICAgICAgICAgICAgICAgICYmIGNwdE9wdGlvbi5pZCA9PSBudWxsXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS5vcHRpb24gPSBjcHRPcHRpb247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGkgPj0gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtvcHRpb246IGNwdE9wdGlvbn0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGlkIGFuZCBuYW1lIGZvciBtYXBwaW5nIHJlc3VsdCAocmVzdWx0IG9mIG1hcHBpbmdUb0V4aXN0cylcbiAgICAgKiBpbnRvIGBrZXlJbmZvYCBmaWVsZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBSZXN1bHQsIGxpa2UgW3tleGlzdDogLi4uLCBvcHRpb246IC4uLn0sIHt9XSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggb3JkZXIgaXMgdGhlIHNhbWUgYXMgZXhpc3RzLlxuICAgICAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBUaGUgaW5wdXQuXG4gICAgICovXG4gICAgbW9kZWxVdGlsLm1ha2VJZEFuZE5hbWUgPSBmdW5jdGlvbiAobWFwUmVzdWx0KSB7XG4gICAgICAgIC8vIFdlIHVzZSB0aGlzIGlkIHRvIGhhc2ggY29tcG9uZW50IG1vZGVscyBhbmQgdmlldyBpbnN0YW5jZXNcbiAgICAgICAgLy8gaW4gZWNoYXJ0cy4gaWQgY2FuIGJlIHNwZWNpZmllZCBieSB1c2VyLCBvciBhdXRvIGdlbmVyYXRlZC5cblxuICAgICAgICAvLyBUaGUgaWQgZ2VuZXJhdGlvbiBydWxlIGVuc3VyZXMgbmV3IHZpZXcgaW5zdGFuY2UgYXJlIGFibGVcbiAgICAgICAgLy8gdG8gbWFwcGVkIHRvIG9sZCBpbnN0YW5jZSB3aGVuIHNldE9wdGlvbiBhcmUgY2FsbGVkIGluXG4gICAgICAgIC8vIG5vLW1lcmdlIG1vZGUuIFNvIHdlIGdlbmVyYXRlIG1vZGVsIGlkIGJ5IG5hbWUgYW5kIHBsdXNcbiAgICAgICAgLy8gdHlwZSBpbiB2aWV3IGlkLlxuXG4gICAgICAgIC8vIG5hbWUgY2FuIGJlIGR1cGxpY2F0ZWQgYW1vbmcgY29tcG9uZW50cywgd2hpY2ggaXMgY29udmVuaWVudFxuICAgICAgICAvLyB0byBzcGVjaWZ5IG11bHRpIGNvbXBvbmVudHMgKGxpa2Ugc2VyaWVzKSBieSBvbmUgbmFtZS5cblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBlYWNoIGlkIGlzIGRpc3RpbmN0LlxuICAgICAgICB2YXIgaWRNYXAgPSB7fTtcblxuICAgICAgICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RDcHQgPSBpdGVtLmV4aXN0O1xuICAgICAgICAgICAgZXhpc3RDcHQgJiYgKGlkTWFwW2V4aXN0Q3B0LmlkXSA9IGl0ZW0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gaXRlbS5vcHRpb247XG5cbiAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoXG4gICAgICAgICAgICAgICAgIW9wdCB8fCBvcHQuaWQgPT0gbnVsbCB8fCAhaWRNYXBbb3B0LmlkXSB8fCBpZE1hcFtvcHQuaWRdID09PSBpdGVtLFxuICAgICAgICAgICAgICAgICdpZCBkdXBsaWNhdGVzOiAnICsgKG9wdCAmJiBvcHQuaWQpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBvcHQgJiYgb3B0LmlkICE9IG51bGwgJiYgKGlkTWFwW29wdC5pZF0gPSBpdGVtKTtcbiAgICAgICAgICAgICFpdGVtLmtleUluZm8gJiYgKGl0ZW0ua2V5SW5mbyA9IHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTWFrZSBuYW1lIGFuZCBpZC5cbiAgICAgICAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGV4aXN0Q3B0ID0gaXRlbS5leGlzdDtcbiAgICAgICAgICAgIHZhciBvcHQgPSBpdGVtLm9wdGlvbjtcbiAgICAgICAgICAgIHZhciBrZXlJbmZvID0gaXRlbS5rZXlJbmZvO1xuXG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG9wdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5hbWUgY2FuIGJlIG92ZXJ3aXR0ZW4uIENvbnNpZGVyIGNhc2U6IGF4aXMubmFtZSA9ICcyMGttJy5cbiAgICAgICAgICAgIC8vIEJ1dCBpZCBnZW5lcmF0ZWQgYnkgbmFtZSB3aWxsIG5vdCBiZSBjaGFuZ2VkLCB3aGljaCBhZmZlY3RcbiAgICAgICAgICAgIC8vIG9ubHkgaW4gdGhhdCBjYXNlOiBzZXRPcHRpb24gd2l0aCAnbm90IG1lcmdlIG1vZGUnIGFuZCB2aWV3XG4gICAgICAgICAgICAvLyBpbnN0YW5jZSB3aWxsIGJlIHJlY3JlYXRlZCwgd2hpY2ggY2FuIGJlIGFjY2VwdGVkLlxuICAgICAgICAgICAga2V5SW5mby5uYW1lID0gb3B0Lm5hbWUgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gb3B0Lm5hbWUgKyAnJ1xuICAgICAgICAgICAgICAgIDogZXhpc3RDcHRcbiAgICAgICAgICAgICAgICA/IGV4aXN0Q3B0Lm5hbWVcbiAgICAgICAgICAgICAgICA6ICdcXDAtJztcblxuICAgICAgICAgICAgaWYgKGV4aXN0Q3B0KSB7XG4gICAgICAgICAgICAgICAga2V5SW5mby5pZCA9IGV4aXN0Q3B0LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0LmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBrZXlJbmZvLmlkID0gb3B0LmlkICsgJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciB0aGlzIHNpdHVhdG9pbjpcbiAgICAgICAgICAgICAgICAvLyAgb3B0aW9uQTogW3tuYW1lOiAnYSd9LCB7bmFtZTogJ2EnfSwgey4ufV1cbiAgICAgICAgICAgICAgICAvLyAgb3B0aW9uQiBbey4ufSwge25hbWU6ICdhJ30sIHtuYW1lOiAnYSd9XVxuICAgICAgICAgICAgICAgIC8vIFNlcmllcyB3aXRoIHRoZSBzYW1lIG5hbWUgYmV0d2VlbiBvcHRpb25BIGFuZCBvcHRpb25CXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIG1hcHBlZC5cbiAgICAgICAgICAgICAgICB2YXIgaWROdW0gPSAwO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAga2V5SW5mby5pZCA9ICdcXDAnICsga2V5SW5mby5uYW1lICsgJ1xcMCcgKyBpZE51bSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoaWRNYXBba2V5SW5mby5pZF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZE1hcFtrZXlJbmZvLmlkXSA9IGl0ZW07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNwdE9wdGlvblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgbW9kZWxVdGlsLmlzSWRJbm5lciA9IGZ1bmN0aW9uIChjcHRPcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGNwdE9wdGlvbilcbiAgICAgICAgICAgICYmIGNwdE9wdGlvbi5pZFxuICAgICAgICAgICAgJiYgKGNwdE9wdGlvbi5pZCArICcnKS5pbmRleE9mKCdcXDBfZWNfXFwwJykgPT09IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIGZvciByZW1vdmluZyBkdXBsaWNhdGUgaXRlbXMgYmV0d2VlbiBiYXRjaEEgYW5kIGJhdGNoQixcbiAgICAgKiBhbmQgaW4gdGhlbXNlbHZlcywgYW5kIGNhdGVnb3JpemUgYnkgc2VyaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gYmF0Y2hBIExpa2U6IFt7c2VyaWVzSWQ6IDIsIGRhdGFJbmRleDogWzMyLCA0LCA1XX0sIC4uLl1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBiYXRjaEIgTGlrZTogW3tzZXJpZXNJZDogMiwgZGF0YUluZGV4OiBbMzIsIDQsIDVdfSwgLi4uXVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48T2JqZWN0PiwgQXJyYXkuPE9iamVjdD4+fSByZXN1bHQ6IFtyZXN1bHRCYXRjaEEsIHJlc3VsdEJhdGNoQl1cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwuY29tcHJlc3NCYXRjaGVzID0gZnVuY3Rpb24gKGJhdGNoQSwgYmF0Y2hCKSB7XG4gICAgICAgIHZhciBtYXBBID0ge307XG4gICAgICAgIHZhciBtYXBCID0ge307XG5cbiAgICAgICAgbWFrZU1hcChiYXRjaEEgfHwgW10sIG1hcEEpO1xuICAgICAgICBtYWtlTWFwKGJhdGNoQiB8fCBbXSwgbWFwQiwgbWFwQSk7XG5cbiAgICAgICAgcmV0dXJuIFttYXBUb0FycmF5KG1hcEEpLCBtYXBUb0FycmF5KG1hcEIpXTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlTWFwKHNvdXJjZUJhdGNoLCBtYXAsIG90aGVyTWFwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlQmF0Y2gubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzSWQgPSBzb3VyY2VCYXRjaFtpXS5zZXJpZXNJZDtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YUluZGljZXMgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShzb3VyY2VCYXRjaFtpXS5kYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciBvdGhlckRhdGFJbmRpY2VzID0gb3RoZXJNYXAgJiYgb3RoZXJNYXBbc2VyaWVzSWRdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbmogPSBkYXRhSW5kaWNlcy5sZW5ndGg7IGogPCBsZW5qOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckRhdGFJbmRpY2VzICYmIG90aGVyRGF0YUluZGljZXNbZGF0YUluZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJEYXRhSW5kaWNlc1tkYXRhSW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChtYXBbc2VyaWVzSWRdIHx8IChtYXBbc2VyaWVzSWRdID0ge30pKVtkYXRhSW5kZXhdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwLCBpc0RhdGEpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShpKSAmJiBtYXBbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgraSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUluZGljZXMgPSBtYXBUb0FycmF5KG1hcFtpXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSW5kaWNlcy5sZW5ndGggJiYgcmVzdWx0LnB1c2goe3Nlcmllc0lkOiBpLCBkYXRhSW5kZXg6IGRhdGFJbmRpY2VzfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgQ29udGFpbnMgZGF0YUluZGV4IChtZWFucyByYXdJbmRleCkgLyBkYXRhSW5kZXhJbnNpZGUgLyBuYW1lXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCBvZiB3aGljaCBjYW4gYmUgQXJyYXkgb3IgcHJpbWFyeSB0eXBlLlxuICAgICAqIEByZXR1cm4ge251bWJlcnxBcnJheS48bnVtYmVyPn0gZGF0YUluZGV4IElmIG5vdCBmb3VuZCwgcmV0dXJuIHVuZGVmaW5lZC9udWxsLlxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleCA9IGZ1bmN0aW9uIChkYXRhLCBwYXlsb2FkKSB7XG4gICAgICAgIGlmIChwYXlsb2FkLmRhdGFJbmRleEluc2lkZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZC5kYXRhSW5kZXhJbnNpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGF5bG9hZC5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KHBheWxvYWQuZGF0YUluZGV4KVxuICAgICAgICAgICAgICAgID8genJVdGlsLm1hcChwYXlsb2FkLmRhdGFJbmRleCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmluZGV4T2ZSYXdJbmRleCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IGRhdGEuaW5kZXhPZlJhd0luZGV4KHBheWxvYWQuZGF0YUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXlsb2FkLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KHBheWxvYWQubmFtZSlcbiAgICAgICAgICAgICAgICA/IHpyVXRpbC5tYXAocGF5bG9hZC5uYW1lLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuaW5kZXhPZk5hbWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBkYXRhLmluZGV4T2ZOYW1lKHBheWxvYWQubmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZpbmRlclxuICAgICAqICAgICAgICBJZiBzdHJpbmcsIGUuZy4sICdnZW8nLCBtZWFucyB7Z2VvSW5kZXg6IDB9LlxuICAgICAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxuICAgICAqICAgICAgICB7XG4gICAgICogICAgICAgICAgICBzZXJpZXNJbmRleCwgc2VyaWVzSWQsIHNlcmllc05hbWUsXG4gICAgICogICAgICAgICAgICBnZW9JbmRleCwgZ2VvSWQsIGdvZU5hbWUsXG4gICAgICogICAgICAgICAgICBibWFwSW5kZXgsIGJtYXBJZCwgYm1hcE5hbWUsXG4gICAgICogICAgICAgICAgICB4QXhpc0luZGV4LCB4QXhpc0lkLCB4QXhpc05hbWUsXG4gICAgICogICAgICAgICAgICB5QXhpc0luZGV4LCB5QXhpc0lkLCB5QXhpc05hbWUsXG4gICAgICogICAgICAgICAgICBncmlkSW5kZXgsIGdyaWRJZCwgZ3JpZE5hbWUsXG4gICAgICogICAgICAgICAgICAuLi4gKGNhbiBiZSBleHRlbmRlZClcbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICAgICBFYWNoIHByb3BlcnRpZXMgY2FuIGJlIG51bWJlcnxzdHJpbmd8QXJyYXkuPG51bWJlcj58QXJyYXkuPHN0cmluZz5cbiAgICAgKiAgICAgICAgRm9yIGV4YW1wbGUsIGEgZmluZGVyIGNvdWxkIGJlXG4gICAgICogICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgIHNlcmllc0luZGV4OiAzLFxuICAgICAqICAgICAgICAgICAgZ2VvSWQ6IFsnYWEnLCAnY2MnXSxcbiAgICAgKiAgICAgICAgICAgIGdyaWROYW1lOiBbJ3h4JywgJ3JyJ11cbiAgICAgKiAgICAgICAgfVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmRlZmF1bHRNYWluVHlwZV1cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdCBsaWtlOlxuICAgICAqICAgICAgICB7XG4gICAgICogICAgICAgICAgICBzZXJpZXNNb2RlbHM6IFtzZXJpZXNNb2RlbDEsIHNlcmllc01vZGVsMl0sXG4gICAgICogICAgICAgICAgICBzZXJpZXNNb2RlbDogc2VyaWVzTW9kZWwxLCAvLyBUaGUgZmlyc3QgbW9kZWxcbiAgICAgKiAgICAgICAgICAgIGdlb01vZGVsczogW2dlb01vZGVsMSwgZ2VvTW9kZWwyXSxcbiAgICAgKiAgICAgICAgICAgIGdlb01vZGVsOiBnZW9Nb2RlbDEsIC8vIFRoZSBmaXJzdCBtb2RlbFxuICAgICAqICAgICAgICAgICAgLi4uXG4gICAgICogICAgICAgIH1cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwucGFyc2VGaW5kZXIgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCBvcHQpIHtcbiAgICAgICAgaWYgKHpyVXRpbC5pc1N0cmluZyhmaW5kZXIpKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgICBvYmpbZmluZGVyICsgJ0luZGV4J10gPSAwO1xuICAgICAgICAgICAgZmluZGVyID0gb2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZmF1bHRNYWluVHlwZSA9IG9wdCAmJiBvcHQuZGVmYXVsdE1haW5UeXBlO1xuICAgICAgICBpZiAoZGVmYXVsdE1haW5UeXBlXG4gICAgICAgICAgICAmJiAhaGFzKGZpbmRlciwgZGVmYXVsdE1haW5UeXBlICsgJ0luZGV4JylcbiAgICAgICAgICAgICYmICFoYXMoZmluZGVyLCBkZWZhdWx0TWFpblR5cGUgKyAnSWQnKVxuICAgICAgICAgICAgJiYgIWhhcyhmaW5kZXIsIGRlZmF1bHRNYWluVHlwZSArICdOYW1lJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBmaW5kZXJbZGVmYXVsdE1haW5UeXBlICsgJ0luZGV4J10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGVhY2goZmluZGVyLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZmluZGVyW2tleV07XG5cbiAgICAgICAgICAgIC8vIEV4Y2x1ZGUgJ2RhdGFJbmRleCcgYW5kIG90aGVyIGlsbGdhbCBrZXlzLlxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2RhdGFJbmRleCcgfHwga2V5ID09PSAnZGF0YUluZGV4SW5zaWRlJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFyc2VkS2V5ID0ga2V5Lm1hdGNoKC9eKFxcdyspKEluZGV4fElkfE5hbWUpJC8pIHx8IFtdO1xuICAgICAgICAgICAgdmFyIG1haW5UeXBlID0gcGFyc2VkS2V5WzFdO1xuICAgICAgICAgICAgdmFyIHF1ZXJ5VHlwZSA9IHBhcnNlZEtleVsyXTtcblxuICAgICAgICAgICAgaWYgKCFtYWluVHlwZSB8fCAhcXVlcnlUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcXVlcnlQYXJhbSA9IHttYWluVHlwZTogbWFpblR5cGV9O1xuICAgICAgICAgICAgcXVlcnlQYXJhbVtxdWVyeVR5cGUudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHZhciBtb2RlbHMgPSBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyhxdWVyeVBhcmFtKTtcbiAgICAgICAgICAgIHJlc3VsdFttYWluVHlwZSArICdNb2RlbHMnXSA9IG1vZGVscztcbiAgICAgICAgICAgIHJlc3VsdFttYWluVHlwZSArICdNb2RlbCddID0gbW9kZWxzWzBdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYXMob2JqLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbW9kZWxVdGlsO1xuIiwiLyoqXG4gKiDmlbDlgLzlpITnkIbmqKHlnZdcbiAqIEBtb2R1bGUgZWNoYXJ0cy91dGlsL251bWJlclxuICovXG5cblxuXG4gICAgdmFyIG51bWJlciA9IHt9O1xuXG4gICAgdmFyIFJBRElBTl9FUFNJTE9OID0gMWUtNDtcblxuICAgIGZ1bmN0aW9uIF90cmltKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpbmVhciBtYXBwaW5nIGEgdmFsdWUgZnJvbSBkb21haW4gdG8gcmFuZ2VcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmVjaGFydHMvdXRpbC9udW1iZXJcbiAgICAgKiBAcGFyYW0gIHsobnVtYmVyfEFycmF5LjxudW1iZXI+KX0gdmFsXG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IGRvbWFpbiBEb21haW4gZXh0ZW50IGRvbWFpblswXSBjYW4gYmUgYmlnZ2VyIHRoYW4gZG9tYWluWzFdXG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJhbmdlICBSYW5nZSBleHRlbnQgcmFuZ2VbMF0gY2FuIGJlIGJpZ2dlciB0aGFuIHJhbmdlWzFdXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gY2xhbXBcbiAgICAgKiBAcmV0dXJuIHsobnVtYmVyfEFycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIG51bWJlci5saW5lYXJNYXAgPSBmdW5jdGlvbiAodmFsLCBkb21haW4sIHJhbmdlLCBjbGFtcCkge1xuICAgICAgICB2YXIgc3ViRG9tYWluID0gZG9tYWluWzFdIC0gZG9tYWluWzBdO1xuICAgICAgICB2YXIgc3ViUmFuZ2UgPSByYW5nZVsxXSAtIHJhbmdlWzBdO1xuXG4gICAgICAgIGlmIChzdWJEb21haW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJSYW5nZSA9PT0gMFxuICAgICAgICAgICAgICAgID8gcmFuZ2VbMF1cbiAgICAgICAgICAgICAgICA6IChyYW5nZVswXSArIHJhbmdlWzFdKSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdm9pZCBhY2N1cmFjeSBwcm9ibGVtIGluIGVkZ2UsIHN1Y2ggYXNcbiAgICAgICAgLy8gMTQ2LjM5IC0gNjIuODMgPT09IDgzLjU1OTk5OTk5OTk5OTk5LlxuICAgICAgICAvLyBTZWUgZWNoYXJ0cy90ZXN0L3V0L3NwZWMvdXRpbC9udW1iZXIuanMjbGluZWFyTWFwI2FjY3VyYWN5RXJyb3JcbiAgICAgICAgLy8gSXQgaXMgYSBsaXR0bGUgdmVyYm9zZSBmb3IgZWZmaWNpZW5jeSBjb25zaWRlcmluZyB0aGlzIG1ldGhvZFxuICAgICAgICAvLyBpcyBhIGhvdHNwb3QuXG4gICAgICAgIGlmIChjbGFtcCkge1xuICAgICAgICAgICAgaWYgKHN1YkRvbWFpbiA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsIDw9IGRvbWFpblswXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA+PSBkb21haW5bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPj0gZG9tYWluWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsIDw9IGRvbWFpblsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbCA9PT0gZG9tYWluWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gZG9tYWluWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh2YWwgLSBkb21haW5bMF0pIC8gc3ViRG9tYWluICogc3ViUmFuZ2UgKyByYW5nZVswXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHBlcmNlbnQgc3RyaW5nIHRvIGFic29sdXRlIG51bWJlci5cbiAgICAgKiBSZXR1cm5zIE5hTiBpZiBwZXJjZW50IGlzIG5vdCBhIHZhbGlkIHN0cmluZyBvciBudW1iZXJcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmVjaGFydHMvdXRpbC9udW1iZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWxsXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlci5wYXJzZVBlcmNlbnQgPSBmdW5jdGlvbihwZXJjZW50LCBhbGwpIHtcbiAgICAgICAgc3dpdGNoIChwZXJjZW50KSB7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gJzUwJSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICcwJSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAnMTAwJSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJjZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKF90cmltKHBlcmNlbnQpLm1hdGNoKC8lJC8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocGVyY2VudCkgLyAxMDAgKiBhbGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBlcmNlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBlcmNlbnQgPT0gbnVsbCA/IE5hTiA6ICtwZXJjZW50O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXggcm91bmRpbmcgZXJyb3Igb2YgZmxvYXQgbnVtYmVyc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlci5yb3VuZCA9IGZ1bmN0aW9uICh4LCBwcmVjaXNpb24pIHtcbiAgICAgICAgaWYgKHByZWNpc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSAxMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdm9pZCByYW5nZSBlcnJvclxuICAgICAgICBwcmVjaXNpb24gPSBNYXRoLm1pbihNYXRoLm1heCgwLCBwcmVjaXNpb24pLCAyMCk7XG4gICAgICAgIHJldHVybiArKCt4KS50b0ZpeGVkKHByZWNpc2lvbik7XG4gICAgfTtcblxuICAgIG51bWJlci5hc2MgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcHJlY2lzaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICAgICAqL1xuICAgIG51bWJlci5nZXRQcmVjaXNpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhbCA9ICt2YWw7XG4gICAgICAgIGlmIChpc05hTih2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBtdWNoIGZhc3RlciB0aGFuIG1ldGhvZHMgY29udmVydGluZyBudW1iZXIgdG8gc3RyaW5nIGFzIGZvbGxvd3NcbiAgICAgICAgLy8gICAgICB2YXIgdG1wID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vICAgICAgcmV0dXJuIHRtcC5sZW5ndGggLSAxIC0gdG1wLmluZGV4T2YoJy4nKTtcbiAgICAgICAgLy8gZXNwZWNpYWxseSB3aGVuIHByZWNpc2lvbiBpcyBsb3dcbiAgICAgICAgdmFyIGUgPSAxO1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICB3aGlsZSAoTWF0aC5yb3VuZCh2YWwgKiBlKSAvIGUgIT09IHZhbCkge1xuICAgICAgICAgICAgZSAqPSAxMDtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH07XG5cbiAgICBudW1iZXIuZ2V0UHJlY2lzaW9uU2FmZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIHN0ciA9IHZhbC50b1N0cmluZygpO1xuICAgICAgICB2YXIgZG90SW5kZXggPSBzdHIuaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZG90SW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyLmxlbmd0aCAtIDEgLSBkb3RJbmRleDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWluaW1hbCBkaWNlcm5pYmxlIGRhdGEgcHJlY2lzaW9pbiBhY2NvcmRpbmcgdG8gYSBzaW5nbGUgcGl4ZWwuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YUV4dGVudFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBpeGVsRXh0ZW50XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBwcmVjaXNpb25cbiAgICAgKi9cbiAgICBudW1iZXIuZ2V0UGl4ZWxQcmVjaXNpb24gPSBmdW5jdGlvbiAoZGF0YUV4dGVudCwgcGl4ZWxFeHRlbnQpIHtcbiAgICAgICAgdmFyIGxvZyA9IE1hdGgubG9nO1xuICAgICAgICB2YXIgTE4xMCA9IE1hdGguTE4xMDtcbiAgICAgICAgdmFyIGRhdGFRdWFudGl0eSA9IE1hdGguZmxvb3IobG9nKGRhdGFFeHRlbnRbMV0gLSBkYXRhRXh0ZW50WzBdKSAvIExOMTApO1xuICAgICAgICB2YXIgc2l6ZVF1YW50aXR5ID0gTWF0aC5yb3VuZChsb2coTWF0aC5hYnMocGl4ZWxFeHRlbnRbMV0gLSBwaXhlbEV4dGVudFswXSkpIC8gTE4xMCk7XG4gICAgICAgIC8vIHRvRml4ZWQoKSBkaWdpdHMgYXJndW1lbnQgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDIwLlxuICAgICAgICB2YXIgcHJlY2lzaW9uID0gTWF0aC5taW4oTWF0aC5tYXgoLWRhdGFRdWFudGl0eSArIHNpemVRdWFudGl0eSwgMCksIDIwKTtcbiAgICAgICAgcmV0dXJuICFpc0Zpbml0ZShwcmVjaXNpb24pID8gMjAgOiBwcmVjaXNpb247XG4gICAgfTtcblxuICAgIC8vIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCBpZSBkbyBub3Qgc3VwcG9ydC5cbiAgICBudW1iZXIuTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbiAgICAvKipcbiAgICAgKiBUbyAwIC0gMiAqIFBJLCBjb25zaWRlcmluZyBuZWdhdGl2ZSByYWRpYW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhblxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIucmVtUmFkaWFuID0gZnVuY3Rpb24gKHJhZGlhbikge1xuICAgICAgICB2YXIgcGkyID0gTWF0aC5QSSAqIDI7XG4gICAgICAgIHJldHVybiAocmFkaWFuICUgcGkyICsgcGkyKSAlIHBpMjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHt0eXBlfSByYWRpYW5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIG51bWJlci5pc1JhZGlhbkFyb3VuZFplcm8gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPiAtUkFESUFOX0VQU0lMT04gJiYgdmFsIDwgUkFESUFOX0VQU0lMT047XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfERhdGV8bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0RhdGV9IGRhdGVcbiAgICAgKi9cbiAgICBudW1iZXIucGFyc2VEYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBUcmVhdCBhcyBJU08gZm9ybWF0LiBTZWUgaXNzdWUgIzM2MjNcbiAgICAgICAgICAgIHZhciByZXQgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNOYU4oK3JldCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBuZXcgRGF0ZSgnMTk3MC0wMS0wMScpIGlzIFVUQywgbmV3IERhdGUoJzE5NzAvMDEvMDEnKSBpcyBsb2NhbFxuICAgICAgICAgICAgICAgIHJldCA9IG5ldyBEYXRlKG5ldyBEYXRlKHZhbHVlLnJlcGxhY2UoLy0vZywgJy8nKSkgLSBuZXcgRGF0ZSgnMTk3MC8wMS8wMScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERhdGUoTWF0aC5yb3VuZCh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBRdWFudGl0eSBvZiBhIG51bWJlci4gZS5nLiAwLjEsIDEsIDEwLCAxMDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIucXVhbnRpdHkgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjEwKSk7XG4gICAgfTtcblxuICAgIC8vIFwiTmljZSBOdW1iZXJzIGZvciBHcmFwaCBMYWJlbHNcIiBvZiBHcmFwaGljIEdlbXNcbiAgICAvKipcbiAgICAgKiBmaW5kIGEg4oCcbmljZeKAnSBudW1iZXIgYXBwcm94aW1hdGVseSBlcXVhbCB0byB4LiBSb3VuZCB0aGUgbnVtYmVyIGlmIHJvdW5kID0gdHJ1ZSwgdGFrZSBjZWlsaW5nIGlmIHJvdW5kID0gZmFsc2VcbiAgICAgKiBUaGUgcHJpbWFyeSBvYnNlcnZhdGlvbiBpcyB0aGF0IHRoZSDigJxuaWNlc3TigJ0gbnVtYmVycyBpbiBkZWNpbWFsIGFyZSAxLCAyLCBhbmQgNSwgYW5kIGFsbCBwb3dlci1vZi10ZW4gbXVsdGlwbGVzIG9mIHRoZXNlIG51bWJlcnMuXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSByb3VuZFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIubmljZSA9IGZ1bmN0aW9uICh2YWwsIHJvdW5kKSB7XG4gICAgICAgIHZhciBleHAxMCA9IG51bWJlci5xdWFudGl0eSh2YWwpO1xuICAgICAgICB2YXIgZiA9IHZhbCAvIGV4cDEwOyAvLyBiZXR3ZWVuIDEgYW5kIDEwXG4gICAgICAgIHZhciBuZjtcbiAgICAgICAgaWYgKHJvdW5kKSB7XG4gICAgICAgICAgICBpZiAoZiA8IDEuNSkgeyBuZiA9IDE7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGYgPCAyLjUpIHsgbmYgPSAyOyB9XG4gICAgICAgICAgICBlbHNlIGlmIChmIDwgNCkgeyBuZiA9IDM7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGYgPCA3KSB7IG5mID0gNTsgfVxuICAgICAgICAgICAgZWxzZSB7IG5mID0gMTA7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmIDwgMSkgeyBuZiA9IDE7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGYgPCAyKSB7IG5mID0gMjsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZiA8IDMpIHsgbmYgPSAzOyB9XG4gICAgICAgICAgICBlbHNlIGlmIChmIDwgNSkgeyBuZiA9IDU7IH1cbiAgICAgICAgICAgIGVsc2UgeyBuZiA9IDEwOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5mICogZXhwMTA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE9yZGVyIGludGVydmFscyBhc2MsIGFuZCBzcGxpdCB0aGVtIHdoZW4gb3ZlcmxhcC5cbiAgICAgKiBleHBlY3QobnVtYmVyVXRpbC5yZWZvcm1JbnRlcnZhbHMoW1xuICAgICAqICAgICB7aW50ZXJ2YWw6IFsxOCwgNjJdLCBjbG9zZTogWzEsIDFdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbLUluZmluaXR5LCAtNzBdLCBjbG9zZTogWzAsIDBdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbLTcwLCAtMjZdLCBjbG9zZTogWzEsIDFdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbLTI2LCAxOF0sIGNsb3NlOiBbMSwgMV19LFxuICAgICAqICAgICB7aW50ZXJ2YWw6IFs2MiwgMTUwXSwgY2xvc2U6IFsxLCAxXX0sXG4gICAgICogICAgIHtpbnRlcnZhbDogWzEwNiwgMTUwXSwgY2xvc2U6IFsxLCAxXX0sXG4gICAgICogICAgIHtpbnRlcnZhbDogWzE1MCwgSW5maW5pdHldLCBjbG9zZTogWzAsIDBdfVxuICAgICAqIF0pKS50b0VxdWFsKFtcbiAgICAgKiAgICAge2ludGVydmFsOiBbLUluZmluaXR5LCAtNzBdLCBjbG9zZTogWzAsIDBdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbLTcwLCAtMjZdLCBjbG9zZTogWzEsIDFdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbLTI2LCAxOF0sIGNsb3NlOiBbMCwgMV19LFxuICAgICAqICAgICB7aW50ZXJ2YWw6IFsxOCwgNjJdLCBjbG9zZTogWzAsIDFdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbNjIsIDE1MF0sIGNsb3NlOiBbMCwgMV19LFxuICAgICAqICAgICB7aW50ZXJ2YWw6IFsxNTAsIEluZmluaXR5XSwgY2xvc2U6IFswLCAwXX1cbiAgICAgKiBdKTtcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBsaXN0LCB3aGVyZSBgY2xvc2VgIG1lYW4gb3BlbiBvciBjbG9zZVxuICAgICAqICAgICAgICBvZiB0aGUgaW50ZXJ2YWwsIGFuZCBJbmZpbml0eSBjYW4gYmUgdXNlZC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn0gVGhlIG9yaWdpbiBsaXN0LCB3aGljaCBoYXMgYmVlbiByZWZvcm1lZC5cbiAgICAgKi9cbiAgICBudW1iZXIucmVmb3JtSW50ZXJ2YWxzID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgbGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gbGl0dGxlVGhhbihhLCBiLCAwKSA/IC0xIDogMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGN1cnIgPSAtSW5maW5pdHk7XG4gICAgICAgIHZhciBjdXJyQ2xvc2UgPSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOykge1xuICAgICAgICAgICAgdmFyIGludGVydmFsID0gbGlzdFtpXS5pbnRlcnZhbDtcbiAgICAgICAgICAgIHZhciBjbG9zZSA9IGxpc3RbaV0uY2xvc2U7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGxnID0gMDsgbGcgPCAyOyBsZysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVydmFsW2xnXSA8PSBjdXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsW2xnXSA9IGN1cnI7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlW2xnXSA9ICFsZyA/IDEgLSBjdXJyQ2xvc2UgOiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyID0gaW50ZXJ2YWxbbGddO1xuICAgICAgICAgICAgICAgIGN1cnJDbG9zZSA9IGNsb3NlW2xnXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGludGVydmFsWzBdID09PSBpbnRlcnZhbFsxXSAmJiBjbG9zZVswXSAqIGNsb3NlWzFdICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcblxuICAgICAgICBmdW5jdGlvbiBsaXR0bGVUaGFuKGEsIGIsIGxnKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5pbnRlcnZhbFtsZ10gPCBiLmludGVydmFsW2xnXVxuICAgICAgICAgICAgICAgIHx8IChcbiAgICAgICAgICAgICAgICAgICAgYS5pbnRlcnZhbFtsZ10gPT09IGIuaW50ZXJ2YWxbbGddXG4gICAgICAgICAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChhLmNsb3NlW2xnXSAtIGIuY2xvc2VbbGddID09PSAoIWxnID8gMSA6IC0xKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICghbGcgJiYgbGl0dGxlVGhhbihhLCBiLCAxKSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKG51bGx8dHJ1ZXxmYWxzZXxcIlwiKVxuICAgICAqIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcbiAgICAgKiBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cbiAgICAgKiBAcGFyYW0geyp9IHZcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIG51bWJlci5pc051bWVyaWMgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdiAtIHBhcnNlRmxvYXQodikgPj0gMDtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBudW1iZXI7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBTeW1ib2wgZmFjdG9yeVxuXG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4vZ3JhcGhpYycpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuXG4gICAgLyoqXG4gICAgICogVHJpYW5nbGUgc2hhcGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgVHJpYW5nbGUgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgICAgICAgdHlwZTogJ3RyaWFuZ2xlJyxcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIGN4OiAwLFxuICAgICAgICAgICAgY3k6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LFxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIGN4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgY3kgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoIC8gMjtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4ICsgd2lkdGgsIGN5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4IC0gd2lkdGgsIGN5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBEaWFtb25kIHNoYXBlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIERpYW1vbmQgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgICAgICAgdHlwZTogJ2RpYW1vbmQnLFxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgY3ggPSBzaGFwZS5jeDtcbiAgICAgICAgICAgIHZhciBjeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodCAvIDI7XG4gICAgICAgICAgICBwYXRoLm1vdmVUbyhjeCwgY3kgLSBoZWlnaHQpO1xuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kpO1xuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3gsIGN5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4IC0gd2lkdGgsIGN5KTtcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFBpbiBzaGFwZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBQaW4gPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgICAgICAgdHlwZTogJ3BpbicsXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAvLyB4LCB5IG9uIHRoZSBjdXNwXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgIHZhciB3ID0gc2hhcGUud2lkdGggLyA1ICogMztcbiAgICAgICAgICAgIC8vIEhlaWdodCBtdXN0IGJlIGxhcmdlciB0aGFuIHdpZHRoXG4gICAgICAgICAgICB2YXIgaCA9IE1hdGgubWF4KHcsIHNoYXBlLmhlaWdodCk7XG4gICAgICAgICAgICB2YXIgciA9IHcgLyAyO1xuXG4gICAgICAgICAgICAvLyBEaXN0IG9uIHkgd2l0aCB0YW5nZW50IHBvaW50IGFuZCBjaXJjbGUgY2VudGVyXG4gICAgICAgICAgICB2YXIgZHkgPSByICogciAvIChoIC0gcik7XG4gICAgICAgICAgICB2YXIgY3kgPSB5IC0gaCArIHIgKyBkeTtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXNpbihkeSAvIHIpO1xuICAgICAgICAgICAgLy8gRGlzdCBvbiB4IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxuICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5jb3MoYW5nbGUpICogcjtcblxuICAgICAgICAgICAgdmFyIHRhblggPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgICB2YXIgdGFuWSA9IE1hdGguY29zKGFuZ2xlKTtcblxuICAgICAgICAgICAgcGF0aC5hcmMoXG4gICAgICAgICAgICAgICAgeCwgY3ksIHIsXG4gICAgICAgICAgICAgICAgTWF0aC5QSSAtIGFuZ2xlLFxuICAgICAgICAgICAgICAgIE1hdGguUEkgKiAyICsgYW5nbGVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBjcExlbiA9IHIgKiAwLjY7XG4gICAgICAgICAgICB2YXIgY3BMZW4yID0gciAqIDAuNztcbiAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4ICsgZHggLSB0YW5YICogY3BMZW4sIGN5ICsgZHkgKyB0YW5ZICogY3BMZW4sXG4gICAgICAgICAgICAgICAgeCwgeSAtIGNwTGVuMixcbiAgICAgICAgICAgICAgICB4LCB5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHgsIHkgLSBjcExlbjIsXG4gICAgICAgICAgICAgICAgeCAtIGR4ICsgdGFuWCAqIGNwTGVuLCBjeSArIGR5ICsgdGFuWSAqIGNwTGVuLFxuICAgICAgICAgICAgICAgIHggLSBkeCwgY3kgKyBkeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFycm93IHNoYXBlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIEFycm93ID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG5cbiAgICAgICAgdHlwZTogJ2Fycm93JyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgIHZhciBkeCA9IHdpZHRoIC8gMyAqIDI7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgZHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgaGVpZ2h0IC8gNCAqIDMpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0gZHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogTWFwIG9mIHBhdGggY29udHJ1Y3RvcnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aD59XG4gICAgICovXG4gICAgdmFyIHN5bWJvbEN0b3JzID0ge1xuICAgICAgICBsaW5lOiBncmFwaGljLkxpbmUsXG5cbiAgICAgICAgcmVjdDogZ3JhcGhpYy5SZWN0LFxuXG4gICAgICAgIHJvdW5kUmVjdDogZ3JhcGhpYy5SZWN0LFxuXG4gICAgICAgIHNxdWFyZTogZ3JhcGhpYy5SZWN0LFxuXG4gICAgICAgIGNpcmNsZTogZ3JhcGhpYy5DaXJjbGUsXG5cbiAgICAgICAgZGlhbW9uZDogRGlhbW9uZCxcblxuICAgICAgICBwaW46IFBpbixcblxuICAgICAgICBhcnJvdzogQXJyb3csXG5cbiAgICAgICAgdHJpYW5nbGU6IFRyaWFuZ2xlXG4gICAgfTtcblxuICAgIHZhciBzeW1ib2xTaGFwZU1ha2VycyA9IHtcblxuICAgICAgICBsaW5lOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBzaGFwZS54MSA9IHg7XG4gICAgICAgICAgICBzaGFwZS55MSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgIHNoYXBlLngyID0geCArIHc7XG4gICAgICAgICAgICBzaGFwZS55MiA9IHkgKyBoIC8gMjtcbiAgICAgICAgfSxcblxuICAgICAgICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xuICAgICAgICAgICAgc2hhcGUueSA9IHk7XG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJvdW5kUmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgICAgICAgICBzaGFwZS54ID0geDtcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5O1xuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgICAgICAgICAgIHNoYXBlLnIgPSBNYXRoLm1pbih3LCBoKSAvIDQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3F1YXJlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4odywgaCk7XG4gICAgICAgICAgICBzaGFwZS54ID0geDtcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5O1xuICAgICAgICAgICAgc2hhcGUud2lkdGggPSBzaXplO1xuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gc2l6ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjaXJjbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgICAgICAgICAgLy8gUHV0IGNpcmNsZSBpbiB0aGUgY2VudGVyIG9mIHNxdWFyZVxuICAgICAgICAgICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XG4gICAgICAgICAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgIHNoYXBlLnIgPSBNYXRoLm1pbih3LCBoKSAvIDI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlhbW9uZDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgICAgICAgfSxcblxuICAgICAgICBwaW46IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgICAgICAgICAgc2hhcGUueCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFycm93OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHNoYXBlLnggPSB4ICsgdyAvIDI7XG4gICAgICAgICAgICBzaGFwZS55ID0geSArIGggLyAyO1xuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmlhbmdsZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3ltYm9sQnVpbGRQcm94aWVzID0ge307XG4gICAgZm9yICh2YXIgbmFtZSBpbiBzeW1ib2xDdG9ycykge1xuICAgICAgICBpZiAoc3ltYm9sQ3RvcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHN5bWJvbEJ1aWxkUHJveGllc1tuYW1lXSA9IG5ldyBzeW1ib2xDdG9yc1tuYW1lXSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFN5bWJvbCA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuXG4gICAgICAgIHR5cGU6ICdzeW1ib2wnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBzeW1ib2xUeXBlOiAnJyxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgaWYgKHNoYXBlLnN5bWJvbFR5cGUgPT09ICdwaW4nICYmIHN0eWxlLnRleHRQb3NpdGlvbiA9PT0gJ2luc2lkZScpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0UG9zaXRpb24gPSBbJzUwJScsICc0MCUnXTtcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUsIGluQnVuZGxlKSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sVHlwZSA9IHNoYXBlLnN5bWJvbFR5cGU7XG4gICAgICAgICAgICB2YXIgcHJveHlTeW1ib2wgPSBzeW1ib2xCdWlsZFByb3hpZXNbc3ltYm9sVHlwZV07XG4gICAgICAgICAgICBpZiAoc2hhcGUuc3ltYm9sVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm94eVN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHJlY3RcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sVHlwZSA9ICdyZWN0JztcbiAgICAgICAgICAgICAgICAgICAgcHJveHlTeW1ib2wgPSBzeW1ib2xCdWlsZFByb3hpZXNbc3ltYm9sVHlwZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN5bWJvbFNoYXBlTWFrZXJzW3N5bWJvbFR5cGVdKFxuICAgICAgICAgICAgICAgICAgICBzaGFwZS54LCBzaGFwZS55LCBzaGFwZS53aWR0aCwgc2hhcGUuaGVpZ2h0LCBwcm94eVN5bWJvbC5zaGFwZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcHJveHlTeW1ib2wuYnVpbGRQYXRoKGN0eCwgcHJveHlTeW1ib2wuc2hhcGUsIGluQnVuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUHJvdmlkZSBzZXRDb2xvciBoZWxwZXIgbWV0aG9kIHRvIGF2b2lkIGRldGVybWluZSBpZiBzZXQgdGhlIGZpbGwgb3Igc3Ryb2tlIG91dHNpZGVcbiAgICB2YXIgc3ltYm9sUGF0aFNldENvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdpbWFnZScpIHtcbiAgICAgICAgICAgIHZhciBzeW1ib2xTdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgc3ltYm9sU2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgaWYgKHN5bWJvbFNoYXBlICYmIHN5bWJvbFNoYXBlLnN5bWJvbFR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fX2lzRW1wdHlCcnVzaCkge1xuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLmZpbGwgPSAnI2ZmZic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDliKTmlq3lm77lvaLpu5jorqTmmK/loavlhYXov5jmmK/mj4/ovrnvvIzkvb/nlKggb25seVN0cm9rZSA/XG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuZmlsbCAmJiAoc3ltYm9sU3R5bGUuZmlsbCA9IGNvbG9yKTtcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5zdHJva2UgJiYgKHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzeW1ib2xVdGlsID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgc3ltYm9sIGVsZW1lbnQgd2l0aCBnaXZlbiBzeW1ib2wgY29uZmlndXJhdGlvbjogc2hhcGUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlU3ltYm9sOiBmdW5jdGlvbiAoc3ltYm9sVHlwZSwgeCwgeSwgdywgaCwgY29sb3IpIHtcbiAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gc3ltYm9sVHlwZS5pbmRleE9mKCdlbXB0eScpID09PSAwO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xUeXBlID0gc3ltYm9sVHlwZS5zdWJzdHIoNSwgMSkudG9Mb3dlckNhc2UoKSArIHN5bWJvbFR5cGUuc3Vic3RyKDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN5bWJvbFBhdGg7XG5cbiAgICAgICAgICAgIGlmIChzeW1ib2xUeXBlLmluZGV4T2YoJ2ltYWdlOi8vJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xQYXRoID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHN5bWJvbFR5cGUuc2xpY2UoOCksXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN5bWJvbFR5cGUuaW5kZXhPZigncGF0aDovLycpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IGdyYXBoaWMubWFrZVBhdGgoc3ltYm9sVHlwZS5zbGljZSg3KSwge30sIG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgdywgaCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IG5ldyBTeW1ib2woe1xuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sVHlwZTogc3ltYm9sVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzeW1ib2xQYXRoLl9faXNFbXB0eUJydXNoID0gaXNFbXB0eTtcblxuICAgICAgICAgICAgc3ltYm9sUGF0aC5zZXRDb2xvciA9IHN5bWJvbFBhdGhTZXRDb2xvcjtcblxuICAgICAgICAgICAgc3ltYm9sUGF0aC5zZXRDb2xvcihjb2xvcik7XG5cbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xQYXRoO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gc3ltYm9sVXRpbDtcbiIsIlxuXG4gICAgdmFyIGxpYiA9IHt9O1xuXG4gICAgdmFyIE9SSUdJTl9NRVRIT0QgPSAnXFwwX190aHJvdHRsZU9yaWdpbk1ldGhvZCc7XG4gICAgdmFyIFJBVEUgPSAnXFwwX190aHJvdHRsZVJhdGUnO1xuICAgIHZhciBUSFJPVFRMRV9UWVBFID0gJ1xcMF9fdGhyb3R0bGVUeXBlJztcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0geyhGdW5jdGlvbil9IGZuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXSBVbml0OiBtcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWJvdW5jZT1mYWxzZV1cbiAgICAgKiAgICAgICAgdHJ1ZTogSWYgY2FsbCBpbnRlcnZhbCBsZXNzIHRoYW4gYGRlbGF5YCwgb25seSB0aGUgbGFzdCBjYWxsIHdvcmtzLlxuICAgICAqICAgICAgICBmYWxzZTogSWYgY2FsbCBpbnRlcnZhbCBsZXNzIHRoYW4gYGRlbGF5LCBjYWxsIHdvcmtzIG9uIGZpeGVkIHJhdGUuXG4gICAgICogQHJldHVybiB7KEZ1bmN0aW9uKX0gdGhyb3R0bGVkIGZuLlxuICAgICAqL1xuICAgIGxpYi50aHJvdHRsZSA9IGZ1bmN0aW9uIChmbiwgZGVsYXksIGRlYm91bmNlKSB7XG5cbiAgICAgICAgdmFyIGN1cnJDYWxsO1xuICAgICAgICB2YXIgbGFzdENhbGwgPSAwO1xuICAgICAgICB2YXIgbGFzdEV4ZWMgPSAwO1xuICAgICAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgICAgICB2YXIgZGlmZjtcbiAgICAgICAgdmFyIHNjb3BlO1xuICAgICAgICB2YXIgYXJncztcblxuICAgICAgICBkZWxheSA9IGRlbGF5IHx8IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICAgIGxhc3RFeGVjID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGZuLmFwcGx5KHNjb3BlLCBhcmdzIHx8IFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGN1cnJDYWxsID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHNjb3BlID0gdGhpcztcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBkaWZmID0gY3VyckNhbGwgLSAoZGVib3VuY2UgPyBsYXN0Q2FsbCA6IGxhc3RFeGVjKSAtIGRlbGF5O1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgICAgICBpZiAoZGVib3VuY2UpIHtcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZXhlYywgZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBleGVjKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZXhlYywgLWRpZmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdENhbGwgPSBjdXJyQ2FsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXIgdGhyb3R0bGUuXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIGNiLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGNiO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhyb3R0bGUgbWV0aG9kIG9yIHVwZGF0ZSB0aHJvdHRsZSByYXRlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgIC4uLlxuICAgICAqICAgICB0aHJvdHRsZS5jcmVhdGVPclVwZGF0ZShcbiAgICAgKiAgICAgICAgIHRoaXMsXG4gICAgICogICAgICAgICAnX2Rpc3BhdGNoQWN0aW9uJyxcbiAgICAgKiAgICAgICAgIHRoaXMubW9kZWwuZ2V0KCd0aHJvdHRsZScpLFxuICAgICAqICAgICAgICAgJ2ZpeFJhdGUnXG4gICAgICogICAgICk7XG4gICAgICogfTtcbiAgICAgKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgIHRocm90dGxlLmNsZWFyKHRoaXMsICdfZGlzcGF0Y2hBY3Rpb24nKTtcbiAgICAgKiB9O1xuICAgICAqIENvbXBvbmVudFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgIHRocm90dGxlLmNsZWFyKHRoaXMsICdfZGlzcGF0Y2hBY3Rpb24nKTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm5BdHRyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYXRlXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGhyb3R0bGVUeXBlPSdmaXhSYXRlJ10gJ2ZpeFJhdGUnIG9yICdkZWJvdW5jZSdcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGxpYi5jcmVhdGVPclVwZGF0ZSA9IGZ1bmN0aW9uIChvYmosIGZuQXR0ciwgcmF0ZSwgdGhyb3R0bGVUeXBlKSB7XG4gICAgICAgIHZhciBmbiA9IG9ialtmbkF0dHJdO1xuXG4gICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcmlnaW5GbiA9IGZuW09SSUdJTl9NRVRIT0RdIHx8IGZuO1xuICAgICAgICB2YXIgbGFzdFRocm90dGxlVHlwZSA9IGZuW1RIUk9UVExFX1RZUEVdO1xuICAgICAgICB2YXIgbGFzdFJhdGUgPSBmbltSQVRFXTtcblxuICAgICAgICBpZiAobGFzdFJhdGUgIT09IHJhdGUgfHwgbGFzdFRocm90dGxlVHlwZSAhPT0gdGhyb3R0bGVUeXBlKSB7XG4gICAgICAgICAgICBpZiAocmF0ZSA9PSBudWxsIHx8ICF0aHJvdHRsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG9ialtmbkF0dHJdID0gb3JpZ2luRm4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbiA9IG9ialtmbkF0dHJdID0gbGliLnRocm90dGxlKFxuICAgICAgICAgICAgICAgIG9yaWdpbkZuLCByYXRlLCB0aHJvdHRsZVR5cGUgPT09ICdkZWJvdW5jZSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmbltPUklHSU5fTUVUSE9EXSA9IG9yaWdpbkZuO1xuICAgICAgICAgICAgZm5bVEhST1RUTEVfVFlQRV0gPSB0aHJvdHRsZVR5cGU7XG4gICAgICAgICAgICBmbltSQVRFXSA9IHJhdGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRocm90dGxlLiBFeGFtcGxlIHNlZSB0aHJvdHRsZS5jcmVhdGVPclVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZuQXR0clxuICAgICAqL1xuICAgIGxpYi5jbGVhciA9IGZ1bmN0aW9uIChvYmosIGZuQXR0cikge1xuICAgICAgICB2YXIgZm4gPSBvYmpbZm5BdHRyXTtcbiAgICAgICAgaWYgKGZuICYmIGZuW09SSUdJTl9NRVRIT0RdKSB7XG4gICAgICAgICAgICBvYmpbZm5BdHRyXSA9IGZuW09SSUdJTl9NRVRIT0RdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gbGliO1xuXG4iLCJcblxuICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xuICAgIHZhciBjb21wb25lbnRVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9jb21wb25lbnQnKTtcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9jbGF6eicpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgZnVuY3Rpb24gQ2hhcnQoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudWlkID0gY29tcG9uZW50VXRpbC5nZXRVSUQoJ3ZpZXdDaGFydCcpO1xuICAgIH1cblxuICAgIENoYXJ0LnByb3RvdHlwZSA9IHtcblxuICAgICAgICB0eXBlOiAnY2hhcnQnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0IHRoZSBjaGFydFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGNoYXJ0XG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhpZ2hsaWdodCBzZXJpZXMgb3Igc3BlY2lmaWVkIGRhdGEgaXRlbVxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICovXG4gICAgICAgIGhpZ2hsaWdodDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHRvZ2dsZUhpZ2hsaWdodChzZXJpZXNNb2RlbC5nZXREYXRhKCksIHBheWxvYWQsICdlbXBoYXNpcycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEb3ducGxheSBzZXJpZXMgb3Igc3BlY2lmaWVkIGRhdGEgaXRlbVxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICovXG4gICAgICAgIGRvd25wbGF5OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgdG9nZ2xlSGlnaGxpZ2h0KHNlcmllc01vZGVsLmdldERhdGEoKSwgcGF5bG9hZCwgJ25vcm1hbCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgc2VsZlxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcG9zZSBzZWxmXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge31cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZpZXcgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxuICAgICAgICAgKiBAaW50ZXJmYWNlXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICAvLyBjb250YWluUG9pbnQ6IGZ1bmN0aW9uICgpIHt9XG5cbiAgICB9O1xuXG4gICAgdmFyIGNoYXJ0UHJvdG8gPSBDaGFydC5wcm90b3R5cGU7XG4gICAgY2hhcnRQcm90by51cGRhdGVWaWV3XG4gICAgICAgID0gY2hhcnRQcm90by51cGRhdGVMYXlvdXRcbiAgICAgICAgPSBjaGFydFByb3RvLnVwZGF0ZVZpc3VhbFxuICAgICAgICA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICAgICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBzdGF0ZSBvZiBzaW5nbGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBzdGF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVsU2V0U3RhdGUoZWwsIHN0YXRlKSB7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgZWwudHJpZ2dlcihzdGF0ZSk7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWwuY2hpbGRDb3VudCgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZWxTZXRTdGF0ZShlbC5jaGlsZEF0KGkpLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gc3RhdGUgJ25vcm1hbCd8J2VtcGhhc2lzJ1xuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvZ2dsZUhpZ2hsaWdodChkYXRhLCBwYXlsb2FkLCBzdGF0ZSkge1xuICAgICAgICB2YXIgZGF0YUluZGV4ID0gbW9kZWxVdGlsLnF1ZXJ5RGF0YUluZGV4KGRhdGEsIHBheWxvYWQpO1xuXG4gICAgICAgIGlmIChkYXRhSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2gobW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkoZGF0YUluZGV4KSwgZnVuY3Rpb24gKGRhdGFJZHgpIHtcbiAgICAgICAgICAgICAgICBlbFNldFN0YXRlKGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSWR4KSwgc3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIGVsU2V0U3RhdGUoZWwsIHN0YXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5hYmxlIENoYXJ0LmV4dGVuZC5cbiAgICBjbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoQ2hhcnQsIFsnZGlzcG9zZSddKTtcblxuICAgIC8vIEFkZCBjYXBhYmlsaXR5IG9mIHJlZ2lzdGVyQ2xhc3MsIGdldENsYXNzLCBoYXNDbGFzcywgcmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyIGFuZCBzbyBvbi5cbiAgICBjbGF6elV0aWwuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KENoYXJ0LCB7cmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENoYXJ0O1xuIiwiXG5cbiAgICB2YXIgR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAnKTtcbiAgICB2YXIgY29tcG9uZW50VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY29tcG9uZW50Jyk7XG4gICAgdmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhenonKTtcblxuICAgIHZhciBDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXAgPSBuZXcgR3JvdXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVpZCA9IGNvbXBvbmVudFV0aWwuZ2V0VUlEKCd2aWV3Q29tcG9uZW50Jyk7XG4gICAgfTtcblxuICAgIENvbXBvbmVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IENvbXBvbmVudCxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7fSxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChjb21wb25lbnRNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7fSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fVxuXG4gICAgfTtcblxuICAgIHZhciBjb21wb25lbnRQcm90byA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gICAgY29tcG9uZW50UHJvdG8udXBkYXRlVmlld1xuICAgICAgICA9IGNvbXBvbmVudFByb3RvLnVwZGF0ZUxheW91dFxuICAgICAgICA9IGNvbXBvbmVudFByb3RvLnVwZGF0ZVZpc3VhbFxuICAgICAgICA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nO1xuICAgICAgICB9O1xuICAgIC8vIEVuYWJsZSBDb21wb25lbnQuZXh0ZW5kLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChDb21wb25lbnQpO1xuXG4gICAgLy8gRW5hYmxlIGNhcGFiaWxpdHkgb2YgcmVnaXN0ZXJDbGFzcywgZ2V0Q2xhc3MsIGhhc0NsYXNzLCByZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgYW5kIHNvIG9uLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoQ29tcG9uZW50LCB7cmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudDtcbiIsIi8vIFBpY2sgY29sb3IgZnJvbSBwYWxldHRlIGZvciBlYWNoIGRhdGEgaXRlbS5cbi8vIEFwcGxpY2FibGUgZm9yIGNoYXJ0cyB0aGF0IHJlcXVpcmUgYXBwbHlpbmcgY29sb3IgcGFsZXR0ZVxuLy8gaW4gZGF0YSBsZXZlbCAobGlrZSBwaWUsIGZ1bm5lbCwgY2hvcmQpLlxuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBlY01vZGVsKSB7XG4gICAgICAgIC8vIFBpZSBhbmQgZnVubmVsIG1heSB1c2UgZGlmZXJyZW50IHNjb3BlXG4gICAgICAgIHZhciBwYWxldHRlU2NvcGUgPSB7fTtcbiAgICAgICAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGRhdGFBbGwgPSBzZXJpZXNNb2RlbC5nZXRSYXdEYXRhKCk7XG4gICAgICAgICAgICB2YXIgaWR4TWFwID0ge307XG4gICAgICAgICAgICBpZiAoIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SWR4ID0gZGF0YS5nZXRSYXdJbmRleChpZHgpO1xuICAgICAgICAgICAgICAgICAgICBpZHhNYXBbcmF3SWR4XSA9IGlkeDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkYXRhQWxsLmVhY2goZnVuY3Rpb24gKHJhd0lkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWRJZHggPSBpZHhNYXBbcmF3SWR4XTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZXJpZXMuaXRlbVN0eWxlLm5vcm1hbC5jb2xvciBpcyBhIGZ1bmN0aW9uLiBpdGVtVmlzdWFsIG1heSBiZSBlbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaW5nbGVEYXRhQ29sb3IgPSBmaWx0ZXJlZElkeCAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBkYXRhLmdldEl0ZW1WaXN1YWwoZmlsdGVyZWRJZHgsICdjb2xvcicsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2luZ2xlRGF0YUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBQZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGFBbGwuZ2V0SXRlbU1vZGVsKHJhd0lkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBpdGVtTW9kZWwuZ2V0KCdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBzZXJpZXNNb2RlbC5nZXRDb2xvckZyb21QYWxldHRlKGRhdGFBbGwuZ2V0TmFtZShyYXdJZHgpLCBwYWxldHRlU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVnZW5kIG1heSB1c2UgdGhlIHZpc3VhbCBpbmZvIGluIGRhdGEgYmVmb3JlIHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUFsbC5zZXRJdGVtVmlzdWFsKHJhd0lkeCwgJ2NvbG9yJywgY29sb3IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEYXRhIGlzIG5vdCBmaWx0ZXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkSWR4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoZmlsdGVyZWRJZHgsICdjb2xvcicsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBkYXRhIGFsbCBjb2xvciBmb3IgbGVnZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhQWxsLnNldEl0ZW1WaXN1YWwocmF3SWR4LCAnY29sb3InLCBzaW5nbGVEYXRhQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4iLCJcbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50Jyk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgICBmdW5jdGlvbiBlbmNvZGVDb2xvcihzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yQWNjZXNzUGF0aCA9IChzZXJpZXNNb2RlbC52aXN1YWxDb2xvckFjY2Vzc1BhdGggfHwgJ2l0ZW1TdHlsZS5ub3JtYWwuY29sb3InKS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBzZXJpZXNNb2RlbC5nZXQoY29sb3JBY2Nlc3NQYXRoKSAvLyBTZXQgaW4gaXRlbVN0eWxlXG4gICAgICAgICAgICAgICAgfHwgc2VyaWVzTW9kZWwuZ2V0Q29sb3JGcm9tUGFsZXR0ZShzZXJpZXNNb2RlbC5nZXQoJ25hbWUnKSk7ICAvLyBEZWZhdWx0IGNvbG9yXG5cbiAgICAgICAgICAgIC8vIEZJWE1FIFNldCBjb2xvciBmdW5jdGlvbiBvciB1c2UgdGhlIHBsYXR0ZSBjb2xvclxuICAgICAgICAgICAgZGF0YS5zZXRWaXN1YWwoJ2NvbG9yJywgY29sb3IpO1xuXG4gICAgICAgICAgICAvLyBPbmx5IHZpc2libGUgc2VyaWVzIGhhcyBlYWNoIGRhdGEgYmUgdmlzdWFsIGVuY29kZWRcbiAgICAgICAgICAgIGlmICghZWNNb2RlbC5pc1Nlcmllc0ZpbHRlcmVkKHNlcmllc01vZGVsKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdmdW5jdGlvbicgJiYgIShjb2xvciBpbnN0YW5jZW9mIEdyYWRpZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtVmlzdWFsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCwgJ2NvbG9yJywgY29sb3Ioc2VyaWVzTW9kZWwuZ2V0RGF0YVBhcmFtcyhpZHgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaXRlbVN0eWxlIGluIGVhY2ggZGF0YSBpdGVtXG4gICAgICAgICAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGl0ZW1Nb2RlbC5nZXQoY29sb3JBY2Nlc3NQYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVjTW9kZWwuZWFjaFJhd1NlcmllcyhlbmNvZGVDb2xvcik7XG4gICAgfTtcbiIsIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgZGVmYXVsdFN5bWJvbFR5cGUsIGxlZ2VuZFN5bWJvbCwgZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgLy8gRW5jb2RpbmcgdmlzdWFsIGZvciBhbGwgc2VyaWVzIGluY2x1ZGUgd2hpY2ggaXMgZmlsdGVyZWQgZm9yIGxlZ2VuZCBkcmF3aW5nXG4gICAgICAgIGVjTW9kZWwuZWFjaFJhd1Nlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgICAgICAgICB2YXIgc3ltYm9sVHlwZSA9IHNlcmllc01vZGVsLmdldCgnc3ltYm9sJykgfHwgZGVmYXVsdFN5bWJvbFR5cGU7XG4gICAgICAgICAgICB2YXIgc3ltYm9sU2l6ZSA9IHNlcmllc01vZGVsLmdldCgnc3ltYm9sU2l6ZScpO1xuXG4gICAgICAgICAgICBkYXRhLnNldFZpc3VhbCh7XG4gICAgICAgICAgICAgICAgbGVnZW5kU3ltYm9sOiBsZWdlbmRTeW1ib2wgfHwgc3ltYm9sVHlwZSxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IHN5bWJvbFR5cGUsXG4gICAgICAgICAgICAgICAgc3ltYm9sU2l6ZTogc3ltYm9sU2l6ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdmlzaWJsZSBzZXJpZXMgaGFzIGVhY2ggZGF0YSBiZSB2aXN1YWwgZW5jb2RlZFxuICAgICAgICAgICAgaWYgKCFlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzeW1ib2xTaXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3VmFsdWUgPSBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBzZXJpZXNNb2RlbC5nZXREYXRhUGFyYW1zKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScsIHN5bWJvbFNpemUocmF3VmFsdWUsIHBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtU3ltYm9sVHlwZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2wnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1TeW1ib2xTaXplID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbFNpemUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaGFzIGl0ZW0gc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtU3ltYm9sVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJywgaXRlbVN5bWJvbFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtU3ltYm9sU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIFRyYW5zZm9ybSBzeW1ib2xTaXplID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xTaXplJywgaXRlbVN5bWJvbFNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9FbGVtZW50XG4gKi9cblxuXG4gICAgdmFyIGd1aWQgPSByZXF1aXJlKCcuL2NvcmUvZ3VpZCcpO1xuICAgIHZhciBFdmVudGZ1bCA9IHJlcXVpcmUoJy4vbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgVHJhbnNmb3JtYWJsZSA9IHJlcXVpcmUoJy4vbWl4aW4vVHJhbnNmb3JtYWJsZScpO1xuICAgIHZhciBBbmltYXRhYmxlID0gcmVxdWlyZSgnLi9taXhpbi9BbmltYXRhYmxlJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9BbmltYXRhYmxlfVxuICAgICAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfVxuICAgICAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bH1cbiAgICAgKi9cbiAgICB2YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChvcHRzKSB7XG5cbiAgICAgICAgVHJhbnNmb3JtYWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgICBBbmltYXRhYmxlLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeUu+W4g+WFg+e0oElEXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gb3B0cy5pZCB8fCBndWlkKCk7XG4gICAgfTtcblxuICAgIEVsZW1lbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlhYPntKDnsbvlnotcbiAgICAgICAgICogRWxlbWVudCB0eXBlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnZWxlbWVudCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWFg+e0oOWQjeWtl1xuICAgICAgICAgKiBFbGVtZW50IG5hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIG5hbWU6ICcnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBaUmVuZGVyIOWunuS+i+Wvueixoe+8jOS8muWcqCBlbGVtZW50IOa3u+WKoOWIsCB6cmVuZGVyIOWunuS+i+S4reWQjuiHquWKqOi1i+WAvFxuICAgICAgICAgKiBaUmVuZGVyIGluc3RhbmNlIHdpbGwgYmUgYXNzaWduZWQgd2hlbiBlbGVtZW50IGlzIGFzc29jaWF0ZWQgd2l0aCB6cmVuZGVyXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9FbGVtZW50I19fenJcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfX3pyOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm77lvaLmmK/lkKblv73nlaXvvIzkuLp0cnVl5pe25b+955Wl5Zu+5b2i55qE57uY5Yi25Lul5Y+K5LqL5Lu26Kem5Y+RXG4gICAgICAgICAqIElmIGlnbm9yZSBkcmF3aW5nIGFuZCBldmVudHMgb2YgdGhlIGVsZW1lbnQgb2JqZWN0XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9FbGVtZW50I2lnbm9yZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlnbm9yZTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeUqOS6juijgeWJqueahOi3r+W+hChzaGFwZSnvvIzmiYDmnIkgR3JvdXAg5YaF55qE6Lev5b6E5Zyo57uY5Yi25pe26YO95Lya6KKr6L+Z5Liq6Lev5b6E6KOB5YmqXG4gICAgICAgICAqIOivpei3r+W+hOS8mue7p+aJv+iiq+ijgeWHj+WvueixoeeahOWPmOaNolxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofVxuICAgICAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC8jY2xpcHBpbmctcmVnaW9uXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgY2xpcFBhdGg6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyaWZ0IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBkeCBvbiB0aGUgZ2xvYmFsIHNwYWNlXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gZHkgZHkgb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJpZnQ6IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgICAgICAgICAgICAgZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgICAgICAgICAgICAgIGR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICBtID0gdGhpcy50cmFuc2Zvcm0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtWzRdICs9IGR4O1xuICAgICAgICAgICAgbVs1XSArPSBkeTtcblxuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb29rIGJlZm9yZSB1cGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb29rIGFmdGVyIHVwZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGVhY2ggZnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3Bvc2l0aW9uJyB8fCBrZXkgPT09ICdzY2FsZScgfHwga2V5ID09PSAnb3JpZ2luJykge1xuICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzW2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbMF0gPSB2YWx1ZVswXTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WzFdID0gdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhpZGUgdGhlIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIGF0dHI6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJLVihrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyS1YobmFtZSwga2V5W25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gY2xpcFBhdGhcbiAgICAgICAgICovXG4gICAgICAgIHNldENsaXBQYXRoOiBmdW5jdGlvbiAoY2xpcFBhdGgpIHtcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIGlmICh6cikge1xuICAgICAgICAgICAgICAgIGNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGNsaXAgcGF0aFxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGggJiYgdGhpcy5jbGlwUGF0aCAhPT0gY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNsaXBQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2xpcFBhdGggPSBjbGlwUGF0aDtcbiAgICAgICAgICAgIGNsaXBQYXRoLl9fenIgPSB6cjtcbiAgICAgICAgICAgIGNsaXBQYXRoLl9fY2xpcFRhcmdldCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQ2xpcFBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGg7XG4gICAgICAgICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGguX196cikge1xuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKGNsaXBQYXRoLl9fenIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNsaXBQYXRoLl9fenIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNsaXBQYXRoLl9fY2xpcFRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwUGF0aCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgICAgICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICAgICAgICovXG4gICAgICAgIGFkZFNlbGZUb1pyOiBmdW5jdGlvbiAoenIpIHtcbiAgICAgICAgICAgIHRoaXMuX196ciA9IHpyO1xuICAgICAgICAgICAgLy8g5re75Yqg5Yqo55S7XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG4gICAgICAgICAgICBpZiAoYW5pbWF0b3JzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpcFBhdGguYWRkU2VsZlRvWnIoenIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgc2VsZiBmcm9tIHpyZW5kZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlU2VsZkZyb21acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgICAgICAgICB0aGlzLl9fenIgPSBudWxsO1xuICAgICAgICAgICAgLy8g56e76Zmk5Yqo55S7XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG4gICAgICAgICAgICBpZiAoYW5pbWF0b3JzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgenIuYW5pbWF0aW9uLnJlbW92ZUFuaW1hdG9yKGFuaW1hdG9yc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acih6cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLm1peGluKEVsZW1lbnQsIEFuaW1hdGFibGUpO1xuICAgIHpyVXRpbC5taXhpbihFbGVtZW50LCBUcmFuc2Zvcm1hYmxlKTtcbiAgICB6clV0aWwubWl4aW4oRWxlbWVudCwgRXZlbnRmdWwpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBIYW5kbGVyXG4gKiBAbW9kdWxlIHpyZW5kZXIvSGFuZGxlclxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiAgICAgICAgIHBpc3NhbmcgKHNoZW55aS45MTRAZ21haWwuY29tKVxuICovXG5cblxuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgRHJhZ2dhYmxlID0gcmVxdWlyZSgnLi9taXhpbi9EcmFnZ2FibGUnKTtcblxuICAgIHZhciBFdmVudGZ1bCA9IHJlcXVpcmUoJy4vbWl4aW4vRXZlbnRmdWwnKTtcblxuICAgIGZ1bmN0aW9uIG1ha2VFdmVudFBhY2tldChldmVUeXBlLCB0YXJnZXQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBldmVUeXBlLFxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBjYW5jZWxCdWJibGU6IGZhbHNlLFxuICAgICAgICAgICAgb2Zmc2V0WDogZXZlbnQuenJYLFxuICAgICAgICAgICAgb2Zmc2V0WTogZXZlbnQuenJZLFxuICAgICAgICAgICAgZ2VzdHVyZUV2ZW50OiBldmVudC5nZXN0dXJlRXZlbnQsXG4gICAgICAgICAgICBwaW5jaFg6IGV2ZW50LnBpbmNoWCxcbiAgICAgICAgICAgIHBpbmNoWTogZXZlbnQucGluY2hZLFxuICAgICAgICAgICAgcGluY2hTY2FsZTogZXZlbnQucGluY2hTY2FsZSxcbiAgICAgICAgICAgIHdoZWVsRGVsdGE6IGV2ZW50LnpyRGVsdGEsXG4gICAgICAgICAgICB6ckJ5VG91Y2g6IGV2ZW50LnpyQnlUb3VjaFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEVtcHR5UHJveHkgKCkge31cbiAgICBFbXB0eVByb3h5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICB2YXIgaGFuZGxlck5hbWVzID0gW1xuICAgICAgICAnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V3aGVlbCcsICdtb3VzZW91dCcsXG4gICAgICAgICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnY29udGV4dG1lbnUnXG4gICAgXTtcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvSGFuZGxlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfSBzdG9yYWdlIFN0b3JhZ2UgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyIFBhaW50ZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9kb20vSGFuZGxlclByb3h5fSBwcm94eSBIYW5kbGVyUHJveHkgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFpbnRlclJvb3QgcGFpbnRlci5yb290IChub3QgcGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkuXG4gICAgICovXG4gICAgdmFyIEhhbmRsZXIgPSBmdW5jdGlvbihzdG9yYWdlLCBwYWludGVyLCBwcm94eSwgcGFpbnRlclJvb3QpIHtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuXG4gICAgICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICAgICAgdGhpcy5wYWludGVyUm9vdCA9IHBhaW50ZXJSb290O1xuXG4gICAgICAgIHByb3h5ID0gcHJveHkgfHwgbmV3IEVtcHR5UHJveHkoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJveHkgb2YgZXZlbnQuIGNhbiBiZSBEb20sIFdlYkdMU3VyZmFjZSwgZXRjLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm94eSA9IHByb3h5O1xuXG4gICAgICAgIC8vIEF0dGFjaCBoYW5kbGVyXG4gICAgICAgIHByb3h5LmhhbmRsZXIgPSB0aGlzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hvdmVyZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtEYXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoTW9tZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGFzdFg7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXN0WTtcblxuXG4gICAgICAgIERyYWdnYWJsZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHV0aWwuZWFjaChoYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBwcm94eS5vbiAmJiBwcm94eS5vbihuYW1lLCB0aGlzW25hbWVdLCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAgIEhhbmRsZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBIYW5kbGVyLFxuXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgeCA9IGV2ZW50LnpyWDtcbiAgICAgICAgICAgIHZhciB5ID0gZXZlbnQuenJZO1xuXG4gICAgICAgICAgICB2YXIgaG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKHgsIHksIG51bGwpO1xuICAgICAgICAgICAgdmFyIGxhc3RIb3ZlcmVkID0gdGhpcy5faG92ZXJlZDtcbiAgICAgICAgICAgIHZhciBwcm94eSA9IHRoaXMucHJveHk7XG5cbiAgICAgICAgICAgIHRoaXMuX2hvdmVyZWQgPSBob3ZlcmVkO1xuXG4gICAgICAgICAgICBwcm94eS5zZXRDdXJzb3IgJiYgcHJveHkuc2V0Q3Vyc29yKGhvdmVyZWQgPyBob3ZlcmVkLmN1cnNvciA6ICdkZWZhdWx0Jyk7XG5cbiAgICAgICAgICAgIC8vIE1vdXNlIG91dCBvbiBwcmV2aW91cyBob3ZlcmVkIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChsYXN0SG92ZXJlZCAmJiBob3ZlcmVkICE9PSBsYXN0SG92ZXJlZCAmJiBsYXN0SG92ZXJlZC5fX3pyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChsYXN0SG92ZXJlZCwgJ21vdXNlb3V0JywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNb3VzZSBtb3Zpbmcgb24gb25lIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgJ21vdXNlbW92ZScsIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gTW91c2Ugb3ZlciBvbiBhIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBpZiAoaG92ZXJlZCAmJiBob3ZlcmVkICE9PSBsYXN0SG92ZXJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgJ21vdXNlb3ZlcicsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHRoaXMuX2hvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgc29tZSBkb21zIGNyZWF0ZWQgYnkgdXBwZXIgbGF5ZXIgYXBwbGljYXRpb25cbiAgICAgICAgICAgIC8vIGF0IHRoZSBzYW1lIGxldmVsIG9mIHBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCkgKGUuZy4sIHRvb2x0aXBcbiAgICAgICAgICAgIC8vIGRvbSBjcmVhdGVkIGJ5IGVjaGFydHMpLCB3aGVyZSAnZ2xvYmFsb3V0JyBldmVudCBzaG91bGQgbm90XG4gICAgICAgICAgICAvLyBiZSB0cmlnZ2VyZWQgd2hlbiBtb3VzZSBlbnRlcnMgdGhlc2UgZG9tcy4gKEJ1dCAnbW91c2VvdXQnXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgdHJpZ2dlcmVkIGF0IHRoZSBvcmlnaW5hbCBob3ZlcmVkIGVsZW1lbnQgYXMgdXN1YWwpLlxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgICAgIHZhciBpbm5lckRvbTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9IDkgJiYgIShcbiAgICAgICAgICAgICAgICBpbm5lckRvbSA9IGVsZW1lbnQgPT09IHRoaXMucGFpbnRlclJvb3RcbiAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAhaW5uZXJEb20gJiYgdGhpcy50cmlnZ2VyKCdnbG9iYWxvdXQnLCB7ZXZlbnQ6IGV2ZW50fSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyZWQgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaCBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICAgICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudEFyZ3NcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgaGFuZGxlciAmJiBoYW5kbGVyLmNhbGwodGhpcywgZXZlbnRBcmdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB0aGlzLnByb3h5LmRpc3Bvc2UoKTtcblxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cbiAgICAgICAgICAgIHRoaXMucHJveHkgPVxuICAgICAgICAgICAgdGhpcy5wYWludGVyID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u6buY6K6k55qEY3Vyc29yIHN0eWxlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3R5bGU9J2RlZmF1bHQnXSDkvovlpoIgY3Jvc3NoYWlyXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgICAgICAgICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihjdXJzb3JTdHlsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS6i+S7tuWIhuWPkeS7o+eQhlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0RWwg55uu5qCH5Zu+5b2i5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUg5LqL5Lu25ZCN56ewXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7blr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoVG9FbGVtZW50OiBmdW5jdGlvbiAodGFyZ2V0RWwsIGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBldmVudEhhbmRsZXIgPSAnb24nICsgZXZlbnROYW1lO1xuICAgICAgICAgICAgdmFyIGV2ZW50UGFja2V0ID0gbWFrZUV2ZW50UGFja2V0KGV2ZW50TmFtZSwgdGFyZ2V0RWwsIGV2ZW50KTtcblxuICAgICAgICAgICAgdmFyIGVsID0gdGFyZ2V0RWw7XG5cbiAgICAgICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgICAgIGVsW2V2ZW50SGFuZGxlcl1cbiAgICAgICAgICAgICAgICAgICAgJiYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSA9IGVsW2V2ZW50SGFuZGxlcl0uY2FsbChlbCwgZXZlbnRQYWNrZXQpKTtcblxuICAgICAgICAgICAgICAgIGVsLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG5cbiAgICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgICAgICAgICAgIC8vIOWGkuazoeWIsOmhtue6pyB6cmVuZGVyIOWvueixoVxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICAvLyDliIblj5Hkuovku7bliLDnlKjmiLfoh6rlrprkuYnlsYJcbiAgICAgICAgICAgICAgICAvLyDnlKjmiLfmnInlj6/og73lnKjlhajlsYAgY2xpY2sg5LqL5Lu25LitIGRpc3Bvc2XvvIzmiYDku6XpnIDopoHliKTmlq3kuIsgcGFpbnRlciDmmK/lkKblrZjlnKhcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIgJiYgdGhpcy5wYWludGVyLmVhY2hPdGhlckxheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGxheWVyW2V2ZW50SGFuZGxlcl0pID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyW2V2ZW50SGFuZGxlcl0uY2FsbChsYXllciwgZXZlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXllci50cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX0gZXhjbHVkZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kSG92ZXI6IGZ1bmN0aW9uKHgsIHksIGV4Y2x1ZGUpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDAgOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxpc3RbaV0uc2lsZW50XG4gICAgICAgICAgICAgICAgICYmIGxpc3RbaV0gIT09IGV4Y2x1ZGVcbiAgICAgICAgICAgICAgICAgLy8gZ2V0RGlzcGxheUxpc3QgbWF5IGluY2x1ZGUgaWdub3JlZCBpdGVtIGluIFZNTCBtb2RlXG4gICAgICAgICAgICAgICAgICYmICFsaXN0W2ldLmlnbm9yZVxuICAgICAgICAgICAgICAgICAmJiBpc0hvdmVyKGxpc3RbaV0sIHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDb21tb24gaGFuZGxlcnNcbiAgICB1dGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIEhhbmRsZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBGaW5kIGhvdmVyIGFnYWluIHRvIGF2b2lkIGNsaWNrIGV2ZW50IGlzIGRpc3BhdGNoZWQgbWFudWFsbHkuIE9yIGNsaWNrIGlzIHRyaWdnZXJlZCB3aXRob3V0IG1vdXNlb3ZlclxuICAgICAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCk7XG5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rvd25lbCA9IGhvdmVyZWQ7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBjbGljayB0cmlnZ2VyZWQgYmVmb3JlIG1vdXNldXBcbiAgICAgICAgICAgICAgICB0aGlzLl91cGVsID0gaG92ZXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdtb3N1ZXVwJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZWwgPSBob3ZlcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kb3duZWwgIT09IHRoaXMuX3VwZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCBuYW1lLCBldmVudCk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBpc0hvdmVyKGRpc3BsYXlhYmxlLCB4LCB5KSB7XG4gICAgICAgIGlmIChkaXNwbGF5YWJsZVtkaXNwbGF5YWJsZS5yZWN0SG92ZXIgPyAncmVjdENvbnRhaW4nIDogJ2NvbnRhaW4nXSh4LCB5KSkge1xuICAgICAgICAgICAgdmFyIGVsID0gZGlzcGxheWFibGU7XG4gICAgICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbmNlc3RvciBpcyBzaWxlbnQgb3IgY2xpcHBlZCBieSBhbmNlc3RvclxuICAgICAgICAgICAgICAgIGlmIChlbC5zaWxlbnQgfHwgKGVsLmNsaXBQYXRoICYmICFlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpKSkgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHV0aWwubWl4aW4oSGFuZGxlciwgRXZlbnRmdWwpO1xuICAgIHV0aWwubWl4aW4oSGFuZGxlciwgRHJhZ2dhYmxlKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlcjtcbiIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL0xheWVyXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cblxuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbiAgICB2YXIgU3R5bGUgPSByZXF1aXJlKCcuL2dyYXBoaWMvU3R5bGUnKTtcbiAgICB2YXIgUGF0dGVybiA9IHJlcXVpcmUoJy4vZ3JhcGhpYy9QYXR0ZXJuJyk7XG5cbiAgICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWIm+W7umRvbVxuICAgICAqXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIGRvbSBpZCDlvoXnlKhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBkb20gdHlwZe+8jHN1Y2ggYXMgY2FudmFzLCBkaXYgZXRjLlxuICAgICAqIEBwYXJhbSB7UGFpbnRlcn0gcGFpbnRlciBwYWludGVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURvbShpZCwgdHlwZSwgcGFpbnRlciwgZHByKSB7XG4gICAgICAgIHZhciBuZXdEb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgICAgICB2YXIgd2lkdGggPSBwYWludGVyLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBwYWludGVyLmdldEhlaWdodCgpO1xuXG4gICAgICAgIHZhciBuZXdEb21TdHlsZSA9IG5ld0RvbS5zdHlsZTtcbiAgICAgICAgLy8g5rKhYXBwZW5k5ZGi77yM6K+35Y6f6LCF5oiR6L+Z5qC35YaZ77yM5riF5pmwflxuICAgICAgICBuZXdEb21TdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIG5ld0RvbVN0eWxlLmxlZnQgPSAwO1xuICAgICAgICBuZXdEb21TdHlsZS50b3AgPSAwO1xuICAgICAgICBuZXdEb21TdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgbmV3RG9tU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgbmV3RG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgIG5ld0RvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAgICAgLy8gaWTkuI3kvZzkuLrntKLlvJXnlKjvvIzpgb/lhY3lj6/og73pgKDmiJDnmoTph43lkI3vvIzlrprkuYnkuLrnp4HmnInlsZ7mgKdcbiAgICAgICAgbmV3RG9tLnNldEF0dHJpYnV0ZSgnZGF0YS16ci1kb20taWQnLCBpZCk7XG4gICAgICAgIHJldHVybiBuZXdEb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0xheWVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvUGFpbnRlcn0gcGFpbnRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZHByXVxuICAgICAqL1xuICAgIHZhciBMYXllciA9IGZ1bmN0aW9uKGlkLCBwYWludGVyLCBkcHIpIHtcbiAgICAgICAgdmFyIGRvbTtcbiAgICAgICAgZHByID0gZHByIHx8IGNvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZG9tID0gY3JlYXRlRG9tKGlkLCAnY2FudmFzJywgcGFpbnRlciwgZHByKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgdXNpbmcgaXNEb20gYmVjYXVzZSBpbiBub2RlIGl0IHdpbGwgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVsc2UgaWYgKHV0aWwuaXNPYmplY3QoaWQpKSB7XG4gICAgICAgICAgICBkb20gPSBpZDtcbiAgICAgICAgICAgIGlkID0gZG9tLmlkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG5cbiAgICAgICAgdmFyIGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuICAgICAgICBpZiAoZG9tU3R5bGUpIHsgLy8gTm90IGluIG5vZGVcbiAgICAgICAgICAgIGRvbS5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuICAgICAgICAgICAgZG9tU3R5bGVbJy13ZWJraXQtdXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICAgICAgICAgIGRvbVN0eWxlWyd1c2VyLXNlbGVjdCddID0gJ25vbmUnO1xuICAgICAgICAgICAgZG9tU3R5bGVbJy13ZWJraXQtdG91Y2gtY2FsbG91dCddID0gJ25vbmUnO1xuICAgICAgICAgICAgZG9tU3R5bGVbJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvciddID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgICAgICAgZG9tU3R5bGVbJ3BhZGRpbmcnXSA9IDA7XG4gICAgICAgICAgICBkb21TdHlsZVsnbWFyZ2luJ10gPSAwO1xuICAgICAgICAgICAgZG9tU3R5bGVbJ2JvcmRlci13aWR0aCddID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZG9tQmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuY3R4QmFjayA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcblxuICAgICAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG5cbiAgICAgICAgLy8gQ29uZmlnc1xuICAgICAgICAvKipcbiAgICAgICAgICog5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYXJDb2xvciA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblvIDlkK/liqjmgIHmqKHns4pcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDAuN1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0RnJhbWVBbHBoYSA9IDAuNztcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGF5ZXIgZHByXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRwciA9IGRwcjtcbiAgICB9O1xuXG4gICAgTGF5ZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBMYXllcixcblxuICAgICAgICBlbENvdW50OiAwLFxuXG4gICAgICAgIF9fZGlydHk6IHRydWUsXG5cbiAgICAgICAgaW5pdENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5kb20uZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgdGhpcy5jdHguZHByID0gdGhpcy5kcHI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQmFja0J1ZmZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgICAgICAgICB0aGlzLmRvbUJhY2sgPSBjcmVhdGVEb20oJ2JhY2stJyArIHRoaXMuaWQsICdjYW52YXMnLCB0aGlzLnBhaW50ZXIsIGRwcik7XG4gICAgICAgICAgICB0aGlzLmN0eEJhY2sgPSB0aGlzLmRvbUJhY2suZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgaWYgKGRwciAhPSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB3aWR0aFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGhlaWdodFxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgICAgICAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgICAgICAgICB2YXIgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG4gICAgICAgICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcblxuICAgICAgICAgICAgZG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgICAgICBkb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgICAgICAgICBkb20ud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgICAgIGRvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAgICAgICAgIGlmIChkb21CYWNrKSB7XG4gICAgICAgICAgICAgICAgZG9tQmFjay53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICAgICAgICAgIGRvbUJhY2suaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRwciAhPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXnqbror6XlsYLnlLvluINcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBjbGVhckFsbCBDbGVhciBhbGwgd2l0aCBvdXQgbW90aW9uIGJsdXJcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoY2xlYXJBbGwpIHtcbiAgICAgICAgICAgIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGRvbS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkb20uaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgY2xlYXJDb2xvciA9IHRoaXMuY2xlYXJDb2xvcjtcbiAgICAgICAgICAgIHZhciBoYXZlTW90aW9uQkx1ciA9IHRoaXMubW90aW9uQmx1ciAmJiAhY2xlYXJBbGw7XG4gICAgICAgICAgICB2YXIgbGFzdEZyYW1lQWxwaGEgPSB0aGlzLmxhc3RGcmFtZUFscGhhO1xuXG4gICAgICAgICAgICB2YXIgZHByID0gdGhpcy5kcHI7XG5cbiAgICAgICAgICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kb21CYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlQmFja0J1ZmZlcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHhCYWNrLmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICAgICAgZG9tLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCAvIGRwcixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0IC8gZHByXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGlmIChjbGVhckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjtcbiAgICAgICAgICAgICAgICAvLyBHcmFkaWVudFxuICAgICAgICAgICAgICAgIGlmIChjbGVhckNvbG9yLmNvbG9yU3RvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgY2FudmFzIGdyYWRpZW50XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiA9IGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCB8fCBTdHlsZS5nZXRHcmFkaWVudChjdHgsIGNsZWFyQ29sb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvci5fX2NhbnZhc0dyYWRpZW50ID0gY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXR0ZXJuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xlYXJDb2xvci5pbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuLmNhbGwoY2xlYXJDb2xvciwgY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuIHx8IGNsZWFyQ29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgICAgICAgICAgIHZhciBkb21CYWNrID0gdGhpcy5kb21CYWNrO1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gbGFzdEZyYW1lQWxwaGE7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShkb21CYWNrLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTGF5ZXI7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIERlZmF1bHQgY2FudmFzIHBhaW50ZXJcbiAqIEBtb2R1bGUgenJlbmRlci9QYWludGVyXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4gXG5cbiAgICB2YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIGxvZyA9IHJlcXVpcmUoJy4vY29yZS9sb2cnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciB0aW1zb3J0ID0gcmVxdWlyZSgnLi9jb3JlL3RpbXNvcnQnKTtcblxuICAgIHZhciBMYXllciA9IHJlcXVpcmUoJy4vTGF5ZXInKTtcblxuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKCcuL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcblxuICAgIC8vIFBFTkRJR05cbiAgICAvLyBMYXllciBleGNlZWRzIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgbWF5IGhhdmUgc29tZSBwcm9ibGVtIHdoZW4gZmx1c2ggZGlyZWN0bHkgc2Vjb25kIHRpbWUuXG4gICAgLy9cbiAgICAvLyBNYXhpbXVtIHByb2dyZXNzaXZlIGxheWVyLiBXaGVuIGV4Y2VlZGluZyB0aGlzIG51bWJlci4gQWxsIGVsZW1lbnRzIHdpbGwgYmUgZHJhd2VkIGluIHRoZSBsYXN0IGxheWVyLlxuICAgIHZhciBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSID0gNTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSW50MTAodmFsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xheWVyVmFsaWQobGF5ZXIpIHtcbiAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxheWVyLmlzQnVpbGRpbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKGxheWVyLnJlc2l6ZSkgIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgIHx8IHR5cGVvZihsYXllci5yZWZyZXNoKSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVByb2Nlc3NMYXllcihsYXllcikge1xuICAgICAgICBsYXllci5fX3VudXNlZENvdW50Kys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zdFByb2Nlc3NMYXllcihsYXllcikge1xuICAgICAgICBpZiAobGF5ZXIuX191bnVzZWRDb3VudCA9PSAxKSB7XG4gICAgICAgICAgICBsYXllci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgIHZhciB2aWV3UmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgZnVuY3Rpb24gaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0bXBSZWN0LmNvcHkoZWwuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICBpZiAoZWwudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgdmlld1JlY3Qud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdmlld1JlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gIXRtcFJlY3QuaW50ZXJzZWN0KHZpZXdSZWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NsaXBQYXRoQ2hhbmdlZChjbGlwUGF0aHMsIHByZXZDbGlwUGF0aHMpIHtcbiAgICAgICAgaWYgKGNsaXBQYXRocyA9PSBwcmV2Q2xpcFBhdGhzKSB7IC8vIENhbiBib3RoIGJlIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNsaXBQYXRocyB8fCAhcHJldkNsaXBQYXRocyB8fCAoY2xpcFBhdGhzLmxlbmd0aCAhPT0gcHJldkNsaXBQYXRocy5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNsaXBQYXRoc1tpXSAhPT0gcHJldkNsaXBQYXRoc1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9DbGlwKGNsaXBQYXRocywgY3R4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGNsaXBQYXRoLnBhdGg7XG5cbiAgICAgICAgICAgIGNsaXBQYXRoLnNldFRyYW5zZm9ybShjdHgpO1xuICAgICAgICAgICAgcGF0aC5iZWdpblBhdGgoY3R4KTtcbiAgICAgICAgICAgIGNsaXBQYXRoLmJ1aWxkUGF0aChwYXRoLCBjbGlwUGF0aC5zaGFwZSk7XG4gICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIGJhY2tcbiAgICAgICAgICAgIGNsaXBQYXRoLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvb3Qod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgZG9tUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIC8vIGRvbVJvb3Qub25zZWxlY3RzdGFydCA9IHJldHVybkZhbHNlOyAvLyDpgb/lhY3pobXpnaLpgInkuK3nmoTlsLTlsKxcbiAgICAgICAgZG9tUm9vdC5zdHlsZS5jc3NUZXh0ID0gW1xuICAgICAgICAgICAgJ3Bvc2l0aW9uOnJlbGF0aXZlJyxcbiAgICAgICAgICAgICdvdmVyZmxvdzpoaWRkZW4nLFxuICAgICAgICAgICAgJ3dpZHRoOicgKyB3aWR0aCArICdweCcsXG4gICAgICAgICAgICAnaGVpZ2h0OicgKyBoZWlnaHQgKyAncHgnLFxuICAgICAgICAgICAgJ3BhZGRpbmc6MCcsXG4gICAgICAgICAgICAnbWFyZ2luOjAnLFxuICAgICAgICAgICAgJ2JvcmRlci13aWR0aDowJ1xuICAgICAgICBdLmpvaW4oJzsnKSArICc7JztcblxuICAgICAgICByZXR1cm4gZG9tUm9vdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvUGFpbnRlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJvb3Qg57uY5Zu+5a655ZmoXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfSBzdG9yYWdlXG4gICAgICogQHBhcmFtIHtPamJlY3R9IG9wdHNcbiAgICAgKi9cbiAgICB2YXIgUGFpbnRlciA9IGZ1bmN0aW9uIChyb290LCBzdG9yYWdlLCBvcHRzKSB7XG4gICAgICAgIC8vIEluIG5vZGUgZW52aXJvbm1lbnQgdXNpbmcgbm9kZS1jYW52YXNcbiAgICAgICAgdmFyIHNpbmdsZUNhbnZhcyA9ICFyb290Lm5vZGVOYW1lIC8vIEluIG5vZGUgP1xuICAgICAgICAgICAgfHwgcm9vdC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQ0FOVkFTJztcblxuICAgICAgICB0aGlzLl9vcHRzID0gb3B0cyA9IHV0aWwuZXh0ZW5kKHt9LCBvcHRzIHx8IHt9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHByID0gb3B0cy5kZXZpY2VQaXhlbFJhdGlvIHx8IGNvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zaW5nbGVDYW52YXMgPSBzaW5nbGVDYW52YXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu5jlm77lrrnlmahcbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcblxuICAgICAgICB2YXIgcm9vdFN0eWxlID0gcm9vdC5zdHlsZTtcblxuICAgICAgICBpZiAocm9vdFN0eWxlKSB7XG4gICAgICAgICAgICByb290U3R5bGVbJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvciddID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgIHJvb3RTdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID1cbiAgICAgICAgICAgIHJvb3RTdHlsZVsndXNlci1zZWxlY3QnXSA9XG4gICAgICAgICAgICByb290U3R5bGVbJy13ZWJraXQtdG91Y2gtY2FsbG91dCddID0gJ25vbmUnO1xuXG4gICAgICAgICAgICByb290LmlubmVySFRNTCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvTGF5ZXI+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycyA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdD59XG4gICAgICAgICAqIEB0eXBlIHtwcml2YXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGF5ZXJDb25maWcgPSB7fTtcblxuICAgICAgICBpZiAoIXNpbmdsZUNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB0aGlzLl9nZXRTaXplKDApO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSgxKTtcblxuICAgICAgICAgICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290ID0gY3JlYXRlUm9vdChcbiAgICAgICAgICAgICAgICB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChkb21Sb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgd2lkdGggYW5kIGhlaWdodCBkaXJlY3RseVxuICAgICAgICAgICAgdmFyIHdpZHRoID0gcm9vdC53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSByb290LmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBsYXllciBpZiBvbmx5IG9uZSBnaXZlbiBjYW52YXNcbiAgICAgICAgICAgIC8vIERldmljZSBwaXhlbCByYXRpbyBpcyBmaXhlZCB0byAxIGJlY2F1c2UgZ2l2ZW4gY2FudmFzIGhhcyBpdHMgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgIHZhciBtYWluTGF5ZXIgPSBuZXcgTGF5ZXIocm9vdCwgdGhpcywgMSk7XG4gICAgICAgICAgICBtYWluTGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICAgICAgICAgIC8vIEZJWE1FIFVzZSBjYW52YXMgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgLy8gbWFpbkxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGxheWVyc1swXSA9IG1haW5MYXllcjtcbiAgICAgICAgICAgIHpsZXZlbExpc3QucHVzaCgwKTtcblxuICAgICAgICAgICAgdGhpcy5fZG9tUm9vdCA9IHJvb3Q7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhdGhUb0ltYWdlID0gdGhpcy5fY3JlYXRlUGF0aFRvSW1hZ2UoKTtcblxuICAgICAgICAvLyBMYXllcnMgZm9yIHByb2dyZXNzaXZlIHJlbmRlcmluZ1xuICAgICAgICB0aGlzLl9wcm9ncmVzc2l2ZUxheWVycyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ob3ZlcmxheWVyO1xuXG4gICAgICAgIHRoaXMuX2hvdmVyRWxlbWVudHMgPSBbXTtcbiAgICB9O1xuXG4gICAgUGFpbnRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFBhaW50ZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHBhaW50ZXIgdXNlIGEgc2luZ2xlIGNhbnZhc1xuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNTaW5nbGVDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW5nbGVDYW52YXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtIVE1MRGl2RWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFZpZXdwb3J0Um9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvbVJvb3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIt+aWsFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwYWludEFsbD1mYWxzZV0g5by65Yi257uY5Yi25omA5pyJZGlzcGxheWFibGVcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uIChwYWludEFsbCkge1xuXG4gICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcblxuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuXG4gICAgICAgICAgICB0aGlzLl9wYWludExpc3QobGlzdCwgcGFpbnRBbGwpO1xuXG4gICAgICAgICAgICAvLyBQYWludCBjdXN0dW0gbGF5ZXJzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXIuaXNCdWlsZGluICYmIGxheWVyLnJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0UHJvZ2Vzc2l2ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRIb3ZlcjogZnVuY3Rpb24gKGVsLCBob3ZlclN0eWxlKSB7XG4gICAgICAgICAgICBpZiAoZWwuX19ob3Zlck1pcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbE1pcnJvciA9IG5ldyBlbC5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICAgICAgc3R5bGU6IGVsLnN0eWxlLFxuICAgICAgICAgICAgICAgIHNoYXBlOiBlbC5zaGFwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbE1pcnJvci5fX2Zyb20gPSBlbDtcbiAgICAgICAgICAgIGVsLl9faG92ZXJNaXIgPSBlbE1pcnJvcjtcbiAgICAgICAgICAgIGVsTWlycm9yLnNldFN0eWxlKGhvdmVyU3R5bGUpO1xuICAgICAgICAgICAgdGhpcy5faG92ZXJFbGVtZW50cy5wdXNoKGVsTWlycm9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgZWxNaXJyb3IgPSBlbC5fX2hvdmVyTWlyO1xuICAgICAgICAgICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgICAgICAgICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZihob3ZlckVsZW1lbnRzLCBlbE1pcnJvcik7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICBob3ZlckVsZW1lbnRzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuX19ob3Zlck1pciA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvdmVyRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IGhvdmVyRWxlbWVudHNbaV0uX19mcm9tO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20uX19ob3Zlck1pciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG92ZXJFbGVtZW50cy5sZW5ndGggPSAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlZnJlc2hIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGhvdmVyRWxlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhvdmVyTGF5ZXIgPSB0aGlzLl9ob3ZlcmxheWVyO1xuICAgICAgICAgICAgaG92ZXJMYXllciAmJiBob3ZlckxheWVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIGlmICghbGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltc29ydChob3ZlckVsZW1lbnRzLCB0aGlzLnN0b3JhZ2UuZGlzcGxheWFibGVTb3J0RnVuYyk7XG5cbiAgICAgICAgICAgIC8vIFVzZSBhIGV4dHJlYW0gbGFyZ2UgemxldmVsXG4gICAgICAgICAgICAvLyBGSVhNRT9cbiAgICAgICAgICAgIGlmICghaG92ZXJMYXllcikge1xuICAgICAgICAgICAgICAgIGhvdmVyTGF5ZXIgPSB0aGlzLl9ob3ZlcmxheWVyID0gdGhpcy5nZXRMYXllcigxZTUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICAgICAgICAgIGhvdmVyTGF5ZXIuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGhvdmVyRWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsRWwgPSBlbC5fX2Zyb207XG4gICAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgZWwgaXMgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgICAgICBpZiAoIShvcmlnaW5hbEVsICYmIG9yaWdpbmFsRWwuX196cikpIHtcbiAgICAgICAgICAgICAgICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRWwuX19ob3Zlck1pciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIC8vIEZJWE1FIHN0eWxlIGFuZCBzaGFwZSA/XG4gICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5hbEVsLmludmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBlbC50cmFuc2Zvcm0gPSBvcmlnaW5hbEVsLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW52VHJhbnNmb3JtID0gb3JpZ2luYWxFbC5pbnZUcmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIGVsLl9fY2xpcFBhdGhzID0gb3JpZ2luYWxFbC5fX2NsaXBQYXRocztcbiAgICAgICAgICAgICAgICAgICAgLy8gZWwuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgaG92ZXJMYXllciwgdHJ1ZSwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvdmVyTGF5ZXIuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc3RhcnRQcm9nZXNzaXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICghc2VsZi5fZnVydGhlclByb2dyZXNzaXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgYSB0b2tlbiB0byBzdG9wIHByb2dyZXNzIHN0ZXBzIHRyaWdnZXJlZCBieVxuICAgICAgICAgICAgLy8gcHJldmlvdXMgenIucmVmcmVzaCBjYWxsaW5nLlxuICAgICAgICAgICAgdmFyIHRva2VuID0gc2VsZi5fcHJvZ3Jlc3NpdmVUb2tlbiA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICAgICAgICBzZWxmLl9wcm9ncmVzcysrO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgcmVmcmVzaGVkIG9yIGRpc3Bvc2VkXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuICYmIHNlbGYuc3RvcmFnZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2RvUGFpbnRMaXN0KHNlbGYuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fZnVydGhlclByb2dyZXNzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9wcm9ncmVzcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcHJvZ3Jlc3NpdmVUb2tlbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9jbGVhclByb2dyZXNzaXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc2l2ZVRva2VuID0gLTE7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICB1dGlsLmVhY2godGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgJiYgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9wYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCkge1xuXG4gICAgICAgICAgICBpZiAocGFpbnRBbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhaW50QWxsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyU3RhdHVzKGxpc3QpO1xuXG4gICAgICAgICAgICB0aGlzLl9jbGVhclByb2dyZXNzaXZlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWxkaW5MYXllcihwcmVQcm9jZXNzTGF5ZXIpO1xuXG4gICAgICAgICAgICB0aGlzLl9kb1BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWxkaW5MYXllcihwb3N0UHJvY2Vzc0xheWVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZG9QYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRMYXllcjtcbiAgICAgICAgICAgIHZhciBjdXJyZW50WkxldmVsO1xuICAgICAgICAgICAgdmFyIGN0eDtcblxuICAgICAgICAgICAgLy8gdmFyIGludlRyYW5zZm9ybSA9IFtdO1xuICAgICAgICAgICAgdmFyIHNjb3BlO1xuXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVMYXllcklkeCA9IDA7XG4gICAgICAgICAgICB2YXIgY3VycmVudFByb2dyZXNzaXZlTGF5ZXI7XG5cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgICAgIHZhciBsYXllclByb2dyZXNzO1xuICAgICAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5fcHJvZ3Jlc3M7XG4gICAgICAgICAgICBmdW5jdGlvbiBmbHVzaFByb2dyZXNzaXZlTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgbGF5ZXIgZG9uJ3QgY2xlYXIgaW4gbmV4dCBwcm9ncmVzc2l2ZSBmcmFtZVxuICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXIuZG9tLCAwLCAwLCB3aWR0aCAqIGRwciwgaGVpZ2h0ICogZHByKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgZWxaTGV2ZWwgPSB0aGlzLl9zaW5nbGVDYW52YXMgPyAwIDogZWwuemxldmVsO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVsRnJhbWUgPSBlbC5fX2ZyYW1lO1xuXG4gICAgICAgICAgICAgICAgLy8gRmx1c2ggYXQgY3VycmVudCBjb250ZXh0XG4gICAgICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgICAgIGlmIChlbEZyYW1lIDwgMCAmJiBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdlIGRyYXcgbGF5ZXJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFpMZXZlbCAhPT0gZWxaTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHNjb3BlXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSAwIHpsZXZlbCBpZiBvbmx5IGhhcyBvbmUgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRaTGV2ZWwgPSBlbFpMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExheWVyID0gdGhpcy5nZXRMYXllcihjdXJyZW50WkxldmVsKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRMYXllci5pc0J1aWxkaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWkxldmVsICcgKyBjdXJyZW50WkxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnIGhhcyBiZWVuIHVzZWQgYnkgdW5rb3duIGxheWVyICcgKyBjdXJyZW50TGF5ZXIuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjb3VudFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuX191bnVzZWRDb3VudCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxGcmFtZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb2dyZXNzaXZlIGxheWVyIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSB0aGlzLl9wcm9ncmVzc2l2ZUxheWVyc1tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVySWR4KyssIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgLSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzID4gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVpY2sganVtcCBhbGwgcHJvZ3Jlc3NpdmUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgcHJvZ3Jlc3NpdmUgZWxlbWVudCBhcmUgbm90IGRpcnR5LCBqdW1wIG92ZXIgYW5kIGZsdXNoIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJQcm9ncmVzcyA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3M7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBsYXllclByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzID0gZnJhbWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsRnJhbWUgPT09IGZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLCB0cnVlLCBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudExheWVyLCBwYWludEFsbCwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgbGFzdExheWVyIGN0eFxuICAgICAgICAgICAgY3R4ICYmIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAvLyBJZiBzdGlsbCBoYXMgY2xpcHBpbmcgc3RhdGVcbiAgICAgICAgICAgIC8vIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgICAgIC8vICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICB0aGlzLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLl9fbWF4UHJvZ3Jlc3MgPj0gbGF5ZXIuX19wcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1BhaW50RWw6IGZ1bmN0aW9uIChlbCwgY3VycmVudExheWVyLCBmb3JjZVBhaW50LCBzY29wZSkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IGN1cnJlbnRMYXllci5jdHg7XG4gICAgICAgICAgICB2YXIgbSA9IGVsLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoY3VycmVudExheWVyLl9fZGlydHkgfHwgZm9yY2VQYWludClcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgaW52aXNpYmxlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiAhZWwuaW52aXNpYmxlXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHRyYW5zcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiBlbC5zdHlsZS5vcGFjaXR5ICE9PSAwXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHNjYWxlIDAgZWxlbWVudCwgaW4gc29tZSBlbnZpcm9ubWVudCBsaWtlIG5vZGUtY2FudmFzXG4gICAgICAgICAgICAgICAgLy8gRHJhdyBhIHNjYWxlIDAgZWxlbWVudCBjYW4gY2F1c2UgYWxsIGZvbGxvd2luZyBkcmF3IHdyb25nXG4gICAgICAgICAgICAgICAgLy8gQW5kIHNldFRyYW5zZm9ybSB3aXRoIHNjYWxlIDAgd2lsbCBjYXVzZSBzZXQgYmFjayB0cmFuc2Zvcm0gZmFpbGVkLlxuICAgICAgICAgICAgICAgICYmICEobSAmJiAhbVswXSAmJiAhbVszXSlcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgY3VsbGVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiAhKGVsLmN1bGxpbmcgJiYgaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpXG4gICAgICAgICAgICApIHtcblxuICAgICAgICAgICAgICAgIHZhciBjbGlwUGF0aHMgPSBlbC5fX2NsaXBQYXRocztcblxuICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIHdoZW4gY2xpcHBpbmcgb24gZ3JvdXAgd2l0aCBzZXZlcmFsIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLnByZXZDbGlwTGF5ZXIgIT09IGN1cnJlbnRMYXllclxuICAgICAgICAgICAgICAgICAgICB8fCBpc0NsaXBQYXRoQ2hhbmdlZChjbGlwUGF0aHMsIHNjb3BlLnByZXZFbENsaXBQYXRocylcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaGFzIHByZXZpb3VzIGNsaXBwaW5nIHN0YXRlLCByZXN0b3JlIGZyb20gaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IHNjb3BlLnByZXZFbENsaXBQYXRocyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHByZXZFbCBzaW5jZSBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2RWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBjbGlwcGluZyBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9DbGlwKGNsaXBQYXRocywgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZDbGlwTGF5ZXIgPSBjdXJyZW50TGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2RWxDbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwuYmVmb3JlQnJ1c2ggJiYgZWwuYmVmb3JlQnJ1c2goY3R4KTtcblxuICAgICAgICAgICAgICAgIGVsLmJydXNoKGN0eCwgc2NvcGUucHJldkVsIHx8IG51bGwpO1xuICAgICAgICAgICAgICAgIHNjb3BlLnByZXZFbCA9IGVsO1xuXG4gICAgICAgICAgICAgICAgZWwuYWZ0ZXJCcnVzaCAmJiBlbC5hZnRlckJydXNoKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPliB6bGV2ZWwg5omA5Zyo5bGC77yM5aaC5p6c5LiN5a2Y5Zyo5YiZ5Lya5Yib5bu65LiA5Liq5paw55qE5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBsYXllclxuICAgICAgICAgICAgICAgIGxheWVyID0gbmV3IExheWVyKCd6cl8nICsgemxldmVsLCB0aGlzLCB0aGlzLmRwcik7XG4gICAgICAgICAgICAgICAgbGF5ZXIuaXNCdWlsZGluID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYXllckNvbmZpZ1t6bGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0TGF5ZXIoemxldmVsLCBsYXllcik7XG5cbiAgICAgICAgICAgICAgICAvLyBDb250ZXh0IGlzIGNyZWF0ZWQgYWZ0ZXIgZG9tIGluc2VydGVkIHRvIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgLy8gT3IgZXhjYW52YXMgd2lsbCBnZXQgMHB4IGNsaWVudFdpZHRoIGFuZCBjbGllbnRIZWlnaHRcbiAgICAgICAgICAgICAgICBsYXllci5pbml0Q29udGV4dCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5zZXJ0TGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwsIGxheWVyKSB7XG5cbiAgICAgICAgICAgIHZhciBsYXllcnNNYXAgPSB0aGlzLl9sYXllcnM7XG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgICAgICAgICB2YXIgbGVuID0gemxldmVsTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgcHJldkxheWVyID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG5cbiAgICAgICAgICAgIGlmIChsYXllcnNNYXBbemxldmVsXSkge1xuICAgICAgICAgICAgICAgIGxvZygnWkxldmVsICcgKyB6bGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYWxyZWFkeScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGlzIGEgdmFsaWQgbGF5ZXJcbiAgICAgICAgICAgIGlmICghaXNMYXllclZhbGlkKGxheWVyKSkge1xuICAgICAgICAgICAgICAgIGxvZygnTGF5ZXIgb2YgemxldmVsICcgKyB6bGV2ZWwgKyAnIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbiA+IDAgJiYgemxldmVsID4gemxldmVsTGlzdFswXSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgemxldmVsTGlzdFtpXSA8IHpsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgemxldmVsTGlzdFtpICsgMV0gPiB6bGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2TGF5ZXIgPSBsYXllcnNNYXBbemxldmVsTGlzdFtpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB6bGV2ZWxMaXN0LnNwbGljZShpICsgMSwgMCwgemxldmVsKTtcblxuICAgICAgICAgICAgaWYgKHByZXZMYXllcikge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2RG9tID0gcHJldkxheWVyLmRvbTtcbiAgICAgICAgICAgICAgICBpZiAocHJldkRvbS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICBkb21Sb290Lmluc2VydEJlZm9yZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLmRvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEb20ubmV4dFNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tUm9vdC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgZG9tUm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxheWVyc01hcFt6bGV2ZWxdID0gbGF5ZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSXRlcmF0ZSBlYWNoIGxheWVyXG4gICAgICAgIGVhY2hMYXllcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgICAgICAgICB2YXIgejtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1t6XSwgeik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSXRlcmF0ZSBlYWNoIGJ1aWxkaW4gbGF5ZXJcbiAgICAgICAgZWFjaEJ1aWxkaW5MYXllcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgICAgICAgICB2YXIgbGF5ZXI7XG4gICAgICAgICAgICB2YXIgejtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuaXNCdWlsZGluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggb3RoZXIgbGF5ZXIgZXhjZXB0IGJ1aWxkaW4gbGF5ZXJcbiAgICAgICAgZWFjaE90aGVyTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICAgICAgdmFyIGxheWVyO1xuICAgICAgICAgICAgdmFyIHo7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgICAgICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgaWYgKCEgbGF5ZXIuaXNCdWlsZGluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5omA5pyJ5bey5Yib5bu655qE5bGCXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0xheWVyPn0gW3ByZXZMYXllcl1cbiAgICAgICAgICovXG4gICAgICAgIGdldExheWVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVycztcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlTGF5ZXJTdGF0dXM6IGZ1bmN0aW9uIChsaXN0KSB7XG5cbiAgICAgICAgICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVMYXllcnMgPSB0aGlzLl9wcm9ncmVzc2l2ZUxheWVycztcblxuICAgICAgICAgICAgdmFyIGVsQ291bnRzTGFzdEZyYW1lID0ge307XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVFbENvdW50c0xhc3RGcmFtZSA9IHt9O1xuXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsZGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICAgICAgICAgICAgZWxDb3VudHNMYXN0RnJhbWVbel0gPSBsYXllci5lbENvdW50O1xuICAgICAgICAgICAgICAgIGxheWVyLmVsQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NpdmVFbENvdW50c0xhc3RGcmFtZVtpZHhdID0gbGF5ZXIuZWxDb3VudDtcbiAgICAgICAgICAgICAgICBsYXllci5lbENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBsYXllci5fX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgY3VycmVudFByb2dyZXNzaXZlTGF5ZXI7XG4gICAgICAgICAgICB2YXIgbGFzdFByb2dyZXNzaXZlS2V5O1xuICAgICAgICAgICAgdmFyIGZyYW1lQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIHpsZXZlbCA9IHRoaXMuX3NpbmdsZUNhbnZhcyA/IDAgOiBlbC56bGV2ZWw7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW3psZXZlbF07XG4gICAgICAgICAgICAgICAgdmFyIGVsUHJvZ3Jlc3MgPSBlbC5wcm9ncmVzc2l2ZTtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZWxDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBsYXllci5fX2RpcnR5ID0gbGF5ZXIuX19kaXJ0eSB8fCBlbC5fX2RpcnR5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vLy8vLy8gVXBkYXRlIHByb2dyZXNzaXZlXG4gICAgICAgICAgICAgICAgaWYgKGVsUHJvZ3Jlc3MgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXggd3JvbmcgcHJvZ3Jlc3NpdmUgc2VxdWVuY2UgcHJvYmxlbS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RQcm9ncmVzc2l2ZUtleSAhPT0gZWxQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFByb2dyZXNzaXZlS2V5ID0gZWxQcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxGcmFtZSA9IGVsLl9fZnJhbWUgPSBmcmFtZUNvdW50IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IE1hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJDb3VudCwgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gcHJvZ3Jlc3NpdmVMYXllcnNbaWR4XSA9IG5ldyBMYXllcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb2dyZXNzaXZlJywgdGhpcywgdGhpcy5kcHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5ID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSB8fCBlbC5fX2RpcnR5O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5lbENvdW50Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcywgZWxGcmFtZVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzID49IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBrZWVwIHJlbmRlcmluZyB0aGlzICBsYXllciBiZWNhdXNlIHByb2dyZXNzaXZlIHJlbmRlcmluZyBpcyBub3QgZmluaXNoZWQgeWV0XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuX19mcmFtZSA9IC0xO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19uZXh0SWR4Tm90UHJvZyA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVyQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NpdmVMYXllckNvdW50Kys7XG4gICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19uZXh0SWR4Tm90UHJvZyA9IGk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIOWxguS4reeahOWFg+e0oOaVsOmHj+acieWPkeeUn+WPmOWMllxuICAgICAgICAgICAgdGhpcy5lYWNoQnVpbGRpbkxheWVyKGZ1bmN0aW9uIChsYXllciwgeikge1xuICAgICAgICAgICAgICAgIGlmIChlbENvdW50c0xhc3RGcmFtZVt6XSAhPT0gbGF5ZXIuZWxDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSKTtcbiAgICAgICAgICAgIHV0aWwuZWFjaChwcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NpdmVFbENvdW50c0xhc3RGcmFtZVtpZHhdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5fX3Byb2dyZXNzID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF6ZmkaG92ZXLlsYLlpJbmiYDmnInlhoXlrrlcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsZGluTGF5ZXIodGhpcy5fY2xlYXJMYXllcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBfY2xlYXJMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICBsYXllci5jbGVhcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkv67mlLnmjIflrpp6bGV2ZWznmoTnu5jliLblj4LmlbBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHpsZXZlbFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIOmFjee9ruWvueixoVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5jbGVhckNvbG9yPTBdIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5tb3Rpb25CbHVyPWZhbHNlXSDmmK/lkKblvIDlkK/liqjmgIHmqKHns4pcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubGFzdEZyYW1lQWxwaGE9MC43XVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAg5Zyo5byA5ZCv5Yqo5oCB5qih57OK55qE5pe25YCZ5L2/55So77yM5LiO5LiK5LiA5bin5re35ZCI55qEYWxwaGHlgLzvvIzlgLzotorlpKflsL7ov7notormmI7mmL5cbiAgICAgICAgICovXG4gICAgICAgIGNvbmZpZ0xheWVyOiBmdW5jdGlvbiAoemxldmVsLCBjb25maWcpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXJDb25maWcgPSB0aGlzLl9sYXllckNvbmZpZztcbiAgICAgICAgICAgICAgICBpZiAoIWxheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb25maWdbemxldmVsXSA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXJDb25maWdbemxldmVsXSwgY29uZmlnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgICAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLm1lcmdlKGxheWVyLCBsYXllckNvbmZpZ1t6bGV2ZWxdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIoOmZpOaMh+WumuWxglxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsIOWxguaJgOWcqOeahHpsZXZlbFxuICAgICAgICAgKi9cbiAgICAgICAgZGVsTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXllci5kb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsYXllci5kb20pO1xuICAgICAgICAgICAgZGVsZXRlIGxheWVyc1t6bGV2ZWxdO1xuXG4gICAgICAgICAgICB6bGV2ZWxMaXN0LnNwbGljZSh1dGlsLmluZGV4T2YoemxldmVsTGlzdCwgemxldmVsKSwgMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWMuuWfn+Wkp+Wwj+WPmOWMluWQjumHjee7mFxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290O1xuICAgICAgICAgICAgLy8gRklYTUUgV2h5ID9cbiAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAgICAgLy8gU2F2ZSBpbnB1dCB3L2hcbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5fb3B0cztcbiAgICAgICAgICAgIHdpZHRoICE9IG51bGwgJiYgKG9wdHMud2lkdGggPSB3aWR0aCk7XG4gICAgICAgICAgICBoZWlnaHQgIT0gbnVsbCAmJiAob3B0cy5oZWlnaHQgPSBoZWlnaHQpO1xuXG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9nZXRTaXplKDEpO1xuXG4gICAgICAgICAgICBkb21Sb290LnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgICAgICAgLy8g5LyY5YyW5rKh5pyJ5a6e6ZmF5pS55Y+Y55qEcmVzaXplXG4gICAgICAgICAgICBpZiAodGhpcy5fd2lkdGggIT0gd2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMuX2hlaWdodCkge1xuICAgICAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYXllcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnNbaWRdLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1dGlsLmVhY2godGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2godHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaTljZXni6znmoTkuIDkuKrlsYJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXJMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG4gICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsYXllci5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDph4rmlL5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICAgICAgdGhpcy5yb290ID1cbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9XG5cbiAgICAgICAgICAgIHRoaXMuX2RvbVJvb3QgPVxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGNhbnZhcyB3aGljaCBoYXMgYWxsIHRoaW5nIHJlbmRlcmVkXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSZW5kZXJlZENhbnZhczogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbMF0uZG9tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW1hZ2VMYXllciA9IG5ldyBMYXllcignaW1hZ2UnLCB0aGlzLCBvcHRzLnBpeGVsUmF0aW8gfHwgdGhpcy5kcHIpO1xuICAgICAgICAgICAgaW1hZ2VMYXllci5pbml0Q29udGV4dCgpO1xuXG4gICAgICAgICAgICBpbWFnZUxheWVyLmNsZWFyQ29sb3IgPSBvcHRzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIGltYWdlTGF5ZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBkaXNwbGF5TGlzdFtpXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGltYWdlTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGltYWdlTGF5ZXIuZG9tO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W57uY5Zu+5Yy65Z+f5a695bqmXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bnu5jlm77ljLrln5/pq5jluqZcbiAgICAgICAgICovXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0U2l6ZTogZnVuY3Rpb24gKHdoSWR4KSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgICAgICAgICB2YXIgd2ggPSBbJ3dpZHRoJywgJ2hlaWdodCddW3doSWR4XTtcbiAgICAgICAgICAgIHZhciBjd2ggPSBbJ2NsaWVudFdpZHRoJywgJ2NsaWVudEhlaWdodCddW3doSWR4XTtcbiAgICAgICAgICAgIHZhciBwbHQgPSBbJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdUb3AnXVt3aElkeF07XG4gICAgICAgICAgICB2YXIgcHJiID0gWydwYWRkaW5nUmlnaHQnLCAncGFkZGluZ0JvdHRvbSddW3doSWR4XTtcblxuICAgICAgICAgICAgaWYgKG9wdHNbd2hdICE9IG51bGwgJiYgb3B0c1t3aF0gIT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG9wdHNbd2hdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB2YXIgc3RsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShyb290KTtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAocm9vdFtjd2hdIHx8IHBhcnNlSW50MTAoc3RsW3doXSkgfHwgcGFyc2VJbnQxMChyb290LnN0eWxlW3doXSkpXG4gICAgICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGxbcGx0XSkgfHwgMClcbiAgICAgICAgICAgICAgICAtIChwYXJzZUludDEwKHN0bFtwcmJdKSB8fCAwKVxuICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3BhdGhUb0ltYWdlOiBmdW5jdGlvbiAoaWQsIHBhdGgsIHdpZHRoLCBoZWlnaHQsIGRwcikge1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGggKiBkcHIsIGhlaWdodCAqIGRwcik7XG5cbiAgICAgICAgICAgIHZhciBwYXRoVHJhbnNmb3JtID0ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwYXRoLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBwYXRoLnJvdGF0aW9uLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBwYXRoLnNjYWxlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGF0aC5wb3NpdGlvbiA9IFswLCAwLCAwXTtcbiAgICAgICAgICAgIHBhdGgucm90YXRpb24gPSAwO1xuICAgICAgICAgICAgcGF0aC5zY2FsZSA9IFsxLCAxXTtcbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5icnVzaChjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgSW1hZ2VTaGFwZSA9IHJlcXVpcmUoJy4vZ3JhcGhpYy9JbWFnZScpO1xuICAgICAgICAgICAgdmFyIGltZ1NoYXBlID0gbmV3IEltYWdlU2hhcGUoe1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogY2FudmFzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChwYXRoVHJhbnNmb3JtLnBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbWdTaGFwZS5wb3NpdGlvbiA9IHBhdGgucG9zaXRpb24gPSBwYXRoVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGF0aFRyYW5zZm9ybS5yb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW1nU2hhcGUucm90YXRpb24gPSBwYXRoLnJvdGF0aW9uID0gcGF0aFRyYW5zZm9ybS5yb3RhdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhdGhUcmFuc2Zvcm0uc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltZ1NoYXBlLnNjYWxlID0gcGF0aC5zY2FsZSA9IHBhdGhUcmFuc2Zvcm0uc2NhbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbWdTaGFwZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfY3JlYXRlUGF0aFRvSW1hZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQsIGUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWUuX3BhdGhUb0ltYWdlKFxuICAgICAgICAgICAgICAgICAgICBpZCwgZSwgd2lkdGgsIGhlaWdodCwgbWUuZHByXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYWludGVyO1xuXG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIFN0b3JhZ2XlhoXlrrnku5PlupPmqKHlnZdcbiAqIEBtb2R1bGUgenJlbmRlci9TdG9yYWdlXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqIEBhdXRob3IgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly9naXRodWIuY29tL3Bpc3NhbmcvKVxuICovXG5cblxuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi9jb3JlL2VudicpO1xuXG4gICAgdmFyIEdyb3VwID0gcmVxdWlyZSgnLi9jb250YWluZXIvR3JvdXAnKTtcblxuICAgIC8vIFVzZSB0aW1zb3J0IGJlY2F1c2UgaW4gbW9zdCBjYXNlIGVsZW1lbnRzIGFyZSBwYXJ0aWFsbHkgc29ydGVkXG4gICAgLy8gaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvcGlzc2FuZy9qcjR4N21kbS84L1xuICAgIHZhciB0aW1zb3J0ID0gcmVxdWlyZSgnLi9jb3JlL3RpbXNvcnQnKTtcblxuICAgIGZ1bmN0aW9uIHNoYXBlQ29tcGFyZUZ1bmMoYSwgYikge1xuICAgICAgICBpZiAoYS56bGV2ZWwgPT09IGIuemxldmVsKSB7XG4gICAgICAgICAgICBpZiAoYS56ID09PSBiLnopIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAoYS56MiA9PT0gYi56Mikge1xuICAgICAgICAgICAgICAgIC8vICAgICAvLyBGSVhNRSBTbG93IGhhcyByZW5kZXJpZHggY29tcGFyZVxuICAgICAgICAgICAgICAgIC8vICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwODgzNDIxL3NvcnRpbmctaW4tamF2YXNjcmlwdC1zaG91bGQtZXZlcnktY29tcGFyZS1mdW5jdGlvbi1oYXZlLWEtcmV0dXJuLTAtc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgLy8gICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92OC92OC9ibG9iLzQ3Y2NlNTQ0YTMxZWQ1NTc3ZmZlMjk2M2Y2N2FjYjQxNDRlZTAyMzIvc3JjL2pzL2FycmF5LmpzI0wxMDEyXG4gICAgICAgICAgICAgICAgLy8gICAgIHJldHVybiBhLl9fcmVuZGVyaWR4IC0gYi5fX3JlbmRlcmlkeDtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuejIgLSBiLnoyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGEueiAtIGIuejtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS56bGV2ZWwgLSBiLnpsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5YaF5a655LuT5bqTIChNKVxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9TdG9yYWdlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIOaJgOacieW4uOinhOW9oueKtu+8jGlk57Si5byV55qEbWFwXG4gICAgICAgIHRoaXMuX2VsZW1lbnRzID0ge307XG5cbiAgICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcblxuICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICB9O1xuXG4gICAgU3RvcmFnZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFN0b3JhZ2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RzW2ldLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6L+U5Zue5omA5pyJ5Zu+5b2i55qE57uY5Yi26Zif5YiXXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZT1mYWxzZV0g5piv5ZCm5Zyo6L+U5Zue5YmN5pu05paw6K+l5pWw57uEXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uELCDlnKggdXBkYXRlIOS4uiB0cnVlIOeahOaXtuWAmeacieaViFxuICAgICAgICAgKlxuICAgICAgICAgKiDor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5wcm90b3R5cGUudXBkYXRlRGlzcGxheUxpc3R9XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldERpc3BsYXlMaXN0OiBmdW5jdGlvbiAodXBkYXRlLCBpbmNsdWRlSWdub3JlKSB7XG4gICAgICAgICAgICBpbmNsdWRlSWdub3JlID0gaW5jbHVkZUlnbm9yZSB8fCBmYWxzZTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXlMaXN0KGluY2x1ZGVJZ25vcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXlMaXN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmm7TmlrDlm77lvaLnmoTnu5jliLbpmJ/liJfjgIJcbiAgICAgICAgICog5q+P5qyh57uY5Yi25YmN6YO95Lya6LCD55So77yM6K+l5pa55rOV5Lya5YWI5rex5bqm5LyY5YWI6YGN5Y6G5pW05Liq5qCR77yM5pu05paw5omA5pyJR3JvdXDlkoxTaGFwZeeahOWPmOaNouW5tuS4lOaKiuaJgOacieWPr+ingeeahFNoYXBl5L+d5a2Y5Yiw5pWw57uE5Lit77yMXG4gICAgICAgICAqIOacgOWQjuagueaNrue7mOWItueahOS8mOWFiOe6p++8iHpsZXZlbCA+IHogPiDmj5LlhaXpobrluo/vvInmjpLluo/lvpfliLDnu5jliLbpmJ/liJdcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUlnbm9yZT1mYWxzZV0g5piv5ZCm5YyF5ZCrIGlnbm9yZSDnmoTmlbDnu4RcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZURpc3BsYXlMaXN0OiBmdW5jdGlvbiAoaW5jbHVkZUlnbm9yZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuICAgICAgICAgICAgdmFyIHJvb3RzID0gdGhpcy5fcm9vdHM7XG4gICAgICAgICAgICB2YXIgZGlzcGxheUxpc3QgPSB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb290cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKHJvb3RzW2ldLCBudWxsLCBpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BsYXlMaXN0Lmxlbmd0aCA9IHRoaXMuX2Rpc3BsYXlMaXN0TGVuO1xuXG4gICAgICAgICAgICAvLyBmb3IgKHZhciBpID0gMCwgbGVuID0gZGlzcGxheUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIC8vICAgICBkaXNwbGF5TGlzdFtpXS5fX3JlbmRlcmlkeCA9IGk7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIC8vIGRpc3BsYXlMaXN0LnNvcnQoc2hhcGVDb21wYXJlRnVuYyk7XG4gICAgICAgICAgICBlbnYuY2FudmFzU3VwcG9ydGVkICYmIHRpbXNvcnQoZGlzcGxheUxpc3QsIHNoYXBlQ29tcGFyZUZ1bmMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVBbmRBZGREaXNwbGF5YWJsZTogZnVuY3Rpb24gKGVsLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpIHtcblxuICAgICAgICAgICAgaWYgKGVsLmlnbm9yZSAmJiAhaW5jbHVkZUlnbm9yZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwuYmVmb3JlVXBkYXRlKCk7XG5cbiAgICAgICAgICAgIGlmIChlbC5fX2RpcnR5KSB7XG5cbiAgICAgICAgICAgICAgICBlbC51cGRhdGUoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbC5hZnRlclVwZGF0ZSgpO1xuXG4gICAgICAgICAgICB2YXIgdXNlclNldENsaXBQYXRoID0gZWwuY2xpcFBhdGg7XG4gICAgICAgICAgICBpZiAodXNlclNldENsaXBQYXRoKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDmlYjnjoflvbHlk41cbiAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRocyA9IGNsaXBQYXRocy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGhzID0gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDbGlwUGF0aCA9IHVzZXJTZXRDbGlwUGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q2xpcFBhdGggPSBlbDtcbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBhZGQgY2xpcCBwYXRoXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRDbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGlwUGF0aCDnmoTlj5jmjaLmmK/ln7rkuo7kvb/nlKjov5nkuKogY2xpcFBhdGgg55qE5YWD57SgXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDbGlwUGF0aC5wYXJlbnQgPSBwYXJlbnRDbGlwUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENsaXBQYXRoLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRocy5wdXNoKGN1cnJlbnRDbGlwUGF0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDbGlwUGF0aCA9IGN1cnJlbnRDbGlwUGF0aC5jbGlwUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbC5pc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuX2NoaWxkcmVuO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSB0byBtYXJrIGFzIGRpcnR5IGlmIGdyb3VwIGlzIGRpcnR5XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIF9fZGlydHlQYXRoID9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQW5kQWRkRGlzcGxheWFibGUoY2hpbGQsIGNsaXBQYXRocywgaW5jbHVkZUlnbm9yZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFyayBncm91cCBjbGVhbiBoZXJlXG4gICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbC5fX2NsaXBQYXRocyA9IGNsaXBQYXRocztcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0W3RoaXMuX2Rpc3BsYXlMaXN0TGVuKytdID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXAp5Yiw5qC56IqC54K5XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIGFkZFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgLy8gRWxlbWVudCBoYXMgYmVlbiBhZGRlZFxuICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRzW2VsLmlkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICBlbC5hZGRDaGlsZHJlblRvU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hZGRUb01hcChlbCk7XG4gICAgICAgICAgICB0aGlzLl9yb290cy5wdXNoKGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5oyH5a6a55qE5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtlbElkXSDlpoLmnpzkuLrnqbrmuIXnqbrmlbTkuKpTdG9yYWdlXG4gICAgICAgICAqL1xuICAgICAgICBkZWxSb290OiBmdW5jdGlvbiAoZWxJZCkge1xuICAgICAgICAgICAgaWYgKGVsSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIOS4jeaMh+WummVsSWTmuIXnqbpcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290IGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRzID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsSWQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWxJZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxSb290KGVsSWRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoZWxJZCkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBlbCA9IHRoaXMuX2VsZW1lbnRzW2VsSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwgPSBlbElkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKHRoaXMuX3Jvb3RzLCBlbCk7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbEZyb21NYXAoZWwuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2UodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFRvTWFwOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgZWwuX19zdG9yYWdlID0gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLmRpcnR5KGZhbHNlKTtcblxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudHNbZWwuaWRdID0gZWw7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKGVsSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50c1tlbElkXTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxGcm9tTWFwOiBmdW5jdGlvbiAoZWxJZCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5fZWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgZWwgPSBlbGVtZW50c1tlbElkXTtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50c1tlbElkXTtcbiAgICAgICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5fX3N0b3JhZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4heepuuW5tuS4lOmHiuaUvlN0b3JhZ2VcbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRzID1cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckxpc3QgPVxuICAgICAgICAgICAgdGhpcy5fcm9vdHMgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3BsYXlhYmxlU29ydEZ1bmM6IHNoYXBlQ29tcGFyZUZ1bmNcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTdG9yYWdlO1xuXG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOWKqOeUu+S4u+exuywg6LCD5bqm5ZKM566h55CG5omA5pyJ5Yqo55S75o6n5Yi25ZmoXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBBZGRpdGl2ZSBhbmltYXRpb25cbi8vIGh0dHA6Ly9pb3NvdGVyaWMuY29tL2FkZGl0aXZlLWFuaW1hdGlvbnMtYW5pbWF0ZXdpdGhkdXJhdGlvbi1pbi1pb3MtOC9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS92aWRlb3Mvd3dkYzIwMTQvIzIzNlxuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpLkRpc3BhdGNoZXI7XG5cbiAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgnLi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcblxuICAgIHZhciBBbmltYXRvciA9IHJlcXVpcmUoJy4vQW5pbWF0b3InKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBJWlJlbmRlclN0YWdlXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXBkYXRlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbmZyYW1lXVxuICAgICAqIEBwYXJhbSB7SVpSZW5kZXJTdGFnZX0gW29wdGlvbnMuc3RhZ2VdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgdmFyIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcbiAgICAgKiAgICAgdmFyIG9iaiA9IHtcbiAgICAgKiAgICAgICAgIHg6IDEwMCxcbiAgICAgKiAgICAgICAgIHk6IDEwMFxuICAgICAqICAgICB9O1xuICAgICAqICAgICBhbmltYXRpb24uYW5pbWF0ZShub2RlLnBvc2l0aW9uKVxuICAgICAqICAgICAgICAgLndoZW4oMTAwMCwge1xuICAgICAqICAgICAgICAgICAgIHg6IDUwMCxcbiAgICAgKiAgICAgICAgICAgICB5OiA1MDBcbiAgICAgKiAgICAgICAgIH0pXG4gICAgICogICAgICAgICAud2hlbigyMDAwLCB7XG4gICAgICogICAgICAgICAgICAgeDogMTAwLFxuICAgICAqICAgICAgICAgICAgIHk6IDEwMFxuICAgICAqICAgICAgICAgfSlcbiAgICAgKiAgICAgICAgIC5zdGFydCgnc3BsaW5lJyk7XG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5zdGFnZSA9IG9wdGlvbnMuc3RhZ2UgfHwge307XG5cbiAgICAgICAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICAgICAgLy8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuX2NsaXBzID0gW107XG5cbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3RpbWU7XG5cbiAgICAgICAgdGhpcy5fcGF1c2VkVGltZTtcblxuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0O1xuXG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIERpc3BhdGNoZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQW5pbWF0aW9uLFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75YqgIGNsaXBcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ2xpcDogZnVuY3Rpb24gKGNsaXApIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaXBzLnB1c2goY2xpcCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqAgYW5pbWF0b3JcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9IGFuaW1hdG9yXG4gICAgICAgICAqL1xuICAgICAgICBhZGRBbmltYXRvcjogZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgICAgICAgICBhbmltYXRvci5hbmltYXRpb24gPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNsaXBzID0gYW5pbWF0b3IuZ2V0Q2xpcHMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENsaXAoY2xpcHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXB9IGNsaXBcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNsaXA6IGZ1bmN0aW9uKGNsaXApIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fY2xpcHMsIGNsaXApO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpcHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIoOmZpOWKqOeUu+eJh+autVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICAgICAgICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGlwKGNsaXBzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9wYXVzZWRUaW1lO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gdGltZSAtIHRoaXMuX3RpbWU7XG4gICAgICAgICAgICB2YXIgY2xpcHMgPSB0aGlzLl9jbGlwcztcbiAgICAgICAgICAgIHZhciBsZW4gPSBjbGlwcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHZhciBkZWZlcnJlZEV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkQ2xpcHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNsaXBzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBlID0gY2xpcC5zdGVwKHRpbWUpO1xuICAgICAgICAgICAgICAgIC8vIFRocm93IG91dCB0aGUgZXZlbnRzIG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyXG4gICAgICAgICAgICAgICAgLy8gc3RhZ2UudXBkYXRlLCBsaWtlIGRlc3Ryb3lcbiAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZEV2ZW50cy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENsaXBzLnB1c2goY2xpcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGZpbmlzaGVkIGNsaXBcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIGlmIChjbGlwc1tpXS5fbmVlZHNSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcHNbaV0gPSBjbGlwc1tsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2xpcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGVuID0gZGVmZXJyZWRFdmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkQ2xpcHNbaV0uZmlyZShkZWZlcnJlZEV2ZW50c1tpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuXG4gICAgICAgICAgICB0aGlzLm9uZnJhbWUoZGVsdGEpO1xuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2ZyYW1lJywgZGVsdGEpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFnZS51cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9zdGFydExvb3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3J1bm5pbmcpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG5cbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuX3BhdXNlZCAmJiBzZWxmLl91cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5byA5aeL6L+Q6KGM5Yqo55S7XG4gICAgICAgICAqL1xuICAgICAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcblxuICAgICAgICAgICAgdGhpcy5fc3RhcnRMb29wKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLov5DooYzliqjnlLtcbiAgICAgICAgICovXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGF1c2VcbiAgICAgICAgICovXG4gICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdXNlU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXN1bWVcbiAgICAgICAgICovXG4gICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdXNlZFRpbWUgKz0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSAtIHRoaXMuX3BhdXNlU3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4hemZpOaJgOacieWKqOeUu+eJh+autVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaXBzID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlr7nkuIDkuKrnm67moIfliJvlu7rkuIDkuKphbmltYXRvcuWvueixoe+8jOWPr+S7peaMh+Wumuebruagh+S4reeahOWxnuaAp+S9v+eUqOWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMubG9vcD1mYWxzZV0g5piv5ZCm5b6q546v5pKt5pS+5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZXR0ZXI9bnVsbF1cbiAgICAgICAgICogICAgICAgICDlpoLmnpzmjIflrppnZXR0ZXLlh73mlbDvvIzkvJrpgJrov4dnZXR0ZXLlh73mlbDlj5blsZ7mgKflgLxcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLnNldHRlcj1udWxsXVxuICAgICAgICAgKiAgICAgICAgIOWmguaenOaMh+WumnNldHRlcuWHveaVsO+8jOS8mumAmui/h3NldHRlcuWHveaVsOiuvue9ruWxnuaAp+WAvFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufkFuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETyBHYXBcbiAgICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcihcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb29wLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZ2V0dGVyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2V0dGVyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcblxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdG9yO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHV0aWwubWl4aW4oQW5pbWF0aW9uLCBEaXNwYXRjaGVyKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQW5pbWF0aW9uO1xuXG4iLCIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9hbmltYXRpb24vQW5pbWF0b3JcbiAqL1xuXG5cbiAgICB2YXIgQ2xpcCA9IHJlcXVpcmUoJy4vQ2xpcCcpO1xuICAgIHZhciBjb2xvciA9IHJlcXVpcmUoJy4uL3Rvb2wvY29sb3InKTtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBpc0FycmF5TGlrZSA9IHV0aWwuaXNBcnJheUxpa2U7XG5cbiAgICB2YXIgYXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRHZXR0ZXIodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRTZXR0ZXIodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVOdW1iZXIocDAsIHAxLCBwZXJjZW50KSB7XG4gICAgICAgIHJldHVybiAocDEgLSBwMCkgKiBwZXJjZW50ICsgcDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwMFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVTdHJpbmcocDAsIHAxLCBwZXJjZW50KSB7XG4gICAgICAgIHJldHVybiBwZXJjZW50ID4gMC41ID8gcDEgOiBwMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcGVyY2VudCwgb3V0LCBhcnJEaW0pIHtcbiAgICAgICAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV0sIHAxW2ldLCBwZXJjZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4yID0gcDBbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtpXVtqXSA9IGludGVycG9sYXRlTnVtYmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgcDBbaV1bal0sIHAxW2ldW2pdLCBwZXJjZW50XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXJyMCBpcyBzb3VyY2UgYXJyYXksIGFycjEgaXMgdGFyZ2V0IGFycmF5LlxuICAgIC8vIERvIHNvbWUgcHJlcHJvY2VzcyB0byBhdm9pZCBlcnJvciBoYXBwZW5lZCB3aGVuIGludGVycG9sYXRpbmcgZnJvbSBhcnIwIHRvIGFycjFcbiAgICBmdW5jdGlvbiBmaWxsQXJyKGFycjAsIGFycjEsIGFyckRpbSkge1xuICAgICAgICB2YXIgYXJyMExlbiA9IGFycjAubGVuZ3RoO1xuICAgICAgICB2YXIgYXJyMUxlbiA9IGFycjEubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyMExlbiAhPT0gYXJyMUxlbikge1xuICAgICAgICAgICAgLy8gRklYTUUgTm90IHdvcmsgZm9yIFR5cGVkQXJyYXlcbiAgICAgICAgICAgIHZhciBpc1ByZXZpb3VzTGFyZ2VyID0gYXJyMExlbiA+IGFycjFMZW47XG4gICAgICAgICAgICBpZiAoaXNQcmV2aW91c0xhcmdlcikge1xuICAgICAgICAgICAgICAgIC8vIEN1dCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgICAgICBhcnIwLmxlbmd0aCA9IGFycjFMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGaWxsIHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcnIwTGVuOyBpIDwgYXJyMUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycjAucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyckRpbSA9PT0gMSA/IGFycjFbaV0gOiBhcnJheVNsaWNlLmNhbGwoYXJyMVtpXSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxpbmcgTmFOIHZhbHVlXG4gICAgICAgIHZhciBsZW4yID0gYXJyMFswXSAmJiBhcnIwWzBdLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGFycjBbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycjBbaV0gPSBhcnIxW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihhcnIwW2ldW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyMFtpXVtqXSA9IGFycjFbaV1bal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyMFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnIxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlTYW1lKGFycjAsIGFycjEsIGFyckRpbSkge1xuICAgICAgICBpZiAoYXJyMCA9PT0gYXJyMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGFycjAubGVuZ3RoO1xuICAgICAgICBpZiAobGVuICE9PSBhcnIxLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyMFtpXSAhPT0gYXJyMVtpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlbjIgPSBhcnIwWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyMFtpXVtqXSAhPT0gYXJyMVtpXVtqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdG11bGwgUm9tIGludGVycG9sYXRlIGFycmF5XG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAwXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAxXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mywgb3V0LCBhcnJEaW1cbiAgICApIHtcbiAgICAgICAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICBwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdCwgdDIsIHQzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4yID0gcDBbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtpXVtqXSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHAwW2ldW2pdLCBwMVtpXVtqXSwgcDJbaV1bal0sIHAzW2ldW2pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdCwgdDIsIHQzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F0bXVsbCBSb20gaW50ZXJwb2xhdGUgbnVtYmVyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQzXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gICAgICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgICAgICAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICAgICAgICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzXG4gICAgICAgICAgICAgICAgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MlxuICAgICAgICAgICAgICAgICsgdjAgKiB0ICsgcDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlWzBdKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGFycmF5U2xpY2UuY2FsbCh2YWx1ZVtpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlTbGljZS5jYWxsKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZ2JhMlN0cmluZyhyZ2JhKSB7XG4gICAgICAgIHJnYmFbMF0gPSBNYXRoLmZsb29yKHJnYmFbMF0pO1xuICAgICAgICByZ2JhWzFdID0gTWF0aC5mbG9vcihyZ2JhWzFdKTtcbiAgICAgICAgcmdiYVsyXSA9IE1hdGguZmxvb3IocmdiYVsyXSk7XG5cbiAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyByZ2JhLmpvaW4oJywnKSArICcpJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUcmFja0NsaXAgKGFuaW1hdG9yLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSwga2V5ZnJhbWVzLCBwcm9wTmFtZSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gYW5pbWF0b3IuX2dldHRlcjtcbiAgICAgICAgdmFyIHNldHRlciA9IGFuaW1hdG9yLl9zZXR0ZXI7XG4gICAgICAgIHZhciB1c2VTcGxpbmUgPSBlYXNpbmcgPT09ICdzcGxpbmUnO1xuXG4gICAgICAgIHZhciB0cmFja0xlbiA9IGtleWZyYW1lcy5sZW5ndGg7XG4gICAgICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHdWVzcyBkYXRhIHR5cGVcbiAgICAgICAgdmFyIGZpcnN0VmFsID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICAgICAgICB2YXIgaXNWYWx1ZUFycmF5ID0gaXNBcnJheUxpa2UoZmlyc3RWYWwpO1xuICAgICAgICB2YXIgaXNWYWx1ZUNvbG9yID0gZmFsc2U7XG4gICAgICAgIHZhciBpc1ZhbHVlU3RyaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRm9yIHZlcnRpY2VzIG1vcnBoaW5nXG4gICAgICAgIHZhciBhcnJEaW0gPSAoXG4gICAgICAgICAgICAgICAgaXNWYWx1ZUFycmF5XG4gICAgICAgICAgICAgICAgJiYgaXNBcnJheUxpa2UoZmlyc3RWYWxbMF0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICA/IDIgOiAxO1xuICAgICAgICB2YXIgdHJhY2tNYXhUaW1lO1xuICAgICAgICAvLyBTb3J0IGtleWZyYW1lIGFzIGFzY2VuZGluZ1xuICAgICAgICBrZXlmcmFtZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICAgICAgICB9KTtcblxuICAgICAgICB0cmFja01heFRpbWUgPSBrZXlmcmFtZXNbdHJhY2tMZW4gLSAxXS50aW1lO1xuICAgICAgICAvLyBQZXJjZW50cyBvZiBlYWNoIGtleWZyYW1lXG4gICAgICAgIHZhciBrZlBlcmNlbnRzID0gW107XG4gICAgICAgIC8vIFZhbHVlIG9mIGVhY2gga2V5ZnJhbWVcbiAgICAgICAgdmFyIGtmVmFsdWVzID0gW107XG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gICAgICAgIHZhciBpc0FsbFZhbHVlRXF1YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGtmUGVyY2VudHMucHVzaChrZXlmcmFtZXNbaV0udGltZSAvIHRyYWNrTWF4VGltZSk7XG4gICAgICAgICAgICAvLyBBc3N1bWUgdmFsdWUgaXMgYSBjb2xvciB3aGVuIGl0IGlzIGEgc3RyaW5nXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBrZXlmcmFtZXNbaV0udmFsdWU7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHZhbHVlIGlzIGVxdWFsLCBkZWVwIGNoZWNrIGlmIHZhbHVlIGlzIGFycmF5XG4gICAgICAgICAgICBpZiAoISgoaXNWYWx1ZUFycmF5ICYmIGlzQXJyYXlTYW1lKHZhbHVlLCBwcmV2VmFsdWUsIGFyckRpbSkpXG4gICAgICAgICAgICAgICAgfHwgKCFpc1ZhbHVlQXJyYXkgJiYgdmFsdWUgPT09IHByZXZWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgaXNBbGxWYWx1ZUVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gVHJ5IGNvbnZlcnRpbmcgYSBzdHJpbmcgdG8gYSBjb2xvciBhcnJheVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvckFycmF5ID0gY29sb3IucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb2xvckFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29sb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWx1ZUNvbG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsdWVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtmVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FsbFZhbHVlRXF1YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBrZlZhbHVlc1t0cmFja0xlbiAtIDFdO1xuICAgICAgICAvLyBQb2x5ZmlsbCBhcnJheSBhbmQgTmFOIHZhbHVlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmaWxsQXJyKGtmVmFsdWVzW2ldLCBsYXN0VmFsdWUsIGFyckRpbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oa2ZWYWx1ZXNbaV0pICYmICFpc05hTihsYXN0VmFsdWUpICYmICFpc1ZhbHVlU3RyaW5nICYmICFpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAga2ZWYWx1ZXNbaV0gPSBsYXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzVmFsdWVBcnJheSAmJiBmaWxsQXJyKGdldHRlcihhbmltYXRvci5fdGFyZ2V0LCBwcm9wTmFtZSksIGxhc3RWYWx1ZSwgYXJyRGltKTtcblxuICAgICAgICAvLyBDYWNoZSB0aGUga2V5IG9mIGxhc3QgZnJhbWUgdG8gc3BlZWQgdXAgd2hlblxuICAgICAgICAvLyBhbmltYXRpb24gcGxheWJhY2sgaXMgc2VxdWVuY3lcbiAgICAgICAgdmFyIGxhc3RGcmFtZSA9IDA7XG4gICAgICAgIHZhciBsYXN0RnJhbWVQZXJjZW50ID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICB2YXIgdztcbiAgICAgICAgdmFyIHAwO1xuICAgICAgICB2YXIgcDE7XG4gICAgICAgIHZhciBwMjtcbiAgICAgICAgdmFyIHAzO1xuXG4gICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgIHZhciByZ2JhID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSByYW5nZSBrZXlmcmFtZXNcbiAgICAgICAgICAgIC8vIGtmMS0tLS0ta2YyLS0tLS0tLS0tY3VycmVudC0tLS0tLS0ta2YzXG4gICAgICAgICAgICAvLyBmaW5kIGtmMiBhbmQga2YzIGFuZCBkbyBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICB2YXIgZnJhbWU7XG4gICAgICAgICAgICAvLyBJbiB0aGUgZWFzaW5nIGZ1bmN0aW9uIGxpa2UgZWxhc3RpY091dCwgcGVyY2VudCBtYXkgbGVzcyB0aGFuIDBcbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIGZyYW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlcmNlbnQgPCBsYXN0RnJhbWVQZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSBuZXh0IGtleVxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4obGFzdEZyYW1lICsgMSwgdHJhY2tMZW4gLSAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGZyYW1lID0gc3RhcnQ7IGZyYW1lID49IDA7IGZyYW1lLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdIDw9IHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgcmVhbGx5IG5lZWQgdG8gZG8gdGhpcyA/XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSwgdHJhY2tMZW4gLSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgdHJhY2tMZW47IGZyYW1lKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdID4gcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSAtIDEsIHRyYWNrTGVuIC0gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0RnJhbWUgPSBmcmFtZTtcbiAgICAgICAgICAgIGxhc3RGcmFtZVBlcmNlbnQgPSBwZXJjZW50O1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSAoa2ZQZXJjZW50c1tmcmFtZSArIDFdIC0ga2ZQZXJjZW50c1tmcmFtZV0pO1xuICAgICAgICAgICAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdyA9IChwZXJjZW50IC0ga2ZQZXJjZW50c1tmcmFtZV0pIC8gcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlU3BsaW5lKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBrZlZhbHVlc1tmcmFtZV07XG4gICAgICAgICAgICAgICAgcDAgPSBrZlZhbHVlc1tmcmFtZSA9PT0gMCA/IGZyYW1lIDogZnJhbWUgLSAxXTtcbiAgICAgICAgICAgICAgICBwMiA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAyID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAxXTtcbiAgICAgICAgICAgICAgICBwMyA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAzID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAyXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZ2JhLCAxXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcocDEsIHAyLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICBrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmdiYSwgMVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGludGVycG9sYXRlTnVtYmVyKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2xpcCA9IG5ldyBDbGlwKHtcbiAgICAgICAgICAgIHRhcmdldDogYW5pbWF0b3IuX3RhcmdldCxcbiAgICAgICAgICAgIGxpZmU6IHRyYWNrTWF4VGltZSxcbiAgICAgICAgICAgIGxvb3A6IGFuaW1hdG9yLl9sb29wLFxuICAgICAgICAgICAgZGVsYXk6IGFuaW1hdG9yLl9kZWxheSxcbiAgICAgICAgICAgIG9uZnJhbWU6IG9uZnJhbWUsXG4gICAgICAgICAgICBvbmRlc3Ryb3k6IG9uZVRyYWNrRG9uZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZWFzaW5nICYmIGVhc2luZyAhPT0gJ3NwbGluZScpIHtcbiAgICAgICAgICAgIGNsaXAuZWFzaW5nID0gZWFzaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsaXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0b3IgPSBmdW5jdGlvbih0YXJnZXQsIGxvb3AsIGdldHRlciwgc2V0dGVyKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgdGhpcy5fbG9vcCA9IGxvb3AgfHwgZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fZ2V0dGVyID0gZ2V0dGVyIHx8IGRlZmF1bHRHZXR0ZXI7XG4gICAgICAgIHRoaXMuX3NldHRlciA9IHNldHRlciB8fCBkZWZhdWx0U2V0dGVyO1xuXG4gICAgICAgIHRoaXMuX2NsaXBDb3VudCA9IDA7XG5cbiAgICAgICAgdGhpcy5fZGVsYXkgPSAwO1xuXG4gICAgICAgIHRoaXMuX2RvbmVMaXN0ID0gW107XG5cbiAgICAgICAgdGhpcy5fb25mcmFtZUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9jbGlwTGlzdCA9IFtdO1xuICAgIH07XG5cbiAgICBBbmltYXRvci5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7liqjnlLvlhbPplK7luKdcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWFs+mUruW4p+aXtumXtO+8jOWNleS9jeaYr21zXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMg5YWz6ZSu5bin55qE5bGe5oCn5YC877yMa2V5LXZhbHVl6KGo56S6XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHdoZW46IGZ1bmN0aW9uKHRpbWUgLyogbXMgKi8sIHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy5fdHJhY2tzO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRyYWNrc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tzW3Byb3BOYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldHRlcih0aGlzLl90YXJnZXQsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHpyTG9nKCdJbnZhbGlkIHByb3BlcnR5ICcgKyBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aW1lIGlzIDBcbiAgICAgICAgICAgICAgICAgICAgLy8gIFRoZW4gcHJvcHMgaXMgZ2l2ZW4gaW5pdGlhbGl6ZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlXG4gICAgICAgICAgICAgICAgICAgIC8vICBJbml0aWFsaXplIHZhbHVlIGZyb20gY3VycmVudCBwcm9wIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNsb25lVmFsdWUodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcHNbcHJvcE5hbWVdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWKqOeUu+avj+S4gOW4p+eahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZHVyaW5nOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX29uZnJhbWVMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvbmVDYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgYWxsIHRyYWNrc1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tzID0ge307XG4gICAgICAgICAgICAvLyBDbGVhciBhbGwgY2xpcHNcbiAgICAgICAgICAgIHRoaXMuX2NsaXBMaXN0Lmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBkb25lTGlzdCA9IHRoaXMuX2RvbmVMaXN0O1xuICAgICAgICAgICAgdmFyIGxlbiA9IGRvbmVMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkb25lTGlzdFtpXS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5byA5aeL5omn6KGM5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ3xGdW5jdGlvbn0gZWFzaW5nXG4gICAgICAgICAqICAgICAgICAg5Yqo55S757yT5Yqo5Ye95pWw77yM6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmd9XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoZWFzaW5nKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjbGlwQ291bnQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgb25lVHJhY2tEb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2xpcENvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZG9uZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGxhc3RDbGlwO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdGhpcy5fdHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFja3MuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNyZWF0ZVRyYWNrQ2xpcChcbiAgICAgICAgICAgICAgICAgICAgdGhpcywgZWFzaW5nLCBvbmVUcmFja0RvbmUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrc1twcm9wTmFtZV0sIHByb3BOYW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGlwTGlzdC5wdXNoKGNsaXApO1xuICAgICAgICAgICAgICAgICAgICBjbGlwQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdGFydCBhZnRlciBhZGRlZCB0byBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGRDbGlwKGNsaXApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdENsaXAgPSBjbGlwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGR1cmluZyBjYWxsYmFjayBvbiB0aGUgbGFzdCBjbGlwXG4gICAgICAgICAgICBpZiAobGFzdENsaXApIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkT25GcmFtZSA9IGxhc3RDbGlwLm9uZnJhbWU7XG4gICAgICAgICAgICAgICAgbGFzdENsaXAub25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkT25GcmFtZSh0YXJnZXQsIHBlcmNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fb25mcmFtZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uZnJhbWVMaXN0W2ldKHRhcmdldCwgcGVyY2VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLliqjnlLtcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgIHZhciBjbGlwTGlzdCA9IHRoaXMuX2NsaXBMaXN0O1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwID0gY2xpcExpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgICAgICAgICAgICAgIGNsaXAub25mcmFtZSh0aGlzLl90YXJnZXQsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnJlbW92ZUNsaXAoY2xpcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGlwTGlzdC5sZW5ndGggPSAwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5Yqo55S75bu26L+f5byA5aeL55qE5pe26Ze0XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDljZXkvY1tc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxheTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ID0gdGltZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Yqo55S757uT5p2f55qE5Zue6LCDXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkb25lOiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9uZUxpc3QucHVzaChjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldENsaXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpcExpc3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBbmltYXRvcjtcbiIsIi8qKlxuICog5Yqo55S75Li75o6n5Yi25ZmoXG4gKiBAY29uZmlnIHRhcmdldCDliqjnlLvlr7nosaHvvIzlj6/ku6XmmK/mlbDnu4TvvIzlpoLmnpzmmK/mlbDnu4TnmoTor53kvJrmibnph4/liIblj5FvbmZyYW1l562J5LqL5Lu2XG4gKiBAY29uZmlnIGxpZmUoMTAwMCkg5Yqo55S75pe26ZW/XG4gKiBAY29uZmlnIGRlbGF5KDApIOWKqOeUu+W7tui/n+aXtumXtFxuICogQGNvbmZpZyBsb29wKHRydWUpXG4gKiBAY29uZmlnIGdhcCgwKSDlvqrnjq/nmoTpl7TpmpTml7bpl7RcbiAqIEBjb25maWcgb25mcmFtZVxuICogQGNvbmZpZyBlYXNpbmcob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9uZGVzdHJveShvcHRpb25hbClcbiAqIEBjb25maWcgb25yZXN0YXJ0KG9wdGlvbmFsKVxuICpcbiAqIFRPRE8gcGF1c2VcbiAqL1xuXG5cbiAgICB2YXIgZWFzaW5nRnVuY3MgPSByZXF1aXJlKCcuL2Vhc2luZycpO1xuXG4gICAgZnVuY3Rpb24gQ2xpcChvcHRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG5cbiAgICAgICAgLy8g55Sf5ZG95ZGo5pyfXG4gICAgICAgIHRoaXMuX2xpZmUgPSBvcHRpb25zLmxpZmUgfHwgMTAwMDtcbiAgICAgICAgLy8g5bu25pe2XG4gICAgICAgIHRoaXMuX2RlbGF5ID0gb3B0aW9ucy5kZWxheSB8fCAwO1xuICAgICAgICAvLyDlvIDlp4vml7bpl7RcbiAgICAgICAgLy8gdGhpcy5fc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLl9kZWxheTsvLyDljZXkvY3mr6vnp5JcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyDmmK/lkKblvqrnjq9cbiAgICAgICAgdGhpcy5sb29wID0gb3B0aW9ucy5sb29wID09IG51bGwgPyBmYWxzZSA6IG9wdGlvbnMubG9vcDtcblxuICAgICAgICB0aGlzLmdhcCA9IG9wdGlvbnMuZ2FwIHx8IDA7XG5cbiAgICAgICAgdGhpcy5lYXNpbmcgPSBvcHRpb25zLmVhc2luZyB8fCAnTGluZWFyJztcblxuICAgICAgICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWU7XG4gICAgICAgIHRoaXMub25kZXN0cm95ID0gb3B0aW9ucy5vbmRlc3Ryb3k7XG4gICAgICAgIHRoaXMub25yZXN0YXJ0ID0gb3B0aW9ucy5vbnJlc3RhcnQ7XG4gICAgfVxuXG4gICAgQ2xpcC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IENsaXAsXG5cbiAgICAgICAgc3RlcDogZnVuY3Rpb24gKGdsb2JhbFRpbWUpIHtcbiAgICAgICAgICAgIC8vIFNldCBzdGFydFRpbWUgb24gZmlyc3Qgc3RlcCwgb3IgX3N0YXJ0VGltZSBtYXkgaGFzIG1pbGxlc2Vjb25kcyBkaWZmZXJlbnQgYmV0d2VlbiBjbGlwc1xuICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgKyB0aGlzLl9kZWxheTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gKGdsb2JhbFRpbWUgLSB0aGlzLl9zdGFydFRpbWUpIC8gdGhpcy5fbGlmZTtcblxuICAgICAgICAgICAgLy8g6L+Y5rKh5byA5aeLXG4gICAgICAgICAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBlcmNlbnQgPSBNYXRoLm1pbihwZXJjZW50LCAxKTtcblxuICAgICAgICAgICAgdmFyIGVhc2luZyA9IHRoaXMuZWFzaW5nO1xuICAgICAgICAgICAgdmFyIGVhc2luZ0Z1bmMgPSB0eXBlb2YgZWFzaW5nID09ICdzdHJpbmcnID8gZWFzaW5nRnVuY3NbZWFzaW5nXSA6IGVhc2luZztcbiAgICAgICAgICAgIHZhciBzY2hlZHVsZSA9IHR5cGVvZiBlYXNpbmdGdW5jID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBlYXNpbmdGdW5jKHBlcmNlbnQpXG4gICAgICAgICAgICAgICAgOiBwZXJjZW50O1xuXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2ZyYW1lJywgc2NoZWR1bGUpO1xuXG4gICAgICAgICAgICAvLyDnu5PmnZ9cbiAgICAgICAgICAgIGlmIChwZXJjZW50ID09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb29wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydCAoZ2xvYmFsVGltZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIOmHjeaWsOW8gOWni+WRqOacn1xuICAgICAgICAgICAgICAgICAgICAvLyDmipvlh7rogIzkuI3mmK/nm7TmjqXosIPnlKjkuovku7bnm7TliLAgc3RhZ2UudXBkYXRlIOWQjuWGjee7n+S4gOiwg+eUqOi/meS6m+S6i+S7tlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3Jlc3RhcnQnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIOWKqOeUu+WujOaIkOWwhui/meS4quaOp+WItuWZqOagh+ivhuS4uuW+heWIoOmZpFxuICAgICAgICAgICAgICAgIC8vIOWcqEFuaW1hdGlvbi51cGRhdGXkuK3ov5vooYzmibnph4/liKDpmaRcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkZXN0cm95JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzdGFydDogZnVuY3Rpb24gKGdsb2JhbFRpbWUpIHtcbiAgICAgICAgICAgIHZhciByZW1haW5kZXIgPSAoZ2xvYmFsVGltZSAtIHRoaXMuX3N0YXJ0VGltZSkgJSB0aGlzLl9saWZlO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gZ2xvYmFsVGltZSAtIHJlbWFpbmRlciArIHRoaXMuZ2FwO1xuXG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpcmU6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgYXJnKSB7XG4gICAgICAgICAgICBldmVudFR5cGUgPSAnb24nICsgZXZlbnRUeXBlO1xuICAgICAgICAgICAgaWYgKHRoaXNbZXZlbnRUeXBlXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbZXZlbnRUeXBlXSh0aGlzLl90YXJnZXQsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDbGlwO1xuXG4iLCIvKipcbiAqIOe8k+WKqOS7o+eggeadpeiHqiBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qcy9ibG9iL21hc3Rlci9zcmMvVHdlZW4uanNcbiAqIEBzZWUgaHR0cDovL3NvbGUuZ2l0aHViLmlvL3R3ZWVuLmpzL2V4YW1wbGVzLzAzX2dyYXBocy5odG1sXG4gKiBAZXhwb3J0cyB6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmdcbiAqL1xuXG4gICAgdmFyIGVhc2luZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGxpbmVhcjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YWRyYXRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogKDIgLSBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YWRyYXRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDkuInmrKHmlrnnmoTnvJPliqjvvIh0XjPvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGN1YmljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY3ViaWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY3ViaWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5Zub5qyh5pa555qE57yT5Yqo77yIdF4077yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFydGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqIGsgKiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YXJ0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtICgtLWsgKiBrICogayAqIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhcnRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgLSAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDkupTmrKHmlrnnmoTnvJPliqjvvIh0XjXvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1aW50aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqIGsgKiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1aW50aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gLS1rICogayAqIGsgKiBrICogayArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWludGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAqIGsgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDmraPlvKbmm7Lnur/nmoTnvJPliqjvvIhzaW4odCnvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHNpbnVzb2lkYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5jb3MoayAqIE1hdGguUEkgLyAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHNpbnVzb2lkYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4oayAqIE1hdGguUEkgLyAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHNpbnVzb2lkYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5oyH5pWw5puy57q/55qE57yT5Yqo77yIMl5077yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBleHBvbmVudGlhbEluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZXhwb25lbnRpYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBleHBvbmVudGlhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChrIC0gMSkpICsgMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5ZyG5b2i5puy57q/55qE57yT5Yqo77yIc3FydCgxLXReMinvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGNpcmN1bGFySW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY2lyY3VsYXJPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS1rICogaykpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY2lyY3VsYXJJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIChrIC09IDIpICogaykgKyAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDliJvlu7rnsbvkvLzkuo7lvLnnsKflnKjlgZzmraLliY3mnaXlm57mjK/ojaHnmoTliqjnlLtcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGVsYXN0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgdmFyIGEgPSAwLjE7XG4gICAgICAgICAgICB2YXIgcCA9IDAuNDtcbiAgICAgICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICAgICAgICAgICAgYSA9IDE7IHMgPSBwIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBlbGFzdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgICB2YXIgYSA9IDAuMTtcbiAgICAgICAgICAgIHZhciBwID0gMC40O1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgICAgICAgICAgICBhID0gMTsgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoYSAqIE1hdGgucG93KDIsIC0xMCAqIGspICpcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDEpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZWxhc3RpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgICB2YXIgYSA9IDAuMTtcbiAgICAgICAgICAgIHZhciBwID0gMC40O1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgICAgICAgICAgICBhID0gMTsgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSlcbiAgICAgICAgICAgICAgICAgICAgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKGsgLT0gMSkpXG4gICAgICAgICAgICAgICAgICAgICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvLyDlnKjmn5DkuIDliqjnlLvlvIDlp4vmsr/mjIfnpLrnmoTot6/lvoTov5vooYzliqjnlLvlpITnkIbliY3nqI3nqI3mlLblm57or6XliqjnlLvnmoTnp7vliqhcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJhY2tJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYmFja091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYmFja0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDliJvlu7rlvLnot7PmlYjmnpxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJvdW5jZUluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBlYXNpbmcuYm91bmNlT3V0KDEgLSBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJvdW5jZU91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrIDwgKDEgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPCAoMiAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgxLjUgLyAyLjc1KSkgKiBrICsgMC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPCAoMi41IC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuMjUgLyAyLjc1KSkgKiBrICsgMC45Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgyLjYyNSAvIDIuNzUpKSAqIGsgKyAwLjk4NDM3NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJvdW5jZUluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZUluKGsgKiAyKSAqIDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlYXNpbmcuYm91bmNlT3V0KGsgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlYXNpbmc7XG5cblxuIiwiXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmMsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuIiwiXG4gICAgdmFyIGRwciA9IDE7XG4gICAgLy8gSWYgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkcHIgPSBNYXRoLm1heCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY29uZmln6buY6K6k6YWN572u6aG5XG4gICAgICogQGV4cG9ydHMgenJlbmRlci9jb25maWdcbiAgICAgKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAgICAgKi9cbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogZGVidWfml6Xlv5fpgInpobnvvJpjYXRjaEJydXNoRXhjZXB0aW9u5Li6dHJ1ZeS4i+acieaViFxuICAgICAgICAgKiAwIDog5LiN55Sf5oiQZGVidWfmlbDmja7vvIzlj5HluIPnlKhcbiAgICAgICAgICogMSA6IOW8guW4uOaKm+WHuu+8jOiwg+ivleeUqFxuICAgICAgICAgKiAyIDog5o6n5Yi25Y+w6L6T5Ye677yM6LCD6K+V55SoXG4gICAgICAgICAqL1xuICAgICAgICBkZWJ1Z01vZGU6IDAsXG5cbiAgICAgICAgLy8gcmV0aW5hIOWxj+W5leS8mOWMllxuICAgICAgICBkZXZpY2VQaXhlbFJhdGlvOiBkcHJcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gY29uZmlnO1xuXG5cbiIsIlxuXG4gICAgdmFyIG5vcm1hbGl6ZVJhZGlhbiA9IHJlcXVpcmUoJy4vdXRpbCcpLm5vcm1hbGl6ZVJhZGlhbjtcbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWchuW8p+aPj+i+ueWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBjeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBjeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICByXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHN0YXJ0QW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgZW5kQW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gIGFudGljbG9ja3dpc2VcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICkge1xuXG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuXG4gICAgICAgICAgICB4IC09IGN4O1xuICAgICAgICAgICAgeSAtPSBjeTtcbiAgICAgICAgICAgIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gICAgICAgICAgICBpZiAoKGQgLSBfbCA+IHIpIHx8IChkICsgX2wgPCByKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpICUgUEkyIDwgMWUtNCkge1xuICAgICAgICAgICAgICAgIC8vIElzIGEgY2lyY2xlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4KTtcbiAgICAgICAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICBhbmdsZSArPSBQSTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgfHwgKGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGUpO1xuICAgICAgICB9XG4gICAgfTtcbiIsIlxuXG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY29yZS9jdXJ2ZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuInmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgJiYgeSA+IHkzICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sICYmIHkgPCB5MyAtIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbCAmJiB4ID4geDMgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wgJiYgeCA8IHgzIC0gX2wpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZCA9IGN1cnZlLmN1YmljUHJvamVjdFBvaW50KFxuICAgICAgICAgICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MyxcbiAgICAgICAgICAgICAgICB4LCB5LCBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGQgPD0gX2wgLyAyO1xuICAgICAgICB9XG4gICAgfTtcbiIsIlxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog57q/5q615YyF5ZCr5Yik5patXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5TdHJva2U6IGZ1bmN0aW9uICh4MCwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgdmFyIF9hID0gMDtcbiAgICAgICAgICAgIHZhciBfYiA9IHgwO1xuICAgICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeDAgIT09IHgxKSB7XG4gICAgICAgICAgICAgICAgX2EgPSAoeTAgLSB5MSkgLyAoeDAgLSB4MSk7XG4gICAgICAgICAgICAgICAgX2IgPSAoeDAgKiB5MSAtIHgxICogeTApIC8gKHgwIC0geDEpIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh4IC0geDApIDw9IF9sIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0bXAgPSBfYSAqIHggLSB5ICsgX2I7XG4gICAgICAgICAgICB2YXIgX3MgPSB0bXAgKiB0bXAgLyAoX2EgKiBfYSArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIF9zIDw9IF9sIC8gMiAqIF9sIC8gMjtcbiAgICAgICAgfVxuICAgIH07XG4iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBDTUQgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpLkNNRDtcbiAgICB2YXIgbGluZSA9IHJlcXVpcmUoJy4vbGluZScpO1xuICAgIHZhciBjdWJpYyA9IHJlcXVpcmUoJy4vY3ViaWMnKTtcbiAgICB2YXIgcXVhZHJhdGljID0gcmVxdWlyZSgnLi9xdWFkcmF0aWMnKTtcbiAgICB2YXIgYXJjID0gcmVxdWlyZSgnLi9hcmMnKTtcbiAgICB2YXIgbm9ybWFsaXplUmFkaWFuID0gcmVxdWlyZSgnLi91dGlsJykubm9ybWFsaXplUmFkaWFuO1xuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvY3VydmUnKTtcblxuICAgIHZhciB3aW5kaW5nTGluZSA9IHJlcXVpcmUoJy4vd2luZGluZ0xpbmUnKTtcblxuICAgIHZhciBjb250YWluU3Ryb2tlID0gbGluZS5jb250YWluU3Ryb2tlO1xuXG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG4gICAgdmFyIEVQU0lMT04gPSAxZS00O1xuXG4gICAgZnVuY3Rpb24gaXNBcm91bmRFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBFUFNJTE9OO1xuICAgIH1cblxuICAgIC8vIOS4tOaXtuaVsOe7hFxuICAgIHZhciByb290cyA9IFstMSwgLTEsIC0xXTtcbiAgICB2YXIgZXh0cmVtYSA9IFstMSwgLTFdO1xuXG4gICAgZnVuY3Rpb24gc3dhcEV4dHJlbWEoKSB7XG4gICAgICAgIHZhciB0bXAgPSBleHRyZW1hWzBdO1xuICAgICAgICBleHRyZW1hWzBdID0gZXh0cmVtYVsxXTtcbiAgICAgICAgZXh0cmVtYVsxXSA9IHRtcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aW5kaW5nQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5KSB7XG4gICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgJiYgeSA+IHkzKVxuICAgICAgICAgICAgfHwgKHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyICYmIHkgPCB5MylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgblJvb3RzID0gY3VydmUuY3ViaWNSb290QXQoeTAsIHkxLCB5MiwgeTMsIHksIHJvb3RzKTtcbiAgICAgICAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgICAgICB2YXIgbkV4dHJlbWEgPSAtMTtcbiAgICAgICAgICAgIHZhciB5MF8sIHkxXztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHJvb3RzW2ldO1xuXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG4gICAgICAgICAgICAgICAgdmFyIHVuaXQgPSAodCA9PT0gMCB8fCB0ID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5jdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgICAgICBpZiAoeF8gPCB4KSB7IC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5FeHRyZW1hIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBuRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyZW1hWzFdIDwgZXh0cmVtYVswXSAmJiBuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3YXBFeHRyZW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeTBfID0gY3VydmUuY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYVswXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWIhuaIkOS4ieauteWNleiwg+WHveaVsFxuICAgICAgICAgICAgICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodCA8IGV4dHJlbWFbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTFfIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MyA8IHkxXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiG5oiQ5Lik5q615Y2V6LCD5Ye95pWwXG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDwgZXh0cmVtYVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTMgPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpbmRpbmdRdWFkcmF0aWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyKVxuICAgICAgICAgICAgfHwgKHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuUm9vdHMgPSBjdXJ2ZS5xdWFkcmF0aWNSb290QXQoeTAsIHkxLCB5MiwgeSwgcm9vdHMpO1xuICAgICAgICBpZiAoblJvb3RzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0ID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5Mik7XG4gICAgICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgICAgICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgeV8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbmUgZW5kcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHJvb3RzW2ldID09PSAwIHx8IHJvb3RzW2ldID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeF8gPCB4KSB7ICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocm9vdHNbaV0gPCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHlfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkyIDwgeV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHJvb3RzWzBdID09PSAwIHx8IHJvb3RzWzBdID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCByb290c1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkyIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPXG4gICAgLy8gQXJjIOaXi+i9rFxuICAgIGZ1bmN0aW9uIHdpbmRpbmdBcmMoXG4gICAgICAgIGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHgsIHlcbiAgICApIHtcbiAgICAgICAgeSAtPSBjeTtcbiAgICAgICAgaWYgKHkgPiByIHx8IHkgPCAtcikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRtcCA9IE1hdGguc3FydChyICogciAtIHkgKiB5KTtcbiAgICAgICAgcm9vdHNbMF0gPSAtdG1wO1xuICAgICAgICByb290c1sxXSA9IHRtcDtcblxuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG4gICAgICAgIGlmIChkaWZmIDwgMWUtNCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpZmYgJSBQSTIgPCAxZS00KSB7XG4gICAgICAgICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IDA7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IFBJMjtcbiAgICAgICAgICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuICAgICAgICAgICAgaWYgKHggPj0gcm9vdHNbMF0gKyBjeCAmJiB4IDw9IHJvb3RzWzFdICsgY3gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgICAgICAgZW5kQW5nbGUgKz0gUEkyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgdmFyIHhfID0gcm9vdHNbaV07XG4gICAgICAgICAgICBpZiAoeF8gKyBjeCA+IHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHksIHhfKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gUEkyICsgYW5nbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgICAgIHx8IChhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gMiAmJiBhbmdsZSA8IE1hdGguUEkgKiAxLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpciA9IC1kaXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdyArPSBkaXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5QYXRoKGRhdGEsIGxpbmVXaWR0aCwgaXNTdHJva2UsIHgsIHkpIHtcbiAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICB2YXIgeWkgPSAwO1xuICAgICAgICB2YXIgeDAgPSAwO1xuICAgICAgICB2YXIgeTAgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgLy8gQmVnaW4gYSBuZXcgc3VicGF0aFxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gQ01ELk0gJiYgaSA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzdWJwYXRoXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgICAgICAgICAgIC8vIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5L2/55SoXG4gICAgICAgICAgICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFIOWcqOesrOS4gOS4quWRveS7pOS4uiBMLCBDLCBRIOeahOaXtuWAmeS8muiuoeeul+WHuiBOYU5cbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1YmljLmNvbnRhaW5TdHJva2UoeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdDdWJpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWFkcmF0aWMuY29udGFpblN0cm9rZSh4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nUXVhZHJhdGljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDml4vovaxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSBNYXRoLmNvcyh0aGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSBNYXRoLnNpbih0aGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAvLyDkuI3mmK/nm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB6ciDkvb/nlKhzY2FsZeadpeaooeaLn+akreWchiwg6L+Z6YeM5Lmf5a+5eOWBmuS4gOWumueahOe8qeaUvlxuICAgICAgICAgICAgICAgICAgICB2YXIgX3ggPSAoeCAtIGN4KSAqIHJ5IC8gcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJjLmNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgX3gsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0FyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3gsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBNYXRoLmNvcyh0aGV0YSArIGRUaGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICB5aSA9IE1hdGguc2luKHRoZXRhICsgZFRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0geDAgKyB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0geTAgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTAsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGFpblN0cm9rZSh4MSwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250YWluU3Ryb2tlKHgxLCB5MSwgeDAsIHkxLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRhaW5TdHJva2UoeDAsIHkxLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgQ2xvY2t3aXNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDEsIHkwLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4MCwgeTEsIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpblN0cm9rZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksIHgwLCB5MCwgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSBhIHN1YnBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBzdWJwYXRocyBtYXkgb3ZlcmxhcFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU3Ryb2tlICYmICFpc0Fyb3VuZEVxdWFsKHlpLCB5MCkpIHtcbiAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHcgIT09IDA7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uIChwYXRoRGF0YSwgeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCAwLCBmYWxzZSwgeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgbGluZVdpZHRoLCB0cnVlLCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH07XG4iLCJcblxuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvY3VydmUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5LqM5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5TdHJva2U6IGZ1bmN0aW9uICh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZCA9IGN1cnZlLnF1YWRyYXRpY1Byb2plY3RQb2ludChcbiAgICAgICAgICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgICAgIHgsIHksIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gZCA8PSBfbCAvIDI7XG4gICAgICAgIH1cbiAgICB9O1xuIiwiXG5cbiAgICB2YXIgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbiAgICB2YXIgdGV4dFdpZHRoQ2FjaGVDb3VudGVyID0gMDtcbiAgICB2YXIgVEVYVF9DQUNIRV9NQVggPSA1MDAwO1xuXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcbiAgICB2YXIgcmV0cmlldmUgPSB1dGlsLnJldHJpZXZlO1xuXG4gICAgZnVuY3Rpb24gZ2V0VGV4dFdpZHRoKHRleHQsIHRleHRGb250KSB7XG4gICAgICAgIHZhciBrZXkgPSB0ZXh0ICsgJzonICsgdGV4dEZvbnQ7XG4gICAgICAgIGlmICh0ZXh0V2lkdGhDYWNoZVtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFdpZHRoQ2FjaGVba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0TGluZXMgPSAodGV4dCArICcnKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtZWFzdXJlVGV4dCDlj6/ku6Xooqvopobnm5bku6XlhbzlrrnkuI3mlK/mjIEgQ2FudmFzIOeahOeOr+Wig1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1heCh0ZXh0Q29udGFpbi5tZWFzdXJlVGV4dCh0ZXh0TGluZXNbaV0sIHRleHRGb250KS53aWR0aCwgd2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRXaWR0aENhY2hlQ291bnRlciA+IFRFWFRfQ0FDSEVfTUFYKSB7XG4gICAgICAgICAgICB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIrKztcbiAgICAgICAgdGV4dFdpZHRoQ2FjaGVba2V5XSA9IHdpZHRoO1xuXG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUZXh0UmVjdCh0ZXh0LCB0ZXh0Rm9udCwgdGV4dEFsaWduLCB0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgdmFyIHRleHRMaW5lTGVuID0gKCh0ZXh0IHx8ICcnKSArICcnKS5zcGxpdCgnXFxuJykubGVuZ3RoO1xuXG4gICAgICAgIHZhciB3aWR0aCA9IGdldFRleHRXaWR0aCh0ZXh0LCB0ZXh0Rm9udCk7XG4gICAgICAgIC8vIEZJWE1FIOmrmOW6puiuoeeul+avlOi+g+eyl+aatFxuICAgICAgICB2YXIgbGluZUhlaWdodCA9IGdldFRleHRXaWR0aCgn5Zu9JywgdGV4dEZvbnQpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGV4dExpbmVMZW4gKiBsaW5lSGVpZ2h0O1xuXG4gICAgICAgIHZhciByZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgLy8gVGV4dCBoYXMgYSBzcGVjaWFsIGxpbmUgaGVpZ2h0IHByb3BlcnR5XG4gICAgICAgIHJlY3QubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBjYXNlICdhbHBoYWJldGljJzpcbiAgICAgICAgICAgICAgICByZWN0LnkgLT0gbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgcmVjdC55IC09IGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gY2FzZSAnaGFuZ2luZyc6XG4gICAgICAgICAgICAvLyBjYXNlICd0b3AnOlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRklYTUUgUmlnaHQgdG8gbGVmdCBsYW5ndWFnZVxuICAgICAgICBzd2l0Y2ggKHRleHRBbGlnbikge1xuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICByZWN0LnggLT0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgcmVjdC54IC09IHJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgLy8gY2FzZSAnbGVmdCc6XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3QodGV4dFBvc2l0aW9uLCByZWN0LCB0ZXh0UmVjdCwgZGlzdGFuY2UpIHtcblxuICAgICAgICB2YXIgeCA9IHJlY3QueDtcbiAgICAgICAgdmFyIHkgPSByZWN0Lnk7XG5cbiAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuXG4gICAgICAgIHZhciB0ZXh0SGVpZ2h0ID0gdGV4dFJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMiAtIHRleHRIZWlnaHQgLyAyO1xuXG4gICAgICAgIHZhciB0ZXh0QWxpZ24gPSAnbGVmdCc7XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHggLT0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZSArIHdpZHRoO1xuICAgICAgICAgICAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgLT0gZGlzdGFuY2UgKyB0ZXh0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCArIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVMZWZ0JzpcbiAgICAgICAgICAgICAgICB4ICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVSaWdodCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlVG9wJzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlQm90dG9tJzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCAtIHRleHRIZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcExlZnQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVUb3BSaWdodCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZUJvdHRvbUxlZnQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoZWlnaHQgLSB0ZXh0SGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b21SaWdodCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gdGV4dEhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCdcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IGVsbGlwc2lzIGlmIG92ZXJmbG93LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb250YWluZXJXaWR0aFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dEZvbnRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtlbGxpcHNpcz0nLi4uJ11cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMubWF4SXRlcmF0aW9ucz0zXVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMubWluQ2hhcj0wXSBJZiB0cnVuY2F0ZSByZXN1bHQgYXJlIGxlc3NcbiAgICAgKiAgICAgICAgICAgICAgICAgIHRoZW4gbWluQ2hhciwgZWxsaXBzaXMgd2lsbCBub3Qgc2hvdywgd2hpY2ggaXNcbiAgICAgKiAgICAgICAgICAgICAgICAgIGJldHRlciBmb3IgdXNlciBoaW50IGluIHNvbWUgY2FzZXMuXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5wbGFjZWhvbGRlcj0nJ10gV2hlbiBhbGwgdHJ1bmNhdGVkLCB1c2UgdGhlIHBsYWNlaG9sZGVyLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZVRleHQodGV4dCwgY29udGFpbmVyV2lkdGgsIHRleHRGb250LCBlbGxpcHNpcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIWNvbnRhaW5lcldpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBlbGxpcHNpcyA9IHJldHJpZXZlKGVsbGlwc2lzLCAnLi4uJyk7XG4gICAgICAgIHZhciBtYXhJdGVyYXRpb25zID0gcmV0cmlldmUob3B0aW9ucy5tYXhJdGVyYXRpb25zLCAyKTtcbiAgICAgICAgdmFyIG1pbkNoYXIgPSByZXRyaWV2ZShvcHRpb25zLm1pbkNoYXIsIDApO1xuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBPdGhlciBsYW5ndWFnZXM/XG4gICAgICAgIHZhciBjbkNoYXJXaWR0aCA9IGdldFRleHRXaWR0aCgn5Zu9JywgdGV4dEZvbnQpO1xuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBDb25zaWRlciBwcm9wb3J0aW9uYWwgZm9udD9cbiAgICAgICAgdmFyIGFzY0NoYXJXaWR0aCA9IGdldFRleHRXaWR0aCgnYScsIHRleHRGb250KTtcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gcmV0cmlldmUob3B0aW9ucy5wbGFjZWhvbGRlciwgJycpO1xuXG4gICAgICAgIC8vIEV4YW1wbGUgMTogbWluQ2hhcjogMywgdGV4dDogJ2FzZGZ6eGN2JywgdHJ1bmNhdGUgcmVzdWx0OiAnYXNkZicsIGJ1dCBub3Q6ICdhLi4uJy5cbiAgICAgICAgLy8gRXhhbXBsZSAyOiBtaW5DaGFyOiAzLCB0ZXh0OiAn57u05bqmJywgdHJ1bmNhdGUgcmVzdWx0OiAn57u0JywgYnV0IG5vdDogJy4uLicuXG4gICAgICAgIHZhciBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCA9IE1hdGgubWF4KDAsIGNvbnRhaW5lcldpZHRoIC0gMSk7IC8vIFJlc2VydmUgc29tZSBnYXAuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluQ2hhciAmJiBjb250ZW50V2lkdGggPj0gYXNjQ2hhcldpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRlbnRXaWR0aCAtPSBhc2NDaGFyV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxsaXBzaXNXaWR0aCA9IGdldFRleHRXaWR0aChlbGxpcHNpcyk7XG4gICAgICAgIGlmIChlbGxpcHNpc1dpZHRoID4gY29udGVudFdpZHRoKSB7XG4gICAgICAgICAgICBlbGxpcHNpcyA9ICcnO1xuICAgICAgICAgICAgZWxsaXBzaXNXaWR0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCAtIGVsbGlwc2lzV2lkdGg7XG5cbiAgICAgICAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGV4dExpbmUgPSB0ZXh0TGluZXNbaV07XG4gICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gZ2V0VGV4dFdpZHRoKHRleHRMaW5lLCB0ZXh0Rm9udCk7XG5cbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPD0gY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7OyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZVdpZHRoIDw9IGNvbnRlbnRXaWR0aCB8fCBqID49IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dExpbmUgKz0gZWxsaXBzaXM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzdWJMZW5ndGggPSBqID09PSAwXG4gICAgICAgICAgICAgICAgICAgID8gZXN0aW1hdGVMZW5ndGgodGV4dExpbmUsIGNvbnRlbnRXaWR0aCwgYXNjQ2hhcldpZHRoLCBjbkNoYXJXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgOiBsaW5lV2lkdGggPiAwXG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5mbG9vcih0ZXh0TGluZS5sZW5ndGggKiBjb250ZW50V2lkdGggLyBsaW5lV2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIDogMDtcblxuICAgICAgICAgICAgICAgIHRleHRMaW5lID0gdGV4dExpbmUuc3Vic3RyKDAsIHN1Ykxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGluZVdpZHRoID0gZ2V0VGV4dFdpZHRoKHRleHRMaW5lLCB0ZXh0Rm9udCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0ZXh0TGluZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICB0ZXh0TGluZSA9IHBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0TGluZXNbaV0gPSB0ZXh0TGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0TGluZXMuam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXN0aW1hdGVMZW5ndGgodGV4dCwgY29udGVudFdpZHRoLCBhc2NDaGFyV2lkdGgsIGNuQ2hhcldpZHRoKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgZm9yICh2YXIgbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBsZW4gJiYgd2lkdGggPCBjb250ZW50V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgd2lkdGggKz0gKDAgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMTI3KSA/IGFzY0NoYXJXaWR0aCA6IGNuQ2hhcldpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIHZhciB0ZXh0Q29udGFpbiA9IHtcblxuICAgICAgICBnZXRXaWR0aDogZ2V0VGV4dFdpZHRoLFxuXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZ2V0VGV4dFJlY3QsXG5cbiAgICAgICAgYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0OiBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3QsXG5cbiAgICAgICAgdHJ1bmNhdGVUZXh0OiB0cnVuY2F0ZVRleHQsXG5cbiAgICAgICAgbWVhc3VyZVRleHQ6IGZ1bmN0aW9uICh0ZXh0LCB0ZXh0Rm9udCkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHV0aWwuZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSB0ZXh0Rm9udCB8fCAnMTJweCBzYW5zLXNlcmlmJztcbiAgICAgICAgICAgIHJldHVybiBjdHgubWVhc3VyZVRleHQodGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0ZXh0Q29udGFpbjtcbiIsIlxuXG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBub3JtYWxpemVSYWRpYW46IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgICAgICBhbmdsZSAlPSBQSTI7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgYW5nbGUgKz0gUEkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgICAgICB9XG4gICAgfTtcbiIsIlxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2luZGluZ0xpbmUoeDAsIHkwLCB4MSwgeTEsIHgsIHkpIHtcbiAgICAgICAgaWYgKCh5ID4geTAgJiYgeSA+IHkxKSB8fCAoeSA8IHkwICYmIHkgPCB5MSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSBob3Jpem9udGFsIGxpbmVcbiAgICAgICAgaWYgKHkxID09PSB5MCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpciA9IHkxIDwgeTAgPyAxIDogLTE7XG4gICAgICAgIHZhciB0ID0gKHkgLSB5MCkgLyAoeTEgLSB5MCk7XG5cbiAgICAgICAgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG4gICAgICAgIGlmICh0ID09PSAxIHx8IHQgPT09IDApIHtcbiAgICAgICAgICAgIGRpciA9IHkxIDwgeTAgPyAwLjUgOiAtMC41O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhfID0gdCAqICh4MSAtIHgwKSArIHgwO1xuXG4gICAgICAgIHJldHVybiB4XyA+IHggPyBkaXIgOiAwO1xuICAgIH07XG4iLCIvKipcbiAqIEdyb3Vw5piv5LiA5Liq5a655Zmo77yM5Y+v5Lul5o+S5YWl5a2Q6IqC54K577yMR3JvdXDnmoTlj5jmjaLkuZ/kvJrooqvlupTnlKjliLDlrZDoioLngrnkuIpcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0dyb3VwXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xuICogICAgIHZhciBDaXJjbGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xuICogICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gKiAgICAgZy5wb3NpdGlvblswXSA9IDEwMDtcbiAqICAgICBnLnBvc2l0aW9uWzFdID0gMTAwO1xuICogICAgIGcuYWRkKG5ldyBDaXJjbGUoe1xuICogICAgICAgICBzdHlsZToge1xuICogICAgICAgICAgICAgeDogMTAwLFxuICogICAgICAgICAgICAgeTogMTAwLFxuICogICAgICAgICAgICAgcjogMjAsXG4gKiAgICAgICAgIH1cbiAqICAgICB9KSk7XG4gKiAgICAgenIuYWRkKGcpO1xuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4uL0VsZW1lbnQnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gICAgICovXG4gICAgdmFyIEdyb3VwID0gZnVuY3Rpb24gKG9wdHMpIHtcblxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBFbGVtZW50LmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgIHRoaXMuX19zdG9yYWdlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgIH07XG5cbiAgICBHcm91cC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEdyb3VwLFxuXG4gICAgICAgIGlzR3JvdXA6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnZ3JvdXAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiYDmnInlrZDlrZnlhYPntKDmmK/lkKblk43lupTpvKDmoIfkuovku7ZcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2NvbnRhaW5lci9Hcm91cCNzaWxlbnRcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaWxlbnQ6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvRWxlbWVudD59XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluaMh+WumiBpbmRleCDnmoTlhL/lrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBpZHhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkQXQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltpZHhdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmjIflrprlkI3lrZfnmoTlhL/lrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZE9mTmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlrZDoioLngrnliLDmnIDlkI5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5a2Q6IqC54K55ZyoIG5leHRTaWJsaW5nIOS5i+WJjVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gbmV4dFNpYmxpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFkZEJlZm9yZTogZnVuY3Rpb24gKGNoaWxkLCBuZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpc1xuICAgICAgICAgICAgICAgICYmIG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLnBhcmVudCA9PT0gdGhpcykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGNoaWxkcmVuLmluZGV4T2YobmV4dFNpYmxpbmcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDAsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvQWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlICYmIHN0b3JhZ2UgIT09IGNoaWxkLl9fc3RvcmFnZSkge1xuXG4gICAgICAgICAgICAgICAgc3RvcmFnZS5hZGRUb01hcChjaGlsZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5hZGRDaGlsZHJlblRvU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHpyICYmIHpyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog56e76Zmk5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgICAgICAgIHZhciBpZHggPSB6clV0aWwuaW5kZXhPZihjaGlsZHJlbiwgY2hpbGQpO1xuICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xuXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoc3RvcmFnZSkge1xuXG4gICAgICAgICAgICAgICAgc3RvcmFnZS5kZWxGcm9tTWFwKGNoaWxkLmlkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnp7vpmaTmiYDmnInlrZDoioLngrlcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UuZGVsRnJvbU1hcChjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6YGN5Y6G5omA5pyJ5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaENoaWxkOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3seW6puS8mOWFiOmBjeWOhuaJgOacieWtkOWtmeiKgueCuVxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRDaGlsZHJlblRvU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLmFkZFRvTWFwKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5hZGRDaGlsZHJlblRvU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLmRlbEZyb21NYXAoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uIChpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIC8vIFRPRE8gQ2FjaGluZ1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gaW5jbHVkZUNoaWxkcmVuIHx8IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgdmFyIHRtcE1hdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlnbm9yZSB8fCBjaGlsZC5pbnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkUmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBjaGlsZC5nZXRMb2NhbFRyYW5zZm9ybSh0bXBNYXQpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgICAgICAvLyBUaGUgYm91bmRpbmdSZWN0IGNhY2x1YXRlZCBieSB0cmFuc2Zvcm1pbmcgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAvLyByZWN0IG1heSBiZSBiaWdnZXIgdGhhbiB0aGUgYWN0dWFsIGJ1bmRpbmdSZWN0IHdoZW4gcm90YXRpb25cbiAgICAgICAgICAgICAgICAvLyBpcyB1c2VkLiAoQ29uc2lkZXIgYSBjaXJjbGUgcm90YXRlZCBhZ2luc3QgaXRzIGNlbnRlciwgd2hlcmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgYWN0dWFsIGJvdW5kaW5nUmVjdCBzaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhhdCBub3QgYmVcbiAgICAgICAgICAgICAgICAvLyByb3RhdGVkLikgQnV0IHdlIGNhbiBub3QgZmluZCBiZXR0ZXIgYXBwcm9hY2ggdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsIGJvdW5kaW5nUmVjdCB5ZXQsIGNvbnNpZGVyaW5nIHBlcmZvcm1hbmNlLlxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wUmVjdC5jb3B5KGNoaWxkUmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QgfHwgdG1wUmVjdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICByZWN0LnVuaW9uKHRtcFJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QgfHwgY2hpbGRSZWN0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QudW5pb24oY2hpbGRSZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjdCB8fCB0bXBSZWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhHcm91cCwgRWxlbWVudCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdyb3VwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAqL1xuXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJy4vbWF0cml4Jyk7XG5cbiAgICB2YXIgdjJBcHBseVRyYW5zZm9ybSA9IHZlYzIuYXBwbHlUcmFuc2Zvcm07XG4gICAgdmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJvdW5kaW5nUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgICAgeCA9IHggKyB3aWR0aDtcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICB5ID0geSArIGhlaWdodDtcbiAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuXG4gICAgQm91bmRpbmdSZWN0LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQm91bmRpbmdSZWN0LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fSBvdGhlclxuICAgICAgICAgKi9cbiAgICAgICAgdW5pb246IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgdmFyIHggPSBtYXRoTWluKG90aGVyLngsIHRoaXMueCk7XG4gICAgICAgICAgICB2YXIgeSA9IG1hdGhNaW4ob3RoZXIueSwgdGhpcy55KTtcblxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLnggKyBvdGhlci53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ICsgdGhpcy53aWR0aFxuICAgICAgICAgICAgICAgICkgLSB4O1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBtYXRoTWF4KFxuICAgICAgICAgICAgICAgICAgICBvdGhlci55ICsgb3RoZXIuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgKyB0aGlzLmhlaWdodFxuICAgICAgICAgICAgICAgICkgLSB5O1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1cbiAgICAgICAgICogQG1ldGhvZHNcbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5VHJhbnNmb3JtOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGx0ID0gW107XG4gICAgICAgICAgICB2YXIgcmIgPSBbXTtcbiAgICAgICAgICAgIHZhciBsYiA9IFtdO1xuICAgICAgICAgICAgdmFyIHJ0ID0gW107XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHVzYWdlIGxpa2UgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGVsLmdldEJvdW5kaW5nUmVjdCgpLmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICAvLyBBbmQgZWxlbWVudCBoYXMgbm8gdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbHRbMF0gPSBsYlswXSA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICBsdFsxXSA9IHJ0WzFdID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIHJiWzBdID0gcnRbMF0gPSB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgICAgICAgICAgICAgIHJiWzFdID0gbGJbMV0gPSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblxuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0obHQsIGx0LCBtKTtcbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHJiLCByYiwgbSk7XG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShsYiwgbGIsIG0pO1xuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocnQsIHJ0LCBtKTtcblxuICAgICAgICAgICAgICAgIHRoaXMueCA9IG1hdGhNaW4obHRbMF0sIHJiWzBdLCBsYlswXSwgcnRbMF0pO1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IG1hdGhNaW4obHRbMV0sIHJiWzFdLCBsYlsxXSwgcnRbMV0pO1xuICAgICAgICAgICAgICAgIHZhciBtYXhYID0gbWF0aE1heChsdFswXSwgcmJbMF0sIGxiWzBdLCBydFswXSk7XG4gICAgICAgICAgICAgICAgdmFyIG1heFkgPSBtYXRoTWF4KGx0WzFdLCByYlsxXSwgbGJbMV0sIHJ0WzFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gbWF4WCAtIHRoaXMueDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IG1heFkgLSB0aGlzLnk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGUgbWF0cml4IG9mIHRyYW5zZm9ybWluZyBmcm9tIHNlbGYgdG8gdGFyZ2V0IHJlY3RcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IGJcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBjYWxjdWxhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc3ggPSBiLndpZHRoIC8gYS53aWR0aDtcbiAgICAgICAgICAgIHZhciBzeSA9IGIuaGVpZ2h0IC8gYS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBtID0gbWF0cml4LmNyZWF0ZSgpO1xuXG4gICAgICAgICAgICAvLyDnn6npmLXlj7PkuZhcbiAgICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGUobSwgbSwgWy1hLngsIC1hLnldKTtcbiAgICAgICAgICAgIG1hdHJpeC5zY2FsZShtLCBtLCBbc3gsIHN5XSk7XG4gICAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFtiLngsIGIueV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHsobW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R8T2JqZWN0KX0gYlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShiIGluc3RhbmNlb2YgQm91bmRpbmdSZWN0KSkge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBuZWdhdGl2ZSB3aWR0aC9oZWlnaHQuXG4gICAgICAgICAgICAgICAgYiA9IEJvdW5kaW5nUmVjdC5jcmVhdGUoYik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgICAgIHZhciBheDAgPSBhLng7XG4gICAgICAgICAgICB2YXIgYXgxID0gYS54ICsgYS53aWR0aDtcbiAgICAgICAgICAgIHZhciBheTAgPSBhLnk7XG4gICAgICAgICAgICB2YXIgYXkxID0gYS55ICsgYS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBieDAgPSBiLng7XG4gICAgICAgICAgICB2YXIgYngxID0gYi54ICsgYi53aWR0aDtcbiAgICAgICAgICAgIHZhciBieTAgPSBiLnk7XG4gICAgICAgICAgICB2YXIgYnkxID0gYi55ICsgYi5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHJldHVybiAhIChheDEgPCBieDAgfHwgYngxIDwgYXgwIHx8IGF5MSA8IGJ5MCB8fCBieTEgPCBheTApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4geCA+PSByZWN0LnhcbiAgICAgICAgICAgICAgICAmJiB4IDw9IChyZWN0LnggKyByZWN0LndpZHRoKVxuICAgICAgICAgICAgICAgICYmIHkgPj0gcmVjdC55XG4gICAgICAgICAgICAgICAgJiYgeSA8PSAocmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3B5IGZyb20gYW5vdGhlciByZWN0XG4gICAgICAgICAqL1xuICAgICAgICBjb3B5OiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IG90aGVyLng7XG4gICAgICAgICAgICB0aGlzLnkgPSBvdGhlci55O1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IG90aGVyLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBvdGhlci5oZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGxhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy54LFxuICAgICAgICAgICAgICAgIHk6IHRoaXMueSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG1vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlY3QueFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVjdC53aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LmhlaWdodFxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAqL1xuICAgIEJvdW5kaW5nUmVjdC5jcmVhdGUgPSBmdW5jdGlvbiAocmVjdCkge1xuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJvdW5kaW5nUmVjdDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogT25seSBpbXBsZW1lbnRzIG5lZWRlZCBnZXN0dXJlcyBmb3IgbW9iaWxlLlxuICovXG5cblxuICAgIHZhciBldmVudFV0aWwgPSByZXF1aXJlKCcuL2V2ZW50Jyk7XG5cbiAgICB2YXIgR2VzdHVyZU1nciA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJhY2sgPSBbXTtcbiAgICB9O1xuXG4gICAgR2VzdHVyZU1nci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEdlc3R1cmVNZ3IsXG5cbiAgICAgICAgcmVjb2duaXplOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgICAgICAgICAgdGhpcy5fZG9UcmFjayhldmVudCwgdGFyZ2V0LCByb290KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWNvZ25pemUoZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFjay5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvVHJhY2s6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0LCByb290KSB7XG4gICAgICAgICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XG5cbiAgICAgICAgICAgIGlmICghdG91Y2hlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRyYWNrSXRlbSA9IHtcbiAgICAgICAgICAgICAgICBwb2ludHM6IFtdLFxuICAgICAgICAgICAgICAgIHRvdWNoZXM6IFtdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRvdWNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBldmVudFV0aWwuY2xpZW50VG9Mb2NhbChyb290LCB0b3VjaCwge30pO1xuICAgICAgICAgICAgICAgIHRyYWNrSXRlbS5wb2ludHMucHVzaChbcG9zLnpyWCwgcG9zLnpyWV0pO1xuICAgICAgICAgICAgICAgIHRyYWNrSXRlbS50b3VjaGVzLnB1c2godG91Y2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90cmFjay5wdXNoKHRyYWNrSXRlbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcmVjb2duaXplcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb2duaXplcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2VzdHVyZUluZm8gPSByZWNvZ25pemVyc1tldmVudE5hbWVdKHRoaXMuX3RyYWNrLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlc3R1cmVJbmZvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRpc3QocG9pbnRQYWlyKSB7XG4gICAgICAgIHZhciBkeCA9IHBvaW50UGFpclsxXVswXSAtIHBvaW50UGFpclswXVswXTtcbiAgICAgICAgdmFyIGR5ID0gcG9pbnRQYWlyWzFdWzFdIC0gcG9pbnRQYWlyWzBdWzFdO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNlbnRlcihwb2ludFBhaXIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIChwb2ludFBhaXJbMF1bMF0gKyBwb2ludFBhaXJbMV1bMF0pIC8gMixcbiAgICAgICAgICAgIChwb2ludFBhaXJbMF1bMV0gKyBwb2ludFBhaXJbMV1bMV0pIC8gMlxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHZhciByZWNvZ25pemVycyA9IHtcblxuICAgICAgICBwaW5jaDogZnVuY3Rpb24gKHRyYWNrLCBldmVudCkge1xuICAgICAgICAgICAgdmFyIHRyYWNrTGVuID0gdHJhY2subGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoIXRyYWNrTGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGluY2hFbmQgPSAodHJhY2tbdHJhY2tMZW4gLSAxXSB8fCB7fSkucG9pbnRzO1xuICAgICAgICAgICAgdmFyIHBpbmNoUHJlID0gKHRyYWNrW3RyYWNrTGVuIC0gMl0gfHwge30pLnBvaW50cyB8fCBwaW5jaEVuZDtcblxuICAgICAgICAgICAgaWYgKHBpbmNoUHJlXG4gICAgICAgICAgICAgICAgJiYgcGluY2hQcmUubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICYmIHBpbmNoRW5kXG4gICAgICAgICAgICAgICAgJiYgcGluY2hFbmQubGVuZ3RoID4gMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBpbmNoU2NhbGUgPSBkaXN0KHBpbmNoRW5kKSAvIGRpc3QocGluY2hQcmUpO1xuICAgICAgICAgICAgICAgICFpc0Zpbml0ZShwaW5jaFNjYWxlKSAmJiAocGluY2hTY2FsZSA9IDEpO1xuXG4gICAgICAgICAgICAgICAgZXZlbnQucGluY2hTY2FsZSA9IHBpbmNoU2NhbGU7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGluY2hDZW50ZXIgPSBjZW50ZXIocGluY2hFbmQpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnBpbmNoWCA9IHBpbmNoQ2VudGVyWzBdO1xuICAgICAgICAgICAgICAgIGV2ZW50LnBpbmNoWSA9IHBpbmNoQ2VudGVyWzFdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BpbmNoJyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0cmFja1swXS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IHBpbmNoIGN1cnJlbnRseS5cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHZXN0dXJlTWdyO1xuXG4iLCIvLyBTaW1wbGUgTFJVIGNhY2hlIHVzZSBkb3VibHkgbGlua2VkIGxpc3Rcbi8vIEBtb2R1bGUgenJlbmRlci9jb3JlL0xSVVxuXG5cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgZG91YmxlIGxpbmtlZCBsaXN0LiBDb21wYXJlZCB3aXRoIGFycmF5LCBpdCBoYXMgTygxKSByZW1vdmUgb3BlcmF0aW9uLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICB9O1xuXG4gICAgdmFyIGxpbmtlZExpc3RQcm90byA9IExpbmtlZExpc3QucHJvdG90eXBlO1xuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5ldyB2YWx1ZSBhdCB0aGUgdGFpbFxuICAgICAqIEBwYXJhbSAge30gdmFsXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmluc2VydCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB2YXIgZW50cnkgPSBuZXcgRW50cnkodmFsKTtcbiAgICAgICAgdGhpcy5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGFuIGVudHJ5IGF0IHRoZSB0YWlsXG4gICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9IGVudHJ5XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmluc2VydEVudHJ5ID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5LnByZXYgPSB0aGlzLnRhaWw7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZW4rKztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGVudHJ5LlxuICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fSBlbnRyeVxuICAgICAqL1xuICAgIGxpbmtlZExpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnByZXY7XG4gICAgICAgIHZhciBuZXh0ID0gZW50cnkubmV4dDtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJcyBoZWFkXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSXMgdGFpbFxuICAgICAgICAgICAgdGhpcy50YWlsID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5uZXh0ID0gZW50cnkucHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xlbi0tO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmxlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVuO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge30gdmFsXG4gICAgICovXG4gICAgdmFyIEVudHJ5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExSVSBDYWNoZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9jb3JlL0xSVVxuICAgICAqL1xuICAgIHZhciBMUlUgPSBmdW5jdGlvbihtYXhTaXplKSB7XG5cbiAgICAgICAgdGhpcy5fbGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG5cbiAgICAgICAgdGhpcy5fbWFwID0ge307XG5cbiAgICAgICAgdGhpcy5fbWF4U2l6ZSA9IG1heFNpemUgfHwgMTA7XG4gICAgfTtcblxuICAgIHZhciBMUlVQcm90byA9IExSVS5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSAge30gdmFsdWVcbiAgICAgKi9cbiAgICBMUlVQcm90by5wdXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgaWYgKG1hcFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBsaXN0LmxlbigpO1xuICAgICAgICAgICAgaWYgKGxlbiA+PSB0aGlzLl9tYXhTaXplICYmIGxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWRcbiAgICAgICAgICAgICAgICB2YXIgbGVhc3RVc2VkRW50cnkgPSBsaXN0LmhlYWQ7XG4gICAgICAgICAgICAgICAgbGlzdC5yZW1vdmUobGVhc3RVc2VkRW50cnkpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXBbbGVhc3RVc2VkRW50cnkua2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbGlzdC5pbnNlcnQodmFsdWUpO1xuICAgICAgICAgICAgZW50cnkua2V5ID0ga2V5O1xuICAgICAgICAgICAgbWFwW2tleV0gPSBlbnRyeTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm4ge31cbiAgICAgKi9cbiAgICBMUlVQcm90by5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fbWFwW2tleV07XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFB1dCB0aGUgbGF0ZXN0IHVzZWQgZW50cnkgaW4gdGhlIHRhaWxcbiAgICAgICAgICAgIGlmIChlbnRyeSAhPT0gbGlzdC50YWlsKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5yZW1vdmUoZW50cnkpO1xuICAgICAgICAgICAgICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGNhY2hlXG4gICAgICovXG4gICAgTFJVUHJvdG8uY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbGlzdC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9tYXAgPSB7fTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMUlU7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIFBhdGgg5Luj55CG77yM5Y+v5Lul5ZyoYGJ1aWxkUGF0aGDkuK3nlKjkuo7mm7/ku6NgY3R4YCwg5Lya5L+d5a2Y5q+P5LiqcGF0aOaTjeS9nOeahOWRveS7pOWIsHBhdGhDb21tYW5kc+WxnuaAp+S4rVxuICog5Y+v5Lul55So5LqOIGlzSW5zaWRlUGF0aCDliKTmlq3ku6Xlj4rojrflj5Zib3VuZGluZ1JlY3RcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBhdXRob3IgWWkgU2hlbiAoaHR0cDovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuIC8vIFRPRE8gZ2V0VG90YWxMZW5ndGgsIGdldFBvaW50QXRMZW5ndGhcblxuXG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpO1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcbiAgICB2YXIgYmJveCA9IHJlcXVpcmUoJy4vYmJveCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciBkcHIgPSByZXF1aXJlKCcuLi9jb25maWcnKS5kZXZpY2VQaXhlbFJhdGlvO1xuXG4gICAgdmFyIENNRCA9IHtcbiAgICAgICAgTTogMSxcbiAgICAgICAgTDogMixcbiAgICAgICAgQzogMyxcbiAgICAgICAgUTogNCxcbiAgICAgICAgQTogNSxcbiAgICAgICAgWjogNixcbiAgICAgICAgLy8gUmVjdFxuICAgICAgICBSOiA3XG4gICAgfTtcblxuICAgIHZhciBtaW4gPSBbXTtcbiAgICB2YXIgbWF4ID0gW107XG4gICAgdmFyIG1pbjIgPSBbXTtcbiAgICB2YXIgbWF4MiA9IFtdO1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuICAgIHZhciBtYXRoU2luID0gTWF0aC5zaW47XG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICB2YXIgaGFzVHlwZWRBcnJheSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgUGF0aFByb3h5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXRoIGRhdGEuIFN0b3JlZCBhcyBmbGF0IGFycmF5XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2xlbiA9IDA7XG5cbiAgICAgICAgdGhpcy5fY3R4ID0gbnVsbDtcblxuICAgICAgICB0aGlzLl94aSA9IDA7XG4gICAgICAgIHRoaXMuX3lpID0gMDtcblxuICAgICAgICB0aGlzLl94MCA9IDA7XG4gICAgICAgIHRoaXMuX3kwID0gMDtcblxuICAgICAgICAvLyBVbml0IHgsIFVuaXQgeS4gUHJvdmlkZSBmb3IgYXZvaWRpbmcgZHJhd2luZyB0aGF0IHRvbyBzaG9ydCBsaW5lIHNlZ21lbnRcbiAgICAgICAgdGhpcy5fdXggPSAwO1xuICAgICAgICB0aGlzLl91eSA9IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOW/q+mAn+iuoeeul1BhdGjljIXlm7Tnm5LvvIjlubbkuI3mmK/mnIDlsI/ljIXlm7Tnm5LvvIlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgUGF0aFByb3h5LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUGF0aFByb3h5LFxuXG4gICAgICAgIF9saW5lRGFzaDogbnVsbCxcblxuICAgICAgICBfZGFzaE9mZnNldDogMCxcblxuICAgICAgICBfZGFzaElkeDogMCxcblxuICAgICAgICBfZGFzaFN1bTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBzZXRTY2FsZTogZnVuY3Rpb24gKHN4LCBzeSkge1xuICAgICAgICAgICAgdGhpcy5fdXggPSBtYXRoQWJzKDEgLyBkcHIgLyBzeCkgfHwgMDtcbiAgICAgICAgICAgIHRoaXMuX3V5ID0gbWF0aEFicygxIC8gZHByIC8gc3kpIHx8IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N0eDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBiZWdpblBhdGg6IGZ1bmN0aW9uIChjdHgpIHtcblxuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuXG4gICAgICAgICAgICBjdHggJiYgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICBjdHggJiYgKHRoaXMuZHByID0gY3R4LmRwcik7XG5cbiAgICAgICAgICAgIC8vIFJlc2V0XG4gICAgICAgICAgICB0aGlzLl9sZW4gPSAwO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lRGFzaCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELk0sIHgsIHkpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5tb3ZlVG8oeCwgeSk7XG5cbiAgICAgICAgICAgIC8vIHgwLCB5MCwgeGksIHlpIOaYr+iusOW9leWcqCBfZGFzaGVkWFhYWFRvIOaWueazleS4reS9v+eUqFxuICAgICAgICAgICAgLy8geGksIHlpIOiusOW9leW9k+WJjeeCuSwgeDAsIHkwIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5Zue5Yiw6LW35aeL54K544CCXG4gICAgICAgICAgICAvLyDmnInlj6/og73lnKggYmVnaW5QYXRoIOS5i+WQjuebtOaOpeiwg+eUqCBsaW5lVG/vvIzov5nml7blgJkgeDAsIHkwIOmcgOimgVxuICAgICAgICAgICAgLy8g5ZyoIGxpbmVUbyDmlrnms5XkuK3orrDlvZXvvIzov5nph4zlhYjkuI3ogIPomZHov5nnp43mg4XlhrXvvIxkYXNoZWQgbGluZSDkuZ/lj6rlnKggSUUxMC0g5Lit5LiN5pSv5oyBXG4gICAgICAgICAgICB0aGlzLl94MCA9IHg7XG4gICAgICAgICAgICB0aGlzLl95MCA9IHk7XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgZXhjZWVkVW5pdCA9IG1hdGhBYnMoeCAtIHRoaXMuX3hpKSA+IHRoaXMuX3V4XG4gICAgICAgICAgICAgICAgfHwgbWF0aEFicyh5IC0gdGhpcy5feWkpID4gdGhpcy5fdXlcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBkcmF3IHRoZSBmaXJzdCBzZWdtZW50XG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fbGVuIDwgNTtcblxuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5MLCB4LCB5KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCAmJiBleGNlZWRVbml0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNEYXNoKCkgPyB0aGlzLl9kYXNoZWRMaW5lVG8oeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4Y2VlZFVuaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94aSA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy5feWkgPSB5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5DLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZEJlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fY3R4LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl94aSA9IHgzO1xuICAgICAgICAgICAgdGhpcy5feWkgPSB5MztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlEsIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZFF1YWRyYXRpY1RvKHgxLCB5MSwgeDIsIHkyKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2N0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDI7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gY3hcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gZW5kQW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gYW50aWNsb2Nrd2lzZVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGFyYzogZnVuY3Rpb24gKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShcbiAgICAgICAgICAgICAgICBDTUQuQSwgY3gsIGN5LCByLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUsIDAsIGFudGljbG9ja3dpc2UgPyAwIDogMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHguYXJjKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpO1xuXG4gICAgICAgICAgICB0aGlzLl94aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogciArIGN4O1xuICAgICAgICAgICAgdGhpcy5feWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgYXJjVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4LmFyY1RvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgICAgICAgICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5SLCB4LCB5LCB3LCBoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlUGF0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5aKTtcblxuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX3gwO1xuICAgICAgICAgICAgdmFyIHkwID0gdGhpcy5feTA7XG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNEYXNoKCkgJiYgdGhpcy5fZGFzaGVkTGluZVRvKHgwLCB5MCk7XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl94aSA9IHgwO1xuICAgICAgICAgICAgdGhpcy5feWkgPSB5MDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250ZXh0IOS7juWklumDqOS8oOWFpe+8jOWboOS4uuacieWPr+iDveaYryByZWJ1aWxkUGF0aCDlrozkuYvlkI7lho0gZmlsbOOAglxuICAgICAgICAgKiBzdHJva2Ug5ZCM5qC3XG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBmaWxsOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBjdHggJiYgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIHN0cm9rZTogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgY3R4ICYmIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAgICAgICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TGluZURhc2g6IGZ1bmN0aW9uIChsaW5lRGFzaCkge1xuICAgICAgICAgICAgaWYgKGxpbmVEYXNoIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lRGFzaCA9IGxpbmVEYXNoO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaElkeCA9IDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGluZURhc2hTdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZURhc2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZURhc2hTdW0gKz0gbGluZURhc2hbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Rhc2hTdW0gPSBsaW5lRGFzaFN1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICAgICAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBzZXRMaW5lRGFzaE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgbGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnm7TmjqXorr7nva4gUGF0aCDmlbDmja5cbiAgICAgICAgICovXG4gICAgICAgIHNldERhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICAgICAgICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKCEgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEubGVuZ3RoID09IGxlbikgJiYgaGFzVHlwZWRBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IGRhdGFbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xlbiA9IGxlbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5a2Q6Lev5b6EXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl8QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5Pn0gcGF0aFxuICAgICAgICAgKi9cbiAgICAgICAgYXBwZW5kUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gW3BhdGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGFwcGVuZFNpemUgPSAwO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2xlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRTaXplICs9IHBhdGhbaV0ubGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzVHlwZWRBcnJheSAmJiAodGhpcy5kYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkob2Zmc2V0ICsgYXBwZW5kU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFwcGVuZFBhdGhEYXRhID0gcGF0aFtpXS5kYXRhO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYXBwZW5kUGF0aERhdGEubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhW29mZnNldCsrXSA9IGFwcGVuZFBhdGhEYXRhW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xlbiA9IG9mZnNldDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5aGr5YWFIFBhdGgg5pWw5o2u44CCXG4gICAgICAgICAqIOWwvemHj+WkjeeUqOiAjOS4jeeUs+aYjuaWsOeahOaVsOe7hOOAguWkp+mDqOWIhuWbvuW9oumHjee7mOeahOaMh+S7pOaVsOaNrumVv+W6pumDveaYr+S4jeWPmOeahOOAglxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRGF0YTogZnVuY3Rpb24gKGNtZCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGVuICsgYXJndW1lbnRzLmxlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8g5Zug5Li65LmL5YmN55qE5pWw57uE5bey57uP6L2s5o2i5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheVxuICAgICAgICAgICAgICAgIC8vIOaJgOS7peS4jeWkn+eUqOaXtumcgOimgeaJqeWxleS4gOS4quaWsOeahOWKqOaAgeaVsOe7hFxuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZERhdGEoKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkYXRhW3RoaXMuX2xlbisrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fcHJldkNtZCA9IGNtZDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZXhwYW5kRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gT25seSBpZiBkYXRhIGlzIEZsb2F0MzJBcnJheVxuICAgICAgICAgICAgaWYgKCEodGhpcy5kYXRhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG5lZWRzIGpzIGltcGxlbWVudGVkIGRhc2hlZCBsaW5lXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfbmVlZHNEYXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZURhc2g7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2Rhc2hlZExpbmVUbzogZnVuY3Rpb24gKHgxLCB5MSkge1xuICAgICAgICAgICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cbiAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgICAgICAgICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgICAgICAgICB2YXIgZHggPSB4MSAtIHgwO1xuICAgICAgICAgICAgdmFyIGR5ID0geTEgLSB5MDtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgdmFyIHggPSB4MDtcbiAgICAgICAgICAgIHZhciB5ID0geTA7XG4gICAgICAgICAgICB2YXIgZGFzaDtcbiAgICAgICAgICAgIHZhciBuRGFzaCA9IGxpbmVEYXNoLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpZHg7XG4gICAgICAgICAgICBkeCAvPSBkaXN0O1xuICAgICAgICAgICAgZHkgLz0gZGlzdDtcblxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHBvc2l0aXZlIG9mZnNldFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGRhc2hTdW0gKyBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgJT0gZGFzaFN1bTtcbiAgICAgICAgICAgIHggLT0gb2Zmc2V0ICogZHg7XG4gICAgICAgICAgICB5IC09IG9mZnNldCAqIGR5O1xuXG4gICAgICAgICAgICB3aGlsZSAoKGR4ID4gMCAmJiB4IDw9IHgxKSB8fCAoZHggPCAwICYmIHggPj0geDEpXG4gICAgICAgICAgICB8fCAoZHggPT0gMCAmJiAoKGR5ID4gMCAmJiB5IDw9IHkxKSB8fCAoZHkgPCAwICYmIHkgPj0geTEpKSkpIHtcbiAgICAgICAgICAgICAgICBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgICAgICAgICAgICAgIGRhc2ggPSBsaW5lRGFzaFtpZHhdO1xuICAgICAgICAgICAgICAgIHggKz0gZHggKiBkYXNoO1xuICAgICAgICAgICAgICAgIHkgKz0gZHkgKiBkYXNoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rhc2hJZHggPSAoaWR4ICsgMSkgJSBuRGFzaDtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHBvc2l0aXZlIG9mZnNldFxuICAgICAgICAgICAgICAgIGlmICgoZHggPiAwICYmIHggPCB4MCkgfHwgKGR4IDwgMCAmJiB4ID4geDApIHx8IChkeSA+IDAgJiYgeSA8IHkwKSB8fCAoZHkgPCAwICYmIHkgPiB5MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eFtpZHggJSAyID8gJ21vdmVUbycgOiAnbGluZVRvJ10oXG4gICAgICAgICAgICAgICAgICAgIGR4ID49IDAgPyBtYXRoTWluKHgsIHgxKSA6IG1hdGhNYXgoeCwgeDEpLFxuICAgICAgICAgICAgICAgICAgICBkeSA+PSAwID8gbWF0aE1pbih5LCB5MSkgOiBtYXRoTWF4KHksIHkxKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPZmZzZXQgZm9yIG5leHQgbGluZVRvXG4gICAgICAgICAgICBkeCA9IHggLSB4MTtcbiAgICAgICAgICAgIGR5ID0geSAtIHkxO1xuICAgICAgICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gTm90IGFjY3VyYXRlIGRhc2hlZCBsaW5lIHRvXG4gICAgICAgIF9kYXNoZWRCZXppZXJUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgICAgICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5fbGluZURhc2g7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gICAgICAgICAgICB2YXIgeDAgPSB0aGlzLl94aTtcbiAgICAgICAgICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICB2YXIgZHg7XG4gICAgICAgICAgICB2YXIgZHk7XG4gICAgICAgICAgICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gICAgICAgICAgICB2YXIgYmV6aWVyTGVuID0gMDtcbiAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgICAgICAgICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuXG4gICAgICAgICAgICB2YXIgeDtcbiAgICAgICAgICAgIHZhciB5O1xuXG4gICAgICAgICAgICB2YXIgdG1wTGVuID0gMDtcblxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHBvc2l0aXZlIG9mZnNldFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGRhc2hTdW0gKyBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgJT0gZGFzaFN1bTtcbiAgICAgICAgICAgIC8vIEJlemllciBhcHByb3ggbGVuZ3RoXG4gICAgICAgICAgICBmb3IgKHQgPSAwOyB0IDwgMTsgdCArPSAwLjEpIHtcbiAgICAgICAgICAgICAgICBkeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQgKyAwLjEpXG4gICAgICAgICAgICAgICAgICAgIC0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICAgICAgZHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0ICsgMC4xKVxuICAgICAgICAgICAgICAgICAgICAtIGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuICAgICAgICAgICAgICAgIGJlemllckxlbiArPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbmQgaWR4IGFmdGVyIGFkZCBvZmZzZXRcbiAgICAgICAgICAgIGZvciAoOyBpZHggPCBuRGFzaDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICB0bXBMZW4gKz0gbGluZURhc2hbaWR4XTtcbiAgICAgICAgICAgICAgICBpZiAodG1wTGVuID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSAodG1wTGVuIC0gb2Zmc2V0KSAvIGJlemllckxlbjtcblxuICAgICAgICAgICAgd2hpbGUgKHQgPD0gMSkge1xuXG4gICAgICAgICAgICAgICAgeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgICAgICAgICAgIHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSBsaW5lIHRvIGFwcHJveGltYXRlIGRhc2hlZCBiZXppZXJcbiAgICAgICAgICAgICAgICAvLyBCYWQgcmVzdWx0IGlmIGRhc2ggaXMgbG9uZ1xuICAgICAgICAgICAgICAgIGlkeCAlIDIgPyBjdHgubW92ZVRvKHgsIHkpXG4gICAgICAgICAgICAgICAgICAgIDogY3R4LmxpbmVUbyh4LCB5KTtcblxuICAgICAgICAgICAgICAgIHQgKz0gbGluZURhc2hbaWR4XSAvIGJlemllckxlbjtcblxuICAgICAgICAgICAgICAgIGlkeCA9IChpZHggKyAxKSAlIG5EYXNoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5pc2ggdGhlIGxhc3Qgc2VnbWVudCBhbmQgY2FsY3VsYXRlIHRoZSBuZXcgb2Zmc2V0XG4gICAgICAgICAgICAoaWR4ICUgMiAhPT0gMCkgJiYgY3R4LmxpbmVUbyh4MywgeTMpO1xuICAgICAgICAgICAgZHggPSB4MyAtIHg7XG4gICAgICAgICAgICBkeSA9IHkzIC0geTtcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kYXNoZWRRdWFkcmF0aWNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHF1YWRyYXRpYyB0byBjdWJpYyB1c2luZyBkZWdyZWUgZWxldmF0aW9uXG4gICAgICAgICAgICB2YXIgeDMgPSB4MjtcbiAgICAgICAgICAgIHZhciB5MyA9IHkyO1xuICAgICAgICAgICAgeDIgPSAoeDIgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgIHkyID0gKHkyICsgMiAqIHkxKSAvIDM7XG4gICAgICAgICAgICB4MSA9ICh0aGlzLl94aSArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgeTEgPSAodGhpcy5feWkgKyAyICogeTEpIC8gMztcblxuICAgICAgICAgICAgdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi9rOaIkOmdmeaAgeeahCBGbG9hdDMyQXJyYXkg5YeP5bCR5aCG5YaF5a2Y5Y2g55SoXG4gICAgICAgICAqIENvbnZlcnQgZHluYW1pYyBhcnJheSB0byBzdGF0aWMgRmxvYXQzMkFycmF5XG4gICAgICAgICAqL1xuICAgICAgICB0b1N0YXRpYzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZGF0YS5sZW5ndGggPSB0aGlzLl9sZW47XG4gICAgICAgICAgICAgICAgaWYgKGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtaW5bMF0gPSBtaW5bMV0gPSBtaW4yWzBdID0gbWluMlsxXSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICBtYXhbMF0gPSBtYXhbMV0gPSBtYXgyWzBdID0gbWF4MlsxXSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgICAgICB2YXIgeWkgPSAwO1xuICAgICAgICAgICAgdmFyIHgwID0gMDtcbiAgICAgICAgICAgIHZhciB5MCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNtZCA9IGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB5aTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZVRvIOWRveS7pOmHjeaWsOWIm+W7uuS4gOS4quaWsOeahCBzdWJwYXRoLCDlubbkuJTmm7TmlrDmlrDnmoTotbfngrlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5L2/55SoXG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4yWzBdID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4yWzFdID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXgyWzBdID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXgyWzFdID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUxpbmUoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21DdWJpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluMiwgbWF4MlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbVF1YWRyYXRpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4yLCBtYXgyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5BOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IGRhdGFbaSsrXSArIHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDml4vovaxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW50aWNsb2Nrd2lzZSA9IDEgLSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgwID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tQXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LCBjeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnRpY2xvY2t3aXNlLCBtaW4yLCBtYXgyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgZnJvbUxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUxpbmUoeDAsIHkwLCB4MCArIHdpZHRoLCB5MCArIGhlaWdodCwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVW5pb25cbiAgICAgICAgICAgICAgICB2ZWMyLm1pbihtaW4sIG1pbiwgbWluMik7XG4gICAgICAgICAgICAgICAgdmVjMi5tYXgobWF4LCBtYXgsIG1heDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBkYXRhXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1pblswXSA9IG1pblsxXSA9IG1heFswXSA9IG1heFsxXSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgICAgIG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVidWlsZCBwYXRoIGZyb20gY3VycmVudCBkYXRhXG4gICAgICAgICAqIFJlYnVpbGQgcGF0aCB3aWxsIG5vdCBjb25zaWRlciBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmUgZGFzaC5cbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0fSBjdHhcbiAgICAgICAgICovXG4gICAgICAgIHJlYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIHZhciB4MCwgeTA7XG4gICAgICAgICAgICB2YXIgeGksIHlpO1xuICAgICAgICAgICAgdmFyIHgsIHk7XG4gICAgICAgICAgICB2YXIgdXggPSB0aGlzLl91eDtcbiAgICAgICAgICAgIHZhciB1eSA9IHRoaXMuX3V5O1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2xlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIHZhciBjbWQgPSBkW2krK107XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgICAgICAgICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkW2ldO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIHgwID0geGk7XG4gICAgICAgICAgICAgICAgICAgIHkwID0geWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeGksIHlpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgZHJhdyB0b28gc21hbGwgc2VnIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRoQWJzKHggLSB4aSkgPiB1eCB8fCBtYXRoQWJzKHkgLSB5aSkgPiB1eSB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkW2kgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5BOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN4ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ5ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwc2kgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnMgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IChyeCA+IHJ5KSA/IHJ4IDogcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVYID0gKHJ4ID4gcnkpID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVZID0gKHJ4ID4gcnkpID8gcnkgLyByeCA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNFbGxpcHNlID0gTWF0aC5hYnMocnggLSByeSkgPiAxZS0zO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gdGhldGEgKyBkVGhldGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbGxpcHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKC1wc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSBtYXRoQ29zKHRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSBtYXRoU2luKHRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBQYXRoUHJveHkuQ01EID0gQ01EO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXRoUHJveHk7XG4iLCIvKipcbiAqIEBhdXRob3IgWWkgU2hlbihodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpO1xuXG4gICAgdmFyIGJib3ggPSB7fTtcbiAgICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuXG4gICAgdmFyIHN0YXJ0ID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgZW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgZXh0cmVtaXR5ID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICAvKipcbiAgICAgKiDku47pobbngrnmlbDnu4TkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9pbnRzIOmhtueCueaVsOe7hFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tUG9pbnRzID0gZnVuY3Rpb24ocG9pbnRzLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gcG9pbnRzWzBdO1xuICAgICAgICB2YXIgbGVmdCA9IHBbMF07XG4gICAgICAgIHZhciByaWdodCA9IHBbMF07XG4gICAgICAgIHZhciB0b3AgPSBwWzFdO1xuICAgICAgICB2YXIgYm90dG9tID0gcFsxXTtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGxlZnQgPSBtYXRoTWluKGxlZnQsIHBbMF0pO1xuICAgICAgICAgICAgcmlnaHQgPSBtYXRoTWF4KHJpZ2h0LCBwWzBdKTtcbiAgICAgICAgICAgIHRvcCA9IG1hdGhNaW4odG9wLCBwWzFdKTtcbiAgICAgICAgICAgIGJvdHRvbSA9IG1hdGhNYXgoYm90dG9tLCBwWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pblswXSA9IGxlZnQ7XG4gICAgICAgIG1pblsxXSA9IHRvcDtcbiAgICAgICAgbWF4WzBdID0gcmlnaHQ7XG4gICAgICAgIG1heFsxXSA9IGJvdHRvbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbUxpbmUgPSBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIG1pbiwgbWF4KSB7XG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDAsIHgxKTtcbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MCwgeTEpO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkxKTtcbiAgICB9O1xuXG4gICAgdmFyIHhEaW0gPSBbXTtcbiAgICB2YXIgeURpbSA9IFtdO1xuICAgIC8qKlxuICAgICAqIOS7juS4iemYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyLCBwMynkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbUN1YmljID0gZnVuY3Rpb24oXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbWluLCBtYXhcbiAgICApIHtcbiAgICAgICAgdmFyIGN1YmljRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYTtcbiAgICAgICAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG4gPSBjdWJpY0V4dHJlbWEoeDAsIHgxLCB4MiwgeDMsIHhEaW0pO1xuICAgICAgICBtaW5bMF0gPSBJbmZpbml0eTtcbiAgICAgICAgbWluWzFdID0gSW5maW5pdHk7XG4gICAgICAgIG1heFswXSA9IC1JbmZpbml0eTtcbiAgICAgICAgbWF4WzFdID0gLUluZmluaXR5O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgeERpbVtpXSk7XG4gICAgICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgsIG1pblswXSk7XG4gICAgICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgsIG1heFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgeURpbSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgeURpbVtpXSk7XG4gICAgICAgICAgICBtaW5bMV0gPSBtYXRoTWluKHksIG1pblsxXSk7XG4gICAgICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHksIG1heFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgwLCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCBtYXhbMF0pO1xuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgzLCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgzLCBtYXhbMF0pO1xuXG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIG1pblsxXSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIG1heFsxXSk7XG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTMsIG1pblsxXSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTMsIG1heFsxXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOS7juS6jOmYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tUXVhZHJhdGljID0gZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHF1YWRyYXRpY0V4dHJlbXVtID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW07XG4gICAgICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlLnF1YWRyYXRpY0F0O1xuICAgICAgICAvLyBGaW5kIGV4dHJlbWl0aWVzLCB3aGVyZSBkZXJpdmF0aXZlIGluIHggZGltIG9yIHkgZGltIGlzIHplcm9cbiAgICAgICAgdmFyIHR4ID1cbiAgICAgICAgICAgIG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgbWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh4MCwgeDEsIHgyKSwgMSksIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIHZhciB0eSA9XG4gICAgICAgICAgICBtYXRoTWF4KFxuICAgICAgICAgICAgICAgIG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5MiksIDEpLCAwXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHZhciB4ID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdHgpO1xuICAgICAgICB2YXIgeSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHR5KTtcblxuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MiwgeCk7XG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkyLCB5KTtcbiAgICAgICAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDIsIHgpO1xuICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MiwgeSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOS7juWchuW8p+S4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcnhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbnRpY2xvY2t3aXNlXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tQXJjID0gZnVuY3Rpb24gKFxuICAgICAgICB4LCB5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4sIG1heFxuICAgICkge1xuICAgICAgICB2YXIgdmVjMk1pbiA9IHZlYzIubWluO1xuICAgICAgICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuXG4gICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcblxuXG4gICAgICAgIGlmIChkaWZmICUgUEkyIDwgMWUtNCAmJiBkaWZmID4gMWUtNCkge1xuICAgICAgICAgICAgLy8gSXMgYSBjaXJjbGVcbiAgICAgICAgICAgIG1pblswXSA9IHggLSByeDtcbiAgICAgICAgICAgIG1pblsxXSA9IHkgLSByeTtcbiAgICAgICAgICAgIG1heFswXSA9IHggKyByeDtcbiAgICAgICAgICAgIG1heFsxXSA9IHkgKyByeTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0WzBdID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgICAgc3RhcnRbMV0gPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyB5O1xuXG4gICAgICAgIGVuZFswXSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyB4O1xuICAgICAgICBlbmRbMV0gPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgeTtcblxuICAgICAgICB2ZWMyTWluKG1pbiwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHZlYzJNYXgobWF4LCBzdGFydCwgZW5kKTtcblxuICAgICAgICAvLyBUaHJlc2ggdG8gWzAsIE1hdGguUEkgKiAyXVxuICAgICAgICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSAlIChQSTIpO1xuICAgICAgICBpZiAoc3RhcnRBbmdsZSA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICsgUEkyO1xuICAgICAgICB9XG4gICAgICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgJSAoUEkyKTtcbiAgICAgICAgaWYgKGVuZEFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBlbmRBbmdsZSArIFBJMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUgJiYgIWFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydEFuZ2xlIDwgZW5kQW5nbGUgJiYgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgc3RhcnRBbmdsZSArPSBQSTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBlbmRBbmdsZTtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YXIgbnVtYmVyID0gMDtcbiAgICAgICAgLy8gdmFyIHN0ZXAgPSAoYW50aWNsb2Nrd2lzZSA/IC1NYXRoLlBJIDogTWF0aC5QSSkgLyAyO1xuICAgICAgICBmb3IgKHZhciBhbmdsZSA9IDA7IGFuZ2xlIDwgZW5kQW5nbGU7IGFuZ2xlICs9IE1hdGguUEkgLyAyKSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPiBzdGFydEFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgZXh0cmVtaXR5WzBdID0gbWF0aENvcyhhbmdsZSkgKiByeCArIHg7XG4gICAgICAgICAgICAgICAgZXh0cmVtaXR5WzFdID0gbWF0aFNpbihhbmdsZSkgKiByeSArIHk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyTWluKG1pbiwgZXh0cmVtaXR5LCBtaW4pO1xuICAgICAgICAgICAgICAgIHZlYzJNYXgobWF4LCBleHRyZW1pdHksIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiYm94O1xuXG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOabsue6v+i+heWKqeaooeWdl1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciB2MkNyZWF0ZSA9IHZlYzIuY3JlYXRlO1xuICAgIHZhciB2MkRpc3RTcXVhcmUgPSB2ZWMyLmRpc3RTcXVhcmU7XG4gICAgdmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG5cbiAgICB2YXIgRVBTSUxPTiA9IDFlLTg7XG4gICAgdmFyIEVQU0lMT05fTlVNRVJJQyA9IDFlLTQ7XG5cbiAgICB2YXIgVEhSRUVfU1FSVCA9IG1hdGhTcXJ0KDMpO1xuICAgIHZhciBPTkVfVEhJUkQgPSAxIC8gMztcblxuICAgIC8vIOS4tOaXtuWPmOmHj1xuICAgIHZhciBfdjAgPSB2MkNyZWF0ZSgpO1xuICAgIHZhciBfdjEgPSB2MkNyZWF0ZSgpO1xuICAgIHZhciBfdjIgPSB2MkNyZWF0ZSgpO1xuICAgIC8vIHZhciBfdjMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgZnVuY3Rpb24gaXNBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gLUVQU0lMT04gJiYgdmFsIDwgRVBTSUxPTjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5YC8XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIG9uZXQgKiBvbmV0ICogKG9uZXQgKiBwMCArIDMgKiB0ICogcDEpXG4gICAgICAgICAgICAgKyB0ICogdCAqICh0ICogcDMgKyAzICogb25ldCAqIHAyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlr7zmlbDlgLxcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIDMgKiAoXG4gICAgICAgICAgICAoKHAxIC0gcDApICogb25ldCArIDIgKiAocDIgLSBwMSkgKiB0KSAqIG9uZXRcbiAgICAgICAgICAgICsgKHAzIC0gcDIpICogdCAqIHRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTmlrnnqIvmoLnvvIzkvb/nlKjnm5vph5HlhazlvI9cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICAgICAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5qC55pWw55uuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNSb290QXQocDAsIHAxLCBwMiwgcDMsIHZhbCwgcm9vdHMpIHtcbiAgICAgICAgLy8gRXZhbHVhdGUgcm9vdHMgb2YgY3ViaWMgZnVuY3Rpb25zXG4gICAgICAgIHZhciBhID0gcDMgKyAzICogKHAxIC0gcDIpIC0gcDA7XG4gICAgICAgIHZhciBiID0gMyAqIChwMiAtIHAxICogMiArIHAwKTtcbiAgICAgICAgdmFyIGMgPSAzICogKHAxICAtIHAwKTtcbiAgICAgICAgdmFyIGQgPSBwMCAtIHZhbDtcblxuICAgICAgICB2YXIgQSA9IGIgKiBiIC0gMyAqIGEgKiBjO1xuICAgICAgICB2YXIgQiA9IGIgKiBjIC0gOSAqIGEgKiBkO1xuICAgICAgICB2YXIgQyA9IGMgKiBjIC0gMyAqIGIgKiBkO1xuXG4gICAgICAgIHZhciBuID0gMDtcblxuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKEEpICYmIGlzQXJvdW5kWmVybyhCKSkge1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHJvb3RzWzBdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjsgIC8vdDEsIHQyLCB0MywgYiBpcyBub3QgemVyb1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkaXNjID0gQiAqIEIgLSA0ICogQSAqIEM7XG5cbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgICAgICAgICAgICB2YXIgSyA9IEIgLyBBO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1iIC8gYSArIEs7ICAvLyB0MSwgYSBpcyBub3QgemVyb1xuICAgICAgICAgICAgICAgIHZhciB0MiA9IC1LIC8gMjsgIC8vIHQyLCB0M1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciBZMSA9IEEgKiBiICsgMS41ICogYSAqICgtQiArIGRpc2NTcXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgWTIgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgLSBkaXNjU3FydCk7XG4gICAgICAgICAgICAgICAgaWYgKFkxIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBZMSA9IC1tYXRoUG93KC1ZMSwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFkxID0gbWF0aFBvdyhZMSwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFkyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBZMiA9IC1tYXRoUG93KC1ZMiwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFkyID0gbWF0aFBvdyhZMiwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iIC0gKFkxICsgWTIpKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIFQgPSAoMiAqIEEgKiBiIC0gMyAqIGEgKiBCKSAvICgyICogbWF0aFNxcnQoQSAqIEEgKiBBKSk7XG4gICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gTWF0aC5hY29zKFQpIC8gMztcbiAgICAgICAgICAgICAgICB2YXIgQVNxcnQgPSBtYXRoU3FydChBKTtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gTWF0aC5jb3ModGhldGEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iIC0gMiAqIEFTcXJ0ICogdG1wKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iICsgQVNxcnQgKiAodG1wICsgVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcbiAgICAgICAgICAgICAgICB2YXIgdDMgPSAoLWIgKyBBU3FydCAqICh0bXAgLSBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQzID49IDAgJiYgdDMgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+aegemZkOWAvOeahOS9jee9rlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBleHRyZW1hXG4gICAgICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmlbDnm65cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY0V4dHJlbWEocDAsIHAxLCBwMiwgcDMsIGV4dHJlbWEpIHtcbiAgICAgICAgdmFyIGIgPSA2ICogcDIgLSAxMiAqIHAxICsgNiAqIHAwO1xuICAgICAgICB2YXIgYSA9IDkgKiBwMSArIDMgKiBwMyAtIDMgKiBwMCAtIDkgKiBwMjtcbiAgICAgICAgdmFyIGMgPSAzICogcDEgLSAzICogcDA7XG5cbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKGIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gLWMgLyBiO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9MSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIGV4dHJlbWFbMF0gPSAtYiAvICgyICogYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWFbbisrXSA9IHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnu4bliIbkuInmrKHotJ3loZ7lsJTmm7Lnur9cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNTdWJkaXZpZGUocDAsIHAxLCBwMiwgcDMsIHQsIG91dCkge1xuICAgICAgICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICAgICAgICB2YXIgcDIzID0gKHAzIC0gcDIpICogdCArIHAyO1xuXG4gICAgICAgIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxO1xuICAgICAgICB2YXIgcDEyMyA9IChwMjMgLSBwMTIpICogdCArIHAxMjtcblxuICAgICAgICB2YXIgcDAxMjMgPSAocDEyMyAtIHAwMTIpICogdCArIHAwMTI7XG4gICAgICAgIC8vIFNlZzBcbiAgICAgICAgb3V0WzBdID0gcDA7XG4gICAgICAgIG91dFsxXSA9IHAwMTtcbiAgICAgICAgb3V0WzJdID0gcDAxMjtcbiAgICAgICAgb3V0WzNdID0gcDAxMjM7XG4gICAgICAgIC8vIFNlZzFcbiAgICAgICAgb3V0WzRdID0gcDAxMjM7XG4gICAgICAgIG91dFs1XSA9IHAxMjM7XG4gICAgICAgIG91dFs2XSA9IHAyMztcbiAgICAgICAgb3V0WzddID0gcDM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5oqV5bCE54K55Yiw5LiJ5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gICAgICog5oqV5bCE54K55pyJ5Y+v6IO95Lya5pyJ5LiA5Liq5oiW6ICF5aSa5Liq77yM6L+Z6YeM5Y+q6L+U5Zue5YW25Lit6Led56a75pyA55+t55qE5LiA5Liq44CCXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIOaKleWwhOeCuVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLFxuICAgICAgICB4LCB5LCBvdXRcbiAgICApIHtcbiAgICAgICAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgdmFyIGludGVydmFsID0gMC4wMDU7XG4gICAgICAgIHZhciBkID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgdmFyIGQxO1xuICAgICAgICB2YXIgZDI7XG5cbiAgICAgICAgX3YwWzBdID0geDtcbiAgICAgICAgX3YwWzFdID0geTtcblxuICAgICAgICAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgICAgICAgLy8gUEVORElOR1xuICAgICAgICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgICAgICAgICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgX3QpO1xuICAgICAgICAgICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgX3QpO1xuICAgICAgICAgICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuICAgICAgICAgICAgaWYgKGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBfdDtcbiAgICAgICAgICAgICAgICBkID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICAgICAgbmV4dCA9IHQgKyBpbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIHQgLSBpbnRlcnZhbFxuICAgICAgICAgICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgcHJldik7XG4gICAgICAgICAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBwcmV2KTtcblxuICAgICAgICAgICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgICAgICAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBwcmV2O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIF92MlswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIG5leHQpO1xuICAgICAgICAgICAgICAgIF92MlsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIG5leHQpO1xuICAgICAgICAgICAgICAgIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkID0gZDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRcbiAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgICAgb3V0WzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICBvdXRbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG4gICAgICAgIHJldHVybiBtYXRoU3FydChkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlgLxcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljQXQocDAsIHAxLCBwMiwgdCkge1xuICAgICAgICB2YXIgb25ldCA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gb25ldCAqIChvbmV0ICogcDAgKyAyICogdCAqIHAxKSArIHQgKiB0ICogcDI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5a+85pWw5YC8XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCB0KSB7XG4gICAgICAgIHJldHVybiAyICogKCgxIC0gdCkgKiAocDEgLSBwMCkgKyB0ICogKHAyIC0gcDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTmlrnnqIvmoLlcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1Jvb3RBdChwMCwgcDEsIHAyLCB2YWwsIHJvb3RzKSB7XG4gICAgICAgIHZhciBhID0gcDAgLSAyICogcDEgKyBwMjtcbiAgICAgICAgdmFyIGIgPSAyICogKHAxIC0gcDApO1xuICAgICAgICB2YXIgYyA9IHAwIC0gdmFsO1xuXG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgICAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1iIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S6jOasoei0neWhnuWwlOaWueeoi+aegemZkOWAvFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0V4dHJlbXVtKHAwLCBwMSwgcDIpIHtcbiAgICAgICAgdmFyIGRpdmlkZXIgPSBwMCArIHAyIC0gMiAqIHAxO1xuICAgICAgICBpZiAoZGl2aWRlciA9PT0gMCkge1xuICAgICAgICAgICAgLy8gcDEgaXMgY2VudGVyIG9mIHAwIGFuZCBwMlxuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAocDAgLSBwMSkgLyBkaXZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog57uG5YiG5LqM5qyh6LSd5aGe5bCU5puy57q/XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHQsIG91dCkge1xuICAgICAgICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICAgICAgICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTtcblxuICAgICAgICAvLyBTZWcwXG4gICAgICAgIG91dFswXSA9IHAwO1xuICAgICAgICBvdXRbMV0gPSBwMDE7XG4gICAgICAgIG91dFsyXSA9IHAwMTI7XG5cbiAgICAgICAgLy8gU2VnMVxuICAgICAgICBvdXRbM10gPSBwMDEyO1xuICAgICAgICBvdXRbNF0gPSBwMTI7XG4gICAgICAgIG91dFs1XSA9IHAyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaKleWwhOeCueWIsOS6jOasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICAgICAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXQg5oqV5bCE54K5XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgeCwgeSwgb3V0XG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICAgICAgICB2YXIgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIF92MFswXSA9IHg7XG4gICAgICAgIF92MFsxXSA9IHk7XG5cbiAgICAgICAgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICAgICAgICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIF90KTtcbiAgICAgICAgICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIF90KTtcbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjAsIF92MSk7XG4gICAgICAgICAgICBpZiAoZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IF90O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkID0gSW5maW5pdHk7XG5cbiAgICAgICAgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICAgICAgdmFyIG5leHQgPSB0ICsgaW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyB0IC0gaW50ZXJ2YWxcbiAgICAgICAgICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHByZXYpO1xuICAgICAgICAgICAgX3YxWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgcHJldik7XG5cbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2ID49IDAgJiYgZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IHByZXY7XG4gICAgICAgICAgICAgICAgZCA9IGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdCArIGludGVydmFsXG4gICAgICAgICAgICAgICAgX3YyWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgbmV4dCk7XG4gICAgICAgICAgICAgICAgX3YyWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgbmV4dCk7XG4gICAgICAgICAgICAgICAgdmFyIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHQpO1xuICAgICAgICAgICAgb3V0WzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuICAgICAgICByZXR1cm4gbWF0aFNxcnQoZCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgY3ViaWNBdDogY3ViaWNBdCxcblxuICAgICAgICBjdWJpY0Rlcml2YXRpdmVBdDogY3ViaWNEZXJpdmF0aXZlQXQsXG5cbiAgICAgICAgY3ViaWNSb290QXQ6IGN1YmljUm9vdEF0LFxuXG4gICAgICAgIGN1YmljRXh0cmVtYTogY3ViaWNFeHRyZW1hLFxuXG4gICAgICAgIGN1YmljU3ViZGl2aWRlOiBjdWJpY1N1YmRpdmlkZSxcblxuICAgICAgICBjdWJpY1Byb2plY3RQb2ludDogY3ViaWNQcm9qZWN0UG9pbnQsXG5cbiAgICAgICAgcXVhZHJhdGljQXQ6IHF1YWRyYXRpY0F0LFxuXG4gICAgICAgIHF1YWRyYXRpY0Rlcml2YXRpdmVBdDogcXVhZHJhdGljRGVyaXZhdGl2ZUF0LFxuXG4gICAgICAgIHF1YWRyYXRpY1Jvb3RBdDogcXVhZHJhdGljUm9vdEF0LFxuXG4gICAgICAgIHF1YWRyYXRpY0V4dHJlbXVtOiBxdWFkcmF0aWNFeHRyZW11bSxcblxuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGU6IHF1YWRyYXRpY1N1YmRpdmlkZSxcblxuICAgICAgICBxdWFkcmF0aWNQcm9qZWN0UG9pbnQ6IHF1YWRyYXRpY1Byb2plY3RQb2ludFxuICAgIH07XG4iLCIvKipcbiAqIGVjaGFydHPorr7lpIfnjq/looPor4bliKtcbiAqXG4gKiBAZGVzYyBlY2hhcnRz5Z+65LqOQ2FudmFz77yM57qvSmF2YXNjcmlwdOWbvuihqOW6k++8jOaPkOS+m+ebtOingu+8jOeUn+WKqO+8jOWPr+S6pOS6ku+8jOWPr+S4quaAp+WMluWumuWItueahOaVsOaNrue7n+iuoeWbvuihqOOAglxuICogQGF1dGhvciBmaXJlZGVbZmlyZWRlQGZpcmVkZS51c11cbiAqIEBkZXNjIHRoYW5rcyB6ZXB0by5cbiAqL1xuXG4gICAgdmFyIGVudiA9IHt9O1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBJbiBub2RlXG4gICAgICAgIGVudiA9IHtcbiAgICAgICAgICAgIGJyb3dzZXI6IHt9LFxuICAgICAgICAgICAgb3M6IHt9LFxuICAgICAgICAgICAgbm9kZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIEFzc3VtZSBjYW52YXMgaXMgc3VwcG9ydGVkXG4gICAgICAgICAgICBjYW52YXNTdXBwb3J0ZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVudiA9IGRldGVjdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVudjtcblxuICAgIC8vIFplcHRvLmpzXG4gICAgLy8gKGMpIDIwMTAtMjAxMyBUaG9tYXMgRnVjaHNcbiAgICAvLyBaZXB0by5qcyBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuICAgIGZ1bmN0aW9uIGRldGVjdCh1YSkge1xuICAgICAgICB2YXIgb3MgPSB7fTtcbiAgICAgICAgdmFyIGJyb3dzZXIgPSB7fTtcbiAgICAgICAgLy8gdmFyIHdlYmtpdCA9IHVhLm1hdGNoKC9XZWJba0tdaXRbXFwvXXswLDF9KFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBhbmRyb2lkID0gdWEubWF0Y2goLyhBbmRyb2lkKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pO1xuICAgICAgICAvLyB2YXIgaXBhZCA9IHVhLm1hdGNoKC8oaVBhZCkuKk9TXFxzKFtcXGRfXSspLyk7XG4gICAgICAgIC8vIHZhciBpcG9kID0gdWEubWF0Y2goLyhpUG9kKSguKk9TXFxzKFtcXGRfXSspKT8vKTtcbiAgICAgICAgLy8gdmFyIGlwaG9uZSA9ICFpcGFkICYmIHVhLm1hdGNoKC8oaVBob25lXFxzT1MpXFxzKFtcXGRfXSspLyk7XG4gICAgICAgIC8vIHZhciB3ZWJvcyA9IHVhLm1hdGNoKC8od2ViT1N8aHB3T1MpW1xcc1xcL10oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIHRvdWNocGFkID0gd2Vib3MgJiYgdWEubWF0Y2goL1RvdWNoUGFkLyk7XG4gICAgICAgIC8vIHZhciBraW5kbGUgPSB1YS5tYXRjaCgvS2luZGxlXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBzaWxrID0gdWEubWF0Y2goL1NpbGtcXC8oW1xcZC5fXSspLyk7XG4gICAgICAgIC8vIHZhciBibGFja2JlcnJ5ID0gdWEubWF0Y2goLyhCbGFja0JlcnJ5KS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgYmIxMCA9IHVhLm1hdGNoKC8oQkIxMCkuKlZlcnNpb25cXC8oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIHJpbXRhYmxldG9zID0gdWEubWF0Y2goLyhSSU1cXHNUYWJsZXRcXHNPUylcXHMoW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIHBsYXlib29rID0gdWEubWF0Y2goL1BsYXlCb29rLyk7XG4gICAgICAgIC8vIHZhciBjaHJvbWUgPSB1YS5tYXRjaCgvQ2hyb21lXFwvKFtcXGQuXSspLykgfHwgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIHZhciBmaXJlZm94ID0gdWEubWF0Y2goL0ZpcmVmb3hcXC8oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIHNhZmFyaSA9IHdlYmtpdCAmJiB1YS5tYXRjaCgvTW9iaWxlXFwvLykgJiYgIWNocm9tZTtcbiAgICAgICAgLy8gdmFyIHdlYnZpZXcgPSB1YS5tYXRjaCgvKGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS8pICYmICFjaHJvbWU7XG4gICAgICAgIHZhciBpZSA9IHVhLm1hdGNoKC9NU0lFXFxzKFtcXGQuXSspLylcbiAgICAgICAgICAgIC8vIElFIDExIFRyaWRlbnQvNy4wOyBydjoxMS4wXG4gICAgICAgICAgICB8fCB1YS5tYXRjaCgvVHJpZGVudFxcLy4rP3J2OigoW1xcZC5dKykpLyk7XG4gICAgICAgIHZhciBlZGdlID0gdWEubWF0Y2goL0VkZ2VcXC8oW1xcZC5dKykvKTsgLy8gSUUgMTIgYW5kIDEyK1xuXG4gICAgICAgIHZhciB3ZUNoYXQgPSAoL21pY3JvbWVzc2VuZ2VyL2kpLnRlc3QodWEpO1xuXG4gICAgICAgIC8vIFRvZG86IGNsZWFuIHRoaXMgdXAgd2l0aCBhIGJldHRlciBPUy9icm93c2VyIHNlcGVyYXRpb246XG4gICAgICAgIC8vIC0gZGlzY2VybiAobW9yZSkgYmV0d2VlbiBtdWx0aXBsZSBicm93c2VycyBvbiBhbmRyb2lkXG4gICAgICAgIC8vIC0gZGVjaWRlIGlmIGtpbmRsZSBmaXJlIGluIHNpbGsgbW9kZSBpcyBhbmRyb2lkIG9yIG5vdFxuICAgICAgICAvLyAtIEZpcmVmb3ggb24gQW5kcm9pZCBkb2Vzbid0IHNwZWNpZnkgdGhlIEFuZHJvaWQgdmVyc2lvblxuICAgICAgICAvLyAtIHBvc3NpYmx5IGRldmlkZSBpbiBvcywgZGV2aWNlIGFuZCBicm93c2VyIGhhc2hlc1xuXG4gICAgICAgIC8vIGlmIChicm93c2VyLndlYmtpdCA9ICEhd2Via2l0KSBicm93c2VyLnZlcnNpb24gPSB3ZWJraXRbMV07XG5cbiAgICAgICAgLy8gaWYgKGFuZHJvaWQpIG9zLmFuZHJvaWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gYW5kcm9pZFsyXTtcbiAgICAgICAgLy8gaWYgKGlwaG9uZSAmJiAhaXBvZCkgb3MuaW9zID0gb3MuaXBob25lID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwaG9uZVsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gICAgICAgIC8vIGlmIChpcGFkKSBvcy5pb3MgPSBvcy5pcGFkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwYWRbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgICAgICAvLyBpZiAoaXBvZCkgb3MuaW9zID0gb3MuaXBvZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcG9kWzNdID8gaXBvZFszXS5yZXBsYWNlKC9fL2csICcuJykgOiBudWxsO1xuICAgICAgICAvLyBpZiAod2Vib3MpIG9zLndlYm9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHdlYm9zWzJdO1xuICAgICAgICAvLyBpZiAodG91Y2hwYWQpIG9zLnRvdWNocGFkID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgKGJsYWNrYmVycnkpIG9zLmJsYWNrYmVycnkgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmxhY2tiZXJyeVsyXTtcbiAgICAgICAgLy8gaWYgKGJiMTApIG9zLmJiMTAgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmIxMFsyXTtcbiAgICAgICAgLy8gaWYgKHJpbXRhYmxldG9zKSBvcy5yaW10YWJsZXRvcyA9IHRydWUsIG9zLnZlcnNpb24gPSByaW10YWJsZXRvc1syXTtcbiAgICAgICAgLy8gaWYgKHBsYXlib29rKSBicm93c2VyLnBsYXlib29rID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgKGtpbmRsZSkgb3Mua2luZGxlID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGtpbmRsZVsxXTtcbiAgICAgICAgLy8gaWYgKHNpbGspIGJyb3dzZXIuc2lsayA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IHNpbGtbMV07XG4gICAgICAgIC8vIGlmICghc2lsayAmJiBvcy5hbmRyb2lkICYmIHVhLm1hdGNoKC9LaW5kbGUgRmlyZS8pKSBicm93c2VyLnNpbGsgPSB0cnVlO1xuICAgICAgICAvLyBpZiAoY2hyb21lKSBicm93c2VyLmNocm9tZSA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IGNocm9tZVsxXTtcbiAgICAgICAgaWYgKGZpcmVmb3gpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuZmlyZWZveCA9IHRydWU7XG4gICAgICAgICAgICBicm93c2VyLnZlcnNpb24gPSBmaXJlZm94WzFdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIChzYWZhcmkgJiYgKHVhLm1hdGNoKC9TYWZhcmkvKSB8fCAhIW9zLmlvcykpIGJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgKHdlYnZpZXcpIGJyb3dzZXIud2VidmlldyA9IHRydWU7XG5cbiAgICAgICAgaWYgKGllKSB7XG4gICAgICAgICAgICBicm93c2VyLmllID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyb3dzZXIudmVyc2lvbiA9IGllWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVkZ2UpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuZWRnZSA9IHRydWU7XG4gICAgICAgICAgICBicm93c2VyLnZlcnNpb24gPSBlZGdlWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSXQgaXMgZGlmZmljdWx0IHRvIGRldGVjdCBXZUNoYXQgaW4gV2luIFBob25lIHByZWNpc2VseSwgYmVjYXVzZSB1YSBjYW5cbiAgICAgICAgLy8gbm90IGJlIHNldCBvbiB3aW4gcGhvbmUuIFNvIHdlIGRvIG5vdCBjb25zaWRlciBXaW4gUGhvbmUuXG4gICAgICAgIGlmICh3ZUNoYXQpIHtcbiAgICAgICAgICAgIGJyb3dzZXIud2VDaGF0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9zLnRhYmxldCA9ICEhKGlwYWQgfHwgcGxheWJvb2sgfHwgKGFuZHJvaWQgJiYgIXVhLm1hdGNoKC9Nb2JpbGUvKSkgfHxcbiAgICAgICAgLy8gICAgIChmaXJlZm94ICYmIHVhLm1hdGNoKC9UYWJsZXQvKSkgfHwgKGllICYmICF1YS5tYXRjaCgvUGhvbmUvKSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpO1xuICAgICAgICAvLyBvcy5waG9uZSAgPSAhISghb3MudGFibGV0ICYmICFvcy5pcG9kICYmIChhbmRyb2lkIHx8IGlwaG9uZSB8fCB3ZWJvcyB8fFxuICAgICAgICAvLyAgICAgKGNocm9tZSAmJiB1YS5tYXRjaCgvQW5kcm9pZC8pKSB8fCAoY2hyb21lICYmIHVhLm1hdGNoKC9DcmlPU1xcLyhbXFxkLl0rKS8pKSB8fFxuICAgICAgICAvLyAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL01vYmlsZS8pKSB8fCAoaWUgJiYgdWEubWF0Y2goL1RvdWNoLykpKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJyb3dzZXI6IGJyb3dzZXIsXG4gICAgICAgICAgICBvczogb3MsXG4gICAgICAgICAgICBub2RlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIOWOn+eUn2NhbnZhc+aUr+aMge+8jOaUueaegeerr+eCueS6hlxuICAgICAgICAgICAgLy8gY2FudmFzU3VwcG9ydGVkIDogIShicm93c2VyLmllICYmIHBhcnNlRmxvYXQoYnJvd3Nlci52ZXJzaW9uKSA8IDkpXG4gICAgICAgICAgICBjYW52YXNTdXBwb3J0ZWQgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0ID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgLy8gQHNlZSA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80ODE3MDI5L3doYXRzLXRoZS1iZXN0LXdheS10by1kZXRlY3QtYS10b3VjaC1zY3JlZW4tZGV2aWNlLXVzaW5nLWphdmFzY3JpcHQ+XG4gICAgICAgICAgICAvLyB3b3JrcyBvbiBtb3N0IGJyb3dzZXJzXG4gICAgICAgICAgICAvLyBJRTEwLzExIGRvZXMgbm90IHN1cHBvcnQgdG91Y2ggZXZlbnQsIGFuZCBNUyBFZGdlIHN1cHBvcnRzIHRoZW0gYnV0IG5vdCBieVxuICAgICAgICAgICAgLy8gZGVmYXVsdCwgc28gd2UgZG9udCBjaGVjayBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgZm9yIHRoZW0gaGVyZS5cbiAgICAgICAgICAgIHRvdWNoRXZlbnRzU3VwcG9ydGVkOiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgIWJyb3dzZXIuaWUgJiYgIWJyb3dzZXIuZWRnZSxcbiAgICAgICAgICAgIC8vIDxodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1wb2ludGVyJTIwZXZlbnQ+LlxuICAgICAgICAgICAgcG9pbnRlckV2ZW50c1N1cHBvcnRlZDogJ29ucG9pbnRlcmRvd24nIGluIHdpbmRvd1xuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggc3VwcG9ydHMgcG9pbnRlciBidXQgbm90IGJ5IGRlZmF1bHQsIG9ubHkgTVMgYnJvd3NlcnMgYXJlIHJlbGlhYmxlIG9uIHBvaW50ZXJcbiAgICAgICAgICAgICAgICAvLyBldmVudHMgY3VycmVudGx5LiBTbyB3ZSBkb250IHVzZSB0aGF0IG9uIG90aGVyIGJyb3dzZXJzIHVubGVzcyB0ZXN0ZWQgc3VmZmljaWVudGx5LlxuICAgICAgICAgICAgICAgIC8vIEFsdGhvdWdoIElFIDEwIHN1cHBvcnRzIHBvaW50ZXIgZXZlbnQsIGl0IHVzZSBvbGQgc3R5bGUgYW5kIGlzIGRpZmZlcmVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkLiBTbyB3ZSBleGNsdWRlIHRoYXQuIChJRSAxMCBpcyBoYXJkbHkgdXNlZCBvbiB0b3VjaCBkZXZpY2UpXG4gICAgICAgICAgICAgICAgJiYgKGJyb3dzZXIuZWRnZSB8fCAoYnJvd3Nlci5pZSAmJiBicm93c2VyLnZlcnNpb24gPj0gMTEpKVxuICAgICAgICB9O1xuICAgIH1cbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog5LqL5Lu26L6F5Yqp57G7XG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9ldmVudFxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKi9cblxuXG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi4vbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi9lbnYnKTtcblxuICAgIHZhciBpc0RvbUxldmVsMiA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgJiYgISF3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcjtcblxuICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCkge1xuICAgICAgICAvLyBCbGFja0JlcnJ5IDUsIGlPUyAzIChvcmlnaW5hbCBpUGhvbmUpIGRvbid0IGhhdmUgZ2V0Qm91bmRpbmdSZWN0XG4gICAgICAgIHJldHVybiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPyBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHtsZWZ0OiAwLCB0b3A6IDB9O1xuICAgIH1cblxuICAgIC8vIGBjYWxjdWxhdGVgIGlzIG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlXG4gICAgZnVuY3Rpb24gY2xpZW50VG9Mb2NhbChlbCwgZSwgb3V0LCBjYWxjdWxhdGUpIHtcbiAgICAgICAgb3V0ID0gb3V0IHx8IHt9O1xuXG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgVzNDIFdvcmtpbmcgRHJhZnQsIG9mZnNldFggYW5kIG9mZnNldFkgc2hvdWxkIGJlIHJlbGF0aXZlXG4gICAgICAgIC8vIHRvIHRoZSBwYWRkaW5nIGVkZ2Ugb2YgdGhlIHRhcmdldCBlbGVtZW50LiBUaGUgb25seSBicm93c2VyIHVzaW5nIHRoaXMgY29udmVudGlvblxuICAgICAgICAvLyBpcyBJRS4gV2Via2l0IHVzZXMgdGhlIGJvcmRlciBlZGdlLCBPcGVyYSB1c2VzIHRoZSBjb250ZW50IGVkZ2UsIGFuZCBGaXJlRm94IGRvZXNcbiAgICAgICAgLy8gbm90IHN1cHBvcnQgdGhlIHByb3BlcnRpZXMuXG4gICAgICAgIC8vIChzZWUgaHR0cDovL3d3dy5qYWNrbG1vb3JlLmNvbS9ub3Rlcy9tb3VzZS1wb3NpdGlvbi8pXG4gICAgICAgIC8vIEluIHpyIHBhaW50ZXIuZG9tLCBwYWRkaW5nIGVkZ2UgZXF1YWxzIHRvIGJvcmRlciBlZGdlLlxuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIFdoZW4gbW91c2Vtb3ZlIGV2ZW50IHRyaWdnZXJlZCBvbiBlYyB0b29sdGlwLCB0YXJnZXQgaXMgbm90IHpyIHBhaW50ZXIuZG9tLCBhbmRcbiAgICAgICAgLy8gb2Zmc2V0WC9ZIGlzIHJlbGF0aXZlIHRvIGUudGFyZ2V0LCB3aGVyZSB0aGUgY2FsY3VsYXRpb24gb2YgenJYL1kgdmlhIG9mZnNldFgvWVxuICAgICAgICAvLyBpcyB0b28gY29tcGxleC4gU28gY3NzLXRyYW5zZnJvbSBkb250IHN1cHBvcnQgaW4gdGhpcyBjYXNlIHRlbXBvcmFyaWx5LlxuICAgICAgICBpZiAoY2FsY3VsYXRlIHx8ICFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBkZWZhdWx0R2V0WnJYWShlbCwgZSwgb3V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYXV0aW9uOiBJbiBGaXJlRm94LCBsYXllclgvbGF5ZXJZIE1vdXNlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBjbG9zZXN0IHBvc2l0aW9uZWRcbiAgICAgICAgLy8gYW5jZXN0b3IgZWxlbWVudCwgc28gd2Ugc2hvdWxkIG1ha2Ugc3VyZSBlbCBpcyBwb3NpdGlvbmVkIChlLmcuLCBub3QgcG9zaXRpb246c3RhdGljKS5cbiAgICAgICAgLy8gQlRXMSwgV2Via2l0IGRvbid0IHJldHVybiB0aGUgc2FtZSByZXN1bHRzIGFzIEZGIGluIG5vbi1zaW1wbGUgY2FzZXMgKGxpa2UgYWRkXG4gICAgICAgIC8vIHpvb20tZmFjdG9yLCBvdmVyZmxvdyAvIG9wYWNpdHkgbGF5ZXJzLCB0cmFuc2Zvcm1zIC4uLilcbiAgICAgICAgLy8gQlRXMiwgKGV2Lm9mZnNldFkgfHwgZXYucGFnZVkgLSAkKGV2LnRhcmdldCkub2Zmc2V0KCkudG9wKSBpcyBub3QgY29ycmVjdCBpbiBwcmVzZXJ2ZS0zZC5cbiAgICAgICAgLy8gPGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC84NTIzI2NvbW1lbnQ6MTQ+XG4gICAgICAgIC8vIEJUVzMsIEluIGZmLCBvZmZzZXRYL29mZnNldFkgaXMgYWx3YXlzIDAuXG4gICAgICAgIGVsc2UgaWYgKGVudi5icm93c2VyLmZpcmVmb3ggJiYgZS5sYXllclggIT0gbnVsbCAmJiBlLmxheWVyWCAhPT0gZS5vZmZzZXRYKSB7XG4gICAgICAgICAgICBvdXQuenJYID0gZS5sYXllclg7XG4gICAgICAgICAgICBvdXQuenJZID0gZS5sYXllclk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIElFNissIGNocm9tZSwgc2FmYXJpLCBvcGVyYS4gKFdoZW4gd2lsbCBmZiBzdXBwb3J0IG9mZnNldFg/KVxuICAgICAgICBlbHNlIGlmIChlLm9mZnNldFggIT0gbnVsbCkge1xuICAgICAgICAgICAgb3V0LnpyWCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgIG91dC56clkgPSBlLm9mZnNldFk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIHNvbWUgb3RoZXIgZGV2aWNlLCBlLmcuLCBJT1Mgc2FmYXJpLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0R2V0WnJYWShlbCwgZSwgb3V0KSB7XG4gICAgICAgIC8vIFRoaXMgd2VsbC1rbm93biBtZXRob2QgYmVsb3cgZG9lcyBub3Qgc3VwcG9ydCBjc3MgdHJhbnNmb3JtLlxuICAgICAgICB2YXIgYm94ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKTtcbiAgICAgICAgb3V0LnpyWCA9IGUuY2xpZW50WCAtIGJveC5sZWZ0O1xuICAgICAgICBvdXQuenJZID0gZS5jbGllbnRZIC0gYm94LnRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlpoLmnpzlrZjlnKjnrKzkuInmlrnltYzlhaXnmoTkuIDkuptkb23op6blj5HnmoTkuovku7bvvIzmiJZ0b3VjaOS6i+S7tu+8jOmcgOimgei9rOaNouS4gOS4i+S6i+S7tuWdkOaghy5cbiAgICAgKiBgY2FsY3VsYXRlYCBpcyBvcHRpb25hbCwgZGVmYXVsdCBmYWxzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVFdmVudChlbCwgZSwgY2FsY3VsYXRlKSB7XG5cbiAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgICAgIGlmIChlLnpyWCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBldmVudFR5cGUgPSBlLnR5cGU7XG4gICAgICAgIHZhciBpc1RvdWNoID0gZXZlbnRUeXBlICYmIGV2ZW50VHlwZS5pbmRleE9mKCd0b3VjaCcpID49IDA7XG5cbiAgICAgICAgaWYgKCFpc1RvdWNoKSB7XG4gICAgICAgICAgICBjbGllbnRUb0xvY2FsKGVsLCBlLCBlLCBjYWxjdWxhdGUpO1xuICAgICAgICAgICAgZS56ckRlbHRhID0gKGUud2hlZWxEZWx0YSkgPyBlLndoZWVsRGVsdGEgLyAxMjAgOiAtKGUuZGV0YWlsIHx8IDApIC8gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2ZW50VHlwZSAhPSAndG91Y2hlbmQnXG4gICAgICAgICAgICAgICAgPyBlLnRhcmdldFRvdWNoZXNbMF1cbiAgICAgICAgICAgICAgICA6IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICB0b3VjaCAmJiBjbGllbnRUb0xvY2FsKGVsLCB0b3VjaCwgZSwgY2FsY3VsYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAoaXNEb21MZXZlbDIpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgbmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcmV2ZW50RGVmYXVsdCBhbmQgc3RvcFByb3BhZ2F0aW9uLlxuICAgICAqIE5vdGljZTogZG8gbm90IGRvIHRoYXQgaW4genJlbmRlci4gVXBwZXIgYXBwbGljYXRpb25cbiAgICAgKiBkbyB0aGF0IGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2V2ZW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgOiBldmVudOWvueixoVxuICAgICAqL1xuICAgIHZhciBzdG9wID0gaXNEb21MZXZlbDJcbiAgICAgICAgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgY2xpZW50VG9Mb2NhbDogY2xpZW50VG9Mb2NhbCxcbiAgICAgICAgbm9ybWFsaXplRXZlbnQ6IG5vcm1hbGl6ZUV2ZW50LFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBhZGRFdmVudExpc3RlbmVyLFxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiByZW1vdmVFdmVudExpc3RlbmVyLFxuXG4gICAgICAgIHN0b3A6IHN0b3AsXG4gICAgICAgIC8vIOWBmuWQkeS4iuWFvOWuuVxuICAgICAgICBEaXNwYXRjaGVyOiBFdmVudGZ1bFxuICAgIH07XG5cbiIsIi8qKlxuICogenJlbmRlcjog55Sf5oiQ5ZSv5LiAaWRcbiAqXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4gICAgdmFyIGlkU3RhcnQgPSAweDA5MDc7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlkU3RhcnQrKztcbiAgICB9O1xuXG4iLCJcbiAgICAgICAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvbG9nXG4gICAgICAgICAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuZGVidWdNb2RlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLmRlYnVnTW9kZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3VtZW50c1trXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLmRlYnVnTW9kZSA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHNba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKiBmb3IgZGVidWdcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG1lcykge1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dyb25nLW1lc3NhZ2UnKS5pbm5lckhUTUwgPVxuICAgICAgICAgICAgICAgIG1lcyArICcgJyArIChuZXcgRGF0ZSgpIC0gMClcbiAgICAgICAgICAgICAgICArICc8YnIvPidcbiAgICAgICAgICAgICAgICArIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cm9uZy1tZXNzYWdlJykuaW5uZXJIVE1MO1xuICAgICAgICB9O1xuICAgICAgICAqL1xuICAgIFxuIiwiXG4gICAgdmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gQXJyYXlcbiAgICAgICAgOiBGbG9hdDMyQXJyYXk7XG4gICAgLyoqXG4gICAgICogM3gy55+p6Zi15pON5L2c57G7XG4gICAgICogQGV4cG9ydHMgenJlbmRlci90b29sL21hdHJpeFxuICAgICAqL1xuICAgIHZhciBtYXRyaXggPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJvlu7rkuIDkuKrljZXkvY3nn6npmLVcbiAgICAgICAgICogQHJldHVybiB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5Q3Rvcig2KTtcbiAgICAgICAgICAgIG1hdHJpeC5pZGVudGl0eShvdXQpO1xuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u55+p6Zi15Li65Y2V5L2N55+p6Zi1XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICovXG4gICAgICAgIGlkZW50aXR5IDogZnVuY3Rpb24ob3V0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAxO1xuICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIG91dFsyXSA9IDA7XG4gICAgICAgICAgICBvdXRbM10gPSAxO1xuICAgICAgICAgICAgb3V0WzRdID0gMDtcbiAgICAgICAgICAgIG91dFs1XSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5aSN5Yi255+p6Zi1XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG1cbiAgICAgICAgICovXG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uKG91dCwgbSkge1xuICAgICAgICAgICAgb3V0WzBdID0gbVswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IG1bMV07XG4gICAgICAgICAgICBvdXRbMl0gPSBtWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gbVszXTtcbiAgICAgICAgICAgIG91dFs0XSA9IG1bNF07XG4gICAgICAgICAgICBvdXRbNV0gPSBtWzVdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOefqemYteebuOS5mFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTJcbiAgICAgICAgICovXG4gICAgICAgIG11bCA6IGZ1bmN0aW9uIChvdXQsIG0xLCBtMikge1xuICAgICAgICAgICAgLy8gQ29uc2lkZXIgbWF0cml4Lm11bChtLCBtMiwgbSk7XG4gICAgICAgICAgICAvLyB3aGVyZSBvdXQgaXMgdGhlIHNhbWUgYXMgbTIuXG4gICAgICAgICAgICAvLyBTbyB1c2UgdGVtcCB2YXJpYWJsZSB0byBlc2NhcGUgZXJyb3IuXG4gICAgICAgICAgICB2YXIgb3V0MCA9IG0xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdO1xuICAgICAgICAgICAgdmFyIG91dDEgPSBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXTtcbiAgICAgICAgICAgIHZhciBvdXQyID0gbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM107XG4gICAgICAgICAgICB2YXIgb3V0MyA9IG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdO1xuICAgICAgICAgICAgdmFyIG91dDQgPSBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdO1xuICAgICAgICAgICAgdmFyIG91dDUgPSBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdO1xuICAgICAgICAgICAgb3V0WzBdID0gb3V0MDtcbiAgICAgICAgICAgIG91dFsxXSA9IG91dDE7XG4gICAgICAgICAgICBvdXRbMl0gPSBvdXQyO1xuICAgICAgICAgICAgb3V0WzNdID0gb3V0MztcbiAgICAgICAgICAgIG91dFs0XSA9IG91dDQ7XG4gICAgICAgICAgICBvdXRbNV0gPSBvdXQ1O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW5s+enu+WPmOaNolxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2xhdGUgOiBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICAgICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSBhWzFdO1xuICAgICAgICAgICAgb3V0WzJdID0gYVsyXTtcbiAgICAgICAgICAgIG91dFszXSA9IGFbM107XG4gICAgICAgICAgICBvdXRbNF0gPSBhWzRdICsgdlswXTtcbiAgICAgICAgICAgIG91dFs1XSA9IGFbNV0gKyB2WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaXi+i9rOWPmOaNolxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRcbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZSA6IGZ1bmN0aW9uKG91dCwgYSwgcmFkKSB7XG4gICAgICAgICAgICB2YXIgYWEgPSBhWzBdO1xuICAgICAgICAgICAgdmFyIGFjID0gYVsyXTtcbiAgICAgICAgICAgIHZhciBhdHggPSBhWzRdO1xuICAgICAgICAgICAgdmFyIGFiID0gYVsxXTtcbiAgICAgICAgICAgIHZhciBhZCA9IGFbM107XG4gICAgICAgICAgICB2YXIgYXR5ID0gYVs1XTtcbiAgICAgICAgICAgIHZhciBzdCA9IE1hdGguc2luKHJhZCk7XG4gICAgICAgICAgICB2YXIgY3QgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgICAgICAgICBvdXRbMF0gPSBhYSAqIGN0ICsgYWIgKiBzdDtcbiAgICAgICAgICAgIG91dFsxXSA9IC1hYSAqIHN0ICsgYWIgKiBjdDtcbiAgICAgICAgICAgIG91dFsyXSA9IGFjICogY3QgKyBhZCAqIHN0O1xuICAgICAgICAgICAgb3V0WzNdID0gLWFjICogc3QgKyBjdCAqIGFkO1xuICAgICAgICAgICAgb3V0WzRdID0gY3QgKiBhdHggKyBzdCAqIGF0eTtcbiAgICAgICAgICAgIG91dFs1XSA9IGN0ICogYXR5IC0gc3QgKiBhdHg7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog57yp5pS+5Y+Y5o2iXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlIDogZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgICAgICAgICB2YXIgdnggPSB2WzBdO1xuICAgICAgICAgICAgdmFyIHZ5ID0gdlsxXTtcbiAgICAgICAgICAgIG91dFswXSA9IGFbMF0gKiB2eDtcbiAgICAgICAgICAgIG91dFsxXSA9IGFbMV0gKiB2eTtcbiAgICAgICAgICAgIG91dFsyXSA9IGFbMl0gKiB2eDtcbiAgICAgICAgICAgIG91dFszXSA9IGFbM10gKiB2eTtcbiAgICAgICAgICAgIG91dFs0XSA9IGFbNF0gKiB2eDtcbiAgICAgICAgICAgIG91dFs1XSA9IGFbNV0gKiB2eTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLpgIbnn6npmLVcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICAgICAgICAgKi9cbiAgICAgICAgaW52ZXJ0IDogZnVuY3Rpb24ob3V0LCBhKSB7XG5cbiAgICAgICAgICAgIHZhciBhYSA9IGFbMF07XG4gICAgICAgICAgICB2YXIgYWMgPSBhWzJdO1xuICAgICAgICAgICAgdmFyIGF0eCA9IGFbNF07XG4gICAgICAgICAgICB2YXIgYWIgPSBhWzFdO1xuICAgICAgICAgICAgdmFyIGFkID0gYVszXTtcbiAgICAgICAgICAgIHZhciBhdHkgPSBhWzVdO1xuXG4gICAgICAgICAgICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG4gICAgICAgICAgICBpZiAoIWRldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgICAgICAgICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgICAgICAgICAgIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgICAgICAgICAgIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgICAgICAgICAgIG91dFszXSA9IGFhICogZGV0O1xuICAgICAgICAgICAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICAgICAgICAgICAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1hdHJpeDtcblxuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL216aWNjYXJkL25vZGUtdGltc29ydFxuXG4gICAgdmFyIERFRkFVTFRfTUlOX01FUkdFID0gMzI7XG5cbiAgICB2YXIgREVGQVVMVF9NSU5fR0FMTE9QSU5HID0gNztcblxuICAgIHZhciBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCA9IDI1NjtcblxuICAgIGZ1bmN0aW9uIG1pblJ1bkxlbmd0aChuKSB7XG4gICAgICAgIHZhciByID0gMDtcblxuICAgICAgICB3aGlsZSAobiA+PSBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgICAgICAgICAgciB8PSBuICYgMTtcbiAgICAgICAgICAgIG4gPj49IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbiArIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKSB7XG4gICAgICAgIHZhciBydW5IaSA9IGxvICsgMTtcblxuICAgICAgICBpZiAocnVuSGkgPT09IGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycmF5W3J1bkhpKytdLCBhcnJheVtsb10pIDwgMCkge1xuICAgICAgICAgICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgIHJ1bkhpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldmVyc2VSdW4oYXJyYXksIGxvLCBydW5IaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bkhpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnVuSGkgLSBsbztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXZlcnNlUnVuKGFycmF5LCBsbywgaGkpIHtcbiAgICAgICAgaGktLTtcblxuICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgICAgdmFyIHQgPSBhcnJheVtsb107XG4gICAgICAgICAgICBhcnJheVtsbysrXSA9IGFycmF5W2hpXTtcbiAgICAgICAgICAgIGFycmF5W2hpLS1dID0gdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgc3RhcnQsIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBsbykge1xuICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBzdGFydCA8IGhpOyBzdGFydCsrKSB7XG4gICAgICAgICAgICB2YXIgcGl2b3QgPSBhcnJheVtzdGFydF07XG5cbiAgICAgICAgICAgIHZhciBsZWZ0ID0gbG87XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBzdGFydDtcbiAgICAgICAgICAgIHZhciBtaWQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICBtaWQgPSBsZWZ0ICsgcmlnaHQgPj4+IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShwaXZvdCwgYXJyYXlbbWlkXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbiA9IHN0YXJ0IC0gbGVmdDtcblxuICAgICAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgM10gPSBhcnJheVtsZWZ0ICsgMl07XG5cbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2xlZnQgKyAyXSA9IGFycmF5W2xlZnQgKyAxXTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIDFdID0gYXJyYXlbbGVmdF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIG5dID0gYXJyYXlbbGVmdCArIG4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVtsZWZ0XSA9IHBpdm90O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2FsbG9wTGVmdCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pID4gMCkge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICAgICAgICAgIG9mZnNldCArPSBoaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDw9IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RPZmZzZXQrKztcbiAgICAgICAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pID4gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnYWxsb3BSaWdodCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludF0pIDwgMCkge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0T2Zmc2V0Kys7XG5cbiAgICAgICAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pIDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIG1pbkdhbGxvcCA9IERFRkFVTFRfTUlOX0dBTExPUElORztcbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgIHZhciB0bXBTdG9yYWdlTGVuZ3RoID0gREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEg7XG4gICAgICAgIHZhciBzdGFja0xlbmd0aCA9IDA7XG4gICAgICAgIHZhciBydW5TdGFydDtcbiAgICAgICAgdmFyIHJ1bkxlbmd0aDtcbiAgICAgICAgdmFyIHN0YWNrU2l6ZSA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAyICogREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRtcFN0b3JhZ2VMZW5ndGggPSBsZW5ndGggPj4+IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wID0gW107XG5cbiAgICAgICAgc3RhY2tMZW5ndGggPSBsZW5ndGggPCAxMjAgPyA1IDogbGVuZ3RoIDwgMTU0MiA/IDEwIDogbGVuZ3RoIDwgMTE5MTUxID8gMTkgOiA0MDtcblxuICAgICAgICBydW5TdGFydCA9IFtdO1xuICAgICAgICBydW5MZW5ndGggPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBwdXNoUnVuKF9ydW5TdGFydCwgX3J1bkxlbmd0aCkge1xuICAgICAgICAgICAgcnVuU3RhcnRbc3RhY2tTaXplXSA9IF9ydW5TdGFydDtcbiAgICAgICAgICAgIHJ1bkxlbmd0aFtzdGFja1NpemVdID0gX3J1bkxlbmd0aDtcbiAgICAgICAgICAgIHN0YWNrU2l6ZSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VSdW5zKCkge1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgICAgICAgICBpZiAobiA+PSAxICYmIHJ1bkxlbmd0aFtuIC0gMV0gPD0gcnVuTGVuZ3RoW25dICsgcnVuTGVuZ3RoW24gKyAxXSB8fCBuID49IDIgJiYgcnVuTGVuZ3RoW24gLSAyXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydW5MZW5ndGhbbiAtIDFdIDwgcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bkxlbmd0aFtuXSA+IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lcmdlQXQobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmb3JjZU1lcmdlUnVucygpIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzdGFja1NpemUgLSAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKG4gPiAwICYmIHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZXJnZUF0KG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VBdChpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQxID0gcnVuU3RhcnRbaV07XG4gICAgICAgICAgICB2YXIgbGVuZ3RoMSA9IHJ1bkxlbmd0aFtpXTtcbiAgICAgICAgICAgIHZhciBzdGFydDIgPSBydW5TdGFydFtpICsgMV07XG4gICAgICAgICAgICB2YXIgbGVuZ3RoMiA9IHJ1bkxlbmd0aFtpICsgMV07XG5cbiAgICAgICAgICAgIHJ1bkxlbmd0aFtpXSA9IGxlbmd0aDEgKyBsZW5ndGgyO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gc3RhY2tTaXplIC0gMykge1xuICAgICAgICAgICAgICAgIHJ1blN0YXJ0W2kgKyAxXSA9IHJ1blN0YXJ0W2kgKyAyXTtcbiAgICAgICAgICAgICAgICBydW5MZW5ndGhbaSArIDFdID0gcnVuTGVuZ3RoW2kgKyAyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhY2tTaXplLS07XG5cbiAgICAgICAgICAgIHZhciBrID0gZ2FsbG9wUmlnaHQoYXJyYXlbc3RhcnQyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG4gICAgICAgICAgICBzdGFydDEgKz0gaztcbiAgICAgICAgICAgIGxlbmd0aDEgLT0gaztcblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlbmd0aDIgPSBnYWxsb3BMZWZ0KGFycmF5W3N0YXJ0MSArIGxlbmd0aDEgLSAxXSwgYXJyYXksIHN0YXJ0MiwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPD0gbGVuZ3RoMikge1xuICAgICAgICAgICAgICAgIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQxICsgaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJzb3IxID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJzb3IyID0gc3RhcnQyO1xuICAgICAgICAgICAgdmFyIGRlc3QgPSBzdGFydDE7XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuICAgICAgICAgICAgdmFyIGNvdW50MSwgY291bnQyLCBleGl0O1xuXG4gICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG4gICAgICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGFycmF5W2N1cnNvcjJdLCB0bXBbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IGdhbGxvcFJpZ2h0KGFycmF5W2N1cnNvcjJdLCB0bXAsIGN1cnNvcjEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3QgKz0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yMSArPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb3VudDIgPSBnYWxsb3BMZWZ0KHRtcFtjdXJzb3IxXSwgYXJyYXksIGN1cnNvcjIsIGxlbmd0aDIsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCArPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IyICs9IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPCAxICYmIChtaW5HYWxsb3AgPSAxKTtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignbWVyZ2VMb3cgcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZUhpZ2ggKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDIgKyBpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnNvcjEgPSBzdGFydDEgKyBsZW5ndGgxIC0gMTtcbiAgICAgICAgICAgIHZhciBjdXJzb3IyID0gbGVuZ3RoMiAtIDE7XG4gICAgICAgICAgICB2YXIgZGVzdCA9IHN0YXJ0MiArIGxlbmd0aDIgLSAxO1xuICAgICAgICAgICAgdmFyIGN1c3RvbUN1cnNvciA9IDA7XG4gICAgICAgICAgICB2YXIgY3VzdG9tRGVzdCA9IDA7XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICAgICAgICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudDEgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudDIgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBleGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKHRtcFtjdXJzb3IyXSwgYXJyYXlbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IF9taW5HYWxsb3ApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDEgPSBsZW5ndGgxIC0gZ2FsbG9wUmlnaHQodG1wW2N1cnNvcjJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCBsZW5ndGgxIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCAtPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGNvdW50MSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IGxlbmd0aDIgLSBnYWxsb3BMZWZ0KGFycmF5W2N1cnNvcjFdLCB0bXAsIDAsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0IC09IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjIgLT0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IyICsgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gdG1wW2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuXG4gICAgICAgICAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgICAgICAgICAgIG1pbkdhbGxvcCA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUhpZ2ggcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tZXJnZVJ1bnMgPSBtZXJnZVJ1bnM7XG4gICAgICAgIHRoaXMuZm9yY2VNZXJnZVJ1bnMgPSBmb3JjZU1lcmdlUnVucztcbiAgICAgICAgdGhpcy5wdXNoUnVuID0gcHVzaFJ1bjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzb3J0KGFycmF5LCBjb21wYXJlLCBsbywgaGkpIHtcbiAgICAgICAgaWYgKCFsbykge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGkpIHtcbiAgICAgICAgICAgIGhpID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGhpIC0gbG87XG5cbiAgICAgICAgaWYgKHJlbWFpbmluZyA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBydW5MZW5ndGggPSAwO1xuXG4gICAgICAgIGlmIChyZW1haW5pbmcgPCBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgICAgICAgICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcbiAgICAgICAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRzID0gbmV3IFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpO1xuXG4gICAgICAgIHZhciBtaW5SdW4gPSBtaW5SdW5MZW5ndGgocmVtYWluaW5nKTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgICAgICAgICAgaWYgKHJ1bkxlbmd0aCA8IG1pblJ1bikge1xuICAgICAgICAgICAgICAgIHZhciBmb3JjZSA9IHJlbWFpbmluZztcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UgPiBtaW5SdW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2UgPSBtaW5SdW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGxvICsgZm9yY2UsIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgICAgICAgICAgICBydW5MZW5ndGggPSBmb3JjZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHMucHVzaFJ1bihsbywgcnVuTGVuZ3RoKTtcbiAgICAgICAgICAgIHRzLm1lcmdlUnVucygpO1xuXG4gICAgICAgICAgICByZW1haW5pbmcgLT0gcnVuTGVuZ3RoO1xuICAgICAgICAgICAgbG8gKz0gcnVuTGVuZ3RoO1xuICAgICAgICB9IHdoaWxlIChyZW1haW5pbmcgIT09IDApO1xuXG4gICAgICAgIHRzLmZvcmNlTWVyZ2VSdW5zKCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG4gICAgLy8g55So5LqO5aSE55CGbWVyZ2Xml7bml6Dms5XpgY3ljoZEYXRl562J5a+56LGh55qE6Zeu6aKYXG4gICAgdmFyIEJVSUxUSU5fT0JKRUNUID0ge1xuICAgICAgICAnW29iamVjdCBGdW5jdGlvbl0nOiAxLFxuICAgICAgICAnW29iamVjdCBSZWdFeHBdJzogMSxcbiAgICAgICAgJ1tvYmplY3QgRGF0ZV0nOiAxLFxuICAgICAgICAnW29iamVjdCBFcnJvcl0nOiAxLFxuICAgICAgICAnW29iamVjdCBDYW52YXNHcmFkaWVudF0nOiAxLFxuICAgICAgICAnW29iamVjdCBDYW52YXNQYXR0ZXJuXSc6IDEsXG4gICAgICAgIC8vIEZvciBub2RlLWNhbnZhc1xuICAgICAgICAnW29iamVjdCBJbWFnZV0nOiAxLFxuICAgICAgICAnW29iamVjdCBDYW52YXNdJzogMVxuICAgIH07XG5cbiAgICB2YXIgVFlQRURfQVJSQVkgPSB7XG4gICAgICAgICdbb2JqZWN0IEludDhBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBVaW50OEFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc6IDFcbiAgICB9O1xuXG4gICAgdmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuICAgIHZhciBuYXRpdmVGb3JFYWNoID0gYXJyYXlQcm90by5mb3JFYWNoO1xuICAgIHZhciBuYXRpdmVGaWx0ZXIgPSBhcnJheVByb3RvLmZpbHRlcjtcbiAgICB2YXIgbmF0aXZlU2xpY2UgPSBhcnJheVByb3RvLnNsaWNlO1xuICAgIHZhciBuYXRpdmVNYXAgPSBhcnJheVByb3RvLm1hcDtcbiAgICB2YXIgbmF0aXZlUmVkdWNlID0gYXJyYXlQcm90by5yZWR1Y2U7XG5cbiAgICAvKipcbiAgICAgKiBUaG9zZSBkYXRhIHR5cGVzIGNhbiBiZSBjbG9uZWQ6XG4gICAgICogICAgIFBsYWluIG9iamVjdCwgQXJyYXksIFR5cGVkQXJyYXksIG51bWJlciwgc3RyaW5nLCBudWxsLCB1bmRlZmluZWQuXG4gICAgICogVGhvc2UgZGF0YSB0eXBlcyB3aWxsIGJlIGFzc2dpbmVkIHVzaW5nIHRoZSBvcmdpbmFsIGRhdGE6XG4gICAgICogICAgIEJVSUxUSU5fT0JKRUNUXG4gICAgICogSW5zdGFuY2Ugb2YgdXNlciBkZWZpbmVkIGNsYXNzIHdpbGwgYmUgY2xvbmVkIHRvIGEgcGxhaW4gb2JqZWN0LCB3aXRob3V0XG4gICAgICogcHJvcGVydGllcyBpbiBwcm90b3R5cGUuXG4gICAgICogT3RoZXIgZGF0YSB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkIChub3Qgc3VyZSB3aGF0IHdpbGwgaGFwcGVuKS5cbiAgICAgKlxuICAgICAqIENhdXRpb246IGRvIG5vdCBzdXBwb3J0IGNsb25lIERhdGUsIGZvciBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9uLlxuICAgICAqIChUaGVyZSBtaWdodCBiZSBhIGxhcmdlIG51bWJlciBvZiBkYXRlIGluIGBzZXJpZXMuZGF0YWApLlxuICAgICAqIFNvIGRhdGUgc2hvdWxkIG5vdCBiZSBtb2RpZmllZCBpbiBhbmQgb3V0IG9mIGVjaGFydHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEByZXR1cm4geyp9IG5ld1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlID09IG51bGwgfHwgdHlwZW9mIHNvdXJjZSAhPSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBzb3VyY2U7XG4gICAgICAgIHZhciB0eXBlU3RyID0gb2JqVG9TdHJpbmcuY2FsbChzb3VyY2UpO1xuXG4gICAgICAgIGlmICh0eXBlU3RyID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBjbG9uZShzb3VyY2VbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFRZUEVEX0FSUkFZW3R5cGVTdHJdKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzb3VyY2UuY29uc3RydWN0b3IuZnJvbShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFCVUlMVElOX09CSkVDVFt0eXBlU3RyXSAmJiAhaXNEb20oc291cmNlKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmUoc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkge1xuICAgICAgICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcbiAgICAgICAgLy8gYW5kIGVudGVyIGZvciAuLi4gaW4gLi4uXG4gICAgICAgIGlmICghaXNPYmplY3Qoc291cmNlKSB8fCAhaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJ3cml0ZSA/IGNsb25lKHNvdXJjZSkgOiB0YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0UHJvcCA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgaXNPYmplY3QodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQXJyYXkoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQXJyYXkodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzRG9tKHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0RvbSh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNCdWlsZEluT2JqZWN0KHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0J1aWxkSW5PYmplY3QodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c6ZyA6KaB6YCS5b2S6KaG55uW77yM5bCx6YCS5b2S6LCD55SobWVyZ2VcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2UodGFyZ2V0UHJvcCwgc291cmNlUHJvcCwgb3ZlcndyaXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3ZlcndyaXRlIHx8ICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5ZCm5YiZ5Y+q5aSE55CGb3ZlcndyaXRl5Li6dHJ1Ze+8jOaIluiAheWcqOebruagh+WvueixoeS4reayoeacieatpOWxnuaAp+eahOaDheWGtVxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RF77yM5ZyoIHRhcmdldFtrZXldIOS4jeWtmOWcqOeahOaXtuWAmeS5n+aYr+ebtOaOpeimhuebllxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldEFuZFNvdXJjZXMgVGhlIGZpcnN0IGl0ZW0gaXMgdGFyZ2V0LCBhbmQgdGhlIHJlc3RzIGFyZSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXVxuICAgICAqIEByZXR1cm4geyp9IHRhcmdldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlQWxsKHRhcmdldEFuZFNvdXJjZXMsIG92ZXJ3cml0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0QW5kU291cmNlc1swXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHRhcmdldEFuZFNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG1lcmdlKHJlc3VsdCwgdGFyZ2V0QW5kU291cmNlc1tpXSwgb3ZlcndyaXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlXG4gICAgICogQHBhcmFtIHtib29sZW59IFtvdmVybGF5PWZhbHNlXVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSlcbiAgICAgICAgICAgICAgICAmJiAob3ZlcmxheSA/IHNvdXJjZVtrZXldICE9IG51bGwgOiB0YXJnZXRba2V5XSA9PSBudWxsKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH1cbiAgICAvLyBGSVhNRVxuICAgIHZhciBfY3R4O1xuICAgIGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgICAgIGlmICghX2N0eCkge1xuICAgICAgICAgICAgLy8gVXNlIHV0aWwuY3JlYXRlQ2FudmFzIGluc3RlYWQgb2YgY3JlYXRlQ2FudmFzXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGNyZWF0ZUNhbnZhcyBtYXkgYmUgb3ZlcndyaXR0ZW4gaW4gZGlmZmVyZW50IGVudmlyb25tZW50XG4gICAgICAgICAgICBfY3R4ID0gdXRpbC5jcmVhdGVDYW52YXMoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfY3R4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOafpeivouaVsOe7hOS4reWFg+e0oOeahGluZGV4XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKGFycmF5LmluZGV4T2YpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5p6E6YCg57G757un5om/5YWz57O7XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZUNsYXp6IOWfuuexu1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcbiAgICAgICAgdmFyIGNsYXp6UHJvdG90eXBlID0gY2xhenoucHJvdG90eXBlO1xuICAgICAgICBmdW5jdGlvbiBGKCkge31cbiAgICAgICAgRi5wcm90b3R5cGUgPSBiYXNlQ2xhenoucHJvdG90eXBlO1xuICAgICAgICBjbGF6ei5wcm90b3R5cGUgPSBuZXcgRigpO1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gY2xhenpQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wXSA9IGNsYXp6UHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGNsYXp6LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNsYXp6O1xuICAgICAgICBjbGF6ei5zdXBlckNsYXNzID0gYmFzZUNsYXp6O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHNvcmNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvdmVybGF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4odGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgICAgICAgdGFyZ2V0ID0gJ3Byb3RvdHlwZScgaW4gdGFyZ2V0ID8gdGFyZ2V0LnByb3RvdHlwZSA6IHRhcmdldDtcbiAgICAgICAgc291cmNlID0gJ3Byb3RvdHlwZScgaW4gc291cmNlID8gc291cmNlLnByb3RvdHlwZSA6IHNvdXJjZTtcblxuICAgICAgICBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UoZGF0YSkge1xuICAgICAgICBpZiAoISBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhLmxlbmd0aCA9PSAnbnVtYmVyJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4TmiJblr7nosaHpgY3ljoZcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYWNoKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICAgICAgb2JqLmZvckVhY2goY2IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4TmmKDlsIRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLm1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoubWFwKGNiLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFttZW1vXVxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKG9iaiwgY2IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoucmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5yZWR1Y2UoY2IsIG1lbW8sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG1lbW8gPSBjYi5jYWxsKGNvbnRleHQsIG1lbW8sIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pWw57uE6L+H5rukXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIob2JqLCBjYiwgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5maWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmZpbHRlcihjYiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9ialtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaVsOe7hOmhueafpeaJvlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kKGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBTdHJpbmddJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAoISF2YWx1ZSAmJiB0eXBlID09ICdvYmplY3QnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCdWlsZEluT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhIUJVSUxUSU5fT0JKRUNUW29ialRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEb20odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICYmIHR5cGVvZiB2YWx1ZS5ub2RlVHlwZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICYmIHR5cGVvZiB2YWx1ZS5vd25lckRvY3VtZW50ID09PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGlzIGV4YWN0bHkgTmFOLiBOb3RpY2UgaXNOYU4oJ2EnKSByZXR1cm5zIHRydWUuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXFOYU4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB2YWx1ZTEgaXMgbm90IG51bGwsIHRoZW4gcmV0dXJuIHZhbHVlMSwgb3RoZXJ3aXNlIGp1ZGdldCByZXN0IG9mIHZhbHVlcy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZSh2YWx1ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRJbmRleFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKCkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24uY2FsbC5hcHBseShuYXRpdmVTbGljZSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1dGlsID0ge1xuICAgICAgICBpbmhlcml0czogaW5oZXJpdHMsXG4gICAgICAgIG1peGluOiBtaXhpbixcbiAgICAgICAgY2xvbmU6IGNsb25lLFxuICAgICAgICBtZXJnZTogbWVyZ2UsXG4gICAgICAgIG1lcmdlQWxsOiBtZXJnZUFsbCxcbiAgICAgICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICAgICAgZ2V0Q29udGV4dDogZ2V0Q29udGV4dCxcbiAgICAgICAgY3JlYXRlQ2FudmFzOiBjcmVhdGVDYW52YXMsXG4gICAgICAgIGluZGV4T2Y6IGluZGV4T2YsXG4gICAgICAgIHNsaWNlOiBzbGljZSxcbiAgICAgICAgZmluZDogZmluZCxcbiAgICAgICAgaXNBcnJheUxpa2U6IGlzQXJyYXlMaWtlLFxuICAgICAgICBlYWNoOiBlYWNoLFxuICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgcmVkdWNlOiByZWR1Y2UsXG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICBiaW5kOiBiaW5kLFxuICAgICAgICBjdXJyeTogY3VycnksXG4gICAgICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICAgICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgICAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgICAgICBpc0J1aWxkSW5PYmplY3Q6IGlzQnVpbGRJbk9iamVjdCxcbiAgICAgICAgaXNEb206IGlzRG9tLFxuICAgICAgICBlcU5hTjogZXFOYU4sXG4gICAgICAgIHJldHJpZXZlOiByZXRyaWV2ZSxcbiAgICAgICAgYXNzZXJ0OiBhc3NlcnQsXG4gICAgICAgIG5vb3A6IGZ1bmN0aW9uICgpIHt9XG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG5cbiIsIlxuICAgIHZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IEFycmF5XG4gICAgICAgIDogRmxvYXQzMkFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gVmVjdG9yMlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIOS6jOe7tOWQkemHj+exu1xuICAgICAqIEBleHBvcnRzIHpyZW5kZXIvdG9vbC92ZWN0b3JcbiAgICAgKi9cbiAgICB2YXIgdmVjdG9yID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5Yib5bu65LiA5Liq5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuICAgICAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0WzBdID0geDtcbiAgICAgICAgICAgIG91dFsxXSA9IHk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlpI3liLblkJHph4/mlbDmja5cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb3B5OiBmdW5jdGlvbiAob3V0LCB2KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2WzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWFi+mahuS4gOS4quWQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG4gICAgICAgICAgICBvdXRbMF0gPSB2WzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWQkemHj+eahOS4pOS4qumhuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfSDnu5PmnpxcbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgICAgICAgICAgb3V0WzBdID0gYTtcbiAgICAgICAgICAgIG91dFsxXSA9IGI7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nm7jliqBcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKyB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICsgdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nvKnmlL7lkI7nm7jliqBcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZUFuZEFkZDogZnVuY3Rpb24gKG91dCwgdjEsIHYyLCBhKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSArIHYyWzBdICogYTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICsgdjJbMV0gKiBhO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP55u45YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgc3ViOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdIC0gdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSAtIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6ZW/5bqmXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsZW46IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuU3F1YXJlKHYpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6ZW/5bqm5bmz5pa5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsZW5TcXVhcmU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdlswXSAqIHZbMF0gKyB2WzFdICogdlsxXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP5LmY5rOVXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdICogdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSAqIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6Zmk5rOVXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgZGl2OiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdIC8gdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSAvIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP54K55LmYXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBkb3Q6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgICAgIHJldHVybiB2MVswXSAqIHYyWzBdICsgdjFbMV0gKiB2MlsxXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP57yp5pS+XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc1xuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uIChvdXQsIHYsIHMpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHZbMF0gKiBzO1xuICAgICAgICAgICAgb3V0WzFdID0gdlsxXSAqIHM7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/lvZLkuIDljJZcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqL1xuICAgICAgICBub3JtYWxpemU6IGZ1bmN0aW9uIChvdXQsIHYpIHtcbiAgICAgICAgICAgIHZhciBkID0gdmVjdG9yLmxlbih2KTtcbiAgICAgICAgICAgIGlmIChkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgb3V0WzBdID0gMDtcbiAgICAgICAgICAgICAgICBvdXRbMV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0WzBdID0gdlswXSAvIGQ7XG4gICAgICAgICAgICAgICAgb3V0WzFdID0gdlsxXSAvIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorqHnrpflkJHph4/pl7Tot53nprtcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgICh2MVswXSAtIHYyWzBdKSAqICh2MVswXSAtIHYyWzBdKVxuICAgICAgICAgICAgICAgICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/ot53nprvlubPmlrlcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGRpc3RhbmNlU3F1YXJlOiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgICAgICByZXR1cm4gKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pXG4gICAgICAgICAgICAgICAgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxgui0n+WQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICovXG4gICAgICAgIG5lZ2F0ZTogZnVuY3Rpb24gKG91dCwgdikge1xuICAgICAgICAgICAgb3V0WzBdID0gLXZbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSAtdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaPkuWAvOS4pOS4queCuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRcbiAgICAgICAgICovXG4gICAgICAgIGxlcnA6IGZ1bmN0aW9uIChvdXQsIHYxLCB2MiwgdCkge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKyB0ICogKHYyWzBdIC0gdjFbMF0pO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKyB0ICogKHYyWzFdIC0gdjFbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog55+p6Zi15bem5LmY5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG1cbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5VHJhbnNmb3JtOiBmdW5jdGlvbiAob3V0LCB2LCBtKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHZbMF07XG4gICAgICAgICAgICB2YXIgeSA9IHZbMV07XG4gICAgICAgICAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgICAgICAgICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxguS4pOS4quWQkemHj+acgOWwj+WAvFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIG1pbjogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBNYXRoLm1pbih2MVswXSwgdjJbMF0pO1xuICAgICAgICAgICAgb3V0WzFdID0gTWF0aC5taW4odjFbMV0sIHYyWzFdKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLkuKTkuKrlkJHph4/mnIDlpKflgLxcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBtYXg6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gTWF0aC5tYXgodjFbMF0sIHYyWzBdKTtcbiAgICAgICAgICAgIG91dFsxXSA9IE1hdGgubWF4KHYxWzFdLCB2MlsxXSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZlY3Rvci5sZW5ndGggPSB2ZWN0b3IubGVuO1xuICAgIHZlY3Rvci5sZW5ndGhTcXVhcmUgPSB2ZWN0b3IubGVuU3F1YXJlO1xuICAgIHZlY3Rvci5kaXN0ID0gdmVjdG9yLmRpc3RhbmNlO1xuICAgIHZlY3Rvci5kaXN0U3F1YXJlID0gdmVjdG9yLmRpc3RhbmNlU3F1YXJlO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB2ZWN0b3I7XG5cbiIsIlxuXG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi4vbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi4vY29yZS9lbnYnKTtcbiAgICB2YXIgR2VzdHVyZU1nciA9IHJlcXVpcmUoJy4uL2NvcmUvR2VzdHVyZU1ncicpO1xuXG4gICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBldmVudFRvb2wuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV2ZW50VG9vbC5yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIHZhciBub3JtYWxpemVFdmVudCA9IGV2ZW50VG9vbC5ub3JtYWxpemVFdmVudDtcblxuICAgIHZhciBUT1VDSF9DTElDS19ERUxBWSA9IDMwMDtcblxuICAgIHZhciBtb3VzZUhhbmRsZXJOYW1lcyA9IFtcbiAgICAgICAgJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLFxuICAgICAgICAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J1xuICAgIF07XG5cbiAgICB2YXIgdG91Y2hIYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSdcbiAgICBdO1xuXG4gICAgdmFyIHBvaW50ZXJFdmVudE5hbWVzID0ge1xuICAgICAgICBwb2ludGVyZG93bjogMSwgcG9pbnRlcnVwOiAxLCBwb2ludGVybW92ZTogMSwgcG9pbnRlcm91dDogMVxuICAgIH07XG5cbiAgICB2YXIgcG9pbnRlckhhbmRsZXJOYW1lcyA9IHpyVXRpbC5tYXAobW91c2VIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBubSA9IG5hbWUucmVwbGFjZSgnbW91c2UnLCAncG9pbnRlcicpO1xuICAgICAgICByZXR1cm4gcG9pbnRlckV2ZW50TmFtZXNbbm1dID8gbm0gOiBuYW1lO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZXZlbnROYW1lRml4KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChuYW1lID09PSAnbW91c2V3aGVlbCcgJiYgZW52LmJyb3dzZXIuZmlyZWZveCkgPyAnRE9NTW91c2VTY3JvbGwnIDogbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzR2VzdHVyZShwcm94eSwgZXZlbnQsIHN0YWdlKSB7XG4gICAgICAgIHZhciBnZXN0dXJlTWdyID0gcHJveHkuX2dlc3R1cmVNZ3I7XG5cbiAgICAgICAgc3RhZ2UgPT09ICdzdGFydCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuXG4gICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IGdlc3R1cmVNZ3IucmVjb2duaXplKFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBwcm94eS5oYW5kbGVyLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCksXG4gICAgICAgICAgICBwcm94eS5kb21cbiAgICAgICAgKTtcblxuICAgICAgICBzdGFnZSA9PT0gJ2VuZCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuXG4gICAgICAgIC8vIERvIG5vdCBkbyBhbnkgcHJldmVudERlZmF1bHQgaGVyZS4gVXBwZXIgYXBwbGljYXRpb24gZG8gdGhhdCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXN0dXJlSW5mby50eXBlO1xuICAgICAgICAgICAgZXZlbnQuZ2VzdHVyZUV2ZW50ID0gdHlwZTtcblxuICAgICAgICAgICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudChnZXN0dXJlSW5mby50YXJnZXQsIHR5cGUsIGdlc3R1cmVJbmZvLmV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZ1bmN0aW9uIG9uTVNHZXN0dXJlQ2hhbmdlKHByb3h5LCBldmVudCkge1xuICAgIC8vICAgICBpZiAoZXZlbnQudHJhbnNsYXRpb25YIHx8IGV2ZW50LnRyYW5zbGF0aW9uWSkge1xuICAgIC8vICAgICAgICAgLy8gbW91c2Vtb3ZlIGlzIGNhcnJpZWQgYnkgTVNHZXN0dXJlIHRvIHJlZHVjZSB0aGUgc2Vuc2l0aXZpdHkuXG4gICAgLy8gICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGV2ZW50LnRhcmdldCwgJ21vdXNlbW92ZScsIGV2ZW50KTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBpZiAoZXZlbnQuc2NhbGUgIT09IDEpIHtcbiAgICAvLyAgICAgICAgIGV2ZW50LnBpbmNoWCA9IGV2ZW50Lm9mZnNldFg7XG4gICAgLy8gICAgICAgICBldmVudC5waW5jaFkgPSBldmVudC5vZmZzZXRZO1xuICAgIC8vICAgICAgICAgZXZlbnQucGluY2hTY2FsZSA9IGV2ZW50LnNjYWxlO1xuICAgIC8vICAgICAgICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudChldmVudC50YXJnZXQsICdwaW5jaCcsIGV2ZW50KTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cblxuICAgIC8qKlxuICAgICAqIFByZXZlbnQgbW91c2UgZXZlbnQgZnJvbSBiZWluZyBkaXNwYXRjaGVkIGFmdGVyIFRvdWNoIEV2ZW50cyBhY3Rpb25cbiAgICAgKiBAc2VlIDxodHRwczovL2dpdGh1Yi5jb20vZGVsdGFrb3NoL2hhbmRqcy9ibG9iL21hc3Rlci9zcmMvaGFuZC5iYXNlLmpzPlxuICAgICAqIDEuIE1vYmlsZSBicm93c2VycyBkaXNwYXRjaCBtb3VzZSBldmVudHMgMzAwbXMgYWZ0ZXIgdG91Y2hlbmQuXG4gICAgICogMi4gQ2hyb21lIGZvciBBbmRyb2lkIGRpc3BhdGNoIG1vdXNlZG93biBmb3IgbG9uZy10b3VjaCBhYm91dCA2NTBtc1xuICAgICAqIFJlc3VsdDogQmxvY2tpbmcgTW91c2UgRXZlbnRzIGZvciA3MDBtcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRUb3VjaFRpbWVyKGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLl90b3VjaGluZyA9IHRydWU7XG4gICAgICAgIGNsZWFyVGltZW91dChpbnN0YW5jZS5fdG91Y2hUaW1lcik7XG4gICAgICAgIGluc3RhbmNlLl90b3VjaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5fdG91Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgNzAwKTtcbiAgICB9XG5cblxuICAgIHZhciBkb21IYW5kbGVycyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIG1vdmUgaGFuZGxlclxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2Vtb3ZlJywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb3VzZSBvdXQgaGFuZGxlclxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICE9IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPSA5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOW/veeVpeWMheWQq+WcqHJvb3TkuK3nmoRkb23lvJXotbfnmoRtb3VzZU91dFxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ21vdXNlb3V0JywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOW8gOWni+WTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBtb3VzZSBiZWhhdmlvdXIgc2hvdWxkIG5vdCBiZSBkaXNhYmxlZCBoZXJlLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIHBhZ2UgbWF5IG5lZWRzIHRvIGJlIHNsaWRlZC5cbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgICAgICAgICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG4gICAgICAgICAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgICAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ3N0YXJ0Jyk7XG5cbiAgICAgICAgICAgIC8vIEluIHRvdWNoIGRldmljZSwgdHJpZ2dlciBgbW91c2Vtb3ZlYChgbW91c2VvdmVyYCkgc2hvdWxkXG4gICAgICAgICAgICAvLyBiZSB0cmlnZ2VyZWQsIGFuZCBtdXN0IGJlZm9yZSBgbW91c2Vkb3duYCB0cmlnZ2VyZWQuXG4gICAgICAgICAgICBkb21IYW5kbGVycy5tb3VzZW1vdmUuY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlZG93bi5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG91Y2jnp7vliqjlk43lupTlh73mlbBcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaG1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG5cbiAgICAgICAgICAgIC8vIE1hcmsgdG91Y2gsIHdoaWNoIGlzIHVzZWZ1bCBpbiBkaXN0aW5ndWlzaCB0b3VjaCBhbmRcbiAgICAgICAgICAgIC8vIG1vdXNlIGV2ZW50IGluIHVwcGVyIGFwcGxpY2F0b2luLlxuICAgICAgICAgICAgZXZlbnQuenJCeVRvdWNoID0gdHJ1ZTtcblxuICAgICAgICAgICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdjaGFuZ2UnKTtcblxuICAgICAgICAgICAgLy8gTW91c2UgbW92ZSBzaG91bGQgYWx3YXlzIGJlIHRyaWdnZXJlZCBubyBtYXR0ZXIgd2hldGhlclxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgZ2VzdHJ1ZSBldmVudCwgYmVjYXVzZSBtb3VzZSBtb3ZlIGFuZCBwaW5jaCBtYXlcbiAgICAgICAgICAgIC8vIGJlIHVzZWQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG91Y2jnu5PmnZ/lk43lupTlh73mlbBcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaGVuZDogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgICAgICAgICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG4gICAgICAgICAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuXG4gICAgICAgICAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2VuZCcpO1xuXG4gICAgICAgICAgICBkb21IYW5kbGVycy5tb3VzZXVwLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBEbyBub3QgdHJpZ2dlciBgbW91c2VvdXRgIGhlcmUsIGluIHNwaXRlIG9mIGBtb3VzZW1vdmVgKGBtb3VzZW92ZXJgKSBpc1xuICAgICAgICAgICAgLy8gdHJpZ2dlcmVkIGluIGB0b3VjaHN0YXJ0YC4gVGhpcyBzZWVtcyB0byBiZSBpbGxvZ2ljYWwsIGJ1dCBieSB0aGlzIG1lY2hhbmlzbSxcbiAgICAgICAgICAgIC8vIHdlIGNhbiBjb252ZW5pZW50bHkgaW1wbGVtZW50IFwiaG92ZXIgc3R5bGVcIiBpbiBib3RoIFBDIGFuZCB0b3VjaCBkZXZpY2UganVzdFxuICAgICAgICAgICAgLy8gYnkgbGlzdGVuaW5nIHRvIGBtb3VzZW92ZXJgIHRvIGFkZCBcImhvdmVyIHN0eWxlXCIgYW5kIGxpc3RlbmluZyB0byBgbW91c2VvdXRgXG4gICAgICAgICAgICAvLyB0byByZW1vdmUgXCJob3ZlciBzdHlsZVwiIG9uIGFuIGVsZW1lbnQsIHdpdGhvdXQgYW55IGFkZGl0aW9uYWwgY29kZSBmb3JcbiAgICAgICAgICAgIC8vIGNvbXBhdGliaWxpdHkuIChgbW91c2VvdXRgIHdpbGwgbm90IGJlIHRyaWdnZXJlZCBpbiBgdG91Y2hlbmRgLCBzbyBcImhvdmVyXG4gICAgICAgICAgICAvLyBzdHlsZVwiIHdpbGwgcmVtYWluIGZvciB1c2VyIHZpZXcpXG5cbiAgICAgICAgICAgIC8vIGNsaWNrIGV2ZW50IHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LiBTeXN0ZW0gY2xpY2sgY2FuIG5vdCBiZSBwcmV2ZW50ZWQuXG4gICAgICAgICAgICBpZiAoK25ldyBEYXRlKCkgLSB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPCBUT1VDSF9DTElDS19ERUxBWSkge1xuICAgICAgICAgICAgICAgIGRvbUhhbmRsZXJzLmNsaWNrLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvaW50ZXJkb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlZG93bi5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gaWYgKHVzZU1TR3Vlc3R1cmUodGhpcywgZXZlbnQpKSB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy5fbXNHZXN0dXJlLmFkZFBvaW50ZXIoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludGVybW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8gcG9pbnRlcm1vdmUgaXMgc28gc2Vuc2l0aXZlIHRoYXQgaXQgYWx3YXlzIHRyaWdnZXJlZCB3aGVuXG4gICAgICAgICAgICAvLyB0YXAoY2xpY2spIG9uIHRvdWNoIHNjcmVlbiwgd2hpY2ggYWZmZWN0IHNvbWUganVkZ2VtZW50IGluXG4gICAgICAgICAgICAvLyB1cHBlciBhcHBsaWNhdGlvbi4gU28sIHdlIGRvbnQgc3VwcG9ydCBtb3VzZW1vdmUgb24gTVMgdG91Y2hcbiAgICAgICAgICAgIC8vIGRldmljZSB5ZXQuXG4gICAgICAgICAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgICAgICAgICAgICBkb21IYW5kbGVycy5tb3VzZW1vdmUuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9pbnRlcnVwOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9pbnRlcm91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBwb2ludGVyb3V0IHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gdGFwIG9uIHRvdWNoIHNjcmVlblxuICAgICAgICAgICAgLy8gKElFMTErL0VkZ2Ugb24gTVMgU3VyZmFjZSkgYWZ0ZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcmVkLFxuICAgICAgICAgICAgLy8gd2hpY2ggaXMgaW5jb25zaXN0ZW50IHdpdGggdGhlIG1vdXNvdXQgYmVoYXZpb3Igd2UgZGVmaW5lZFxuICAgICAgICAgICAgLy8gaW4gdG91Y2hlbmQuIFNvIHdlIHVuaWZ5IHRoZW0uXG4gICAgICAgICAgICAvLyAoY2hlY2sgZG9tSGFuZGxlcnMudG91Y2hlbmQgZm9yIGRldGFpbGVkIGV4cGxhbmF0aW9uKVxuICAgICAgICAgICAgaWYgKCFpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2VvdXQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSB7XG4gICAgICAgIHZhciBwb2ludGVyVHlwZSA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgICAgICByZXR1cm4gcG9pbnRlclR5cGUgPT09ICdwZW4nIHx8IHBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xuICAgIH1cblxuICAgIC8vIGZ1bmN0aW9uIHVzZU1TR3Vlc3R1cmUoaGFuZGxlclByb3h5LCBldmVudCkge1xuICAgIC8vICAgICByZXR1cm4gaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSAmJiAhIWhhbmRsZXJQcm94eS5fbXNHZXN0dXJlO1xuICAgIC8vIH1cblxuICAgIC8vIENvbW1vbiBoYW5kbGVyc1xuICAgIHpyVXRpbC5lYWNoKFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2V3aGVlbCcsICdkYmxjbGljaycsICdjb250ZXh0bWVudSddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBkb21IYW5kbGVyc1tuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG5hbWUsIGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIOS4uuaOp+WItuexu+WunuS+i+WIneWni+WMlmRvbSDkuovku7blpITnkIblh73mlbBcbiAgICAgKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvSGFuZGxlcn0gaW5zdGFuY2Ug5o6n5Yi257G75a6e5L6LXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdERvbUhhbmRsZXIoaW5zdGFuY2UpIHtcbiAgICAgICAgenJVdGlsLmVhY2godG91Y2hIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB6clV0aWwuYmluZChkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICB6clV0aWwuZWFjaChwb2ludGVySGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdID0genJVdGlsLmJpbmQoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgenJVdGlsLmVhY2gobW91c2VIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSBtYWtlTW91c2VIYW5kbGVyKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VNb3VzZUhhbmRsZXIoZm4sIGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5fdG91Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBIYW5kbGVyRG9tUHJveHkoZG9tKSB7XG4gICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5kb20gPSBkb207XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdG91Y2hpbmcgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RvdWNoVGltZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0dlc3R1cmVNZ3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9nZXN0dXJlTWdyID0gbmV3IEdlc3R1cmVNZ3IoKTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuXG4gICAgICAgIGluaXREb21IYW5kbGVyKHRoaXMpO1xuXG4gICAgICAgIGlmIChlbnYucG9pbnRlckV2ZW50c1N1cHBvcnRlZCkgeyAvLyBPbmx5IElFMTErL0VkZ2VcbiAgICAgICAgICAgIC8vIDEuIE9uIGRldmljZXMgdGhhdCBib3RoIGVuYWJsZSB0b3VjaCBhbmQgbW91c2UgKGUuZy4sIE1TIFN1cmZhY2UgYW5kIGxlbm92byBYMjQwKSxcbiAgICAgICAgICAgIC8vIElFMTErL0VkZ2UgZG8gbm90IHRyaWdnZXIgdG91Y2ggZXZlbnQsIGJ1dCB0cmlnZ2VyIHBvaW50ZXIgZXZlbnQgYW5kIG1vdXNlIGV2ZW50XG4gICAgICAgICAgICAvLyBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgICAgLy8gMi4gT24gTVMgU3VyZmFjZSwgaXQgcHJvYmFibGVseSBvbmx5IHRyaWdnZXIgbW91c2Vkb3duIGJ1dCBubyBtb3VzZXVwIHdoZW4gdGFwIG9uXG4gICAgICAgICAgICAvLyBzY3JlZW4sIHdoaWNoIGRvIG5vdCBvY2N1cnMgaW4gcG9pbnRlciBldmVudC5cbiAgICAgICAgICAgIC8vIFNvIHdlIHVzZSBwb2ludGVyIGV2ZW50IHRvIGJvdGggZGV0ZWN0IHRvdWNoIGdlc3R1cmUgYW5kIG1vdXNlIGJlaGF2aW9yLlxuICAgICAgICAgICAgbW91bnRIYW5kbGVycyhwb2ludGVySGFuZGxlck5hbWVzLCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIC8vIE5vdGU6IE1TIEdlc3R1cmUgcmVxdWlyZSBDU1MgdG91Y2gtYWN0aW9uIHNldC4gQnV0IHRvdWNoLWFjdGlvbiBpcyBub3QgcmVsaWFibGUsXG4gICAgICAgICAgICAvLyB3aGljaCBkb2VzIG5vdCBwcmV2ZW50IGRlZnVhdWx0IGJlaGF2aW9yIG9jY2FzaW9uYWxseSAod2hpY2ggbWF5IGNhdXNlIHZpZXcgcG9ydFxuICAgICAgICAgICAgLy8gem9vbWVkIGluIGJ1dCB1c2UgY2FuIG5vdCB6b29tIGl0IGJhY2spLiBBbmQgZXZlbnQucHJldmVudERlZmF1bHQoKSBkb2VzIG5vdCB3b3JrLlxuICAgICAgICAgICAgLy8gU28gd2UgaGF2ZSB0byBub3QgdG8gdXNlIE1TR2VzdHVyZSBhbmQgbm90IHRvIHN1cHBvcnQgdG91Y2htb3ZlIGFuZCBwaW5jaCBvbiBNU1xuICAgICAgICAgICAgLy8gdG91Y2ggc2NyZWVuLiBBbmQgd2Ugb25seSBzdXBwb3J0IGNsaWNrIGJlaGF2aW9yIG9uIE1TIHRvdWNoIHNjcmVlbiBub3cuXG5cbiAgICAgICAgICAgIC8vIE1TIEdlc3R1cmUgRXZlbnQgaXMgb25seSBzdXBwb3J0ZWQgb24gSUUxMSsvRWRnZSBhbmQgb24gV2luZG93cyA4Ky5cbiAgICAgICAgICAgIC8vIFdlIGRvbnQgc3VwcG9ydCB0b3VjaCBvbiBJRSBvbiB3aW43LlxuICAgICAgICAgICAgLy8gU2VlIDxodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RuNDMzMjQzKHY9dnMuODUpLmFzcHg+XG4gICAgICAgICAgICAvLyBpZiAodHlwZW9mIE1TR2VzdHVyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gICAgICh0aGlzLl9tc0dlc3R1cmUgPSBuZXcgTVNHZXN0dXJlKCkpLnRhcmdldCA9IGRvbTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICAvLyAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ01TR2VzdHVyZUNoYW5nZScsIG9uTVNHZXN0dXJlQ2hhbmdlKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlbnYudG91Y2hFdmVudHNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBtb3VudEhhbmRsZXJzKHRvdWNoSGFuZGxlck5hbWVzLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGVyIG9mICdtb3VzZW91dCcgZXZlbnQgaXMgbmVlZGVkIGluIHRvdWNoIG1vZGUsIHdoaWNoIHdpbGwgYmUgbW91bnRlZCBiZWxvdy5cbiAgICAgICAgICAgICAgICAvLyBhZGRFdmVudExpc3RlbmVyKHJvb3QsICdtb3VzZW91dCcsIHRoaXMuX21vdXNlb3V0SGFuZGxlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDEuIENvbnNpZGVyaW5nIHNvbWUgZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSBldmVudCAobGlrZSBvbiBNUyBTdXJmYWNlXG4gICAgICAgICAgICAvLyBhbmQgbGVub3ZvIFgyNDAsIEBzZWUgIzIzNTApLCB3ZSBtYWtlIG1vdXNlIGV2ZW50IGJlIGFsd2F5cyBsaXN0ZW5lZCwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBtb3VzZSBldmVudCBjYW4gbm90IGJlIGhhbmRsZSBpbiB0aG9zZSBkZXZpY2VzLlxuICAgICAgICAgICAgLy8gMi4gT24gTVMgU3VyZmFjZSwgQ2hyb21lIHdpbGwgdHJpZ2dlciBib3RoIHRvdWNoIGV2ZW50IGFuZCBtb3VzZSBldmVudC4gSG93IHRvIHByZXZlbnRcbiAgICAgICAgICAgIC8vIG1vdXNlZXZlbnQgYWZ0ZXIgdG91Y2ggZXZlbnQgdHJpZ2dlcmVkLCBzZWUgYHNldFRvdWNoVGltZXJgLlxuICAgICAgICAgICAgbW91bnRIYW5kbGVycyhtb3VzZUhhbmRsZXJOYW1lcywgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtb3VudEhhbmRsZXJzKGhhbmRsZXJOYW1lcywgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGRvbSwgZXZlbnROYW1lRml4KG5hbWUpLCBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICAgICAgfSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZXJEb21Qcm94eVByb3RvID0gSGFuZGxlckRvbVByb3h5LnByb3RvdHlwZTtcbiAgICBoYW5kbGVyRG9tUHJveHlQcm90by5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFuZGxlck5hbWVzID0gbW91c2VIYW5kbGVyTmFtZXMuY29uY2F0KHRvdWNoSGFuZGxlck5hbWVzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBoYW5kbGVyTmFtZXNbaV07XG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZG9tLCBldmVudE5hbWVGaXgobmFtZSksIHRoaXMuX2hhbmRsZXJzW25hbWVdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBoYW5kbGVyRG9tUHJveHlQcm90by5zZXRDdXJzb3IgPSBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICAgICAgdGhpcy5kb20uc3R5bGUuY3Vyc29yID0gY3Vyc29yU3R5bGUgfHwgJ2RlZmF1bHQnO1xuICAgIH07XG5cbiAgICB6clV0aWwubWl4aW4oSGFuZGxlckRvbVByb3h5LCBFdmVudGZ1bCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbmRsZXJEb21Qcm94eTtcbiIsIi8vIENvbXBvdW5kUGF0aCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG5cblxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnLi9QYXRoJyk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXRoLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NvbXBvdW5kJyxcblxuICAgICAgICBzaGFwZToge1xuXG4gICAgICAgICAgICBwYXRoczogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVQYXRoRGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkaXJ0eVBhdGggPSB0aGlzLl9fZGlydHlQYXRoO1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5zaGFwZS5wYXRocztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIGFzIGRpcnR5IGlmIGFueSBzdWJwYXRoIGlzIGRpcnR5XG4gICAgICAgICAgICAgICAgZGlydHlQYXRoID0gZGlydHlQYXRoIHx8IHBhdGhzW2ldLl9fZGlydHlQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRoaXMuX19kaXJ0eSB8fCBkaXJ0eVBhdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmVmb3JlQnJ1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBhdGhEaXJ0eSgpO1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5zaGFwZS5wYXRocyB8fCBbXTtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwYXRoIHNjYWxlXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGF0aHNbaV0ucGF0aC5zZXRTY2FsZShzY2FsZVswXSwgc2NhbGVbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBwYXRocyA9IHNoYXBlLnBhdGhzIHx8IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhdGhzW2ldLmJ1aWxkUGF0aChjdHgsIHBhdGhzW2ldLnNoYXBlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckJydXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLnNoYXBlLnBhdGhzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhdGhzW2ldLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQYXRoRGlydHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQYXRoLnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuIiwiLyoqXG4gKiDlj6/nu5jliLbnmoTlm77lvaLln7rnsbtcbiAqIEJhc2UgY2xhc3Mgb2YgYWxsIGRpc3BsYXlhYmxlIGdyYXBoaWMgb2JqZWN0c1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqL1xuXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBTdHlsZSA9IHJlcXVpcmUoJy4vU3R5bGUnKTtcblxuICAgIHZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi4vRWxlbWVudCcpO1xuICAgIHZhciBSZWN0VGV4dCA9IHJlcXVpcmUoJy4vbWl4aW4vUmVjdFRleHQnKTtcbiAgICAvLyB2YXIgU3RhdGVmdWwgPSByZXF1aXJlKCcuL21peGluL1N0YXRlZnVsJyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL21peGluL1JlY3RUZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gRGlzcGxheWFibGUob3B0cykge1xuXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICAvLyBFeHRlbmQgcHJvcGVydGllc1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wdHMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBvcHRzLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgICAgICAgICAgbmFtZSAhPT0gJ3N0eWxlJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IG9wdHNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9wdHMuc3R5bGUpO1xuXG4gICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgICAgICAvLyBTaGFwZXMgZm9yIGNhc2NhZGUgY2xpcHBpbmcuXG4gICAgICAgIHRoaXMuX19jbGlwUGF0aHMgPSBbXTtcblxuICAgICAgICAvLyBGSVhNRSBTdGF0ZWZ1bCBtdXN0IGJlIG1peGluZWQgYWZ0ZXIgc3R5bGUgaXMgc2V0dGVkXG4gICAgICAgIC8vIFN0YXRlZnVsLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuXG4gICAgRGlzcGxheWFibGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBEaXNwbGF5YWJsZSxcblxuICAgICAgICB0eXBlOiAnZGlzcGxheWFibGUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5YWJsZSDmmK/lkKbkuLrohI/vvIxQYWludGVyIOS4reS8muagueaNruivpeagh+iusOWIpOaWreaYr+WQpumcgOimgeaYr+WQpumcgOimgemHjeaWsOe7mOWItlxuICAgICAgICAgKiBEaXJ0eSBmbGFnLiBGcm9tIHdoaWNoIHBhaW50ZXIgd2lsbCBkZXRlcm1pbmUgaWYgdGhpcyBkaXNwbGF5YWJsZSBvYmplY3QgbmVlZHMgYnJ1c2hcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNfX2RpcnR5XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgX19kaXJ0eTogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i5piv5ZCm5Y+v6KeB77yM5Li6dHJ1ZeaXtuS4jee7mOWItuWbvuW9ou+8jOS9huaYr+S7jeiDveinpuWPkem8oOagh+S6i+S7tlxuICAgICAgICAgKiBJZiBpZ25vcmUgZHJhd2luZyBvZiB0aGUgZGlzcGxheWFibGUgb2JqZWN0LiBNb3VzZSBldmVudCB3aWxsIHN0aWxsIGJlIHRyaWdnZXJlZFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNpbnZpc2libGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpbnZpc2libGU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHo6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgejI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHrlsYJsZXZlbO+8jOWGs+Wumue7mOeUu+WcqOWTquWxgmNhbnZhc+S4rVxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6bGV2ZWxcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgemxldmVsOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblj6/mi5bmi71cbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5q2j5Zyo5ouW5ou9XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2RyYWdnYWJsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm55u45bqU6byg5qCH5LqL5Lu2XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3NpbGVudFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNpbGVudDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGVuYWJsZSBjdWxsaW5nXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgY3VsbGluZzogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIGN1cnNvciB3aGVuIGhvdmVyZWRcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjY3Vyc29yXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgaG92ZXIgYXJlYSBpcyBib3VuZGluZyByZWN0XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3JlY3RIb3ZlclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVjdEhvdmVyOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyIHRoZSBlbGVtZW50IHByb2dyZXNzaXZlbHkgd2hlbiB0aGUgdmFsdWUgPj0gMCxcbiAgICAgICAgICogdXNlZnVsbCBmb3IgbGFyZ2UgZGF0YS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHByb2dyZXNzaXZlOiAtMSxcblxuICAgICAgICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG5cbiAgICAgICAgYWZ0ZXJCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWbvuW9oue7mOWItuaWueazlVxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhczJEUmVuZGVyaW5nQ29udGV4dH0gY3R4XG4gICAgICAgICAqL1xuICAgICAgICAvLyBJbnRlcmZhY2VcbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluacgOWwj+WMheWbtOebklxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIC8vIEludGVyZmFjZVxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKTmlq3lnZDmoIcgeCwgeSDmmK/lkKblnKjlm77lvaLkuIpcbiAgICAgICAgICogSWYgZGlzcGxheWFibGUgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY3RDb250YWluKHgsIHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9oueahOWMheWbtOebkuS4ilxuICAgICAgICAgKiBJZiBib3VuZGluZyByZWN0IG9mIGVsZW1lbnQgY29udGFpbiBjb29yZCB4LCB5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHJlY3RDb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdC5jb250YWluKGNvb3JkWzBdLCBjb29yZFsxXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagh+iusOWbvuW9ouWFg+e0oOS4uuiEj++8jOW5tuS4lOWcqOS4i+S4gOW4p+mHjee7mFxuICAgICAgICAgKiBNYXJrIGRpc3BsYXlhYmxlIGVsZW1lbnQgZGlydHkgYW5kIHJlZnJlc2ggbmV4dCBmcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuXG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i5piv5ZCm5Lya6Kem5Y+R5LqL5Lu2XG4gICAgICAgICAqIElmIGRpc3BsYXlhYmxlIG9iamVjdCBiaW5kZWQgYW55IGV2ZW50XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPLCDpgJrov4cgYmluZCDnu5HlrprnmoTkuovku7ZcbiAgICAgICAgLy8gaXNTaWxlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gICAgIHJldHVybiAhKFxuICAgICAgICAvLyAgICAgICAgIHRoaXMuaG92ZXJhYmxlIHx8IHRoaXMuZHJhZ2dhYmxlXG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlbW92ZSB8fCB0aGlzLm9ubW91c2VvdmVyIHx8IHRoaXMub25tb3VzZW91dFxuICAgICAgICAvLyAgICAgICAgIHx8IHRoaXMub25tb3VzZWRvd24gfHwgdGhpcy5vbm1vdXNldXAgfHwgdGhpcy5vbmNsaWNrXG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbmRyYWdlbnRlciB8fCB0aGlzLm9uZHJhZ292ZXIgfHwgdGhpcy5vbmRyYWdsZWF2ZVxuICAgICAgICAvLyAgICAgICAgIHx8IHRoaXMub25kcm9wXG4gICAgICAgIC8vICAgICApO1xuICAgICAgICAvLyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWxpYXMgZm9yIGFuaW1hdGUoJ3N0eWxlJylcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlU3R5bGU6IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzdHlsZScsIGxvb3ApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5hdHRyS1YuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuc2V0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U3R5bGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSBnaXZlbiBzdHlsZSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvYmpcbiAgICAgICAgICovXG4gICAgICAgIHVzZVN0eWxlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9iaik7XG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhEaXNwbGF5YWJsZSwgRWxlbWVudCk7XG5cbiAgICB6clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFJlY3RUZXh0KTtcbiAgICAvLyB6clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFN0YXRlZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRGlzcGxheWFibGU7XG4iLCJcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAgICAgKi9cbiAgICB2YXIgR3JhZGllbnQgPSBmdW5jdGlvbiAoY29sb3JTdG9wcykge1xuXG4gICAgICAgIHRoaXMuY29sb3JTdG9wcyA9IGNvbG9yU3RvcHMgfHwgW107XG4gICAgfTtcblxuICAgIEdyYWRpZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR3JhZGllbnQsXG5cbiAgICAgICAgYWRkQ29sb3JTdG9wOiBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvcikge1xuICAgICAgICAgICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG5cbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JhZGllbnQ7XG4iLCIvKipcbiAqIEltYWdlIGVsZW1lbnRcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0ltYWdlXG4gKi9cblxuXG5cbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCcuL0Rpc3BsYXlhYmxlJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIExSVSA9IHJlcXVpcmUoJy4uL2NvcmUvTFJVJyk7XG4gICAgdmFyIGdsb2JhbEltYWdlQ2FjaGUgPSBuZXcgTFJVKDUwKTtcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgenJlbmRlci9ncmFwaGljL0ltYWdlXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gWkltYWdlKG9wdHMpIHtcbiAgICAgICAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9XG5cbiAgICBaSW1hZ2UucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBaSW1hZ2UsXG5cbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcblxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIHNyYyA9IHN0eWxlLmltYWdlO1xuICAgICAgICAgICAgdmFyIGltYWdlO1xuXG4gICAgICAgICAgICAvLyBNdXN0IGJpbmQgZWFjaCB0aW1lXG4gICAgICAgICAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcbiAgICAgICAgICAgIC8vIHN0eWxlLmltYWdlIGlzIGEgdXJsIHN0cmluZ1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0eWxlLmltYWdlIGlzIGFuIEhUTUxJbWFnZUVsZW1lbnQgb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgQ2FudmFzXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbWFnZSA9IHNyYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZJWE1FIENhc2UgY3JlYXRlIG1hbnkgaW1hZ2VzIHdpdGggc3JjXG4gICAgICAgICAgICBpZiAoIWltYWdlICYmIHNyYykge1xuICAgICAgICAgICAgICAgIC8vIFRyeSBnZXQgZnJvbSBnbG9iYWwgaW1hZ2UgY2FjaGVcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQoc3JjKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZEltZ09iaikge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGVkSW1nT2JqLnBlbmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmoucGVuZGluZ1tpXS5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmogPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nOiBbdGhpc11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxJbWFnZUNhY2hlLnB1dChzcmMsIGNhY2hlZEltZ09iaik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlID0gY2FjaGVkSW1nT2JqLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbWFnZSBpcyBub3QgY29tcGxldGUgZmluaXNoLCBhZGQgdG8gcGVuZGluZyBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2Uud2lkdGggfHwgIWltYWdlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW1nT2JqLnBlbmRpbmcucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgLy8g5Zu+54mH5bey57uP5Yqg6L295a6M5oiQXG4gICAgICAgICAgICAgICAgLy8gaWYgKGltYWdlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKCFpbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIEVsc2UgaXMgY2FudmFzXG5cbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBzdHlsZS53aWR0aCB8fCBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc3R5bGUuaGVpZ2h0IHx8IGltYWdlLmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgICAgICAgICAgICAgICAvLyDlm77niYfliqDovb3lpLHotKVcbiAgICAgICAgICAgICAgICBpZiAoIWltYWdlLndpZHRoIHx8ICFpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIOiuvue9rnRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cblxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zV2lkdGggJiYgc3R5bGUuc0hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSBzdHlsZS5zeCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzeCwgc3ksIHN0eWxlLnNXaWR0aCwgc3R5bGUuc0hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHdpZHRoLCBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGUuc3ggJiYgc3R5bGUuc3kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gc3R5bGUuc3g7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeSA9IHN0eWxlLnN5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc1dpZHRoID0gd2lkdGggLSBzeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNIZWlnaHQgPSBoZWlnaHQgLSBzeTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3gsIHN5LCBzV2lkdGgsIHNIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzmsqHorr7nva7lrr3lkozpq5jnmoTor53oh6rliqjmoLnmja7lm77niYflrr3pq5jorr7nva5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUud2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgICAgICAgICAgLy8gRHJhdyByZWN0IHRleHRcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgaWYgKCEgdGhpcy5fcmVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgICAgICAgICBzdHlsZS54IHx8IDAsIHN0eWxlLnkgfHwgMCwgc3R5bGUud2lkdGggfHwgMCwgc3R5bGUuaGVpZ2h0IHx8IDBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKFpJbWFnZSwgRGlzcGxheWFibGUpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBaSW1hZ2U7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJy4vR3JhZGllbnQnKTtcblxuICAgIC8qKlxuICAgICAqIHgsIHksIHgyLCB5MiBhcmUgYWxsIHBlcmNlbnQgZnJvbSAwIHRvIDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3gyPTFdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5Mj0wXVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxDb29yZD1mYWxzZV1cbiAgICAgKi9cbiAgICB2YXIgTGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgeDIsIHkyLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAgICAgICB0aGlzLnggPSB4ID09IG51bGwgPyAwIDogeDtcblxuICAgICAgICB0aGlzLnkgPSB5ID09IG51bGwgPyAwIDogeTtcblxuICAgICAgICB0aGlzLngyID0geDIgPT0gbnVsbCA/IDEgOiB4MjtcblxuICAgICAgICB0aGlzLnkyID0geTIgPT0gbnVsbCA/IDAgOiB5MjtcblxuICAgICAgICAvLyBDYW4gYmUgY2xvbmVkXG4gICAgICAgIHRoaXMudHlwZSA9ICdsaW5lYXInO1xuXG4gICAgICAgIC8vIElmIHVzZSBnbG9iYWwgY29vcmRcbiAgICAgICAgdGhpcy5nbG9iYWwgPSBnbG9iYWxDb29yZCB8fCBmYWxzZTtcblxuICAgICAgICBHcmFkaWVudC5jYWxsKHRoaXMsIGNvbG9yU3RvcHMpO1xuICAgIH07XG5cbiAgICBMaW5lYXJHcmFkaWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IExpbmVhckdyYWRpZW50XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhMaW5lYXJHcmFkaWVudCwgR3JhZGllbnQpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lYXJHcmFkaWVudDtcbiIsIi8qKlxuICogUGF0aCBlbGVtZW50XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gKi9cblxuXG5cbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCcuL0Rpc3BsYXlhYmxlJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBQYXRoUHJveHkgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpO1xuICAgIHZhciBwYXRoQ29udGFpbiA9IHJlcXVpcmUoJy4uL2NvbnRhaW4vcGF0aCcpO1xuXG4gICAgdmFyIFBhdHRlcm4gPSByZXF1aXJlKCcuL1BhdHRlcm4nKTtcbiAgICB2YXIgZ2V0Q2FudmFzUGF0dGVybiA9IFBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm47XG5cbiAgICB2YXIgYWJzID0gTWF0aC5hYnM7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGF0aChvcHRzKSB7XG4gICAgICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gICAgfVxuXG4gICAgUGF0aC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFBhdGgsXG5cbiAgICAgICAgdHlwZTogJ3BhdGgnLFxuXG4gICAgICAgIF9fZGlydHlQYXRoOiB0cnVlLFxuXG4gICAgICAgIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IDUsXG5cbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICAgICAgdmFyIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpO1xuICAgICAgICAgICAgdmFyIGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCk7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGw7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgICAgICAgICAgdmFyIGhhc0ZpbGxHcmFkaWVudCA9IGhhc0ZpbGwgJiYgISEoZmlsbC5jb2xvclN0b3BzKTtcbiAgICAgICAgICAgIHZhciBoYXNTdHJva2VHcmFkaWVudCA9IGhhc1N0cm9rZSAmJiAhIShzdHJva2UuY29sb3JTdG9wcyk7XG4gICAgICAgICAgICB2YXIgaGFzRmlsbFBhdHRlcm4gPSBoYXNGaWxsICYmICEhKGZpbGwuaW1hZ2UpO1xuICAgICAgICAgICAgdmFyIGhhc1N0cm9rZVBhdHRlcm4gPSBoYXNTdHJva2UgJiYgISEoc3Ryb2tlLmltYWdlKTtcblxuICAgICAgICAgICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBncmFkaWVudCBiZWNhdXNlIGJvdW5kaW5nIHJlY3QgbWF5IGNoYW5nZWRcbiAgICAgICAgICAgICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgZmlsbCwgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2VHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgc3Ryb2tlLCByZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGdyYWRpZW50IG9yIHBhdHRlcm5cbiAgICAgICAgICAgIGlmIChoYXNGaWxsR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIElmIG1heSBoYXZlIGFmZmVjdCB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fZmlsbEdyYWRpZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzRmlsbFBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGZpbGwsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLl9zdHJva2VHcmFkaWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc1N0cm9rZVBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoc3Ryb2tlLCBjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSBzdHlsZS5saW5lRGFzaDtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0O1xuXG4gICAgICAgICAgICB2YXIgY3R4TGluZURhc2ggPSAhIWN0eC5zZXRMaW5lRGFzaDtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHBhdGggc3gsIHN5XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldEdsb2JhbFNjYWxlKCk7XG4gICAgICAgICAgICBwYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7XG5cbiAgICAgICAgICAgIC8vIFByb3h5IGNvbnRleHRcbiAgICAgICAgICAgIC8vIFJlYnVpbGQgcGF0aCBpbiBmb2xsb3dpbmcgMiBjYXNlc1xuICAgICAgICAgICAgLy8gMS4gUGF0aCBpcyBkaXJ0eVxuICAgICAgICAgICAgLy8gMi4gUGF0aCBuZWVkcyBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmVEYXNoIHN0cm9raW5nLlxuICAgICAgICAgICAgLy8gICAgSW4gdGhpcyBjYXNlLCBsaW5lRGFzaCBpbmZvcm1hdGlvbiB3aWxsIG5vdCBiZSBzYXZlZCBpbiBQYXRoUHJveHlcbiAgICAgICAgICAgIGlmICh0aGlzLl9fZGlydHlQYXRoIHx8IChcbiAgICAgICAgICAgICAgICBsaW5lRGFzaCAmJiAhY3R4TGluZURhc2ggJiYgaGFzU3Ryb2tlXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHRoaXMucGF0aC5iZWdpblBhdGgoY3R4KTtcblxuICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgbGluZSBkYXNoIGJlZm9yZSBidWlsZCBwYXRoXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVEYXNoICYmICFjdHhMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRMaW5lRGFzaE9mZnNldChsaW5lRGFzaE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgcGF0aCBkaXJ0eSBmbGFnXG4gICAgICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGF5IHBhdGggYnVpbGRpbmdcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhc0ZpbGwgJiYgcGF0aC5maWxsKGN0eCk7XG5cbiAgICAgICAgICAgIGlmIChsaW5lRGFzaCAmJiBjdHhMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhc1N0cm9rZSAmJiBwYXRoLnN0cm9rZShjdHgpO1xuXG4gICAgICAgICAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGxpbmVEYXNoXG4gICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgLy8gRHJhdyByZWN0IHRleHRcbiAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBXaGVuIGJ1bmRsaW5nIHBhdGgsIHNvbWUgc2hhcGUgbWF5IGRlY2lkZSBpZiB1c2UgbW92ZVRvIHRvIGJlZ2luIGEgbmV3IHN1YnBhdGggb3IgY2xvc2VQYXRoXG4gICAgICAgIC8vIExpa2UgaW4gY2lyY2xlXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGVDZmcsIGluQnVuZGxlKSB7fSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdDtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgbmVlZHNVcGRhdGVSZWN0ID0gIXJlY3Q7XG4gICAgICAgICAgICBpZiAobmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkcyB1cGRhdGUgcmVjdCB3aXRoIHN0cm9rZSBsaW5lV2lkdGggd2hlblxuICAgICAgICAgICAgICAgIC8vIDEuIEVsZW1lbnQgY2hhbmdlcyBzY2FsZSBvciBsaW5lV2lkdGhcbiAgICAgICAgICAgICAgICAvLyAyLiBTaGFwZSBpcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgdmFyIHJlY3RXaXRoU3Ryb2tlID0gdGhpcy5fcmVjdFdpdGhTdHJva2UgfHwgKHRoaXMuX3JlY3RXaXRoU3Ryb2tlID0gcmVjdC5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5IHx8IG5lZWRzVXBkYXRlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS5jb3B5KHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBNdXN0IGFmdGVyIHVwZGF0ZVRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUEVORElORywgTWluIGxpbmUgd2lkdGggaXMgbmVlZGVkIHdoZW4gbGluZSBpcyBob3Jpem9udGFsIG9yIHZlcnRpY2FsXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZXh0cmEgaG92ZXIgbGluZVdpZHRoIHdoZW4gdGhlcmUgYXJlIG5vIGZpbGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBNYXRoLm1heCh3LCB0aGlzLnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQgfHwgNCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgbGluZSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIHNjYWxlIGNhbid0IGJlIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2Uud2lkdGggKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLmhlaWdodCArPSB3IC8gbGluZVNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UueCAtPSB3IC8gbGluZVNjYWxlIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnkgLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gcmVjdCB3aXRoIHN0cm9rZVxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0V2l0aFN0cm9rZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbFBvcyA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHggPSBsb2NhbFBvc1swXTtcbiAgICAgICAgICAgIHkgPSBsb2NhbFBvc1sxXTtcblxuICAgICAgICAgICAgaWYgKHJlY3QuY29udGFpbih4LCB5KSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMucGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVNjYWxlID0gc3R5bGUuc3Ryb2tlTm9TY2FsZSA/IHRoaXMuZ2V0TGluZVNjYWxlKCkgOiAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIHNjYWxlIGNhbid0IGJlIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZXh0cmEgaG92ZXIgbGluZVdpZHRoIHdoZW4gdGhlcmUgYXJlIG5vIGZpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gTWF0aC5tYXgobGluZVdpZHRoLCB0aGlzLnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhDb250YWluLmNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aERhdGEsIGxpbmVXaWR0aCAvIGxpbmVTY2FsZSwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhDb250YWluLmNvbnRhaW4ocGF0aERhdGEsIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gZGlydHlQYXRoXG4gICAgICAgICAqL1xuICAgICAgICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgICAgICAgICAgaWYgKGRpcnR5UGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlydHlQYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgbWFyayBkaXJ0eSwgbm90IG1hcmsgY2xlYW5cbiAgICAgICAgICAgIGlmIChkaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZGlydHlQYXRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgLy8gVXNlZCBhcyBhIGNsaXBwaW5nIHBhdGhcbiAgICAgICAgICAgIGlmICh0aGlzLl9fY2xpcFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19jbGlwVGFyZ2V0LmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWFzIGZvciBhbmltYXRlKCdzaGFwZScpXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZVNoYXBlOiBmdW5jdGlvbiAobG9vcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgnc2hhcGUnLCBsb29wKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPdmVyd3JpdGUgYXR0cktWXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnc2hhcGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBEaXNwbGF5YWJsZS5wcm90b3R5cGUuYXR0cktWLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHNldFNoYXBlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIC8vIFBhdGggZnJvbSBzdHJpbmcgbWF5IG5vdCBoYXZlIHNoYXBlXG4gICAgICAgICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZVtuYW1lXSA9IGtleVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGluZVNjYWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBsaW5lIHNjYWxlLlxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5hbnQgb2YgYG1gIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgICAgICAgICAgLy8gZm9yIHdpZHRoLlxuICAgICAgICAgICAgcmV0dXJuIG0gJiYgYWJzKG1bMF0gLSAxKSA+IDFlLTEwICYmIGFicyhtWzNdIC0gMSkgPiAxZS0xMFxuICAgICAgICAgICAgICAgID8gTWF0aC5zcXJ0KGFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKSlcbiAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5omp5bGV5LiA5LiqIFBhdGggZWxlbWVudCwg5q+U5aaC5pif5b2i77yM5ZyG562J44CCXG4gICAgICogRXh0ZW5kIGEgcGF0aCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BzLnR5cGUgUGF0aCB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuaW5pdCBJbml0aWFsaXplXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuYnVpbGRQYXRoIE92ZXJ3cml0ZSBidWlsZFBhdGggbWV0aG9kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zdHlsZV0gRXh0ZW5kZWQgZGVmYXVsdCBzdHlsZSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnNoYXBlXSBFeHRlbmRlZCBkZWZhdWx0IHNoYXBlIGNvbmZpZ1xuICAgICAqL1xuICAgIFBhdGguZXh0ZW5kID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBTdWIgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgUGF0aC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgICAgICBpZiAoZGVmYXVsdHMuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRlbmQgZGVmYXVsdCBzdHlsZVxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuZXh0ZW5kRnJvbShkZWZhdWx0cy5zdHlsZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeHRlbmQgZGVmYXVsdCBzaGFwZVxuICAgICAgICAgICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRTaGFwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSB0aGlzLnNoYXBlIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciB0aGlzU2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdFNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICEgdGhpc1NoYXBlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBkZWZhdWx0U2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzU2hhcGVbbmFtZV0gPSBkZWZhdWx0U2hhcGVbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHRzLmluaXQgJiYgZGVmYXVsdHMuaW5pdC5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHpyVXRpbC5pbmhlcml0cyhTdWIsIFBhdGgpO1xuXG4gICAgICAgIC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xuICAgICAgICAgICAgaWYgKG5hbWUgIT09ICdzdHlsZScgJiYgbmFtZSAhPT0gJ3NoYXBlJykge1xuICAgICAgICAgICAgICAgIFN1Yi5wcm90b3R5cGVbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBTdWI7XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhQYXRoLCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhdGg7XG4iLCJcblxuICAgIHZhciBQYXR0ZXJuID0gZnVuY3Rpb24gKGltYWdlLCByZXBlYXQpIHtcbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICB0aGlzLnJlcGVhdCA9IHJlcGVhdDtcblxuICAgICAgICAvLyBDYW4gYmUgY2xvbmVkXG4gICAgICAgIHRoaXMudHlwZSA9ICdwYXR0ZXJuJztcbiAgICB9O1xuXG4gICAgUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybiA9IGZ1bmN0aW9uIChjdHgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzUGF0dGVyblxuICAgICAgICAgICAgfHwgKHRoaXMuX2NhbnZhc1BhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybih0aGlzLmltYWdlLCB0aGlzLnJlcGVhdCkpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhdHRlcm47XG4iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJy4vR3JhZGllbnQnKTtcblxuICAgIC8qKlxuICAgICAqIHgsIHksIHIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTAuNV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MC41XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcj0wLjVdXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW2NvbG9yU3RvcHNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsQ29vcmQ9ZmFsc2VdXG4gICAgICovXG4gICAgdmFyIFJhZGlhbEdyYWRpZW50ID0gZnVuY3Rpb24gKHgsIHksIHIsIGNvbG9yU3RvcHMsIGdsb2JhbENvb3JkKSB7XG4gICAgICAgIHRoaXMueCA9IHggPT0gbnVsbCA/IDAuNSA6IHg7XG5cbiAgICAgICAgdGhpcy55ID0geSA9PSBudWxsID8gMC41IDogeTtcblxuICAgICAgICB0aGlzLnIgPSByID09IG51bGwgPyAwLjUgOiByO1xuXG4gICAgICAgIC8vIENhbiBiZSBjbG9uZWRcbiAgICAgICAgdGhpcy50eXBlID0gJ3JhZGlhbCc7XG5cbiAgICAgICAgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuICAgICAgICB0aGlzLmdsb2JhbCA9IGdsb2JhbENvb3JkIHx8IGZhbHNlO1xuXG4gICAgICAgIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG4gICAgfTtcblxuICAgIFJhZGlhbEdyYWRpZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUmFkaWFsR3JhZGllbnRcbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKFJhZGlhbEdyYWRpZW50LCBHcmFkaWVudCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJhZGlhbEdyYWRpZW50O1xuIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9TdHlsZVxuICovXG5cblxuICAgIHZhciBTVFlMRV9DT01NT05fUFJPUFMgPSBbXG4gICAgICAgIFsnc2hhZG93Qmx1cicsIDBdLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLFxuICAgICAgICBbJ2xpbmVDYXAnLCAnYnV0dCddLCBbJ2xpbmVKb2luJywgJ21pdGVyJ10sIFsnbWl0ZXJMaW1pdCcsIDEwXVxuICAgIF07XG5cbiAgICAvLyB2YXIgU0hBRE9XX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDAsIDQpO1xuICAgIC8vIHZhciBMSU5FX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDQpO1xuXG4gICAgdmFyIFN0eWxlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgdGhpcy5leHRlbmRGcm9tKG9wdHMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMaW5lYXJHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICAgICAgICAvLyB2YXIgc2l6ZSA9XG4gICAgICAgIHZhciB4ID0gb2JqLng7XG4gICAgICAgIHZhciB4MiA9IG9iai54MjtcbiAgICAgICAgdmFyIHkgPSBvYmoueTtcbiAgICAgICAgdmFyIHkyID0gb2JqLnkyO1xuXG4gICAgICAgIGlmICghb2JqLmdsb2JhbCkge1xuICAgICAgICAgICAgeCA9IHggKiByZWN0LndpZHRoICsgcmVjdC54O1xuICAgICAgICAgICAgeDIgPSB4MiAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgICAgICAgICB5ID0geSAqIHJlY3QuaGVpZ2h0ICsgcmVjdC55O1xuICAgICAgICAgICAgeTIgPSB5MiAqIHJlY3QuaGVpZ2h0ICsgcmVjdC55O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgyLCB5Mik7XG5cbiAgICAgICAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhZGlhbEdyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHZhciB4ID0gb2JqLng7XG4gICAgICAgIHZhciB5ID0gb2JqLnk7XG4gICAgICAgIHZhciByID0gb2JqLnI7XG4gICAgICAgIGlmICghb2JqLmdsb2JhbCkge1xuICAgICAgICAgICAgeCA9IHggKiB3aWR0aCArIHJlY3QueDtcbiAgICAgICAgICAgIHkgPSB5ICogaGVpZ2h0ICsgcmVjdC55O1xuICAgICAgICAgICAgciA9IHIgKiBtaW47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoeCwgeSwgMCwgeCwgeSwgcik7XG5cbiAgICAgICAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xuICAgIH1cblxuXG4gICAgU3R5bGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBTdHlsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGZpbGw6ICcjMDAwMDAwJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHN0cm9rZTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIG9wYWNpdHk6IDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVEYXNoOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzaGFkb3dCbHVyOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2hhZG93T2Zmc2V0WDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNoYWRvd09mZnNldFk6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lV2lkdGg6IDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHN0cm9rZSBpZ25vcmUgc2NhbGVcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzdHJva2VOb1NjYWxlOiBmYWxzZSxcblxuICAgICAgICAvLyBCb3VuZGluZyByZWN0IHRleHQgY29uZmlndXJhdGlvblxuICAgICAgICAvLyBOb3QgYWZmZWN0ZWQgYnkgZWxlbWVudCB0cmFuc2Zvcm1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0OiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEZpbGw6ICcjMDAwJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTdHJva2U6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICdpbnNpZGUnLCAnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ1xuICAgICAgICAgKiBbeCwgeV1cbiAgICAgICAgICogQHR5cGUge3N0cmluZ3xBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQGRlZmF1bHQgJ2luc2lkZSdcbiAgICAgICAgICovXG4gICAgICAgIHRleHRQb3NpdGlvbjogJ2luc2lkZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFt4LCB5XVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0T2Zmc2V0OiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEJhc2VsaW5lOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEFsaWduOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHREaXN0YW5jZTogNSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFNoYWRvd0JsdXI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTaGFkb3dPZmZzZXRYOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0U2hhZG93T2Zmc2V0WTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJhbnNmb3JtIHRleHRcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRUcmFuc2Zvcm06IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXh0IHJvdGF0ZSBhcm91bmQgcG9zaXRpb24gb2YgUGF0aCBvciBJbWFnZVxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50IGFuZCB0ZXh0VHJhbnNmb3JtIGlzIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFJvdGF0aW9uOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYmxlbmQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAgICovXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uIChjdHgsIGVsLCBwcmV2RWwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcHJldlN0eWxlID0gcHJldkVsICYmIHByZXZFbC5zdHlsZTtcbiAgICAgICAgICAgIHZhciBmaXJzdERyYXcgPSAhcHJldlN0eWxlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gU1RZTEVfQ09NTU9OX1BST1BTW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZU5hbWUgPSBwcm9wWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZVtzdHlsZU5hbWVdICE9PSBwcmV2U3R5bGVbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBJbnZhbGlkIHByb3BlcnR5IHZhbHVlIHdpbGwgY2F1c2Ugc3R5bGUgbGVhayBmcm9tIHByZXZpb3VzIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGN0eFtzdHlsZU5hbWVdID0gc3R5bGVbc3R5bGVOYW1lXSB8fCBwcm9wWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChmaXJzdERyYXcgfHwgc3R5bGUuZmlsbCAhPT0gcHJldlN0eWxlLmZpbGwpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmZpbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5zdHJva2UgIT09IHByZXZTdHlsZS5zdHJva2UpKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChmaXJzdERyYXcgfHwgc3R5bGUub3BhY2l0eSAhPT0gcHJldlN0eWxlLm9wYWNpdHkpKSB7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3R5bGUub3BhY2l0eSA9PSBudWxsID8gMSA6IHN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoZmlyc3REcmF3IHx8IHN0eWxlLmJsZW5kICE9PSBwcmV2U3R5bGUuYmxlbmQpKSB7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHN0eWxlLmJsZW5kIHx8ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCAvIChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc3Ryb2tlTm9TY2FsZSAmJiBlbCAmJiBlbC5nZXRMaW5lU2NhbGUpID8gZWwuZ2V0TGluZVNjYWxlKCkgOiAxXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoYXNGaWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IHRoaXMuZmlsbDtcbiAgICAgICAgICAgIHJldHVybiBmaWxsICE9IG51bGwgJiYgZmlsbCAhPT0gJ25vbmUnO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc1N0cm9rZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgICAgICAgcmV0dXJuIHN0cm9rZSAhPSBudWxsICYmIHN0cm9rZSAhPT0gJ25vbmUnICYmIHRoaXMubGluZVdpZHRoID4gMDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXh0ZW5kIGZyb20gb3RoZXIgc3R5bGVcbiAgICAgICAgICogQHBhcmFtIHt6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IG90aGVyU3R5bGVcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBvdmVyd3JpdGVcbiAgICAgICAgICovXG4gICAgICAgIGV4dGVuZEZyb206IGZ1bmN0aW9uIChvdGhlclN0eWxlLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgIGlmIChvdGhlclN0eWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvdGhlclN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAob3ZlcndyaXRlIHx8ICEgdGFyZ2V0Lmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IG90aGVyU3R5bGVbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhdGNoIHNldHRpbmcgc3R5bGUgd2l0aCBhIGdpdmVuIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IG9ialxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvYmpdXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvYmosIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzW29ial0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5kRnJvbShvYmosIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9uZVxuICAgICAgICAgKiBAcmV0dXJuIHt6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IFtkZXNjcmlwdGlvbl1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3U3R5bGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgbmV3U3R5bGUuZXh0ZW5kRnJvbSh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdTdHlsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRHcmFkaWVudDogZnVuY3Rpb24gKGN0eCwgb2JqLCByZWN0KSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gb2JqLnR5cGUgPT09ICdyYWRpYWwnID8gY3JlYXRlUmFkaWFsR3JhZGllbnQgOiBjcmVhdGVMaW5lYXJHcmFkaWVudDtcbiAgICAgICAgICAgIHZhciBjYW52YXNHcmFkaWVudCA9IG1ldGhvZChjdHgsIG9iaiwgcmVjdCk7XG4gICAgICAgICAgICB2YXIgY29sb3JTdG9wcyA9IG9iai5jb2xvclN0b3BzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvclN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzR3JhZGllbnQuYWRkQ29sb3JTdG9wKFxuICAgICAgICAgICAgICAgICAgICBjb2xvclN0b3BzW2ldLm9mZnNldCwgY29sb3JTdG9wc1tpXS5jb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0eWxlUHJvdG8gPSBTdHlsZS5wcm90b3R5cGU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTVFlMRV9DT01NT05fUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG4gICAgICAgIGlmICghKHByb3BbMF0gaW4gc3R5bGVQcm90bykpIHtcbiAgICAgICAgICAgIHN0eWxlUHJvdG9bcHJvcFswXV0gPSBwcm9wWzFdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvdmlkZSBmb3Igb3RoZXJzXG4gICAgU3R5bGUuZ2V0R3JhZGllbnQgPSBzdHlsZVByb3RvLmdldEdyYWRpZW50O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTdHlsZTtcbiIsIi8qKlxuICogVGV4dCBlbGVtZW50XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9UZXh0XG4gKlxuICogVE9ETyBXcmFwcGluZ1xuICpcbiAqIFRleHQgbm90IHN1cHBvcnQgZ3JhZGllbnRcbiAqL1xuXG5cblxuICAgIHZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoJy4vRGlzcGxheWFibGUnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnLi4vY29udGFpbi90ZXh0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgenJlbmRlci9ncmFwaGljL1RleHRcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICB2YXIgVGV4dCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfTtcblxuICAgIFRleHQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBUZXh0LFxuXG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcblxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgICAgICAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgICAgICAgICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gICAgICAgICAgICAvLyBBbHdheXMgYmluZCBzdHlsZVxuICAgICAgICAgICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRCYXNlbGluZTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgICAgICAgICAgICAgIHZhciBmb250ID0gc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udDtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LCBmb250LCBzdHlsZS50ZXh0QWxpZ24sICd0b3AnXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0ZXh0QmFzZWxpbmVcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSByZWN0LmhlaWdodCAvIDIgLSByZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5IC09IHJlY3QuaGVpZ2h0IC0gcmVjdC5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArPSByZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBJbnZhbGlkIGZvbnRcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IGZvbnQgfHwgJzEycHggc2Fucy1zZXJpZic7XG4gICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRleHRBbGlnbiB8fCAnbGVmdCc7XG4gICAgICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyBkZWZhdWx0IGxlZnQgdGV4dEFsaWduLiBHaXZpbmcgaW52YWxpZCB2YWx1ZSB3aWxsIGNhdXNlIHN0YXRlIG5vdCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoY3R4LnRleHRBbGlnbiAhPT0gdGV4dEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmUgfHwgJ2FscGhhYmV0aWMnO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBhbHBoYWJldGljIGJhc2VsaW5lXG4gICAgICAgICAgICAgICAgaWYgKGN0eC50ZXh0QmFzZWxpbmUgIT09IHRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGV4dENvbnRhaW4ubWVhc3VyZVRleHQoJ+WbvScsIGN0eC5mb250KS53aWR0aDtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0TGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5oYXNGaWxsKCkgJiYgY3R4LmZpbGxUZXh0KHRleHRMaW5lc1tpXSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmhhc1N0cm9rZSgpICYmIGN0eC5zdHJva2VUZXh0KHRleHRMaW5lc1tpXSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnRleHQgKyAnJywgc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udCwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA/ICd0b3AnIDogc3R5bGUudGV4dEJhc2VsaW5lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gcmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjdC54ICs9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgICAgICByZWN0LnkgKz0gc3R5bGUueSB8fCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKFRleHQsIERpc3BsYXlhYmxlKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVGV4dDtcbiIsIlxuXG4gICAgdmFyIHNtb290aFNwbGluZSA9IHJlcXVpcmUoJy4vc21vb3RoU3BsaW5lJyk7XG4gICAgdmFyIHNtb290aEJlemllciA9IHJlcXVpcmUoJy4vc21vb3RoQmV6aWVyJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgY2xvc2VQYXRoKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgICAgICAgICAgdmFyIHNtb290aCA9IHNoYXBlLnNtb290aDtcbiAgICAgICAgICAgIGlmIChwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNtb290aCAmJiBzbW9vdGggIT09ICdzcGxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnRzID0gc21vb3RoQmV6aWVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLCBzbW9vdGgsIGNsb3NlUGF0aCwgc2hhcGUuc21vb3RoQ29uc3RyYWludFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoY2xvc2VQYXRoID8gbGVuIDogbGVuIC0gMSk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwMSA9IGNvbnRyb2xQb2ludHNbaSAqIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwMiA9IGNvbnRyb2xQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3AxWzBdLCBjcDFbMV0sIGNwMlswXSwgY3AyWzFdLCBwWzBdLCBwWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc21vb3RoID09PSAnc3BsaW5lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc21vb3RoU3BsaW5lKHBvaW50cywgY2xvc2VQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xvc2VQYXRoICYmIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4iLCJcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgciA9IHNoYXBlLnI7XG4gICAgICAgICAgICB2YXIgcjE7XG4gICAgICAgICAgICB2YXIgcjI7XG4gICAgICAgICAgICB2YXIgcjM7XG4gICAgICAgICAgICB2YXIgcjQ7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgd2lkdGggYW5kIGhlaWdodCB0byBwb3NpdGl2ZSBmb3IgYmV0dGVyIGJvcmRlclJhZGl1c1xuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgICAgICAgIHggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgICAgIHkgPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICByMSA9IHIzID0gclswXTtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gclswXTtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgIHIzID0gclsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gclswXTtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICByMyA9IHJbMl07XG4gICAgICAgICAgICAgICAgICAgIHI0ID0gclszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b3RhbDtcbiAgICAgICAgICAgIGlmIChyMSArIHIyID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIxICsgcjI7XG4gICAgICAgICAgICAgICAgcjEgKj0gd2lkdGggLyB0b3RhbDtcbiAgICAgICAgICAgICAgICByMiAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIzICsgcjQgPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjMgKyByNDtcbiAgICAgICAgICAgICAgICByMyAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHI0ICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocjIgKyByMyA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjIgKyByMztcbiAgICAgICAgICAgICAgICByMiAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgICAgICAgICByMyAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyMSArIHI0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMSArIHI0O1xuICAgICAgICAgICAgICAgIHIxICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHI0ICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgcjEsIHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByMiwgeSk7XG4gICAgICAgICAgICByMiAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHIyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByMyk7XG4gICAgICAgICAgICByMyAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHIzLCB5ICsgaGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgcjQsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgcjQgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHI0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcjEpO1xuICAgICAgICAgICAgcjEgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHIxLCB5KTtcbiAgICAgICAgfVxuICAgIH07XG4iLCIvKipcbiAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoQmV6aWVyXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqICAgICAgICAgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgdjJNaW4gPSB2ZWMyLm1pbjtcbiAgICB2YXIgdjJNYXggPSB2ZWMyLm1heDtcbiAgICB2YXIgdjJTY2FsZSA9IHZlYzIuc2NhbGU7XG4gICAgdmFyIHYyRGlzdGFuY2UgPSB2ZWMyLmRpc3RhbmNlO1xuICAgIHZhciB2MkFkZCA9IHZlYzIuYWRkO1xuXG4gICAgLyoqXG4gICAgICog6LSd5aGe5bCU5bmz5ruR5puy57q/XG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoQmV6aWVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIOe6v+autemhtueCueaVsOe7hFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbW9vdGgg5bmz5ruR562J57qnLCAwLTFcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbnN0cmFpbnQg5bCG6K6h566X5Ye65p2l55qE5o6n5Yi254K557qm5p2f5Zyo5LiA5Liq5YyF5Zu055uS5YaFXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICDmr5TlpoIgW1swLCAwXSwgWzEwMCwgMTAwXV0sIOi/meS4quWMheWbtOebkuS8muS4jlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5pW05Liq5oqY57q/55qE5YyF5Zu055uS5YGa5LiA5Liq5bm26ZuG55So5p2l57qm5p2f5o6n5Yi254K544CCXG4gICAgICogQHBhcmFtIHtBcnJheX0g6K6h566X5Ye65p2l55qE5o6n5Yi254K55pWw57uEXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9pbnRzLCBzbW9vdGgsIGlzTG9vcCwgY29uc3RyYWludCkge1xuICAgICAgICB2YXIgY3BzID0gW107XG5cbiAgICAgICAgdmFyIHYgPSBbXTtcbiAgICAgICAgdmFyIHYxID0gW107XG4gICAgICAgIHZhciB2MiA9IFtdO1xuICAgICAgICB2YXIgcHJldlBvaW50O1xuICAgICAgICB2YXIgbmV4dFBvaW50O1xuXG4gICAgICAgIHZhciBtaW4sIG1heDtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIG1pbiA9IFtJbmZpbml0eSwgSW5maW5pdHldO1xuICAgICAgICAgICAgbWF4ID0gWy1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2Mk1pbihtaW4sIG1pbiwgcG9pbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB2Mk1heChtYXgsIG1heCwgcG9pbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIOS4juaMh+WumueahOWMheWbtOebkuWBmuW5tumbhlxuICAgICAgICAgICAgdjJNaW4obWluLCBtaW4sIGNvbnN0cmFpbnRbMF0pO1xuICAgICAgICAgICAgdjJNYXgobWF4LCBtYXgsIGNvbnN0cmFpbnRbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXNMb29wKSB7XG4gICAgICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgPyBpIC0gMSA6IGxlbiAtIDFdO1xuICAgICAgICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50c1soaSArIDEpICUgbGVuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3BzLnB1c2godmVjMi5jbG9uZShwb2ludHNbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmVjMi5zdWIodiwgbmV4dFBvaW50LCBwcmV2UG9pbnQpO1xuXG4gICAgICAgICAgICAvLyB1c2UgZGVncmVlIHRvIHNjYWxlIHRoZSBoYW5kbGUgbGVuZ3RoXG4gICAgICAgICAgICB2MlNjYWxlKHYsIHYsIHNtb290aCk7XG5cbiAgICAgICAgICAgIHZhciBkMCA9IHYyRGlzdGFuY2UocG9pbnQsIHByZXZQb2ludCk7XG4gICAgICAgICAgICB2YXIgZDEgPSB2MkRpc3RhbmNlKHBvaW50LCBuZXh0UG9pbnQpO1xuICAgICAgICAgICAgdmFyIHN1bSA9IGQwICsgZDE7XG4gICAgICAgICAgICBpZiAoc3VtICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZDAgLz0gc3VtO1xuICAgICAgICAgICAgICAgIGQxIC89IHN1bTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdjJTY2FsZSh2MSwgdiwgLWQwKTtcbiAgICAgICAgICAgIHYyU2NhbGUodjIsIHYsIGQxKTtcbiAgICAgICAgICAgIHZhciBjcDAgPSB2MkFkZChbXSwgcG9pbnQsIHYxKTtcbiAgICAgICAgICAgIHZhciBjcDEgPSB2MkFkZChbXSwgcG9pbnQsIHYyKTtcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgICAgICAgdjJNYXgoY3AwLCBjcDAsIG1pbik7XG4gICAgICAgICAgICAgICAgdjJNaW4oY3AwLCBjcDAsIG1heCk7XG4gICAgICAgICAgICAgICAgdjJNYXgoY3AxLCBjcDEsIG1pbik7XG4gICAgICAgICAgICAgICAgdjJNaW4oY3AxLCBjcDEsIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcHMucHVzaChjcDApO1xuICAgICAgICAgICAgY3BzLnB1c2goY3AxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0xvb3ApIHtcbiAgICAgICAgICAgIGNwcy5wdXNoKGNwcy5zaGlmdCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcHM7XG4gICAgfTtcblxuIiwiLyoqXG4gKiBDYXRtdWxsLVJvbSBzcGxpbmUg5o+S5YC85oqY57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhTcGxpbmVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICogICAgICAgICBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vLi4vY29yZS92ZWN0b3InKTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgICAgICAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICAgICAgICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gICAgICAgIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDNcbiAgICAgICAgICAgICAgICArICgtMyAqIChwMSAtIHAyKSAtIDIgKiB2MCAtIHYxKSAqIHQyXG4gICAgICAgICAgICAgICAgKyB2MCAqIHQgKyBwMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhTcGxpbmVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2ludHMsIGlzTG9vcCkge1xuICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHZlYzIuZGlzdGFuY2UocG9pbnRzW2kgLSAxXSwgcG9pbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWdzID0gZGlzdGFuY2UgLyAyO1xuICAgICAgICBzZWdzID0gc2VncyA8IGxlbiA/IGxlbiA6IHNlZ3M7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gaSAvIChzZWdzIC0gMSkgKiAoaXNMb29wID8gbGVuIDogbGVuIC0gMSk7XG4gICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5mbG9vcihwb3MpO1xuXG4gICAgICAgICAgICB2YXIgdyA9IHBvcyAtIGlkeDtcblxuICAgICAgICAgICAgdmFyIHAwO1xuICAgICAgICAgICAgdmFyIHAxID0gcG9pbnRzW2lkeCAlIGxlbl07XG4gICAgICAgICAgICB2YXIgcDI7XG4gICAgICAgICAgICB2YXIgcDM7XG4gICAgICAgICAgICBpZiAoIWlzTG9vcCkge1xuICAgICAgICAgICAgICAgIHAwID0gcG9pbnRzW2lkeCA9PT0gMCA/IGlkeCA6IGlkeCAtIDFdO1xuICAgICAgICAgICAgICAgIHAyID0gcG9pbnRzW2lkeCA+IGxlbiAtIDIgPyBsZW4gLSAxIDogaWR4ICsgMV07XG4gICAgICAgICAgICAgICAgcDMgPSBwb2ludHNbaWR4ID4gbGVuIC0gMyA/IGxlbiAtIDEgOiBpZHggKyAyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHAwID0gcG9pbnRzWyhpZHggLSAxICsgbGVuKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgcDIgPSBwb2ludHNbKGlkeCArIDEpICUgbGVuXTtcbiAgICAgICAgICAgICAgICBwMyA9IHBvaW50c1soaWR4ICsgMikgJSBsZW5dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdzIgPSB3ICogdztcbiAgICAgICAgICAgIHZhciB3MyA9IHcgKiB3MjtcblxuICAgICAgICAgICAgcmV0LnB1c2goW1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlKHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdLCB3LCB3MiwgdzMpLFxuICAgICAgICAgICAgICAgIGludGVycG9sYXRlKHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdLCB3LCB3MiwgdzMpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiIsIi8qKlxuICogTWl4aW4gZm9yIGRyYXdpbmcgdGV4dCBpbiBhIGVsZW1lbnQgYm91bmRpbmcgcmVjdFxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1JlY3RUZXh0XG4gKi9cblxuXG5cbiAgICB2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKCcuLi8uLi9jb250YWluL3RleHQnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcblxuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgdmFyIFJlY3RUZXh0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBlcmNlbnQodmFsdWUsIG1heFZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGFzdEluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogbWF4VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIFJlY3RUZXh0LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUmVjdFRleHQsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXcgdGV4dCBpbiBhIHJlY3Qgd2l0aCBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAgICAgICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHR9IGN0eFxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlY3QgRGlzcGxheWFibGUgcmVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRleHRSZWN0IEFsdGVybmF0aXZlIHByZWNhbGN1bGF0ZWQgdGV4dCBib3VuZGluZyByZWN0XG4gICAgICAgICAqL1xuICAgICAgICBkcmF3UmVjdFRleHQ6IGZ1bmN0aW9uIChjdHgsIHJlY3QsIHRleHRSZWN0KSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0O1xuICAgICAgICAgICAgLy8gQ29udmVydCB0byBzdHJpbmdcbiAgICAgICAgICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG4gICAgICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICB2YXIgeDtcbiAgICAgICAgICAgIHZhciB5O1xuICAgICAgICAgICAgdmFyIHRleHRQb3NpdGlvbiA9IHN0eWxlLnRleHRQb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciB0ZXh0T2Zmc2V0ID0gc3R5bGUudGV4dE9mZnNldDtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHN0eWxlLnRleHREaXN0YW5jZTtcbiAgICAgICAgICAgIHZhciBhbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgICAgICAgIHZhciBmb250ID0gc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udDtcbiAgICAgICAgICAgIHZhciBiYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247XG5cbiAgICAgICAgICAgIHRleHRSZWN0ID0gdGV4dFJlY3QgfHwgdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHQsIGZvbnQsIGFsaWduLCBiYXNlbGluZSk7XG5cbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSByZWN0IHRvIHZpZXcgc3BhY2VcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGlmICghc3R5bGUudGV4dFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wUmVjdC5jb3B5KHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSB0bXBSZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRleHQgcG9zaXRpb24gcmVwcmVzZW50ZWQgYnkgY29vcmRcbiAgICAgICAgICAgIGlmICh0ZXh0UG9zaXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFBlcmNlbnRcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblswXSwgcmVjdC53aWR0aCk7XG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMV0sIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBhbGlnbiA9IGFsaWduIHx8ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBiYXNlbGluZSA9IGJhc2VsaW5lIHx8ICd0b3AnO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2ZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gdGV4dFJlY3QuaGVpZ2h0IC8gMiAtIHRleHRSZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5IC09IHRleHRSZWN0LmhlaWdodCAtIHRleHRSZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHRleHRSZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIGJzZWxpbmUgdG8gYmUgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRleHRDb250YWluLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdChcbiAgICAgICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uLCByZWN0LCB0ZXh0UmVjdCwgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHggPSByZXMueDtcbiAgICAgICAgICAgICAgICB5ID0gcmVzLnk7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBhbGlnbiBhbmQgYmFzZWxpbmUgd2hlbiBoYXMgdGV4dFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCByZXMudGV4dEFsaWduO1xuICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgfHwgcmVzLnRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB4ICs9IHRleHRPZmZzZXRbMF07XG4gICAgICAgICAgICAgICAgeSArPSB0ZXh0T2Zmc2V0WzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgY2FudmFzIGRlZmF1bHQgbGVmdCB0ZXh0QWxpZ24uIEdpdmluZyBpbnZhbGlkIHZhbHVlIHdpbGwgY2F1c2Ugc3RhdGUgbm90IGNoYW5nZVxuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IGFsaWduIHx8ICdsZWZ0JztcbiAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBhbHBoYWJldGljIGJhc2VsaW5lXG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gYmFzZWxpbmUgfHwgJ2FscGhhYmV0aWMnO1xuXG4gICAgICAgICAgICB2YXIgdGV4dEZpbGwgPSBzdHlsZS50ZXh0RmlsbDtcbiAgICAgICAgICAgIHZhciB0ZXh0U3Ryb2tlID0gc3R5bGUudGV4dFN0cm9rZTtcbiAgICAgICAgICAgIHRleHRGaWxsICYmIChjdHguZmlsbFN0eWxlID0gdGV4dEZpbGwpO1xuICAgICAgICAgICAgdGV4dFN0cm9rZSAmJiAoY3R4LnN0cm9rZVN0eWxlID0gdGV4dFN0cm9rZSk7XG5cbiAgICAgICAgICAgIC8vIFRPRE8gSW52YWxpZCBmb250XG4gICAgICAgICAgICBjdHguZm9udCA9IGZvbnQgfHwgJzEycHggc2Fucy1zZXJpZic7XG5cbiAgICAgICAgICAgIC8vIFRleHQgc2hhZG93XG4gICAgICAgICAgICAvLyBBbHdheXMgc2V0IHNoYWRvd0JsdXIgYW5kIHNoYWRvd09mZnNldCB0byBhdm9pZCBsZWFrIGZyb20gZGlzcGxheWFibGVcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gc3R5bGUudGV4dFNoYWRvd0JsdXI7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBzdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gc3R5bGUudGV4dFNoYWRvd09mZnNldFg7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZO1xuXG4gICAgICAgICAgICB2YXIgdGV4dExpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0Um90YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gJiYgY3R4LnRyYW5zbGF0ZSh0cmFuc2Zvcm1bNF0sIHRyYW5zZm9ybVs1XSk7XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShzdHlsZS50ZXh0Um90YXRpb24pO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSAmJiBjdHgudHJhbnNsYXRlKC10cmFuc2Zvcm1bNF0sIC10cmFuc2Zvcm1bNV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRleHRGaWxsICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgIHRleHRTdHJva2UgJiYgY3R4LnN0cm9rZVRleHQodGV4dExpbmVzW2ldLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB5ICs9IHRleHRSZWN0LmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSZWN0VGV4dDtcbiIsIi8qKlxuICog5ZyG5bynXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9BcmNcbiAqL1xuIFxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnYXJjJyxcblxuICAgICAgICBzaGFwZToge1xuXG4gICAgICAgICAgICBjeDogMCxcblxuICAgICAgICAgICAgY3k6IDAsXG5cbiAgICAgICAgICAgIHI6IDAsXG5cbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IDAsXG5cbiAgICAgICAgICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcblxuICAgICAgICAgICAgY2xvY2t3aXNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcblxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG5cbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG5cbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcblxuICAgICAgICAgICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOi0neWhnuWwlOabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0JlemllckN1cnZlXG4gKi9cblxuXG4gICAgdmFyIGN1cnZlVG9vbCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY3VydmUnKTtcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIHF1YWRyYXRpY1N1YmRpdmlkZSA9IGN1cnZlVG9vbC5xdWFkcmF0aWNTdWJkaXZpZGU7XG4gICAgdmFyIGN1YmljU3ViZGl2aWRlID0gY3VydmVUb29sLmN1YmljU3ViZGl2aWRlO1xuICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlVG9vbC5xdWFkcmF0aWNBdDtcbiAgICB2YXIgY3ViaWNBdCA9IGN1cnZlVG9vbC5jdWJpY0F0O1xuICAgIHZhciBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVRvb2wucXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xuICAgIHZhciBjdWJpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVG9vbC5jdWJpY0Rlcml2YXRpdmVBdDtcblxuICAgIHZhciBvdXQgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHNvbWVWZWN0b3JBdChzaGFwZSwgdCwgaXNUYW5nZW50KSB7XG4gICAgICAgIHZhciBjcHgyID0gc2hhcGUuY3B4MjtcbiAgICAgICAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuICAgICAgICBpZiAoY3B4MiA9PT0gbnVsbCB8fCBjcHkyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBjdWJpY0Rlcml2YXRpdmVBdCA6IGN1YmljQXQpKHNoYXBlLngxLCBzaGFwZS5jcHgxLCBzaGFwZS5jcHgyLCBzaGFwZS54MiwgdCksXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLmNweTIsIHNoYXBlLnkyLCB0KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA6IHF1YWRyYXRpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUueDIsIHQpLFxuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLnkyLCB0KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdiZXppZXItY3VydmUnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICB4MTogMCxcbiAgICAgICAgICAgIHkxOiAwLFxuICAgICAgICAgICAgeDI6IDAsXG4gICAgICAgICAgICB5MjogMCxcbiAgICAgICAgICAgIGNweDE6IDAsXG4gICAgICAgICAgICBjcHkxOiAwLFxuICAgICAgICAgICAgLy8gY3B4MjogMCxcbiAgICAgICAgICAgIC8vIGNweTI6IDBcblxuICAgICAgICAgICAgLy8gQ3VydmUgc2hvdyBwZXJjZW50LCBmb3IgYW5pbWF0aW5nXG4gICAgICAgICAgICBwZXJjZW50OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgICAgICAgICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgICAgICAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICAgICAgICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgICAgICAgICAgdmFyIGNweDEgPSBzaGFwZS5jcHgxO1xuICAgICAgICAgICAgdmFyIGNweTEgPSBzaGFwZS5jcHkxO1xuICAgICAgICAgICAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xuICAgICAgICAgICAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgICAgICAgICAgaWYgKGNweDIgPT0gbnVsbCB8fCBjcHkyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeDEsIGNweDEsIHgyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B4MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxLCBjcHkxLCB5MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIHkyID0gb3V0WzJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICBjcHgxLCBjcHkxLFxuICAgICAgICAgICAgICAgICAgICB4MiwgeTJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1YmljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeDEsIGNweDEsIGNweDIsIHgyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B4MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3B4MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBvdXRbM107XG4gICAgICAgICAgICAgICAgICAgIGN1YmljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeTEsIGNweTEsIGNweTIsIHkyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3B5MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBvdXRbM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICBjcHgxLCBjcHkxLFxuICAgICAgICAgICAgICAgICAgICBjcHgyLCBjcHkyLFxuICAgICAgICAgICAgICAgICAgICB4MiwgeTJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBwb2ludEF0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCBmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0YW5nZW50IGF0IHBlcmNlbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGFuZ2VudEF0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIHAgPSBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmVjMi5ub3JtYWxpemUocCwgcCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDlnIblvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9DaXJjbGVcbiAqL1xuXG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NpcmNsZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIGN4OiAwLFxuICAgICAgICAgICAgY3k6IDAsXG4gICAgICAgICAgICByOiAwXG4gICAgICAgIH0sXG5cblxuICAgICAgICBidWlsZFBhdGggOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgaW5CdW5kbGUpIHtcbiAgICAgICAgICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgICAgICAgICAgLy8gQWx3YXlzIGRvIGl0IG1heSBoYXZlIHBlcmZvcm1lbmNlIGlzc3VlICggZmlsbCBtYXkgYmUgMnggbW9yZSBjb3N0KVxuICAgICAgICAgICAgaWYgKGluQnVuZGxlKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgICAgICAgICAgLy8gY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoc2hhcGUuY3gsIHNoYXBlLmN5LCBzaGFwZS5yLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuIiwiLyoqXG4gKiDnm7Tnur9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL0xpbmVcbiAqL1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnbGluZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHBvaW50XG4gICAgICAgICAgICB4MTogMCxcbiAgICAgICAgICAgIHkxOiAwLFxuICAgICAgICAgICAgLy8gRW5kIHBvaW50XG4gICAgICAgICAgICB4MjogMCxcbiAgICAgICAgICAgIHkyOiAwLFxuXG4gICAgICAgICAgICBwZXJjZW50OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgICAgICAgICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgICAgICAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICAgICAgICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuXG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgICAgICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICB4MiA9IHgxICogKDEgLSBwZXJjZW50KSArIHgyICogcGVyY2VudDtcbiAgICAgICAgICAgICAgICB5MiA9IHkxICogKDEgLSBwZXJjZW50KSArIHkyICogcGVyY2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRBdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHNoYXBlLngxICogKDEgLSBwKSArIHNoYXBlLngyICogcCxcbiAgICAgICAgICAgICAgICBzaGFwZS55MSAqICgxIC0gcCkgKyBzaGFwZS55MiAqIHBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9KTtcblxuIiwiLyoqXG4gKiDlpJrovrnlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9Qb2x5Z29uXG4gKi9cblxuXG4gICAgdmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcG9seScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcbiAgICAgICAgXG4gICAgICAgIHR5cGU6ICdwb2x5Z29uJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgcG9pbnRzOiBudWxsLFxuXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxuXG4gICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUG9seWxpbmVcbiAqL1xuXG5cbiAgICB2YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoJy4uL2hlbHBlci9wb2x5Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuICAgICAgICBcbiAgICAgICAgdHlwZTogJ3BvbHlsaW5lJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgcG9pbnRzOiBudWxsLFxuXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxuXG4gICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4iLCIvKipcbiAqIOefqeW9olxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmVjdFxuICovXG5cblxuICAgIHZhciByb3VuZFJlY3RIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcm91bmRSZWN0Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdyZWN0JyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgLy8g5bem5LiK44CB5Y+z5LiK44CB5Y+z5LiL44CB5bem5LiL6KeS55qE5Y2K5b6E5L6d5qyh5Li6cjHjgIFyMuOAgXIz44CBcjRcbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLoxICAgICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ulsxXSAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6WzEsIDJdICAgIOebuOW9k+S6jiBbMSwgMiwgMSwgMl1cbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLpbMSwgMiwgM10g55u45b2T5LqOIFsxLCAyLCAzLCAyXVxuICAgICAgICAgICAgcjogMCxcblxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICAgICAgICAgIGlmICghc2hhcGUucikge1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm91bmRSZWN0SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4iLCIvKipcbiAqIOWchueOr1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmluZ1xuICovXG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3JpbmcnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBjeDogMCxcbiAgICAgICAgICAgIGN5OiAwLFxuICAgICAgICAgICAgcjogMCxcbiAgICAgICAgICAgIHIwOiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgICAgICAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBzaGFwZS5yLCB5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUuciwgMCwgUEkyLCBmYWxzZSk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBzaGFwZS5yMCwgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHNoYXBlLnIwLCAwLCBQSTIsIHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiIsIi8qKlxuICog5omH5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9TZWN0b3JcbiAqL1xuXG5cblxuICAgIHZhciBlbnYgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2VudicpO1xuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnLi4vUGF0aCcpO1xuXG4gICAgdmFyIHNoYWRvd1RlbXAgPSBbXG4gICAgICAgIFsnc2hhZG93Qmx1cicsIDBdLFxuICAgICAgICBbJ3NoYWRvd0NvbG9yJywgJyMwMDAnXSxcbiAgICAgICAgWydzaGFkb3dPZmZzZXRYJywgMF0sXG4gICAgICAgIFsnc2hhZG93T2Zmc2V0WScsIDBdXG4gICAgXTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUGF0aC5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdzZWN0b3InLFxuXG4gICAgICAgIHNoYXBlOiB7XG5cbiAgICAgICAgICAgIGN4OiAwLFxuXG4gICAgICAgICAgICBjeTogMCxcblxuICAgICAgICAgICAgcjA6IDAsXG5cbiAgICAgICAgICAgIHI6IDAsXG5cbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IDAsXG5cbiAgICAgICAgICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcblxuICAgICAgICAgICAgY2xvY2t3aXNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnJ1c2g6IChlbnYuYnJvd3Nlci5pZSAmJiBlbnYuYnJvd3Nlci52ZXJzaW9uID49IDExKSAvLyB2ZXJzaW9uOiAnMTEuMCdcbiAgICAgICAgICAgIC8vIEZpeCB3ZWlyZCBidWcgaW4gc29tZSB2ZXJzaW9uIG9mIElFMTEgKGxpa2UgMTEuMC45NjAwLjE3ODAxKSxcbiAgICAgICAgICAgIC8vIHdoZXJlIGV4Y2VwdGlvbiBcInVuZXhwZWN0ZWQgY2FsbCB0byBtZXRob2Qgb3IgcHJvcGVydHkgYWNjZXNzXCJcbiAgICAgICAgICAgIC8vIG1pZ2h0IGJlIHRocm93biB3aGVuIGNhbGxpbmcgY3R4LmZpbGwgYWZ0ZXIgYSBwYXRoIHdob3NlIGFyZWEgc2l6ZVxuICAgICAgICAgICAgLy8gaXMgemVybyBpcyBkcmF3biBhbmQgY3R4LmNsaXAoKSBpcyBjYWxsZWQgYW5kIHNoYWRvd0JsdXIgaXMgc2V0LlxuICAgICAgICAgICAgLy8gKGUuZy4sXG4gICAgICAgICAgICAvLyAgY3R4Lm1vdmVUbygxMCwgMTApO1xuICAgICAgICAgICAgLy8gIGN0eC5saW5lVG8oMjAsIDEwKTtcbiAgICAgICAgICAgIC8vICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAvLyAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgIC8vICBjdHguc2hhZG93Qmx1ciA9IDEwO1xuICAgICAgICAgICAgLy8gIC4uLlxuICAgICAgICAgICAgLy8gIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAvLyApXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcFBhdGhzID0gdGhpcy5fX2NsaXBQYXRocztcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZDtcblxuICAgICAgICAgICAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IGNsaXBQYXRoc1tpXSAmJiBjbGlwUGF0aHNbaV0uc2hhcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuc3RhcnRBbmdsZSA9PT0gc2hhcGUuZW5kQW5nbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93VGVtcFtqXVsyXSA9IHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFBhdGgucHJvdG90eXBlLmJydXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaGFkb3dUZW1wLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IFBhdGgucHJvdG90eXBlLmJydXNoLFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcblxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgICAgICAgICB2YXIgcjAgPSBNYXRoLm1heChzaGFwZS5yMCB8fCAwLCAwKTtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG5cbiAgICAgICAgICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odW5pdFggKiByMCArIHgsIHVuaXRZICogcjAgKyB5KTtcblxuICAgICAgICAgICAgY3R4LmxpbmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTtcblxuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG5cbiAgICAgICAgICAgIGN0eC5saW5lVG8oXG4gICAgICAgICAgICAgICAgTWF0aC5jb3MoZW5kQW5nbGUpICogcjAgKyB4LFxuICAgICAgICAgICAgICAgIE1hdGguc2luKGVuZEFuZ2xlKSAqIHIwICsgeVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByMCwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIGNsb2Nrd2lzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9BbmltYXRhYmxlXG4gKi9cblxuXG4gICAgdmFyIEFuaW1hdG9yID0gcmVxdWlyZSgnLi4vYW5pbWF0aW9uL0FuaW1hdG9yJyk7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB1dGlsLmlzU3RyaW5nO1xuICAgIHZhciBpc0Z1bmN0aW9uID0gdXRpbC5pc0Z1bmN0aW9uO1xuICAgIHZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG4gICAgdmFyIGxvZyA9IHJlcXVpcmUoJy4uL2NvcmUvbG9nJyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWU6enJlbmRlci9taXhpbi9BbmltYXRhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGFibGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yPn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdG9ycyA9IFtdO1xuICAgIH07XG5cbiAgICBBbmltYXRhYmxlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQW5pbWF0YWJsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yqo55S7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIOmcgOimgea3u+WKoOWKqOeUu+eahOWxnuaAp+iOt+WPlui3r+W+hO+8jOWPr+S7pemAmui/h2EuYi5j5p2l6I635Y+W5rex5bGC55qE5bGe5oCnXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xvb3BdIOWKqOeUu+aYr+WQpuW+queOr1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqIEBleGFtcGxlOlxuICAgICAgICAgKiAgICAgZWwuYW5pbWF0ZSgnc3R5bGUnLCBmYWxzZSlcbiAgICAgICAgICogICAgICAgICAud2hlbigxMDAwLCB7eDogMTB9IClcbiAgICAgICAgICogICAgICAgICAuZG9uZShmdW5jdGlvbigpeyAvLyBBbmltYXRpb24gZG9uZSB9KVxuICAgICAgICAgKiAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlOiBmdW5jdGlvbiAocGF0aCwgbG9vcCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldDtcbiAgICAgICAgICAgIHZhciBhbmltYXRpbmdTaGFwZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcztcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhTcGxpdHRlZCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IGVsO1xuICAgICAgICAgICAgICAgIC8vIElmIGFuaW1hdGluZyBzaGFwZVxuICAgICAgICAgICAgICAgIGFuaW1hdGluZ1NoYXBlID0gcGF0aFNwbGl0dGVkWzBdID09PSAnc2hhcGUnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aFNwbGl0dGVkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSBwcm9wW3BhdGhTcGxpdHRlZFtpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICAgICAnUHJvcGVydHkgXCInXG4gICAgICAgICAgICAgICAgICAgICsgcGF0aFxuICAgICAgICAgICAgICAgICAgICArICdcIiBpcyBub3QgZXhpc3RlZCBpbiBlbGVtZW50ICdcbiAgICAgICAgICAgICAgICAgICAgKyBlbC5pZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYW5pbWF0b3JzID0gZWwuYW5pbWF0b3JzO1xuXG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IodGFyZ2V0LCBsb29wKTtcblxuICAgICAgICAgICAgYW5pbWF0b3IuZHVyaW5nKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBlbC5kaXJ0eShhbmltYXRpbmdTaGFwZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIEFuaW1hdG9yIHdpbGwgbm90IGJlIHJlbW92ZWQgaWYgdXNlIGBBbmltYXRvciNzdG9wYCB0byBzdG9wIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGFuaW1hdG9ycy5zcGxpY2UodXRpbC5pbmRleE9mKGFuaW1hdG9ycywgYW5pbWF0b3IpLCAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhbmltYXRvcnMucHVzaChhbmltYXRvcik7XG5cbiAgICAgICAgICAgIC8vIElmIGFuaW1hdGUgYWZ0ZXIgYWRkZWQgdG8gdGhlIHpyZW5kZXJcbiAgICAgICAgICAgIGlmICh6cikge1xuICAgICAgICAgICAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhbmltYXRvcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YGc5q2i5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZFRvTGFzdCBJZiBtb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICAgICAgICovXG4gICAgICAgIHN0b3BBbmltYXRpb246IGZ1bmN0aW9uIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG4gICAgICAgICAgICB2YXIgbGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvcnNbaV0uc3RvcChmb3J3YXJkVG9MYXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW1hdG9ycy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXSBUaW1lIGluIG1zXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZWFzaW5nPSdsaW5lYXInXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAgICAgICAgICogIGVsLmFuaW1hdGVUbyh7XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9LCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICAgICAgICpcbiAgICAgICAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtcywgd2l0aCBjdWJpY091dCBlYXNpbmdcbiAgICAgICAgICogIGVsLmFuaW1hdGVUbyh7XG4gICAgICAgICAqICAgICAgc2hhcGU6IHtcbiAgICAgICAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgICAgICAgKiAgICAgIH0sXG4gICAgICAgICAqICAgICAgc3R5bGU6IHtcbiAgICAgICAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICAgICAgICogICAgICB9XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9LCAxMDAsIDEwMCwgJ2N1YmljT3V0JywgZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXG4gICAgICAgICAqL1xuICAgICAgICAgLy8gVE9ETyBSZXR1cm4gYW5pbWF0aW9uIGtleVxuICAgICAgICBhbmltYXRlVG86IGZ1bmN0aW9uICh0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhkZWxheSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSBkZWxheTtcbiAgICAgICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBkZWxheSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihlYXNpbmcpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICAgICAgZWFzaW5nID0gJ2xpbmVhcic7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihkZWxheSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGRlbGF5O1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIGNhbGxiYWNrKVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aW1lKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gdGltZTtcbiAgICAgICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldClcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3AgYWxsIHByZXZpb3VzIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZVRvU2hhbGxvdygnJywgdGhpcywgdGFyZ2V0LCB0aW1lLCBkZWxheSwgZWFzaW5nLCBjYWxsYmFjayk7XG5cbiAgICAgICAgICAgIC8vIEFuaW1hdG9ycyBtYXkgYmUgcmVtb3ZlZCBpbW1lZGlhdGVseSBhZnRlciBzdGFydFxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm90aGluZyB0byBhbmltYXRlXG4gICAgICAgICAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IGFuaW1hdG9ycy5sZW5ndGg7XG4gICAgICAgICAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm8gYW5pbWF0b3JzLiBUaGlzIHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSBhbmltYXRvcnNbaV0uc3RhcnQoKSxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgJ2RvbmUnIG1heSBiZSBleGVjdXRlZCBpbW1lZGlhdGVseSBpZiBubyBuZWVkIHRvIGFuaW1hdGUuXG4gICAgICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IGFmdGVyIGFsbCBhbmltYXRvcnMgY3JlYXRlZFxuICAgICAgICAgICAgLy8gSW5jYXNlIGFueSBhbmltYXRvciBpcyBkb25lIGltbWVkaWF0ZWx5IHdoZW4gYWxsIGFuaW1hdGlvbiBwcm9wZXJ0aWVzIGFyZSBub3QgY2hhbmdlZFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvcnNbaV1cbiAgICAgICAgICAgICAgICAgICAgLmRvbmUoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgLnN0YXJ0KGVhc2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoPScnXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2U9dGhpc1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAgICAgICAgICogIGVsLl9hbmltYXRlVG9TaGFsbG93KHtcbiAgICAgICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgICAgICogIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAvLyBBbmltYXRlIHNoYXBlLCBzdHlsZSBhbmQgcG9zaXRpb24gaW4gMTAwbXMsIGRlbGF5ZWQgMTAwbXNcbiAgICAgICAgICogIGVsLl9hbmltYXRlVG9TaGFsbG93KHtcbiAgICAgICAgICogICAgICBzaGFwZToge1xuICAgICAgICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAgICAgICAqICAgICAgfSxcbiAgICAgICAgICogICAgICBzdHlsZToge1xuICAgICAgICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgICAgICAgKiAgICAgIH1cbiAgICAgICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgICAgICogIH0sIDEwMCwgMTAwKVxuICAgICAgICAgKi9cbiAgICAgICAgX2FuaW1hdGVUb1NoYWxsb3c6IGZ1bmN0aW9uIChwYXRoLCBzb3VyY2UsIHRhcmdldCwgdGltZSwgZGVsYXkpIHtcbiAgICAgICAgICAgIHZhciBvYmpTaGFsbG93ID0ge307XG4gICAgICAgICAgICB2YXIgcHJvcGVydHlDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodGFyZ2V0W25hbWVdKSAmJiAhdXRpbC5pc0FycmF5TGlrZSh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlVG9TaGFsbG93KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPyBwYXRoICsgJy4nICsgbmFtZSA6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlW25hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqU2hhbGxvd1tuYW1lXSA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdHRyIGRpcmVjdGx5IGlmIG5vdCBoYXMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUsIGlmIHNvbWUgcHJvcGVydHkgbm90IG5lZWRlZCBmb3IgZWxlbWVudCA/XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyKG5hbWUsIHRhcmdldFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7ICAvLyBTaGFwZSBvciBzdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1twYXRoXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbcGF0aF1bbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHIocHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJvcGVydHlDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGUocGF0aCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC53aGVuKHRpbWUgPT0gbnVsbCA/IDUwMCA6IHRpbWUsIG9ialNoYWxsb3cpXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheShkZWxheSB8fCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBbmltYXRhYmxlO1xuIiwiLy8gVE9ETyBEcmFnZ2FibGUgZm9yIGdyb3VwXG4vLyBGSVhNRSBEcmFnZ2FibGUgb24gZWxlbWVudCB3aGljaCBoYXMgcGFyZW50IHJvdGF0aW9uIG9yIHNjYWxlXG5cbiAgICBmdW5jdGlvbiBEcmFnZ2FibGUoKSB7XG5cbiAgICAgICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5fZHJhZ1N0YXJ0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignbW91c2Vtb3ZlJywgdGhpcy5fZHJhZywgdGhpcyk7XG4gICAgICAgIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignZ2xvYmFsb3V0JywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7XG4gICAgICAgIC8vIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG5cbiAgICAgICAgLy8gdGhpcy5feCA9IDA7XG4gICAgICAgIC8vIHRoaXMuX3kgPSAwO1xuICAgIH1cblxuICAgIERyYWdnYWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IERyYWdnYWJsZSxcblxuICAgICAgICBfZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgJiYgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBkcmFnZ2luZ1RhcmdldDtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gZS5vZmZzZXRZO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChkcmFnZ2luZ1RhcmdldCwgJ2RyYWdzdGFydCcsIGUuZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kcmFnOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gdGhpcy5fZHJhZ2dpbmdUYXJnZXQ7XG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQpIHtcblxuICAgICAgICAgICAgICAgIHZhciB4ID0gZS5vZmZzZXRYO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gZS5vZmZzZXRZO1xuXG4gICAgICAgICAgICAgICAgdmFyIGR4ID0geCAtIHRoaXMuX3g7XG4gICAgICAgICAgICAgICAgdmFyIGR5ID0geSAtIHRoaXMuX3k7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IHk7XG5cbiAgICAgICAgICAgICAgICBkcmFnZ2luZ1RhcmdldC5kcmlmdChkeCwgZHksIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoZHJhZ2dpbmdUYXJnZXQsICdkcmFnJywgZS5ldmVudCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJvcFRhcmdldCA9IHRoaXMuZmluZEhvdmVyKHgsIHksIGRyYWdnaW5nVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdERyb3BUYXJnZXQgPSB0aGlzLl9kcm9wVGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICE9PSBkcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0RHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChsYXN0RHJvcFRhcmdldCwgJ2RyYWdsZWF2ZScsIGUuZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGRyb3BUYXJnZXQsICdkcmFnZW50ZXInLCBlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuXG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGRyYWdnaW5nVGFyZ2V0LCAnZHJhZ2VuZCcsIGUuZXZlbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQodGhpcy5fZHJvcFRhcmdldCwgJ2Ryb3AnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fZHJvcFRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IERyYWdnYWJsZTtcbiIsIi8qKlxuICog5LqL5Lu25omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIGFycnlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIOS6i+S7tuWIhuWPkeWZqFxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBFdmVudGZ1bCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgfTtcblxuICAgIEV2ZW50ZnVsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogRXZlbnRmdWwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWNleasoeinpuWPkee7keWumu+8jHRyaWdnZXLlkI7plIDmr4FcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgb25lOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9oW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF1baV0uaCA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9oW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICAgICAgICBoOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu5Hlrprkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAgICAgICAqL1xuICAgICAgICBvbjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICBfaFtldmVudF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgaDogaGFuZGxlcixcbiAgICAgICAgICAgICAgICBvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGN0eDogY29udGV4dCB8fCB0aGlzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpue7keWumuS6huS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBldmVudFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNTaWxlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuICAgICAgICAgICAgcmV0dXJuIF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDop6Pnu5Hkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0g5LqL5Lu25aSE55CG5Ye95pWwXG4gICAgICAgICAqL1xuICAgICAgICBvZmY6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9oW2V2ZW50XS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF1baV1bJ2gnXSAhPSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlzdC5wdXNoKF9oW2V2ZW50XVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2hbZXZlbnRdID0gbmV3TGlzdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX2hbZXZlbnRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5LqL5Lu25YiG5Y+RXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnTGVuID4gMykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShfaFtpXVsnY3R4J10sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDluKbmnIljb250ZXh055qE5LqL5Lu25YiG5Y+RLCDmnIDlkI7kuIDkuKrlj4LmlbDmmK/kuovku7blm57osIPnmoRjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcldpdGhDb250ZXh0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdMZW4gPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIOWvueixoeWPr+S7pemAmui/hyBvbnh4eHgg57uR5a6a5LqL5Lu2XG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uY2xpY2tcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3ZlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdXRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlbW92ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V3aGVlbFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vkb3duXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXVwXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbmRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbnRlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2xlYXZlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnb3ZlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJvcFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50ZnVsO1xuXG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOaPkOS+m+WPmOaNouaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cblxuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCcuLi9jb3JlL21hdHJpeCcpO1xuICAgIHZhciB2ZWN0b3IgPSByZXF1aXJlKCcuLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciBtSWRlbnRpdHkgPSBtYXRyaXguaWRlbnRpdHk7XG5cbiAgICB2YXIgRVBTSUxPTiA9IDVlLTU7XG5cbiAgICBmdW5jdGlvbiBpc05vdEFyb3VuZFplcm8odmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPiBFUFNJTE9OIHx8IHZhbCA8IC1FUFNJTE9OO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFRyYW5zZm9ybWFibGUgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGdpdmVuIHBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGVcbiAgICAgICAgaWYgKCFvcHRzLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOW5s+enu1xuICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgICAgICogQGRlZmF1bHQgWzAsIDBdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBbMCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMucm90YXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDml4vovaxcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRzLnNjYWxlKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOe8qeaUvlxuICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgICAgICogQGRlZmF1bHQgWzEsIDFdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBbMSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaXi+i9rOWSjOe8qeaUvueahOWOn+eCuVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5vcmlnaW4gfHwgbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIHRyYW5zZm9ybWFibGVQcm90byA9IFRyYW5zZm9ybWFibGUucHJvdG90eXBlO1xuICAgIHRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm0gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICog5Yik5pat5piv5ZCm6ZyA6KaB5pyJ5Z2Q5qCH5Y+Y5o2iXG4gICAgICog5aaC5p6c5pyJ5Z2Q5qCH5Y+Y5o2iLCDliJnku45wb3NpdGlvbiwgcm90YXRpb24sIHNjYWxl5Lul5Y+K54i26IqC54K555qEdHJhbnNmb3Jt6K6h566X5Ye66Ieq6Lqr55qEdHJhbnNmb3Jt55+p6Zi1XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLm5lZWRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTm90QXJvdW5kWmVybyh0aGlzLnJvdGF0aW9uKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMucG9zaXRpb25bMF0pXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5wb3NpdGlvblsxXSlcbiAgICAgICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnNjYWxlWzBdIC0gMSlcbiAgICAgICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnNjYWxlWzFdIC0gMSk7XG4gICAgfTtcblxuICAgIHRyYW5zZm9ybWFibGVQcm90by51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgdmFyIHBhcmVudEhhc1RyYW5zZm9ybSA9IHBhcmVudCAmJiBwYXJlbnQudHJhbnNmb3JtO1xuICAgICAgICB2YXIgbmVlZExvY2FsVHJhbnNmb3JtID0gdGhpcy5uZWVkTG9jYWxUcmFuc2Zvcm0oKTtcblxuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAoIShuZWVkTG9jYWxUcmFuc2Zvcm0gfHwgcGFyZW50SGFzVHJhbnNmb3JtKSkge1xuICAgICAgICAgICAgbSAmJiBtSWRlbnRpdHkobSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBtID0gbSB8fCBtYXRyaXguY3JlYXRlKCk7XG5cbiAgICAgICAgaWYgKG5lZWRMb2NhbFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdGhpcy5nZXRMb2NhbFRyYW5zZm9ybShtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1JZGVudGl0eShtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOW6lOeUqOeItuiKgueCueWPmOaNolxuICAgICAgICBpZiAocGFyZW50SGFzVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBpZiAobmVlZExvY2FsVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4Lm11bChtLCBwYXJlbnQudHJhbnNmb3JtLCBtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdHJpeC5jb3B5KG0sIHBhcmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIOS/neWtmOi/meS4quWPmOaNouefqemYtVxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IG07XG5cbiAgICAgICAgdGhpcy5pbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybSB8fCBtYXRyaXguY3JlYXRlKCk7XG4gICAgICAgIG1hdHJpeC5pbnZlcnQodGhpcy5pbnZUcmFuc2Zvcm0sIG0pO1xuICAgIH07XG5cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8uZ2V0TG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobSkge1xuICAgICAgICBtID0gbSB8fCBbXTtcbiAgICAgICAgbUlkZW50aXR5KG0pO1xuXG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbjtcblxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICB2YXIgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgdG8gb3JpZ2luXG4gICAgICAgICAgICBtWzRdIC09IG9yaWdpblswXTtcbiAgICAgICAgICAgIG1bNV0gLT0gb3JpZ2luWzFdO1xuICAgICAgICB9XG4gICAgICAgIG1hdHJpeC5zY2FsZShtLCBtLCBzY2FsZSk7XG4gICAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICAgICAgbWF0cml4LnJvdGF0ZShtLCBtLCByb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgLy8gVHJhbnNsYXRlIGJhY2sgZnJvbSBvcmlnaW5cbiAgICAgICAgICAgIG1bNF0gKz0gb3JpZ2luWzBdO1xuICAgICAgICAgICAgbVs1XSArPSBvcmlnaW5bMV07XG4gICAgICAgIH1cblxuICAgICAgICBtWzRdICs9IHBvc2l0aW9uWzBdO1xuICAgICAgICBtWzVdICs9IHBvc2l0aW9uWzFdO1xuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG4gICAgLyoqXG4gICAgICog5bCG6Ieq5bex55qEdHJhbnNmb3Jt5bqU55So5YiwY29udGV4dOS4ilxuICAgICAqIEBwYXJhbSB7Q29udGV4dDJEfSBjdHhcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8uc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybShkcHIgKiBtWzBdLCBkcHIgKiBtWzFdLCBkcHIgKiBtWzJdLCBkcHIgKiBtWzNdLCBkcHIgKiBtWzRdLCBkcHIgKiBtWzVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRyYW5zZm9ybWFibGVQcm90by5yZXN0b3JlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbiAgICB9XG5cbiAgICB2YXIgdG1wVHJhbnNmb3JtID0gW107XG5cbiAgICAvKipcbiAgICAgKiDliIbop6NgdHJhbnNmb3JtYOefqemYteWIsGBwb3NpdGlvbmAsIGByb3RhdGlvbmAsIGBzY2FsZWBcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8uZGVjb21wb3NlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEdldCBsb2NhbCB0cmFuc2Zvcm0gYW5kIGRlY29tcG9zZSB0aGVtIHRvIHBvc2l0aW9uLCBzY2FsZSwgcm90YXRpb25cbiAgICAgICAgICAgIG1hdHJpeC5tdWwodG1wVHJhbnNmb3JtLCBwYXJlbnQuaW52VHJhbnNmb3JtLCBtKTtcbiAgICAgICAgICAgIG0gPSB0bXBUcmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN4ID0gbVswXSAqIG1bMF0gKyBtWzFdICogbVsxXTtcbiAgICAgICAgdmFyIHN5ID0gbVsyXSAqIG1bMl0gKyBtWzNdICogbVszXTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhzeCAtIDEpKSB7XG4gICAgICAgICAgICBzeCA9IE1hdGguc3FydChzeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhzeSAtIDEpKSB7XG4gICAgICAgICAgICBzeSA9IE1hdGguc3FydChzeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1bMF0gPCAwKSB7XG4gICAgICAgICAgICBzeCA9IC1zeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobVszXSA8IDApIHtcbiAgICAgICAgICAgIHN5ID0gLXN5O1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uWzBdID0gbVs0XTtcbiAgICAgICAgcG9zaXRpb25bMV0gPSBtWzVdO1xuICAgICAgICBzY2FsZVswXSA9IHN4O1xuICAgICAgICBzY2FsZVsxXSA9IHN5O1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gTWF0aC5hdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZ2xvYmFsIHNjYWxlXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLmdldEdsb2JhbFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBbMSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN4ID0gTWF0aC5zcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICB2YXIgc3kgPSBNYXRoLnNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgIGlmIChtWzBdIDwgMCkge1xuICAgICAgICAgICAgc3ggPSAtc3g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1bM10gPCAwKSB7XG4gICAgICAgICAgICBzeSA9IC1zeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N4LCBzeV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDlj5jmjaLlnZDmoIfkvY3nva7liLAgc2hhcGUg55qE5bGA6YOo5Z2Q5qCH56m66Ze0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtQ29vcmRUb0xvY2FsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHYyID0gW3gsIHldO1xuICAgICAgICB2YXIgaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm07XG4gICAgICAgIGlmIChpbnZUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIGludlRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDlj5jmjaLlsYDpg6jlnZDmoIfkvY3nva7liLDlhajlsYDlnZDmoIfnqbrpl7RcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvR2xvYmFsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHYyID0gW3gsIHldO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYyO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybWFibGU7XG5cbiIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL3Rvb2wvY29sb3JcbiAqL1xuXG5cbiAgICB2YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gICAgICAgICd0cmFuc3BhcmVudCc6IFswLDAsMCwwXSwgJ2FsaWNlYmx1ZSc6IFsyNDAsMjQ4LDI1NSwxXSxcbiAgICAgICAgJ2FudGlxdWV3aGl0ZSc6IFsyNTAsMjM1LDIxNSwxXSwgJ2FxdWEnOiBbMCwyNTUsMjU1LDFdLFxuICAgICAgICAnYXF1YW1hcmluZSc6IFsxMjcsMjU1LDIxMiwxXSwgJ2F6dXJlJzogWzI0MCwyNTUsMjU1LDFdLFxuICAgICAgICAnYmVpZ2UnOiBbMjQ1LDI0NSwyMjAsMV0sICdiaXNxdWUnOiBbMjU1LDIyOCwxOTYsMV0sXG4gICAgICAgICdibGFjayc6IFswLDAsMCwxXSwgJ2JsYW5jaGVkYWxtb25kJzogWzI1NSwyMzUsMjA1LDFdLFxuICAgICAgICAnYmx1ZSc6IFswLDAsMjU1LDFdLCAnYmx1ZXZpb2xldCc6IFsxMzgsNDMsMjI2LDFdLFxuICAgICAgICAnYnJvd24nOiBbMTY1LDQyLDQyLDFdLCAnYnVybHl3b29kJzogWzIyMiwxODQsMTM1LDFdLFxuICAgICAgICAnY2FkZXRibHVlJzogWzk1LDE1OCwxNjAsMV0sICdjaGFydHJldXNlJzogWzEyNywyNTUsMCwxXSxcbiAgICAgICAgJ2Nob2NvbGF0ZSc6IFsyMTAsMTA1LDMwLDFdLCAnY29yYWwnOiBbMjU1LDEyNyw4MCwxXSxcbiAgICAgICAgJ2Nvcm5mbG93ZXJibHVlJzogWzEwMCwxNDksMjM3LDFdLCAnY29ybnNpbGsnOiBbMjU1LDI0OCwyMjAsMV0sXG4gICAgICAgICdjcmltc29uJzogWzIyMCwyMCw2MCwxXSwgJ2N5YW4nOiBbMCwyNTUsMjU1LDFdLFxuICAgICAgICAnZGFya2JsdWUnOiBbMCwwLDEzOSwxXSwgJ2RhcmtjeWFuJzogWzAsMTM5LDEzOSwxXSxcbiAgICAgICAgJ2Rhcmtnb2xkZW5yb2QnOiBbMTg0LDEzNCwxMSwxXSwgJ2RhcmtncmF5JzogWzE2OSwxNjksMTY5LDFdLFxuICAgICAgICAnZGFya2dyZWVuJzogWzAsMTAwLDAsMV0sICdkYXJrZ3JleSc6IFsxNjksMTY5LDE2OSwxXSxcbiAgICAgICAgJ2RhcmtraGFraSc6IFsxODksMTgzLDEwNywxXSwgJ2RhcmttYWdlbnRhJzogWzEzOSwwLDEzOSwxXSxcbiAgICAgICAgJ2RhcmtvbGl2ZWdyZWVuJzogWzg1LDEwNyw0NywxXSwgJ2RhcmtvcmFuZ2UnOiBbMjU1LDE0MCwwLDFdLFxuICAgICAgICAnZGFya29yY2hpZCc6IFsxNTMsNTAsMjA0LDFdLCAnZGFya3JlZCc6IFsxMzksMCwwLDFdLFxuICAgICAgICAnZGFya3NhbG1vbic6IFsyMzMsMTUwLDEyMiwxXSwgJ2RhcmtzZWFncmVlbic6IFsxNDMsMTg4LDE0MywxXSxcbiAgICAgICAgJ2RhcmtzbGF0ZWJsdWUnOiBbNzIsNjEsMTM5LDFdLCAnZGFya3NsYXRlZ3JheSc6IFs0Nyw3OSw3OSwxXSxcbiAgICAgICAgJ2RhcmtzbGF0ZWdyZXknOiBbNDcsNzksNzksMV0sICdkYXJrdHVycXVvaXNlJzogWzAsMjA2LDIwOSwxXSxcbiAgICAgICAgJ2Rhcmt2aW9sZXQnOiBbMTQ4LDAsMjExLDFdLCAnZGVlcHBpbmsnOiBbMjU1LDIwLDE0NywxXSxcbiAgICAgICAgJ2RlZXBza3libHVlJzogWzAsMTkxLDI1NSwxXSwgJ2RpbWdyYXknOiBbMTA1LDEwNSwxMDUsMV0sXG4gICAgICAgICdkaW1ncmV5JzogWzEwNSwxMDUsMTA1LDFdLCAnZG9kZ2VyYmx1ZSc6IFszMCwxNDQsMjU1LDFdLFxuICAgICAgICAnZmlyZWJyaWNrJzogWzE3OCwzNCwzNCwxXSwgJ2Zsb3JhbHdoaXRlJzogWzI1NSwyNTAsMjQwLDFdLFxuICAgICAgICAnZm9yZXN0Z3JlZW4nOiBbMzQsMTM5LDM0LDFdLCAnZnVjaHNpYSc6IFsyNTUsMCwyNTUsMV0sXG4gICAgICAgICdnYWluc2Jvcm8nOiBbMjIwLDIyMCwyMjAsMV0sICdnaG9zdHdoaXRlJzogWzI0OCwyNDgsMjU1LDFdLFxuICAgICAgICAnZ29sZCc6IFsyNTUsMjE1LDAsMV0sICdnb2xkZW5yb2QnOiBbMjE4LDE2NSwzMiwxXSxcbiAgICAgICAgJ2dyYXknOiBbMTI4LDEyOCwxMjgsMV0sICdncmVlbic6IFswLDEyOCwwLDFdLFxuICAgICAgICAnZ3JlZW55ZWxsb3cnOiBbMTczLDI1NSw0NywxXSwgJ2dyZXknOiBbMTI4LDEyOCwxMjgsMV0sXG4gICAgICAgICdob25leWRldyc6IFsyNDAsMjU1LDI0MCwxXSwgJ2hvdHBpbmsnOiBbMjU1LDEwNSwxODAsMV0sXG4gICAgICAgICdpbmRpYW5yZWQnOiBbMjA1LDkyLDkyLDFdLCAnaW5kaWdvJzogWzc1LDAsMTMwLDFdLFxuICAgICAgICAnaXZvcnknOiBbMjU1LDI1NSwyNDAsMV0sICdraGFraSc6IFsyNDAsMjMwLDE0MCwxXSxcbiAgICAgICAgJ2xhdmVuZGVyJzogWzIzMCwyMzAsMjUwLDFdLCAnbGF2ZW5kZXJibHVzaCc6IFsyNTUsMjQwLDI0NSwxXSxcbiAgICAgICAgJ2xhd25ncmVlbic6IFsxMjQsMjUyLDAsMV0sICdsZW1vbmNoaWZmb24nOiBbMjU1LDI1MCwyMDUsMV0sXG4gICAgICAgICdsaWdodGJsdWUnOiBbMTczLDIxNiwyMzAsMV0sICdsaWdodGNvcmFsJzogWzI0MCwxMjgsMTI4LDFdLFxuICAgICAgICAnbGlnaHRjeWFuJzogWzIyNCwyNTUsMjU1LDFdLCAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiBbMjUwLDI1MCwyMTAsMV0sXG4gICAgICAgICdsaWdodGdyYXknOiBbMjExLDIxMSwyMTEsMV0sICdsaWdodGdyZWVuJzogWzE0NCwyMzgsMTQ0LDFdLFxuICAgICAgICAnbGlnaHRncmV5JzogWzIxMSwyMTEsMjExLDFdLCAnbGlnaHRwaW5rJzogWzI1NSwxODIsMTkzLDFdLFxuICAgICAgICAnbGlnaHRzYWxtb24nOiBbMjU1LDE2MCwxMjIsMV0sICdsaWdodHNlYWdyZWVuJzogWzMyLDE3OCwxNzAsMV0sXG4gICAgICAgICdsaWdodHNreWJsdWUnOiBbMTM1LDIwNiwyNTAsMV0sICdsaWdodHNsYXRlZ3JheSc6IFsxMTksMTM2LDE1MywxXSxcbiAgICAgICAgJ2xpZ2h0c2xhdGVncmV5JzogWzExOSwxMzYsMTUzLDFdLCAnbGlnaHRzdGVlbGJsdWUnOiBbMTc2LDE5NiwyMjIsMV0sXG4gICAgICAgICdsaWdodHllbGxvdyc6IFsyNTUsMjU1LDIyNCwxXSwgJ2xpbWUnOiBbMCwyNTUsMCwxXSxcbiAgICAgICAgJ2xpbWVncmVlbic6IFs1MCwyMDUsNTAsMV0sICdsaW5lbic6IFsyNTAsMjQwLDIzMCwxXSxcbiAgICAgICAgJ21hZ2VudGEnOiBbMjU1LDAsMjU1LDFdLCAnbWFyb29uJzogWzEyOCwwLDAsMV0sXG4gICAgICAgICdtZWRpdW1hcXVhbWFyaW5lJzogWzEwMiwyMDUsMTcwLDFdLCAnbWVkaXVtYmx1ZSc6IFswLDAsMjA1LDFdLFxuICAgICAgICAnbWVkaXVtb3JjaGlkJzogWzE4Niw4NSwyMTEsMV0sICdtZWRpdW1wdXJwbGUnOiBbMTQ3LDExMiwyMTksMV0sXG4gICAgICAgICdtZWRpdW1zZWFncmVlbic6IFs2MCwxNzksMTEzLDFdLCAnbWVkaXVtc2xhdGVibHVlJzogWzEyMywxMDQsMjM4LDFdLFxuICAgICAgICAnbWVkaXVtc3ByaW5nZ3JlZW4nOiBbMCwyNTAsMTU0LDFdLCAnbWVkaXVtdHVycXVvaXNlJzogWzcyLDIwOSwyMDQsMV0sXG4gICAgICAgICdtZWRpdW12aW9sZXRyZWQnOiBbMTk5LDIxLDEzMywxXSwgJ21pZG5pZ2h0Ymx1ZSc6IFsyNSwyNSwxMTIsMV0sXG4gICAgICAgICdtaW50Y3JlYW0nOiBbMjQ1LDI1NSwyNTAsMV0sICdtaXN0eXJvc2UnOiBbMjU1LDIyOCwyMjUsMV0sXG4gICAgICAgICdtb2NjYXNpbic6IFsyNTUsMjI4LDE4MSwxXSwgJ25hdmFqb3doaXRlJzogWzI1NSwyMjIsMTczLDFdLFxuICAgICAgICAnbmF2eSc6IFswLDAsMTI4LDFdLCAnb2xkbGFjZSc6IFsyNTMsMjQ1LDIzMCwxXSxcbiAgICAgICAgJ29saXZlJzogWzEyOCwxMjgsMCwxXSwgJ29saXZlZHJhYic6IFsxMDcsMTQyLDM1LDFdLFxuICAgICAgICAnb3JhbmdlJzogWzI1NSwxNjUsMCwxXSwgJ29yYW5nZXJlZCc6IFsyNTUsNjksMCwxXSxcbiAgICAgICAgJ29yY2hpZCc6IFsyMTgsMTEyLDIxNCwxXSwgJ3BhbGVnb2xkZW5yb2QnOiBbMjM4LDIzMiwxNzAsMV0sXG4gICAgICAgICdwYWxlZ3JlZW4nOiBbMTUyLDI1MSwxNTIsMV0sICdwYWxldHVycXVvaXNlJzogWzE3NSwyMzgsMjM4LDFdLFxuICAgICAgICAncGFsZXZpb2xldHJlZCc6IFsyMTksMTEyLDE0NywxXSwgJ3BhcGF5YXdoaXAnOiBbMjU1LDIzOSwyMTMsMV0sXG4gICAgICAgICdwZWFjaHB1ZmYnOiBbMjU1LDIxOCwxODUsMV0sICdwZXJ1JzogWzIwNSwxMzMsNjMsMV0sXG4gICAgICAgICdwaW5rJzogWzI1NSwxOTIsMjAzLDFdLCAncGx1bSc6IFsyMjEsMTYwLDIyMSwxXSxcbiAgICAgICAgJ3Bvd2RlcmJsdWUnOiBbMTc2LDIyNCwyMzAsMV0sICdwdXJwbGUnOiBbMTI4LDAsMTI4LDFdLFxuICAgICAgICAncmVkJzogWzI1NSwwLDAsMV0sICdyb3N5YnJvd24nOiBbMTg4LDE0MywxNDMsMV0sXG4gICAgICAgICdyb3lhbGJsdWUnOiBbNjUsMTA1LDIyNSwxXSwgJ3NhZGRsZWJyb3duJzogWzEzOSw2OSwxOSwxXSxcbiAgICAgICAgJ3NhbG1vbic6IFsyNTAsMTI4LDExNCwxXSwgJ3NhbmR5YnJvd24nOiBbMjQ0LDE2NCw5NiwxXSxcbiAgICAgICAgJ3NlYWdyZWVuJzogWzQ2LDEzOSw4NywxXSwgJ3NlYXNoZWxsJzogWzI1NSwyNDUsMjM4LDFdLFxuICAgICAgICAnc2llbm5hJzogWzE2MCw4Miw0NSwxXSwgJ3NpbHZlcic6IFsxOTIsMTkyLDE5MiwxXSxcbiAgICAgICAgJ3NreWJsdWUnOiBbMTM1LDIwNiwyMzUsMV0sICdzbGF0ZWJsdWUnOiBbMTA2LDkwLDIwNSwxXSxcbiAgICAgICAgJ3NsYXRlZ3JheSc6IFsxMTIsMTI4LDE0NCwxXSwgJ3NsYXRlZ3JleSc6IFsxMTIsMTI4LDE0NCwxXSxcbiAgICAgICAgJ3Nub3cnOiBbMjU1LDI1MCwyNTAsMV0sICdzcHJpbmdncmVlbic6IFswLDI1NSwxMjcsMV0sXG4gICAgICAgICdzdGVlbGJsdWUnOiBbNzAsMTMwLDE4MCwxXSwgJ3Rhbic6IFsyMTAsMTgwLDE0MCwxXSxcbiAgICAgICAgJ3RlYWwnOiBbMCwxMjgsMTI4LDFdLCAndGhpc3RsZSc6IFsyMTYsMTkxLDIxNiwxXSxcbiAgICAgICAgJ3RvbWF0byc6IFsyNTUsOTksNzEsMV0sICd0dXJxdW9pc2UnOiBbNjQsMjI0LDIwOCwxXSxcbiAgICAgICAgJ3Zpb2xldCc6IFsyMzgsMTMwLDIzOCwxXSwgJ3doZWF0JzogWzI0NSwyMjIsMTc5LDFdLFxuICAgICAgICAnd2hpdGUnOiBbMjU1LDI1NSwyNTUsMV0sICd3aGl0ZXNtb2tlJzogWzI0NSwyNDUsMjQ1LDFdLFxuICAgICAgICAneWVsbG93JzogWzI1NSwyNTUsMCwxXSwgJ3llbGxvd2dyZWVuJzogWzE1NCwyMDUsNTAsMV1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xhbXBDc3NCeXRlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gICAgICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcENzc0FuZ2xlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAzNjAuXG4gICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gICAgICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMzYwID8gMzYwIDogaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcENzc0Zsb2F0KGYpIHsgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gICAgICAgIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ3NzSW50KHN0cikgeyAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlSW50KHN0ciwgMTApKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNzc0Zsb2F0KHN0cikgeyAgLy8gZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgICAgICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhbXBDc3NGbG9hdChwYXJzZUZsb2F0KHN0cikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkge1xuICAgICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgICAgIGggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoID4gMSkge1xuICAgICAgICAgICAgaCAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGggKiA2IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggKiAyIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG0yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoICogMyA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyLzMgLSBoKSAqIDY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxlcnAoYSwgYiwgcCkge1xuICAgICAgICByZXR1cm4gYSArIChiIC0gYSkgKiBwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclN0clxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2UoY29sb3JTdHIpIHtcbiAgICAgICAgaWYgKCFjb2xvclN0cikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbG9yU3RyIG1heSBiZSBub3Qgc3RyaW5nXG4gICAgICAgIGNvbG9yU3RyID0gY29sb3JTdHIgKyAnJztcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG4gICAgICAgIHZhciBzdHIgPSBjb2xvclN0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIC8vIENvbG9yIGtleXdvcmRzIChhbmQgdHJhbnNwYXJlbnQpIGxvb2t1cC5cbiAgICAgICAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtDU1NDb2xvclRhYmxlW3N0cl0uc2xpY2UoKTsgIC8vIGR1cC5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuICAgICAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgIC8vIENvdmVycyBOYU4uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICgoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSxcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLFxuICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgICAgICAgICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmZmZmKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGZmMDAwMCkgPj4gMTYsXG4gICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZmYwMCkgPj4gOCxcbiAgICAgICAgICAgICAgICAgICAgaXYgJiAweGZmLFxuICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcCA9IHN0ci5pbmRleE9mKCcoJyksIGVwID0gc3RyLmluZGV4T2YoJyknKTtcbiAgICAgICAgaWYgKG9wICE9PSAtMSAmJiBlcCArIDEgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3AgKyAxLCBlcCAtIChvcCArIDEpKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgdmFyIGFscGhhID0gMTsgIC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG4gICAgICAgICAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBwYXJzZUNzc0Zsb2F0KHBhcmFtcy5wb3AoKSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgICAgICAgICAgICBjYXNlICdyZ2InOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUNzc0ludChwYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VDc3NJbnQocGFyYW1zWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQ3NzSW50KHBhcmFtc1syXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1szXSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhzbGEycmdiYShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhzbGEycmdiYShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoc2xhMnJnYmEoaHNsYSkge1xuICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQoaHNsYVswXSkgJSAzNjApICsgMzYwKSAlIDM2MCkgLyAzNjA7ICAvLyAwIC4uIDFcbiAgICAgICAgLy8gTk9URShkZWFubSk6IEFjY29yZGluZyB0byB0aGUgQ1NTIHNwZWMgcy9sIHNob3VsZCBvbmx5IGJlXG4gICAgICAgIC8vIHBlcmNlbnRhZ2VzLCBidXQgd2UgZG9uJ3QgYm90aGVyIGFuZCBsZXQgZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgdmFyIHMgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMV0pO1xuICAgICAgICB2YXIgbCA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsyXSk7XG4gICAgICAgIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgbTEgPSBsICogMiAtIG0yO1xuXG4gICAgICAgIHZhciByZ2JhID0gW1xuICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCArIDEgLyAzKSAqIDI1NSksXG4gICAgICAgICAgICBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoKSAqIDI1NSksXG4gICAgICAgICAgICBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoIC0gMSAvIDMpICogMjU1KVxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChoc2xhLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgcmdiYVszXSA9IGhzbGFbM107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmdiYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZ2JhMmhzbGEocmdiYSkge1xuICAgICAgICBpZiAoIXJnYmEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJHQiBmcm9tIDAgdG8gMjU1XG4gICAgICAgIHZhciBSID0gcmdiYVswXSAvIDI1NTtcbiAgICAgICAgdmFyIEcgPSByZ2JhWzFdIC8gMjU1O1xuICAgICAgICB2YXIgQiA9IHJnYmFbMl0gLyAyNTU7XG5cbiAgICAgICAgdmFyIHZNaW4gPSBNYXRoLm1pbihSLCBHLCBCKTsgLy8gTWluLiB2YWx1ZSBvZiBSR0JcbiAgICAgICAgdmFyIHZNYXggPSBNYXRoLm1heChSLCBHLCBCKTsgLy8gTWF4LiB2YWx1ZSBvZiBSR0JcbiAgICAgICAgdmFyIGRlbHRhID0gdk1heCAtIHZNaW47IC8vIERlbHRhIFJHQiB2YWx1ZVxuXG4gICAgICAgIHZhciBMID0gKHZNYXggKyB2TWluKSAvIDI7XG4gICAgICAgIHZhciBIO1xuICAgICAgICB2YXIgUztcbiAgICAgICAgLy8gSFNMIHJlc3VsdHMgZnJvbSAwIHRvIDFcbiAgICAgICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgICAgICBIID0gMDtcbiAgICAgICAgICAgIFMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKEwgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICBTID0gZGVsdGEgLyAodk1heCArIHZNaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgUyA9IGRlbHRhIC8gKDIgLSB2TWF4IC0gdk1pbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkZWx0YVIgPSAoKCh2TWF4IC0gUikgLyA2KSArIChkZWx0YSAvIDIpKSAvIGRlbHRhO1xuICAgICAgICAgICAgdmFyIGRlbHRhRyA9ICgoKHZNYXggLSBHKSAvIDYpICsgKGRlbHRhIC8gMikpIC8gZGVsdGE7XG4gICAgICAgICAgICB2YXIgZGVsdGFCID0gKCgodk1heCAtIEIpIC8gNikgKyAoZGVsdGEgLyAyKSkgLyBkZWx0YTtcblxuICAgICAgICAgICAgaWYgKFIgPT09IHZNYXgpIHtcbiAgICAgICAgICAgICAgICBIID0gZGVsdGFCIC0gZGVsdGFHO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoRyA9PT0gdk1heCkge1xuICAgICAgICAgICAgICAgIEggPSAoMSAvIDMpICsgZGVsdGFSIC0gZGVsdGFCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQiA9PT0gdk1heCkge1xuICAgICAgICAgICAgICAgIEggPSAoMiAvIDMpICsgZGVsdGFHIC0gZGVsdGFSO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoSCA8IDApIHtcbiAgICAgICAgICAgICAgICBIICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChIID4gMSkge1xuICAgICAgICAgICAgICAgIEggLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoc2xhID0gW0ggKiAzNjAsIFMsIExdO1xuXG4gICAgICAgIGlmIChyZ2JhWzNdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhzbGEucHVzaChyZ2JhWzNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoc2xhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpZnQoY29sb3IsIGxldmVsKSB7XG4gICAgICAgIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcbiAgICAgICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JBcnJbaV0gPSBjb2xvckFycltpXSAqICgxIC0gbGV2ZWwpIHwgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQXJyW2ldID0gKCgyNTUgLSBjb2xvckFycltpXSkgKiBsZXZlbCArIGNvbG9yQXJyW2ldKSB8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvckFyciwgY29sb3JBcnIubGVuZ3RoID09PSA0ID8gJ3JnYmEnIDogJ3JnYicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9IZXgoY29sb3IsIGxldmVsKSB7XG4gICAgICAgIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcbiAgICAgICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gKCgxIDw8IDI0KSArIChjb2xvckFyclswXSA8PCAxNikgKyAoY29sb3JBcnJbMV0gPDwgOCkgKyAoK2NvbG9yQXJyWzJdKSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFwIHZhbHVlIHRvIGNvbG9yLiBGYXN0ZXIgdGhhbiBtYXBUb0NvbG9yIG1ldGhvZHMgYmVjYXVzZSBjb2xvciBpcyByZXByZXNlbnRlZCBieSByZ2JhIGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRWYWx1ZSBBIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGNvbG9ycyBMaXN0IG9mIHJnYmEgY29sb3IgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3V0XSBNYXBwZWQgZ2JhIGNvbG9yIGFycmF5XG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmFzdE1hcFRvQ29sb3Iobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIG91dCkge1xuICAgICAgICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aClcbiAgICAgICAgICAgIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG91dCA9IG91dCB8fCBbMCwgMCwgMCwgMF07XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBNYXRoLmNlaWwodmFsdWUpO1xuICAgICAgICB2YXIgbGVmdENvbG9yID0gY29sb3JzW2xlZnRJbmRleF07XG4gICAgICAgIHZhciByaWdodENvbG9yID0gY29sb3JzW3JpZ2h0SW5kZXhdO1xuICAgICAgICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgICAgICAgb3V0WzBdID0gY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpO1xuICAgICAgICBvdXRbMV0gPSBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSk7XG4gICAgICAgIG91dFsyXSA9IGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKTtcbiAgICAgICAgb3V0WzNdID0gY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzNdLCByaWdodENvbG9yWzNdLCBkdikpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBDb2xvciBsaXN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZ1bGxPdXRwdXQgRGVmYXVsdCBmYWxzZS5cbiAgICAgKiBAcmV0dXJuIHsoc3RyaW5nfE9iamVjdCl9IFJlc3VsdCBjb2xvci4gSWYgZnVsbE91dHB1dCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sb3I6IC4uLiwgbGVmdEluZGV4OiAuLi4sIHJpZ2h0SW5kZXg6IC4uLiwgdmFsdWU6IC4uLn0sXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBUb0NvbG9yKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBmdWxsT3V0cHV0KSB7XG4gICAgICAgIGlmICghKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoKVxuICAgICAgICAgICAgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgICAgIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgICAgICAgdmFyIGxlZnRDb2xvciA9IHBhcnNlKGNvbG9yc1tsZWZ0SW5kZXhdKTtcbiAgICAgICAgdmFyIHJpZ2h0Q29sb3IgPSBwYXJzZShjb2xvcnNbcmlnaHRJbmRleF0pO1xuICAgICAgICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcblxuICAgICAgICB2YXIgY29sb3IgPSBzdHJpbmdpZnkoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpLFxuICAgICAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKSxcbiAgICAgICAgICAgICAgICBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSksXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NGbG9hdChsZXJwKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdyZ2JhJ1xuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBmdWxsT3V0cHV0XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgbGVmdEluZGV4OiBsZWZ0SW5kZXgsXG4gICAgICAgICAgICAgICAgcmlnaHRJbmRleDogcmlnaHRJbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogY29sb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBoIDAgfiAzNjAsIGlnbm9yZSB3aGVuIG51bGwuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBzIDAgfiAxLCBpZ25vcmUgd2hlbiBudWxsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbCAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vZGlmeUhTTChjb2xvciwgaCwgcywgbCkge1xuICAgICAgICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIGNvbG9yID0gcmdiYTJoc2xhKGNvbG9yKTtcbiAgICAgICAgICAgIGggIT0gbnVsbCAmJiAoY29sb3JbMF0gPSBjbGFtcENzc0FuZ2xlKGgpKTtcbiAgICAgICAgICAgIHMgIT0gbnVsbCAmJiAoY29sb3JbMV0gPSBwYXJzZUNzc0Zsb2F0KHMpKTtcbiAgICAgICAgICAgIGwgIT0gbnVsbCAmJiAoY29sb3JbMl0gPSBwYXJzZUNzc0Zsb2F0KGwpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShoc2xhMnJnYmEoY29sb3IpLCAncmdiYScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBhbHBoYSAwIH4gMVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW9kaWZ5QWxwaGEoY29sb3IsIGFscGhhKSB7XG4gICAgICAgIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gICAgICAgIGlmIChjb2xvciAmJiBhbHBoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb2xvclszXSA9IGNsYW1wQ3NzRmxvYXQoYWxwaGEpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvciwgJ3JnYmEnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBDb2xvciBsaXN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICdyZ2JhJywgJ2hzdmEnLCAuLi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdCBjb2xvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkoYXJyQ29sb3IsIHR5cGUpIHtcbiAgICAgICAgdmFyIGNvbG9yU3RyID0gYXJyQ29sb3JbMF0gKyAnLCcgKyBhcnJDb2xvclsxXSArICcsJyArIGFyckNvbG9yWzJdO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3JnYmEnIHx8IHR5cGUgPT09ICdoc3ZhJyB8fCB0eXBlID09PSAnaHNsYScpIHtcbiAgICAgICAgICAgIGNvbG9yU3RyICs9ICcsJyArIGFyckNvbG9yWzNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlICsgJygnICsgY29sb3JTdHIgKyAnKSc7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHBhcnNlOiBwYXJzZSxcbiAgICAgICAgbGlmdDogbGlmdCxcbiAgICAgICAgdG9IZXg6IHRvSGV4LFxuICAgICAgICBmYXN0TWFwVG9Db2xvcjogZmFzdE1hcFRvQ29sb3IsXG4gICAgICAgIG1hcFRvQ29sb3I6IG1hcFRvQ29sb3IsXG4gICAgICAgIG1vZGlmeUhTTDogbW9kaWZ5SFNMLFxuICAgICAgICBtb2RpZnlBbHBoYTogbW9kaWZ5QWxwaGEsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG4gICAgfTtcblxuXG4iLCJcblxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9QYXRoJyk7XG4gICAgdmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5Jyk7XG4gICAgdmFyIHRyYW5zZm9ybVBhdGggPSByZXF1aXJlKCcuL3RyYW5zZm9ybVBhdGgnKTtcbiAgICB2YXIgbWF0cml4ID0gcmVxdWlyZSgnLi4vY29yZS9tYXRyaXgnKTtcblxuICAgIC8vIGNvbW1hbmQgY2hhcnNcbiAgICB2YXIgY2MgPSBbXG4gICAgICAgICdtJywgJ00nLCAnbCcsICdMJywgJ3YnLCAnVicsICdoJywgJ0gnLCAneicsICdaJyxcbiAgICAgICAgJ2MnLCAnQycsICdxJywgJ1EnLCAndCcsICdUJywgJ3MnLCAnUycsICdhJywgJ0EnXG4gICAgXTtcblxuICAgIHZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgbWF0aFNpbiA9IE1hdGguc2luO1xuICAgIHZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG4gICAgdmFyIFBJID0gTWF0aC5QSTtcblxuICAgIHZhciB2TWFnID0gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xuICAgIH07XG4gICAgdmFyIHZSYXRpbyA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgICAgICAgcmV0dXJuICh1WzBdICogdlswXSArIHVbMV0gKiB2WzFdKSAvICh2TWFnKHUpICogdk1hZyh2KSk7XG4gICAgfTtcbiAgICB2YXIgdkFuZ2xlID0gZnVuY3Rpb24odSwgdikge1xuICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzFdIDwgdVsxXSAqIHZbMF0gPyAtMSA6IDEpXG4gICAgICAgICAgICAgICAgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0FyYyh4MSwgeTEsIHgyLCB5MiwgZmEsIGZzLCByeCwgcnksIHBzaURlZywgY21kLCBwYXRoKSB7XG4gICAgICAgIHZhciBwc2kgPSBwc2lEZWcgKiAoUEkgLyAxODAuMCk7XG4gICAgICAgIHZhciB4cCA9IG1hdGhDb3MocHNpKSAqICh4MSAtIHgyKSAvIDIuMFxuICAgICAgICAgICAgICAgICArIG1hdGhTaW4ocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcbiAgICAgICAgdmFyIHlwID0gLTEgKiBtYXRoU2luKHBzaSkgKiAoeDEgLSB4MikgLyAyLjBcbiAgICAgICAgICAgICAgICAgKyBtYXRoQ29zKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG5cbiAgICAgICAgdmFyIGxhbWJkYSA9ICh4cCAqIHhwKSAvIChyeCAqIHJ4KSArICh5cCAqIHlwKSAvIChyeSAqIHJ5KTtcblxuICAgICAgICBpZiAobGFtYmRhID4gMSkge1xuICAgICAgICAgICAgcnggKj0gbWF0aFNxcnQobGFtYmRhKTtcbiAgICAgICAgICAgIHJ5ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IChmYSA9PT0gZnMgPyAtMSA6IDEpXG4gICAgICAgICAgICAqIG1hdGhTcXJ0KCgoKHJ4ICogcngpICogKHJ5ICogcnkpKVxuICAgICAgICAgICAgICAgICAgICAtICgocnggKiByeCkgKiAoeXAgKiB5cCkpXG4gICAgICAgICAgICAgICAgICAgIC0gKChyeSAqIHJ5KSAqICh4cCAqIHhwKSkpIC8gKChyeCAqIHJ4KSAqICh5cCAqIHlwKVxuICAgICAgICAgICAgICAgICAgICArIChyeSAqIHJ5KSAqICh4cCAqIHhwKSlcbiAgICAgICAgICAgICAgICApIHx8IDA7XG5cbiAgICAgICAgdmFyIGN4cCA9IGYgKiByeCAqIHlwIC8gcnk7XG4gICAgICAgIHZhciBjeXAgPSBmICogLXJ5ICogeHAgLyByeDtcblxuICAgICAgICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjBcbiAgICAgICAgICAgICAgICAgKyBtYXRoQ29zKHBzaSkgKiBjeHBcbiAgICAgICAgICAgICAgICAgLSBtYXRoU2luKHBzaSkgKiBjeXA7XG4gICAgICAgIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMFxuICAgICAgICAgICAgICAgICsgbWF0aFNpbihwc2kpICogY3hwXG4gICAgICAgICAgICAgICAgKyBtYXRoQ29zKHBzaSkgKiBjeXA7XG5cbiAgICAgICAgdmFyIHRoZXRhID0gdkFuZ2xlKFsgMSwgMCBdLCBbICh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5IF0pO1xuICAgICAgICB2YXIgdSA9IFsgKHhwIC0gY3hwKSAvIHJ4LCAoeXAgLSBjeXApIC8gcnkgXTtcbiAgICAgICAgdmFyIHYgPSBbICgtMSAqIHhwIC0gY3hwKSAvIHJ4LCAoLTEgKiB5cCAtIGN5cCkgLyByeSBdO1xuICAgICAgICB2YXIgZFRoZXRhID0gdkFuZ2xlKHUsIHYpO1xuXG4gICAgICAgIGlmICh2UmF0aW8odSwgdikgPD0gLTEpIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IFBJO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2UmF0aW8odSwgdikgPj0gMSkge1xuICAgICAgICAgICAgZFRoZXRhID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnMgPT09IDAgJiYgZFRoZXRhID4gMCkge1xuICAgICAgICAgICAgZFRoZXRhID0gZFRoZXRhIC0gMiAqIFBJO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcyA9PT0gMSAmJiBkVGhldGEgPCAwKSB7XG4gICAgICAgICAgICBkVGhldGEgPSBkVGhldGEgKyAyICogUEk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjeCwgY3ksIHJ4LCByeSwgdGhldGEsIGRUaGV0YSwgcHNpLCBmcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29tbWFuZCBzdHJpbmdcbiAgICAgICAgdmFyIGNzID0gZGF0YS5yZXBsYWNlKC8tL2csICcgLScpXG4gICAgICAgICAgICAucmVwbGFjZSgvICAvZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyAvZywgJywnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLywsL2csICcsJyk7XG5cbiAgICAgICAgdmFyIG47XG4gICAgICAgIC8vIGNyZWF0ZSBwaXBlcyBzbyB0aGF0IHdlIGNhbiBzcGxpdCB0aGUgZGF0YVxuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgY2MubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIGNzID0gY3MucmVwbGFjZShuZXcgUmVnRXhwKGNjW25dLCAnZycpLCAnfCcgKyBjY1tuXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgYXJyYXlcbiAgICAgICAgdmFyIGFyciA9IGNzLnNwbGl0KCd8Jyk7XG4gICAgICAgIC8vIGluaXQgY29udGV4dCBwb2ludFxuICAgICAgICB2YXIgY3B4ID0gMDtcbiAgICAgICAgdmFyIGNweSA9IDA7XG5cbiAgICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gICAgICAgIHZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xuXG4gICAgICAgIHZhciBwcmV2Q21kO1xuICAgICAgICBmb3IgKG4gPSAxOyBuIDwgYXJyLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gYXJyW25dO1xuICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KDApO1xuICAgICAgICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICAgICAgICB2YXIgcCA9IHN0ci5zbGljZSgxKS5yZXBsYWNlKC9lLC0vZywgJ2UtJykuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHZhciBjbWQ7XG5cbiAgICAgICAgICAgIGlmIChwLmxlbmd0aCA+IDAgJiYgcFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBbaV0gPSBwYXJzZUZsb2F0KHBbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG9mZiA8IHAubGVuZ3RoICYmICFpc05hTihwW29mZl0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHBbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3RsUHR4O1xuICAgICAgICAgICAgICAgIHZhciBjdGxQdHk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcng7XG4gICAgICAgICAgICAgICAgdmFyIHJ5O1xuICAgICAgICAgICAgICAgIHZhciBwc2k7XG4gICAgICAgICAgICAgICAgdmFyIGZhO1xuICAgICAgICAgICAgICAgIHZhciBmcztcblxuICAgICAgICAgICAgICAgIHZhciB4MSA9IGNweDtcbiAgICAgICAgICAgICAgICB2YXIgeTEgPSBjcHk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGwsIEgsIGgsIFYsIGFuZCB2IHRvIExcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnTCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbWQsIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK11cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZiAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZiAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHggKyBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gY3B5ICsgcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBwW29mZisrXSArIGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gcFtvZmYrK10gKyBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICByeSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMgPSBwW29mZisrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0FyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSwgeTEsIGNweCwgY3B5LCBmYSwgZnMsIHJ4LCByeSwgcHNpLCBjbWQsIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzaSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzID0gcFtvZmYrK107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0FyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSwgeTEsIGNweCwgY3B5LCBmYSwgZnMsIHJ4LCByeSwgcHNpLCBjbWQsIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjID09PSAneicgfHwgYyA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgY21kID0gQ01ELlo7XG4gICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZDbWQgPSBjbWQ7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoLnRvU3RhdGljKCk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykge1xuICAgICAgICB2YXIgcGF0aFByb3h5ID0gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhzdHIpO1xuICAgICAgICB2YXIgdHJhbnNmb3JtO1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgb3B0cy5idWlsZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgcGF0aC5zZXREYXRhKHBhdGhQcm94eS5kYXRhKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybSAmJiB0cmFuc2Zvcm1QYXRoKHBhdGgsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAvLyBTdmcgYW5kIHZtbCByZW5kZXJlciBkb24ndCBoYXZlIGNvbnRleHRcbiAgICAgICAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgb3B0cy5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5jcmVhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdHJpeC5tdWwodHJhbnNmb3JtLCBtLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSh0cnVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIFBhdGggb2JqZWN0IGZyb20gcGF0aCBzdHJpbmcgZGF0YVxuICAgICAgICAgKiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlRnJvbVN0cmluZzogZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXRoKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBQYXRoIGNsYXNzIGZyb20gcGF0aCBzdHJpbmcgZGF0YVxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgZXh0ZW5kRnJvbVN0cmluZzogZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIFBhdGguZXh0ZW5kKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXJnZSBtdWx0aXBsZSBwYXRoc1xuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETyBBcHBseSB0cmFuc2Zvcm1cbiAgICAgICAgLy8gVE9ETyBzdHJva2UgZGFzaFxuICAgICAgICAvLyBUT0RPIE9wdGltaXplIGRvdWJsZSBtZW1vcnkgY29zdCBwcm9ibGVtXG4gICAgICAgIG1lcmdlUGF0aDogZnVuY3Rpb24gKHBhdGhFbHMsIG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBwYXRoTGlzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGhFbHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRWwgPSBwYXRoRWxzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoRWwuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoRWwuYnVpbGRQYXRoKHBhdGhFbC5wYXRoLCBwYXRoRWwuc2hhcGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoTGlzdC5wdXNoKHBhdGhFbC5wYXRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhdGhCdW5kbGUgPSBuZXcgUGF0aChvcHRzKTtcbiAgICAgICAgICAgIHBhdGhCdW5kbGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmFwcGVuZFBhdGgocGF0aExpc3QpO1xuICAgICAgICAgICAgICAgIC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gcGF0aEJ1bmRsZTtcbiAgICAgICAgfVxuICAgIH07XG4iLCJcblxuICAgIHZhciBDTUQgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpLkNNRDtcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuXG4gICAgdmFyIHBvaW50cyA9IFtbXSwgW10sIFtdXTtcbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIG1hdGhBdGFuMiA9IE1hdGguYXRhbjI7XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtUGF0aChwYXRoLCBtKSB7XG4gICAgICAgIHZhciBkYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICB2YXIgY21kO1xuICAgICAgICB2YXIgblBvaW50O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIHZhciBrO1xuICAgICAgICB2YXIgcDtcblxuICAgICAgICB2YXIgTSA9IENNRC5NO1xuICAgICAgICB2YXIgQyA9IENNRC5DO1xuICAgICAgICB2YXIgTCA9IENNRC5MO1xuICAgICAgICB2YXIgUiA9IENNRC5SO1xuICAgICAgICB2YXIgQSA9IENNRC5BO1xuICAgICAgICB2YXIgUSA9IENNRC5RO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBjbWQgPSBkYXRhW2krK107XG4gICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgIG5Qb2ludCA9IDA7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBNOlxuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEw6XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQzpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBROlxuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEE6XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gbVs0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBtWzVdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSBtYXRoU3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gbWF0aFNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IG1hdGhBdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjeFxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKz0geDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3lcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IHk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNjYWxlIHJ4IGFuZCByeVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBBc3N1bWUgcHNpIGlzIDAgaGVyZVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKj0gc3g7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSAqPSBzeTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBhbmdsZVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZCBhbmdsZVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIHBzaVxuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFI6XG4gICAgICAgICAgICAgICAgICAgIC8vIHgwLCB5MFxuICAgICAgICAgICAgICAgICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBwWzFdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgICAgICAgICAgICAgICAgICAvLyB4MSwgeTFcbiAgICAgICAgICAgICAgICAgICAgcFswXSArPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHBbMV0gKz0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgblBvaW50OyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBvaW50c1trXTtcbiAgICAgICAgICAgICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHBbMV0gPSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICAgICAgICAgIC8vIFdyaXRlIGJhY2tcbiAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybVBhdGg7XG4iLCIvKiFcbiAqIFpSZW5kZXIsIGEgaGlnaCBwZXJmb3JtYW5jZSAyZCBkcmF3aW5nIGxpYnJhcnkuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLCBCYWlkdSBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvenJlbmRlci9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuICovXG4vLyBHbG9iYWwgZGVmaW5lc1xuXG4gICAgdmFyIGd1aWQgPSByZXF1aXJlKCcuL2NvcmUvZ3VpZCcpO1xuICAgIHZhciBlbnYgPSByZXF1aXJlKCcuL2NvcmUvZW52Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG5cbiAgICB2YXIgSGFuZGxlciA9IHJlcXVpcmUoJy4vSGFuZGxlcicpO1xuICAgIHZhciBTdG9yYWdlID0gcmVxdWlyZSgnLi9TdG9yYWdlJyk7XG4gICAgdmFyIEFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uL0FuaW1hdGlvbicpO1xuICAgIHZhciBIYW5kbGVyUHJveHkgPSByZXF1aXJlKCcuL2RvbS9IYW5kbGVyUHJveHknKTtcblxuICAgIHZhciB1c2VWTUwgPSAhZW52LmNhbnZhc1N1cHBvcnRlZDtcblxuICAgIHZhciBwYWludGVyQ3RvcnMgPSB7XG4gICAgICAgIGNhbnZhczogcmVxdWlyZSgnLi9QYWludGVyJylcbiAgICB9O1xuXG4gICAgdmFyIGluc3RhbmNlcyA9IHt9OyAgICAvLyBaUmVuZGVy5a6e5L6LbWFw57Si5byVXG5cbiAgICB2YXIgenJlbmRlciA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB6cmVuZGVyLnZlcnNpb24gPSAnMy4zLjAnO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6aW5nIGEgenJlbmRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyPSdjYW52YXMnXSAnY2FudmFzJyBvciAnc3ZnJ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMud2lkdGhdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgICAqL1xuICAgIHpyZW5kZXIuaW5pdCA9IGZ1bmN0aW9uKGRvbSwgb3B0cykge1xuICAgICAgICB2YXIgenIgPSBuZXcgWlJlbmRlcihndWlkKCksIGRvbSwgb3B0cyk7XG4gICAgICAgIGluc3RhbmNlc1t6ci5pZF0gPSB6cjtcbiAgICAgICAgcmV0dXJuIHpyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHpyZW5kZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAgICovXG4gICAgenJlbmRlci5kaXNwb3NlID0gZnVuY3Rpb24gKHpyKSB7XG4gICAgICAgIGlmICh6cikge1xuICAgICAgICAgICAgenIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXNba2V5XS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2VzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4genJlbmRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHpyZW5kZXIgaW5zdGFuY2UgYnkgaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgenJlbmRlciBpbnN0YW5jZSBpZFxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICovXG4gICAgenJlbmRlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VzW2lkXTtcbiAgICB9O1xuXG4gICAgenJlbmRlci5yZWdpc3RlclBhaW50ZXIgPSBmdW5jdGlvbiAobmFtZSwgQ3Rvcikge1xuICAgICAgICBwYWludGVyQ3RvcnNbbmFtZV0gPSBDdG9yO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkZWxJbnN0YW5jZShpZCkge1xuICAgICAgICBkZWxldGUgaW5zdGFuY2VzW2lkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIHpyZW5kZXIvWlJlbmRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9aUmVuZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtIVE1MRG9tRWxlbWVudH0gZG9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgKi9cbiAgICB2YXIgWlJlbmRlciA9IGZ1bmN0aW9uKGlkLCBkb20sIG9wdHMpIHtcblxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0hUTUxEb21FbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb20gPSBkb207XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBTdG9yYWdlKCk7XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyVHlwZSA9IG9wdHMucmVuZGVyZXI7XG4gICAgICAgIGlmICh1c2VWTUwpIHtcbiAgICAgICAgICAgIGlmICghcGFpbnRlckN0b3JzLnZtbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcmVxdWlyZSBcXCd6cmVuZGVyL3ZtbC92bWxcXCcgdG8gc3VwcG9ydCBJRTgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9ICd2bWwnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFyZW5kZXJlclR5cGUgfHwgIXBhaW50ZXJDdG9yc1tyZW5kZXJlclR5cGVdKSB7XG4gICAgICAgICAgICByZW5kZXJlclR5cGUgPSAnY2FudmFzJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFpbnRlciA9IG5ldyBwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXShkb20sIHN0b3JhZ2UsIG9wdHMpO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICAgICAgdmFyIGhhbmRlclByb3h5ID0gIWVudi5ub2RlID8gbmV3IEhhbmRsZXJQcm94eShwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKSA6IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IG5ldyBIYW5kbGVyKHN0b3JhZ2UsIHBhaW50ZXIsIGhhbmRlclByb3h5LCBwYWludGVyLnJvb3QpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7XG4gICAgICAgICAgICBzdGFnZToge1xuICAgICAgICAgICAgICAgIHVwZGF0ZTogenJVdGlsLmJpbmQodGhpcy5mbHVzaCwgdGhpcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLnN0YXJ0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoO1xuXG4gICAgICAgIC8vIOS/ruaUuSBzdG9yYWdlLmRlbEZyb21NYXAsIOavj+asoeWIoOmZpOWFg+e0oOS5i+WJjeWIoOmZpOWKqOeUu1xuICAgICAgICAvLyBGSVhNRSDmnInngrl1Z2x5XG4gICAgICAgIHZhciBvbGREZWxGcm9tTWFwID0gc3RvcmFnZS5kZWxGcm9tTWFwO1xuICAgICAgICB2YXIgb2xkQWRkVG9NYXAgPSBzdG9yYWdlLmFkZFRvTWFwO1xuXG4gICAgICAgIHN0b3JhZ2UuZGVsRnJvbU1hcCA9IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBzdG9yYWdlLmdldChlbElkKTtcblxuICAgICAgICAgICAgb2xkRGVsRnJvbU1hcC5jYWxsKHN0b3JhZ2UsIGVsSWQpO1xuXG4gICAgICAgICAgICBlbCAmJiBlbC5yZW1vdmVTZWxmRnJvbVpyKHNlbGYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0b3JhZ2UuYWRkVG9NYXAgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIG9sZEFkZFRvTWFwLmNhbGwoc3RvcmFnZSwgZWwpO1xuXG4gICAgICAgICAgICBlbC5hZGRTZWxmVG9acihzZWxmKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgWlJlbmRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFpSZW5kZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5blrp7kvovllK/kuIDmoIfor4ZcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlhYPntKBcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuYWRkUm9vdChlbCk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTlhYPntKBcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsUm9vdChlbCk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2UgY29uZmlndXJhdGlvbiBvZiBsYXllclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gekxldmVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSBDbGVhciBjb2xvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5tb3Rpb25CbHVyPWZhbHNlXSBJZiBlbmFibGUgbW90aW9uIGJsdXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubGFzdEZyYW1lQWxwaGE9MC43XSBNb3Rpb24gYmx1ciBmYWN0b3IuIExhcmdlciB2YWx1ZSBjYXVzZSBsb25nZXIgdHJhaWxlclxuICAgICAgICAqL1xuICAgICAgICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpMZXZlbCwgY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIuY29uZmlnTGF5ZXIoekxldmVsLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVwYWludCB0aGUgY2FudmFzIGltbWVkaWF0ZWx5XG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoSW1tZWRpYXRlbHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIG5lZWRzUmVmcmVzaCBhaGVhZCB0byBhdm9pZCBzb21ldGhpbmcgd3JvbmcgaGFwcGVucyBpbiByZWZyZXNoXG4gICAgICAgICAgICAvLyBPciBpdCB3aWxsIGNhdXNlIHpyZW5kZXIgcmVmcmVzaGVzIGFnYWluIGFuZCBhZ2Fpbi5cbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXZvaWQgdHJpZ2dlciB6ci5yZWZyZXNoIGluIEVsZW1lbnQjYmVmb3JlVXBkYXRlIGhvb2tcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmsgYW5kIHJlcGFpbnQgdGhlIGNhbnZhcyBpbiB0aGUgbmV4dCBmcmFtZSBvZiBicm93c2VyXG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm0gYWxsIHJlZnJlc2hcbiAgICAgICAgICovXG4gICAgICAgIGZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbmVlZHNSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSW1tZWRpYXRlbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2hIb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVySW1tZWRpYXRlbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGVsZW1lbnQgdG8gaG92ZXIgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICAgICAqL1xuICAgICAgICBhZGRIb3ZlcjogZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFpbnRlci5hZGRIb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlci5hZGRIb3ZlcihlbCwgc3R5bGUpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBlbGVtZW50IGZyb20gaG92ZXIgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIoZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFyIGFsbCBob3ZlciBlbGVtZW50cyBpbiBob3ZlciBsYXllclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFpbnRlci5jbGVhckhvdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyLmNsZWFySG92ZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZyZXNoIGhvdmVyIGluIG5leHQgZnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2hIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZyZXNoIGhvdmVyIGltbWVkaWF0ZWx5XG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoSG92ZXJJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZWZyZXNoSG92ZXIgJiYgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNpemUgdGhlIGNhbnZhcy5cbiAgICAgICAgICogU2hvdWxkIGJlIGludm9rZWQgd2hlbiBjb250YWluZXIgc2l6ZSBpcyBjaGFuZ2VkXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24ob3B0cykge1xuICAgICAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVzaXplKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5yZXNpemUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCBhbmQgY2xlYXIgYWxsIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXJBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjb250YWluZXIgd2lkdGhcbiAgICAgICAgICovXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGNvbnRhaW5lciBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldEhlaWdodCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBvcnQgdGhlIGNhbnZhcyBhcyBCYXNlNjQgVVJMXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFja2dyb3VuZENvbG9yPScjZmZmJ11cbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgVVJMXG4gICAgICAgICAqL1xuICAgICAgICAvLyB0b0RhdGFVUkw6IGZ1bmN0aW9uKHR5cGUsIGJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAvLyAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRSZW5kZXJlZENhbnZhcyh7XG4gICAgICAgIC8vICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgLy8gICAgIH0pLnRvRGF0YVVSTCh0eXBlKTtcbiAgICAgICAgLy8gfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydGluZyBhIHBhdGggdG8gaW1hZ2UuXG4gICAgICAgICAqIEl0IGhhcyBtdWNoIGJldHRlciBwZXJmb3JtYW5jZSBvZiBkcmF3aW5nIGltYWdlIHJhdGhlciB0aGFuIGRyYXdpbmcgYSB2ZWN0b3IgcGF0aC5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHBhdGhUb0ltYWdlOiBmdW5jdGlvbihlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBndWlkKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLnBhdGhUb0ltYWdlKGlkLCBlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGRlZmF1bHQgY3Vyc29yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3R5bGU9J2RlZmF1bHQnXSDkvovlpoIgY3Jvc3NoYWlyXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIuc2V0Q3Vyc29yU3R5bGUoY3Vyc29yU3R5bGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudEhhbmRsZXIgSGFuZGxlciBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5vbihldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuYmluZCBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2V2ZW50SGFuZGxlcl0gSGFuZGxlciBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgb2ZmOiBmdW5jdGlvbihldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLm9mZihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXIgZXZlbnQgbWFudWFsbHlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudCBFdmVudCBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciBhbGwgb2JqZWN0cyBhbmQgdGhlIGNhbnZhcy5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsUm9vdCgpO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3Bvc2Ugc2VsZi5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcblxuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPVxuICAgICAgICAgICAgdGhpcy5wYWludGVyID1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IG51bGw7XG5cbiAgICAgICAgICAgIGRlbEluc3RhbmNlKHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0genJlbmRlcjtcblxuIiwidmFyIGVjaGFydHMgPSByZXF1aXJlKCdlY2hhcnRzL2xpYi9lY2hhcnRzJyk7XHJcbnJlcXVpcmUoJ2VjaGFydHMvbGliL2NoYXJ0L2JhcicpO1xyXG5yZXF1aXJlKCdlY2hhcnRzL2xpYi9jaGFydC9waWUnKTtcclxucmVxdWlyZSgnZWNoYXJ0cy9saWIvY2hhcnQvbGluZScpO1xyXG5yZXF1aXJlKCdlY2hhcnRzL2xpYi9jaGFydC9yYWRhcicpO1xyXG5yZXF1aXJlKCdlY2hhcnRzL2xpYi9jaGFydC9nYXVnZScpO1xyXG5yZXF1aXJlKCdlY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kJyk7XHJcbnJlcXVpcmUoJ2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwJyk7XHJcbnJlcXVpcmUoJ2VjaGFydHMvbGliL2NvbXBvbmVudC90aXRsZScpO1xyXG5yZXF1aXJlKCdlY2hhcnRzL2xpYi9jb21wb25lbnQvbWFya0xpbmUnKTtcclxucmVxdWlyZSgnZWNoYXJ0cy9saWIvY29tcG9uZW50L21hcmtQb2ludCcpO1xyXG5yZXF1aXJlKCdlY2hhcnRzL2xpYi9jb21wb25lbnQvZGF0YVpvb21JbnNpZGUnKTtcclxuXHJcbndpbmRvdy5lY2hhcnRzID0gZWNoYXJ0cztcclxubW9kdWxlLmV4cG9ydHMgPSBlY2hhcnRzO1xyXG4iXX0=\n"]}